Directory Structure:

└── ./
    └── app
        ├── account
        │   └── [address]
        │       ├── components
        │       │   ├── shared
        │       │   │   ├── hooks.ts
        │       │   │   ├── transfer-analytics.ts
        │       │   │   └── types.ts
        │       │   ├── PlaceholderTab.tsx
        │       │   ├── TabContainer.tsx
        │       │   ├── TokensTab.tsx
        │       │   ├── TransferAnalytics.tsx
        │       │   └── TransfersTab.tsx
        │       ├── page.tsx
        │       └── tabs.tsx
        ├── admin
        │   └── page.tsx
        ├── analytics
        │   ├── defi
        │   │   └── page.tsx
        │   ├── tokens
        │   │   └── page.tsx
        │   └── page.tsx
        ├── api
        │   ├── account-stats
        │   │   └── [address]
        │   │       └── route.ts
        │   ├── account-token-stats
        │   │   └── [address]
        │   │       └── [mint]
        │   │           └── route.ts
        │   ├── account-transfers
        │   │   └── [address]
        │   │       └── route.ts
        │   ├── analyze
        │   │   └── route.ts
        │   ├── analyze-transaction
        │   │   └── route.ts
        │   ├── block
        │   │   └── route.ts
        │   ├── blocks
        │   │   └── [slot]
        │   │       └── route.ts
        │   ├── chat
        │   │   └── route.ts
        │   ├── check-account-type
        │   │   └── route.ts
        │   ├── check-token
        │   │   └── route.ts
        │   ├── favicon
        │   │   └── route.ts
        │   ├── getAnswer
        │   │   └── route.ts
        │   ├── getSimilarQuestions
        │   │   └── route.ts
        │   ├── getSources
        │   │   └── route.ts
        │   ├── nft-collections
        │   │   ├── new
        │   │   │   └── route.ts
        │   │   ├── trending
        │   │   │   └── route.ts
        │   │   └── route.ts
        │   ├── nfts
        │   │   └── collections
        │   │       └── route.ts
        │   ├── og
        │   │   └── route.tsx
        │   ├── qdrant
        │   │   └── init
        │   │       └── route.ts
        │   ├── search
        │   │   ├── accounts
        │   │   │   └── route.ts
        │   │   ├── filtered
        │   │   │   └── route.ts
        │   │   └── suggestions
        │   │       └── route.ts
        │   ├── solana-proxy
        │   │   ├── [transaction]
        │   │   │   └── route.ts
        │   │   └── route.ts
        │   ├── solana-rpc
        │   │   └── route.ts
        │   ├── test-transaction
        │   │   └── route.ts
        │   ├── token
        │   │   └── [mint]
        │   │       └── route.ts
        │   ├── token-stats
        │   │   └── [account]
        │   │       └── [mint]
        │   │           └── route.ts
        │   └── transaction
        │       ├── [signature]
        │       │   └── route.ts
        │       └── route.ts
        ├── block
        │   ├── [slot]
        │   │   ├── metadata.ts
        │   │   ├── opengraph-image.tsx
        │   │   └── page.tsx
        │   └── layout.tsx
        ├── blocks
        │   └── page.tsx
        ├── docs
        │   ├── [slug]
        │   │   └── page.tsx
        │   └── page.tsx
        ├── networks
        │   └── page.tsx
        ├── nfts
        │   ├── new
        │   │   └── page.tsx
        │   ├── trending
        │   │   └── page.tsx
        │   └── page.tsx
        ├── program
        │   └── [address]
        │       ├── disassembly-view.tsx
        │       ├── hex-view.tsx
        │       ├── hilbert.worker.ts
        │       ├── layout.tsx
        │       ├── opengraph-image.tsx
        │       ├── page.tsx
        │       ├── program-content-client.tsx
        │       └── program-visualizer.tsx
        ├── programs
        │   └── page.tsx
        ├── providers
        │   └── SolanaProvider.tsx
        ├── search
        │   └── page.tsx
        ├── slots
        │   └── page.tsx
        ├── solana
        │   └── page.tsx
        ├── styles
        │   └── vtable.css
        ├── test
        │   ├── transfers
        │   │   └── page.tsx
        │   ├── layout.tsx
        │   ├── page.tsx
        │   └── test-page-client.tsx
        ├── token
        │   └── [mint]
        │       ├── opengraph-image.tsx
        │       └── page.tsx
        ├── tokens
        │   ├── gainers
        │   │   └── page.tsx
        │   ├── new
        │   │   └── page.tsx
        │   └── page.tsx
        ├── tx
        │   ├── [signature]
        │   │   ├── opengraph-image.tsx
        │   │   ├── page.tsx
        │   │   └── TransactionContent.tsx
        │   └── page.tsx
        ├── globals.css
        ├── layout.tsx
        ├── page.tsx
        └── providers.tsx



---
File: /app/account/[address]/components/shared/hooks.ts
---

import { useState, useEffect } from 'react';
import { Transfer } from './types';

interface TransferResponse {
  data: Transfer[];
  hasMore: boolean;
  total?: number;
  error?: string;
}

interface UseTransfersResult {
  transfers: Transfer[];
  loading: boolean;
  error: string | null;
  hasMore: boolean;
  loadMore: () => void;
  totalCount?: number;
}

const CACHE_PREFIX = 'transfers-cache';
const CACHE_EXPIRY = 5 * 60 * 1000; // 5 minutes

interface CacheEntry {
  transfers: Transfer[];
  timestamp: number;
  hasMore: boolean;
  page: number;
}

function getCacheKey(address: string): string {
  return `${CACHE_PREFIX}-${address}`;
}

function getFromCache(address: string): CacheEntry | null {
  if (typeof window === 'undefined') return null;
  
  try {
    const cacheKey = getCacheKey(address);
    const cached = localStorage.getItem(cacheKey);
    if (!cached) return null;

    const entry: CacheEntry = JSON.parse(cached);
    const now = Date.now();
    
    if (now - entry.timestamp > CACHE_EXPIRY) {
      localStorage.removeItem(cacheKey);
      return null;
    }
    
    return entry;
  } catch (err) {
    console.error('Error reading from cache:', err);
    return null;
  }
}

function saveToCache(address: string, transfers: Transfer[], hasMore: boolean, page: number): void {
  if (typeof window === 'undefined') return;
  
  try {
    const cacheKey = getCacheKey(address);
    const entry: CacheEntry = {
      transfers,
      hasMore,
      page,
      timestamp: Date.now()
    };
    localStorage.setItem(cacheKey, JSON.stringify(entry));
  } catch (err) {
    console.error('Error saving to cache:', err);
  }
}

export function useTransfers(address: string): UseTransfersResult {
  const cachedData = getFromCache(address);
  const [transfers, setTransfers] = useState<Transfer[]>(cachedData?.transfers || []);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [hasMore, setHasMore] = useState(cachedData?.hasMore ?? true);
  const [page, setPage] = useState(cachedData?.page || 0);
  const [totalCount, setTotalCount] = useState<number>();

  const fetchTransfers = async (pageToFetch: number) => {
    if (loading || !hasMore) return;
    
    const controller = new AbortController();
    
    try {
      setLoading(true);
      setError(null);
      
      const response = await fetch(`/api/account-transfers/${encodeURIComponent(address)}?offset=${pageToFetch * 1000}`, {
        signal: controller.signal
      });
      
      const result: TransferResponse = await response.json();
      
      if (!response.ok) {
        throw new Error(result.error || 'Failed to fetch transfers');
      }
      
      if (!result.data || !Array.isArray(result.data)) {
        throw new Error('Invalid response format');
      }
      
      if (result.data.length === 0) {
        setHasMore(false);
        saveToCache(address, transfers, false, pageToFetch);
      } else {
        const newTransfers = [...transfers, ...result.data];
        setTransfers(newTransfers);
        const newPage = pageToFetch + 1;
        setPage(newPage);
        saveToCache(address, newTransfers, true, newPage);
        if (result.total) {
          setTotalCount(result.total);
        }
      }
      
    } catch (err) {
      if (err instanceof Error && err.name === 'AbortError') {
        return;
      }

      console.error('Error fetching transfers:', err);
      
      setError(err instanceof Error ? err.message : 'Failed to fetch transfers');
      
    } finally {
      setLoading(false);
    }
  };

  // Initial load
  useEffect(() => {
    const shouldFetch = !cachedData || Date.now() - cachedData.timestamp > CACHE_EXPIRY;
    
    if (shouldFetch) {
      // Only reset state if we don't have valid cached data
      if (!cachedData) {
        setTransfers([]);
        setPage(0);
        setHasMore(true);
      }
      fetchTransfers(0);
    }
// eslint-disable-next-line react-hooks/exhaustive-deps
  }, [address]);

  const loadMore = () => {
    if (!loading && hasMore) {
      fetchTransfers(page);
    }
  };

  return {
    transfers,
    loading,
    error,
    hasMore,
    loadMore,
    totalCount
  };
}



---
File: /app/account/[address]/components/shared/transfer-analytics.ts
---

import { Transfer } from './types';

interface TransferAnalytics {
  totalVolume: number;
  totalTransactions: number;
  uniqueTokens: number;
  topTokens: {
    symbol: string;
    volume: number;
    count: number;
  }[];
  volumeByDay: {
    date: string;
    volume: number;
  }[];
  unusualActivity: {
    type: string;
    details: string;
    timestamp: string;
    signature: string;
  }[];
}

interface GroupedTransfer {
  signature: string;
  timestamp: string;
  transfers: Transfer[];
  totalValue: number;
}

export function groupTransfersByTx(transfers: Transfer[]): GroupedTransfer[] {
  const grouped = transfers.reduce((acc, transfer) => {
    if (!acc[transfer.signature]) {
      acc[transfer.signature] = {
        signature: transfer.signature,
        timestamp: transfer.timestamp,
        transfers: [],
        totalValue: 0
      };
    }
    acc[transfer.signature].transfers.push(transfer);
    acc[transfer.signature].totalValue += transfer.usdValue || 0;
    return acc;
  }, {} as Record<string, GroupedTransfer>);

  return Object.values(grouped).sort((a, b) => 
    new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()
  );
}

export function analyzeTransfers(transfers: Transfer[]): TransferAnalytics {
  const tokenMap = new Map<string, { volume: number; count: number }>();
  const dayVolumes = new Map<string, number>();
  const unusualActivity = [];

  // Calculate volumes and counts
  transfers.forEach(transfer => {
    const symbol = transfer.tokenSymbol || transfer.token;
    const value = transfer.usdValue || 0;
    const day = new Date(transfer.timestamp).toISOString().split('T')[0];

    // Token stats
    if (!tokenMap.has(symbol)) {
      tokenMap.set(symbol, { volume: 0, count: 0 });
    }
    const tokenStats = tokenMap.get(symbol)!;
    tokenStats.volume += value;
    tokenStats.count += 1;

    // Daily volumes
    dayVolumes.set(day, (dayVolumes.get(day) || 0) + value);

    // Detect unusual activity
    if (value > 10000) { // Large transfers
      unusualActivity.push({
        type: 'Large Transfer',
        details: `${symbol} transfer worth $${value.toLocaleString()}`,
        timestamp: transfer.timestamp,
        signature: transfer.signature
      });
    }
  });

  // Get top tokens by volume
  const topTokens = Array.from(tokenMap.entries())
    .map(([symbol, stats]) => ({
      symbol,
      volume: stats.volume,
      count: stats.count
    }))
    .sort((a, b) => b.volume - a.volume)
    .slice(0, 5);

  // Get volume by day
  const volumeByDay = Array.from(dayVolumes.entries())
    .map(([date, volume]) => ({ date, volume }))
    .sort((a, b) => b.date.localeCompare(a.date));

  return {
    totalVolume: transfers.reduce((sum, t) => sum + (t.usdValue || 0), 0),
    totalTransactions: new Set(transfers.map(t => t.signature)).size,
    uniqueTokens: tokenMap.size,
    topTokens,
    volumeByDay,
    unusualActivity
  };
}

export function transfersToCSV(transfers: Transfer[]): string {
  const headers = [
    'Timestamp',
    'Transaction ID',
    'From',
    'To',
    'Token',
    'Amount',
    'USD Value',
    'Current USD Value',
    'Type'
  ];

  const rows = transfers.map(t => [
    t.timestamp,
    t.signature,
    t.from,
    t.to,
    t.tokenSymbol || t.token,
    t.amount.toString(),
    (t.usdValue || '').toString(),
    (t.currentUsdValue || '').toString(),
    t.type
  ]);

  return [
    headers.join(','),
    ...rows.map(row => row.map(cell => `"${cell}"`).join(','))
  ].join('\n');
}

export function downloadCSV(content: string, filename: string) {
  const blob = new Blob([content], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  if (link.download !== undefined) {
    const url = URL.createObjectURL(blob);
    link.setAttribute('href', url);
    link.setAttribute('download', filename);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }
}



---
File: /app/account/[address]/components/shared/types.ts
---

export interface TokenAccount {
  mint: string;
  balance: number;
}

export interface Transfer {
  timestamp: string;
  type: string;
  amount: number;
  token: string;
  from: string;
  to: string;
  mint?: string;
  signature: string;
  tokenName?: string;
  tokenSymbol?: string;
  usdValue?: number;
  currentUsdValue?: number;
}

export type Tab = 'transfers' | 'activity' | 'tokens' | 'nfts' | 'transactions';

export interface TabContainerProps {
  address: string;
  solBalance: number;
  tokenBalances: TokenAccount[];
}



---
File: /app/account/[address]/components/PlaceholderTab.tsx
---

"use client";

import { VTableWrapper } from '@/components/vtable';

export default function PlaceholderTab() {
  const columns = [
    { field: 'id', title: 'ID', width: 80, sortable: true },
    { field: 'name', title: 'Name', width: 200, sortable: true },
  ];

  const data = [
    { id: 1, name: 'Loading...' },
    { id: 2, name: 'Please wait...' },
  ];

  return (
    <div className="w-full">
      <VTableWrapper
        columns={columns}
        data={data}
        loading={true}
      />
    </div>
  );
}



---
File: /app/account/[address]/components/TabContainer.tsx
---

"use client";

import { memo, useCallback } from 'react';
import { useRouter } from 'next/navigation';
import TokensTab from './TokensTab';
import TransfersTab from './TransfersTab';
import PlaceholderTab from './PlaceholderTab';

export const tabs = [
  { id: 'tokens', label: 'Tokens' },
  { id: 'transfers', label: 'Transfers' },
  { id: 'nfts', label: 'NFTs' },
  { id: 'programs', label: 'Programs' },
];

interface Props {
  address: string;
  activeTab: string;
  solBalance: number;
  tokenBalances: { mint: string; balance: number; }[];
}

function TabContainerComponent({ address, activeTab, solBalance, tokenBalances }: Props) {
  const router = useRouter();

  const handleTabChange = useCallback((tabId: string) => {
    router.push(`/account/${address}?tab=${tabId}`);
  }, [address, router]);

  const renderTabs = () => (
    <div className="flex space-x-4 mb-4 border-b border-gray-200">
      {tabs.map(tab => (
        <button
          key={tab.id}
          onClick={() => handleTabChange(tab.id)}
          className={`px-4 py-2 -mb-px ${
            activeTab === tab.id 
              ? 'text-blue-500 border-b-2 border-blue-500 font-medium'
              : 'text-gray-500 hover:text-gray-700'
          }`}
        >
          {tab.label}
        </button>
      ))}
    </div>
  );

  const renderContent = () => {
    switch (activeTab) {
      case 'tokens':
        return <TokensTab address={address} tokenBalances={tokenBalances} />;
      case 'transfers':
        return (
          <div className="w-full">
            <TransfersTab address={address} />
          </div>
        );
      default:
        return <PlaceholderTab />;
    }
  };

  return (
    <div className="mt-6 w-full">
      {renderTabs()}
      {renderContent()}
    </div>
  );
}

export default memo(TabContainerComponent);



---
File: /app/account/[address]/components/TokensTab.tsx
---

"use client";

interface Props {
  address: string;
  tokenBalances: { mint: string; balance: number; }[];
}

export default function TokensTab({ address, tokenBalances }: Props) {
  return (
    <div className="mt-4">
      <table className="w-full">
        <thead>
          <tr>
            <th className="text-left">Token</th>
            <th className="text-right">Balance</th>
          </tr>
        </thead>
        <tbody>
          {tokenBalances.map((token, index) => (
            <tr key={token.mint}>
              <td className="text-left">{token.mint}</td>
              <td className="text-right">{token.balance}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}



---
File: /app/account/[address]/components/TransferAnalytics.tsx
---

"use client";

import { useEffect, useRef, useMemo } from 'react';
import { Transfer } from './shared/types';
import { analyzeTransfers, transfersToCSV, downloadCSV, groupTransfersByTx } from './shared/transfer-analytics';

interface TransferAnalyticsProps {
  transfers: Transfer[];
}

export function TransferAnalytics({ transfers }: TransferAnalyticsProps) {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const analytics = useMemo(() => analyzeTransfers(transfers), [transfers]);
  const groupedTransfers = useMemo(() => groupTransfersByTx(transfers), [transfers]);

  const handleExportCSV = () => {
    const csv = transfersToCSV(transfers);
    downloadCSV(csv, 'transfers.csv');
  };

  useEffect(() => {
    if (!canvasRef.current || !analytics.volumeByDay.length) return;

    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const padding = 40;
    const width = canvas.width - padding * 2;
    const height = canvas.height - padding * 2;

    // Calculate max volume for scale
    const maxVolume = Math.max(...analytics.volumeByDay.map(d => d.volume));

    // Draw axes with rough style
    ctx.beginPath();
    ctx.strokeStyle = '#666';
    ctx.lineWidth = 2;
    // Y-axis with slight wobble
    ctx.moveTo(padding + Math.random() * 2, padding);
    ctx.lineTo(padding + Math.random() * 2, canvas.height - padding);
    // X-axis with slight wobble
    ctx.moveTo(padding, canvas.height - padding + Math.random() * 2);
    ctx.lineTo(canvas.width - padding, canvas.height - padding + Math.random() * 2);
    ctx.stroke();

    // Draw volume bars with hand-drawn style
    const barWidth = (width / analytics.volumeByDay.length) * 0.8;
    analytics.volumeByDay.forEach((day, i) => {
      const barHeight = (day.volume / maxVolume) * height;
      const x = padding + (width / analytics.volumeByDay.length) * i;
      const y = canvas.height - padding - barHeight;

      // Draw each bar with a sketchy style
      ctx.beginPath();
      ctx.fillStyle = '#22c55e44';
      ctx.strokeStyle = '#22c55e';
      ctx.lineWidth = 2;

      // Main bar shape with wobble
      ctx.moveTo(x + Math.random() * 2, canvas.height - padding);
      ctx.lineTo(x + Math.random() * 2, y + Math.random() * 2);
      ctx.lineTo(x + barWidth + Math.random() * 2, y + Math.random() * 2);
      ctx.lineTo(x + barWidth + Math.random() * 2, canvas.height - padding);
      
      // Add some random short lines for texture
      for (let j = 0; j < 3; j++) {
        const randomY = y + Math.random() * barHeight;
        ctx.moveTo(x + Math.random() * barWidth, randomY);
        ctx.lineTo(x + Math.random() * barWidth + 5, randomY + Math.random() * 5);
      }

      ctx.stroke();
      ctx.fill();
    });

    // Draw labels
    ctx.font = '12px sans-serif';
    ctx.fillStyle = '#666';
    ctx.textAlign = 'right';

    // Y-axis labels
    ctx.fillText(`$${maxVolume.toLocaleString()}`, padding - 5, padding + 10);
    ctx.fillText('$0', padding - 5, canvas.height - padding + 10);

    // X-axis labels
    ctx.textAlign = 'center';
    const firstDay = new Date(analytics.volumeByDay[analytics.volumeByDay.length - 1].date);
    const lastDay = new Date(analytics.volumeByDay[0].date);
    ctx.fillText(firstDay.toLocaleDateString(), padding, canvas.height - padding + 20);
    ctx.fillText(lastDay.toLocaleDateString(), canvas.width - padding, canvas.height - padding + 20);

  }, [analytics.volumeByDay]);

  return (
    <div className="space-y-6 mb-6">
      {/* Summary Stats */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
        <div className="p-4 rounded-lg bg-neutral-900 border border-neutral-800">
          <div className="text-sm text-neutral-400">Total Volume</div>
          <div className="text-xl font-medium">
            ${analytics.totalVolume.toLocaleString()}
          </div>
        </div>
        <div className="p-4 rounded-lg bg-neutral-900 border border-neutral-800">
          <div className="text-sm text-neutral-400">Total Transactions</div>
          <div className="text-xl font-medium">
            {analytics.totalTransactions.toLocaleString()}
          </div>
        </div>
        <div className="p-4 rounded-lg bg-neutral-900 border border-neutral-800">
          <div className="text-sm text-neutral-400">Unique Tokens</div>
          <div className="text-xl font-medium">
            {analytics.uniqueTokens.toLocaleString()}
          </div>
        </div>
        <div className="p-4 rounded-lg bg-neutral-900 border border-neutral-800">
          <button
            onClick={handleExportCSV}
            className="w-full h-full flex items-center justify-center gap-2 text-sm text-neutral-400 hover:text-white transition-colors"
          >
            <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
              <path fillRule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clipRule="evenodd" />
            </svg>
            Export CSV
          </button>
        </div>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        {/* Volume Chart */}
        <div className="p-4 rounded-lg bg-neutral-900 border border-neutral-800">
          <h3 className="text-sm font-medium mb-4">Volume by Day</h3>
          <div className="h-64">
            <canvas
              ref={canvasRef}
              width={600}
              height={300}
              className="w-full h-full"
            />
          </div>
        </div>

        {/* Top Tokens */}
        <div className="p-4 rounded-lg bg-neutral-900 border border-neutral-800">
          <h3 className="text-sm font-medium mb-4">Top Tokens by Volume</h3>
          <div className="space-y-4">
            {analytics.topTokens.map((token) => (
              <div key={token.symbol} className="flex items-center justify-between">
                <div>
                  <div className="font-medium">{token.symbol}</div>
                  <div className="text-sm text-neutral-400">
                    {token.count} transfers
                  </div>
                </div>
                <div className="text-right">
                  <div className="font-medium">
                    ${token.volume.toLocaleString()}
                  </div>
                </div>
              </div>
            ))}
          </div>
        </div>
      </div>

      {/* Grouped Transfers */}
      <div className="rounded-lg border border-neutral-800 bg-neutral-900 p-4">
        <h3 className="text-sm font-medium mb-4">Recent Transactions</h3>
        <div className="space-y-4">
          {groupedTransfers.slice(0, 5).map((tx) => (
            <div key={tx.signature} className="border-b border-neutral-800 last:border-0 pb-4 last:pb-0">
              <div className="flex items-center justify-between mb-2">
                <a
                  href={`/tx/${tx.signature}`}
                  className="text-sm text-neutral-400 hover:text-white transition-colors"
                >
                  {tx.signature.slice(0, 8)}...{tx.signature.slice(-8)}
                </a>
                <div className="text-sm text-neutral-500">
                  {new Date(tx.timestamp).toLocaleString()}
                </div>
              </div>
              <div className="space-y-2">
                {tx.transfers.map((transfer, i) => (
                  <div key={i} className="flex items-center justify-between text-sm">
                    <div className="flex items-center gap-2">
                      <span className="text-neutral-400">
                        {transfer.tokenSymbol || transfer.token}
                      </span>
                      <span className="text-neutral-500">
                        {transfer.amount.toLocaleString()}
                      </span>
                    </div>
                    <div className="text-neutral-400">
                      ${transfer.usdValue?.toLocaleString() || '-'}
                    </div>
                  </div>
                ))}
              </div>
            </div>
          ))}
        </div>
      </div>

      {/* Unusual Activity */}
      {analytics.unusualActivity.length > 0 && (
        <div className="p-4 rounded-lg bg-neutral-900 border border-neutral-800">
          <h3 className="text-sm font-medium mb-4">Unusual Activity</h3>
          <div className="space-y-4">
            {analytics.unusualActivity.map((activity, i) => (
              <div key={i} className="flex items-center justify-between">
                <div>
                  <div className="font-medium text-yellow-500">{activity.type}</div>
                  <div className="text-sm text-neutral-400">{activity.details}</div>
                  <div className="text-xs text-neutral-500">
                    {new Date(activity.timestamp).toLocaleString()}
                  </div>
                </div>
                <a
                  href={`/tx/${activity.signature}`}
                  className="text-sm text-neutral-400 hover:text-white transition-colors"
                >
                  View Transaction →
                </a>
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  );
}



---
File: /app/account/[address]/components/TransfersTab.tsx
---

"use client";

import { memo } from 'react';
import { TransfersTable } from '@/components/TransfersTable';

interface Props {
  address: string;
}

function TransfersTabComponent({ address }: Props) {
  return (
    <div className="w-full h-full">
      <TransfersTable key={address} address={address} />
    </div>
  );
}

export default memo(TransfersTabComponent);



---
File: /app/account/[address]/page.tsx
---

import { getConnection } from '@/lib/solana-connection';
import { PublicKey } from '@solana/web3.js';
import { validateSolanaAddress, getAccountInfo as getSolanaAccountInfo } from '@/lib/solana';
import AccountInfo from '@/components/AccountInfo';
import AccountTabs from './tabs';

interface AccountData {
  address: string;
  isSystemProgram: boolean;
  parsedOwner: string;
  solBalance: number;
  tokenBalances: {
    mint: string;
    balance: number;
  }[];
}

async function getAccountData(address: string): Promise<AccountData> {
  const connection = await getConnection();
  
  try {
    const pubkey = validateSolanaAddress(address);
    const accountInfo = await getSolanaAccountInfo(address);
    const balance = await connection.getBalance(pubkey);
    const tokenAccounts = await connection.getParsedTokenAccountsByOwner(pubkey, {
      programId: new PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'),
    });

    const tokenBalances = tokenAccounts.value.map(account => ({
      mint: account.account.data.parsed.info.mint,
      balance: account.account.data.parsed.info.tokenAmount.uiAmount,
    }));

    return {
      address,
      isSystemProgram: !accountInfo?.owner || accountInfo.owner.equals(PublicKey.default),
      parsedOwner: accountInfo?.owner?.toBase58() || PublicKey.default.toBase58(),
      solBalance: balance / 1e9,
      tokenBalances,
    };
  } catch (error) {
    console.error('Error fetching account info:', error);
    return {
      address,
      isSystemProgram: true,
      parsedOwner: PublicKey.default.toBase58(),
      solBalance: 0,
      tokenBalances: [],
    };
  }
}

interface PageProps {
  params: Promise<{ address: string }>;
  searchParams: Promise<{ [key: string]: string | string[] | undefined }>;
}

export default async function AccountPage({ params, searchParams }: PageProps) {
  const { address: rawAddress } = await params;
  const resolvedSearchParams = await searchParams;
  const { tab } = resolvedSearchParams;
  const activeTab = tab || 'tokens';
  
  try {
    // Basic validation
    if (!rawAddress) {
      throw new Error('Address is required');
    }

    // Clean up the address
    let address = rawAddress;
    try {
      address = decodeURIComponent(rawAddress);
    } catch (e) {
      // Address was likely already decoded
    }
    address = address.trim();

    // Basic format validation
    if (!/^[1-9A-HJ-NP-Za-km-z]+$/.test(address)) {
      throw new Error('Invalid characters in address. Solana addresses can only contain base58 characters.');
    }

    if (address.length < 32 || address.length > 44) {
      throw new Error('Invalid address length. Solana addresses must be between 32 and 44 characters.');
    }

    // Fetch account info
    try {
      const accountInfo = await getAccountData(address);

      return (
        <div className="container mx-auto px-4 py-8">
          <AccountInfo
            address={accountInfo.address}
            isSystemProgram={accountInfo.isSystemProgram}
            parsedOwner={accountInfo.parsedOwner}
          />
          <AccountTabs
            address={accountInfo.address}
            solBalance={accountInfo.solBalance}
            tokenBalances={accountInfo.tokenBalances}
            activeTab={activeTab as string}
          />
        </div>
      );
    } catch (error) {
      console.error('Error fetching account info:', error);
      return (
        <div className="container mx-auto px-4 py-8">
          <div className="rounded-lg border border-red-500 bg-red-50 p-4">
            <h2 className="text-xl font-semibold text-red-700">Error</h2>
            <p className="text-red-600">Account not found or invalid address format</p>
            <p className="mt-2 text-sm text-red-500">Please check the address and try again</p>
          </div>
        </div>
      );
    }
  } catch (error) {
    console.error('Error in account page:', error);
    return (
      <div className="container mx-auto px-4 py-8">
        <div className="rounded-lg border border-red-500 bg-red-50 p-4">
          <h2 className="text-xl font-semibold text-red-700">Error</h2>
          <p className="text-red-600">{error instanceof Error ? error.message : 'Invalid address format'}</p>
          <p className="mt-2 text-sm text-red-500">Please provide a valid Solana address</p>
        </div>
      </div>
    );
  }
}



---
File: /app/account/[address]/tabs.tsx
---

"use client";

import TabContainer from './components/TabContainer';

export interface Tab {
  id: string;
  label: string;
}

export const tabs: Tab[] = [
  { id: 'tokens', label: 'Tokens' },
  { id: 'transfers', label: 'Transfers' },
  { id: 'nfts', label: 'NFTs' },
  { id: 'programs', label: 'Programs' },
];

interface Props {
  address: string;
  solBalance: number;
  tokenBalances: { mint: string; balance: number; }[];
  activeTab: string;
}

export default function Tabs({ address, solBalance, tokenBalances, activeTab }: Props) {
  return (
    <div className="w-full">
      <TabContainer address={address} activeTab={activeTab} solBalance={solBalance} tokenBalances={tokenBalances} />
    </div>
  );
}



---
File: /app/admin/page.tsx
---

export default async function AdminPage() {
  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold mb-6">Admin Dashboard</h1>
      
      <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
        {/* System Stats Card */}
        <div className="p-6 bg-white dark:bg-gray-800 rounded-lg shadow">
          <h2 className="text-xl font-semibold mb-4">System Stats</h2>
          <div className="space-y-2">
            <p>API Requests: 1,234</p>
            <p>Active Users: 567</p>
            <p>Server Load: 45%</p>
          </div>
        </div>

        {/* User Management Card */}
        <div className="p-6 bg-white dark:bg-gray-800 rounded-lg shadow">
          <h2 className="text-xl font-semibold mb-4">User Management</h2>
          <button className="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded">
            View Users
          </button>
        </div>

        {/* System Settings Card */}
        <div className="p-6 bg-white dark:bg-gray-800 rounded-lg shadow">
          <h2 className="text-xl font-semibold mb-4">System Settings</h2>
          <button className="bg-gray-500 hover:bg-gray-600 text-white px-4 py-2 rounded">
            Configure Settings
          </button>
        </div>
      </div>
    </div>
  );
}


---
File: /app/analytics/defi/page.tsx
---

export default function DeFiAnalyticsPage() {
  return (
    <div className="container mx-auto py-8">
      <div className="mb-8">
        <h1 className="text-4xl font-bold mb-2">DeFi Overview</h1>
        <p className="text-muted-foreground">
          Comprehensive statistics and analytics for DeFi protocols on Solana.
        </p>
      </div>
      <div className="rounded-md border p-8 text-center">
        <p className="text-muted-foreground">DeFi analytics coming soon...</p>
      </div>
    </div>
  );
}



---
File: /app/analytics/tokens/page.tsx
---

export default function TokenAnalyticsPage() {
  return (
    <div className="container mx-auto py-8">
      <div className="mb-8">
        <h1 className="text-4xl font-bold mb-2">Token Analytics</h1>
        <p className="text-muted-foreground">
          In-depth market analysis and metrics for tokens on Solana.
        </p>
      </div>
      <div className="rounded-md border p-8 text-center">
        <p className="text-muted-foreground">Token analytics coming soon...</p>
      </div>
    </div>
  );
}



---
File: /app/analytics/page.tsx
---

export default function AnalyticsPage() {
  return (
    <div className="container mx-auto py-8">
      <div className="mb-8">
        <h1 className="text-4xl font-bold mb-2">Network Stats</h1>
        <p className="text-muted-foreground">
          Solana network performance metrics and analytics.
        </p>
      </div>
      <div className="rounded-md border p-8 text-center">
        <p className="text-muted-foreground">Network analytics coming soon...</p>
      </div>
    </div>
  );
}



---
File: /app/api/account-stats/[address]/route.ts
---

import { NextRequest, NextResponse } from 'next/server';
import { getConnection } from '@/lib/solana-connection';
import { PublicKey } from '@solana/web3.js';
import { memoryCache } from '@/lib/cache';
import { queryFlipside } from '@/lib/flipside';

const BATCH_SIZE = 1000;
const MAX_BATCHES = 3;
const CACHE_TTL = 300; // 5 minutes
const CACHE_ERROR_TTL = 60; // 1 minute
const QUERY_TIMEOUT = 5000; // 5 seconds
const API_TIMEOUT = 10000; // 10 seconds

interface AccountStats {
  totalTransactions: string | number;
  tokenTransfers: number;
  lastUpdated: number;
}

type TransferCount = {
  transfer_count: number;
}

async function getSignatureCount(pubkey: PublicKey, connection: any): Promise<string | number> {
  const cacheKey = `signatures-${pubkey.toBase58()}`;
  const cachedData = memoryCache.get<number>(cacheKey);
  if (cachedData !== null) {
    return cachedData;
  }

  const batches = [];
  let before = undefined;

  for (let i = 0; i < MAX_BATCHES; i++) {
    batches.push(
      connection.getSignaturesForAddress(pubkey, {
        before,
        limit: BATCH_SIZE
      }).then(signatures => {
        if (signatures.length > 0) {
          before = signatures[signatures.length - 1].signature;
        }
        return signatures;
      })
    );
  }

  const results = await Promise.all(batches);
  const allSignatures = results.flatMap(batch => batch);
  const count = allSignatures.length === MAX_BATCHES * BATCH_SIZE
    ? `${allSignatures.length}+`
    : allSignatures.length;

  memoryCache.set(cacheKey, count, CACHE_TTL);
  return count;
}

async function getTokenTransfers(address: string): Promise<number> {
  const cacheKey = `transfers-${address}`;
  const cachedData = memoryCache.get<number>(cacheKey);
  if (cachedData !== null) {
    return cachedData;
  }

  // Add timeout to prevent hanging
  let timeoutId: NodeJS.Timeout;
  const timeoutPromise = new Promise<number>((_, reject) => {
    timeoutId = setTimeout(() => {
      reject(new Error('Flipside query timeout'));
    }, QUERY_TIMEOUT);
  });

  const query = `
    WITH recent_transfers AS (
      SELECT 
        DATE_TRUNC('minute', block_timestamp) as ts,
        COUNT(DISTINCT tx_id) as tx_count
      FROM solana.core.fact_transfers
      WHERE block_timestamp >= DATEADD('hour', -24, CURRENT_TIMESTAMP())
      AND (tx_to = '${address}' OR tx_from = '${address}')
      GROUP BY 1
    )
    SELECT COUNT(*) as transfer_count
    FROM recent_transfers
  `;

  try {
    // Race between query and timeout
    const results = await Promise.race([
      queryFlipside<TransferCount>(query),
      timeoutPromise
    ]);

    clearTimeout(timeoutId!);

    if (Array.isArray(results) && results.length > 0) {
      const transferCount = Number(results[0]?.transfer_count) || 0;
      memoryCache.set(cacheKey, transferCount, CACHE_TTL);
      return transferCount;
    }

    // If query fails or returns no results, try getting cached data
    const cachedCount = memoryCache.get<number>(cacheKey);
    if (cachedCount !== null) {
      return cachedCount;
    }

    return 0;
  } catch (error) {
    console.error('Error querying Flipside:', error);
    // Return 0 and cache it to prevent repeated timeouts
    memoryCache.set(cacheKey, 0, CACHE_ERROR_TTL);
    return 0;
  }
}

export async function GET(
  request: NextRequest,
  context: { params: Promise<{ address: string }> }
) {
  try {
    // Get the address from params - properly awaited in Next.js 15
    const params = await context.params;
    const { address } = await params;
    
    // Add overall API timeout
    let timeoutId: NodeJS.Timeout;
    const timeoutPromise = new Promise((_, reject) => {
      timeoutId = setTimeout(() => {
        reject(new Error('API timeout'));
      }, API_TIMEOUT);
    });

    const cacheKey = `account-stats-${address}`;
    const cachedStats = memoryCache.get<AccountStats>(cacheKey);
    
    // Return cached data and refresh in background if stale
    if (cachedStats) {
      const age = Date.now() - cachedStats.lastUpdated;
      if (age > CACHE_TTL * 1000) {
        // Refresh in background if cache is stale
        refreshAccountStats(address, cacheKey).catch(console.error);
      }
      clearTimeout(timeoutId!);
      return NextResponse.json(cachedStats, {
        headers: {
          'Cache-Control': 'public, s-maxage=300, stale-while-revalidate=60'
        }
      });
    }

    const connection = await getConnection();
    const pubkey = new PublicKey(address);

    // Race between data fetching and timeout
    const [totalTransactions, tokenTransfers] = await Promise.race([
      Promise.all([
        getSignatureCount(pubkey, connection),
        getTokenTransfers(address)
      ]),
      timeoutPromise
    ]) as [string | number, number];

    clearTimeout(timeoutId!);

    const stats: AccountStats = {
      totalTransactions,
      tokenTransfers,
      lastUpdated: Date.now()
    };

    memoryCache.set(cacheKey, stats, CACHE_TTL);

    return NextResponse.json(stats, {
      headers: {
        'Cache-Control': 'public, s-maxage=300, stale-while-revalidate=60'
      }
    });
  } catch (error) {
    console.error('Error fetching account stats:', error);
    return NextResponse.json(
      { error: 'Failed to fetch account stats' },
      { status: 500 }
    );
  }
}

// Background refresh function
async function refreshAccountStats(address: string, cacheKey: string) {
  try {
    const connection = await getConnection();
    const pubkey = new PublicKey(address);

    const [totalTransactions, tokenTransfers] = await Promise.all([
      getSignatureCount(pubkey, connection),
      getTokenTransfers(address)
    ]);

    const stats: AccountStats = {
      totalTransactions,
      tokenTransfers,
      lastUpdated: Date.now()
    };

    memoryCache.set(cacheKey, stats, CACHE_TTL);
  } catch (error) {
    console.error('Error refreshing account stats:', error);
  }
}



---
File: /app/api/account-token-stats/[address]/[mint]/route.ts
---

import { NextRequest, NextResponse } from 'next/server';
import { PublicKey } from '@solana/web3.js';
import { getConnection } from '@/lib/solana-connection';

export async function GET(
  request: NextRequest,
  context: { params: Promise<{ address: string; mint: string }> }
) {
  try {
    const connection = await getConnection();
    const params = await context.params;
    const { address, mint } = await params;

    // Get SOL balance
    const balance = await connection.getBalance(new PublicKey(address));

    // Count transfers for this token
    const signatures = await connection.getSignaturesForAddress(new PublicKey(address), { limit: 1000 });
    let transferCount = 0;

    for (const { signature } of signatures) {
      try {
        const tx = await connection.getParsedTransaction(signature, {
          maxSupportedTransactionVersion: 0
        });
        if (!tx?.meta) continue;

        const transfers = tx.meta.postTokenBalances?.filter(
          balance => balance.mint === mint
        );

        if (transfers?.length) {
          transferCount++;
        }
      } catch (err) {
        console.error('Error parsing transaction:', err);
      }
    }

    return NextResponse.json({
      solBalance: balance / 1e9, // Convert lamports to SOL
      transferCount
    });
  } catch (error) {
    console.error('Error fetching account token stats:', error);
    return NextResponse.json(
      { error: 'Failed to fetch account token stats' },
      { status: 500 }
    );
  }
}



---
File: /app/api/account-transfers/[address]/route.ts
---

import { NextRequest, NextResponse } from 'next/server';
import { PublicKey } from '@solana/web3.js';
import { getConnection } from '@/lib/solana-connection';
import { z } from 'zod';

export const dynamic = 'force-dynamic';
export const dynamicParams = true;
export const revalidate = 0;
export const fetchCache = 'force-no-store';

// Constants
const MAX_BATCH_SIZE = 10;
const CACHE_TTL = 300_000;
const TX_TIMEOUT = 5000;
const PRICE_CACHE_TTL = 60_000;

// In-memory cache
const cache = new Map<string, any>();

// Cache cleanup interval
if (typeof setInterval !== 'undefined') {
  setInterval(() => {
    const now = Date.now();
    for (const [key, value] of cache.entries()) {
      if (now > value.expiry) {
        cache.delete(key);
      }
    }
  }, 60_000);
}

// More permissive schema for optional parameters
const QuerySchema = z.object({
  before: z.string().nullish(),
  limit: z.preprocess(
    (val) => Number(val) || 20,
    z.number().min(1).max(100)
  ),
  sortBy: z.enum(['date', 'tokenAmount', 'usdValue', 'currentUsdValue']).default('date'),
  sortOrder: z.enum(['asc', 'desc']).default('desc'),
  filterType: z.enum(['IN', 'OUT', 'ALL']).default('ALL'),
  minAmount: z.string().nullish(),
  maxAmount: z.string().nullish(),
  tokenSymbol: z.string().nullish()
}).transform((data) => ({
  ...data,
  before: data.before || undefined,
  minAmount: data.minAmount || undefined,
  maxAmount: data.maxAmount || undefined,
  tokenSymbol: data.tokenSymbol || undefined
}));

interface Transfer {
  txId: string;
  date: string;
  from: string;
  to: string;
  tokenSymbol: string;
  tokenAmount: string;
  usdValue: string;
  currentUsdValue: string;
  transferType: 'IN' | 'OUT';
}

async function getCachedData<T>(key: string): Promise<T | null> {
  try {
    const cached = cache.get(key);
    if (!cached) return null;
    
    if (Date.now() > cached.expiry) {
      cache.delete(key);
      return null;
    }
    
    return cached.data;
  } catch (err) {
    console.error('Cache error:', err);
    return null;
  }
}

async function setCacheData<T>(key: string, data: T, ttl: number = CACHE_TTL): Promise<void> {
  try {
    cache.set(key, {
      data,
      expiry: Date.now() + ttl
    });
  } catch (err) {
    console.error('Cache error:', err);
  }
}

async function getPriceData(symbol: string): Promise<number> {
  try {
    const cacheKey = `price:${symbol}`;
    const cached = await getCachedData<number>(cacheKey);
    
    if (cached !== null) {
      return cached;
    }

    try {
      const response = await fetch(
        `https://api.coingecko.com/api/v3/simple/price?ids=solana&vs_currencies=usd`,
        { next: { revalidate: 60 } }
      );
      const data = await response.json();
      const price = data?.solana?.usd || 0;

      if (price > 0) {
        await setCacheData(cacheKey, price, PRICE_CACHE_TTL);
      }
      return price;
    } catch (err) {
      console.error('Price API error:', err);
      return 0;
    }
  } catch (err) {
    console.error('Price fetch error:', err);
    return 0;
  }
}

async function fetchTransactionWithTimeout(
  connection: any,
  signature: string,
  timeout: number
): Promise<any> {
  return Promise.race([
    connection.getTransaction(signature, {
      maxSupportedTransactionVersion: 0,
      commitment: 'confirmed'
    }),
    new Promise((_, reject) => 
      setTimeout(() => reject(new Error('Transaction fetch timeout')), timeout)
    )
  ]);
}

async function fetchTransactionBatch(
  connection: any,
  signatures: string[],
  address: string
): Promise<Transfer[]> {
  const transfers: Transfer[] = [];
  const startTime = Date.now();

  await Promise.all(
    signatures.map(async (signature) => {
      let retries = 3;
      while (retries > 0) {
        try {
          const tx = await fetchTransactionWithTimeout(connection, signature, TX_TIMEOUT);
          if (!tx?.meta) return;

          const preBalances = tx.meta.preBalances || [];
          const postBalances = tx.meta.postBalances || [];
          const accountKeys = tx.transaction.message.getAccountKeys();
          const blockTime = tx.blockTime! * 1000;

          const solPrice = await getPriceData('SOL');

          preBalances.forEach((_, index) => {
            const preBalance = preBalances[index] || 0;
            const postBalance = postBalances[index] || 0;
            const delta = postBalance - preBalance;
            const account = accountKeys.get(index)?.toString();
            const firstAccount = accountKeys.get(0)?.toString();

            if (delta === 0 || !account) return;

            const amount = Math.abs(delta / 1e9);
            const usdValue = amount * solPrice;

            transfers.push({
              txId: signature,
              date: new Date(blockTime).toISOString(),
              from: delta < 0 ? account : (delta > 0 ? firstAccount : ''),
              to: delta > 0 ? account : (delta < 0 ? firstAccount : ''),
              tokenSymbol: 'SOL',
              tokenAmount: amount.toString(),
              usdValue: usdValue.toString(),
              currentUsdValue: usdValue.toString(),
              transferType: delta < 0 ? 'OUT' : 'IN',
            });
          });

          break;
        } catch (err) {
          console.error(`Transaction error (${retries} retries left):`, err);
          retries--;
          if (retries > 0) {
            await new Promise(resolve => setTimeout(resolve, 1000));
          }
        }
      }
    })
  );

  console.log(`Processed ${transfers.length} transfers in ${Date.now() - startTime}ms`);
  return transfers;
}

export async function GET(
  request: NextRequest,
  context: { params: Promise<{ address: string }> }
) {
  const startTime = Date.now();

  try {
    const params = await context.params;
    const { address: rawAddress } = await params;
    const address = decodeURIComponent(String(rawAddress));
    console.log(`Starting transfer fetch for ${address}`);

    const searchParams = request.nextUrl.searchParams;
    
    // Build query parameters with defaults
    const queryParams = {
      before: searchParams.get('before') || undefined,
      limit: searchParams.get('limit') || 20,
      sortBy: searchParams.get('sortBy') || 'date',
      sortOrder: searchParams.get('sortOrder') || 'desc',
      filterType: searchParams.get('filterType') || 'ALL',
      minAmount: searchParams.get('minAmount') || undefined,
      maxAmount: searchParams.get('maxAmount') || undefined,
      tokenSymbol: searchParams.get('tokenSymbol') || undefined,
    };

    // Validate query parameters
    const query = QuerySchema.parse(queryParams);

    // Validate address
    const pubkey = new PublicKey(address);
    
    // Check cache first
    const cacheKey = `transfers:${address}:${JSON.stringify(query)}`;
    const cached = await getCachedData<Transfer[]>(cacheKey);
    
    if (cached) {
      console.log(`Cache hit for ${address}, returning ${cached.length} transfers in ${Date.now() - startTime}ms`);
      return NextResponse.json({
        transfers: cached,
        hasMore: false,
        cached: true
      });
    }

    // Get connection from pool
    const connection = await getConnection();

    // Fetch signatures
    console.log(`Fetching signatures for ${address}`);
    const signatures = await connection.getSignaturesForAddress(
      pubkey,
      {
        before: query.before,
        limit: query.limit
      }
    );

    if (signatures.length === 0) {
      return NextResponse.json({
        transfers: [],
        hasMore: false
      });
    }

    console.log(`Found ${signatures.length} signatures, processing in batches of ${MAX_BATCH_SIZE}`);

    // Process transactions in batches
    const transfers: Transfer[] = [];
    for (let i = 0; i < signatures.length; i += MAX_BATCH_SIZE) {
      const batchStartTime = Date.now();
      const batch = signatures.slice(i, i + MAX_BATCH_SIZE);
      console.log(`Processing batch ${Math.floor(i / MAX_BATCH_SIZE) + 1}/${Math.ceil(signatures.length / MAX_BATCH_SIZE)}`);
      
      const batchTransfers = await fetchTransactionBatch(
        connection,
        batch.map(s => s.signature),
        address
      );
      transfers.push(...batchTransfers);
      
      console.log(`Batch processed in ${Date.now() - batchStartTime}ms`);
    }

    console.log(`Total transfers found: ${transfers.length}`);

    // Apply filters
    let filteredTransfers = transfers;
    
    if (query.filterType !== 'ALL') {
      filteredTransfers = filteredTransfers.filter(t => t.transferType === query.filterType);
    }

    if (query.minAmount) {
      const minAmount = parseFloat(query.minAmount);
      if (!isNaN(minAmount)) {
        filteredTransfers = filteredTransfers.filter(
          t => parseFloat(t.tokenAmount) >= minAmount
        );
      }
    }

    if (query.maxAmount) {
      const maxAmount = parseFloat(query.maxAmount);
      if (!isNaN(maxAmount)) {
        filteredTransfers = filteredTransfers.filter(
          t => parseFloat(t.tokenAmount) <= maxAmount
        );
      }
    }

    if (query.tokenSymbol) {
      filteredTransfers = filteredTransfers.filter(
        t => t.tokenSymbol.toLowerCase() === query.tokenSymbol!.toLowerCase()
      );
    }

    // Apply sorting
    filteredTransfers.sort((a, b) => {
      const aValue = a[query.sortBy as keyof Transfer];
      const bValue = b[query.sortBy as keyof Transfer];
      
      if (typeof aValue === 'string' && typeof bValue === 'string') {
        if (query.sortBy === 'date') {
          return query.sortOrder === 'desc'
            ? new Date(bValue).getTime() - new Date(aValue).getTime()
            : new Date(aValue).getTime() - new Date(bValue).getTime();
        }
        
        const aNum = parseFloat(aValue);
        const bNum = parseFloat(bValue);
        
        if (!isNaN(aNum) && !isNaN(bNum)) {
          return query.sortOrder === 'desc' ? bNum - aNum : aNum - bNum;
        }
        
        return query.sortOrder === 'desc'
          ? bValue.localeCompare(aValue)
          : aValue.localeCompare(bValue);
      }
      
      return 0;
    });

    // Cache the results
    await setCacheData(cacheKey, filteredTransfers);

    console.log(`Request completed in ${Date.now() - startTime}ms`);
    return NextResponse.json({
      transfers: filteredTransfers,
      hasMore: signatures.length === query.limit,
      cached: false
    });

  } catch (error) {
    console.error('API Error:', error);
    const errorTime = Date.now() - startTime;
    console.error(`Request failed after ${errorTime}ms`);
    
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Invalid query parameters', details: error.errors },
        { status: 400 }
      );
    }

    return NextResponse.json(
      { error: 'Failed to fetch transfers' },
      { status: 500 }
    );
  }
}



---
File: /app/api/analyze/route.ts
---

import { NextRequest, NextResponse } from 'next/server';

const DEEPSEEK_PROMPT = `You are a Solana transaction analyzer. Your task is to:
1. Analyze the transaction data and explain what happened in simple terms
2. Identify the likely goal of the user who made this transaction
3. Point out any notable patterns or implications

Focus on:
- Program interactions and their purpose
- Token transfers and their significance
- Any interesting patterns in the transaction flow
- Potential user intentions based on the transaction type

Keep your analysis clear and concise, avoiding technical jargon when possible.`;

export async function POST(req: NextRequest) {
  try {
    const { prompt } = await req.json();

    // Use deepseek r1 reasoner to analyze the transaction
    const response = await fetch('http://localhost:11434/api/generate', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        model: 'deepseek-coder:6.7b',
        prompt: `${DEEPSEEK_PROMPT}\n\n${prompt}`,
        stream: false,
        options: {
          temperature: 0.7,
          num_predict: 1000
        }
      })
    });

    if (!response.ok) {
      throw new Error('Failed to analyze transaction');
    }

    const result = await response.json();
    const analysis = result.response.trim();

    return NextResponse.json({ analysis });
  } catch (error) {
    console.error('Error analyzing transaction:', error);
    return NextResponse.json(
      { error: 'Failed to analyze transaction' },
      { status: 500 }
    );
  }
}



---
File: /app/api/analyze-transaction/route.ts
---

import { NextResponse } from 'next/server';

export async function POST(request: Request) {
  try {
    const { logs, type, status, amount, from, to } = await request.json();

    const prompt = `Analyze this Solana transaction:
Type: ${type}
Status: ${status}
Amount: ${amount} SOL
From: ${from}
To: ${to}

Transaction Logs:
${logs.join('\n')}

Please explain in simple terms what happened in this transaction, including:
1. What type of operation was performed
2. Whether it was successful
3. Any notable details from the logs
4. Potential purpose of the transaction`;

    const response = await fetch('https://api.together.xyz/inference', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${process.env.TOGETHER_API_KEY}`
      },
      body: JSON.stringify({
        model: 'mistralai/Mixtral-8x7B-Instruct-v0.1',
        prompt,
        max_tokens: 500,
        temperature: 0.7,
        top_p: 0.7,
        top_k: 50,
        repetition_penalty: 1,
        stop: ['<human>', '<assistant>'],
      }),
    });

    if (!response.ok) {
      throw new Error('GPT API request failed');
    }

    const data = await response.json();
    return NextResponse.json({ analysis: data.output.choices[0].text.trim() });
  } catch (error) {
    console.error('Error analyzing transaction:', error);
    return NextResponse.json(
      { error: 'Failed to analyze transaction' },
      { status: 500 }
    );
  }
} 


---
File: /app/api/block/route.ts
---

export const dynamic = 'force-dynamic';
import { NextRequest, NextResponse } from 'next/server';
import { getConnection } from '@/lib/solana';

export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams;
  const slot = searchParams.get('slot');

  if (!slot) {
    return NextResponse.json(
      { error: 'Slot parameter is required' },
      { status: 400 }
    );
  }

  try {
    const conn = await getConnection();
    const slotNumber = parseInt(slot);
    if (isNaN(slotNumber)) {
      return NextResponse.json(
        { error: 'Invalid slot number' },
        { status: 400 }
      );
    }

    const [block, blockTime] = await Promise.all([
      conn.getBlock(slotNumber, { maxSupportedTransactionVersion: 0 }),
      conn.getBlockTime(slotNumber),
    ]);

    if (!block) {
      return NextResponse.json(
        { error: 'Block not found' },
        { status: 404 }
      );
    }

    return NextResponse.json({ block, blockTime });
  } catch (error) {
    console.error('Error fetching block:', error);
    return NextResponse.json(
      { error: 'Failed to fetch block data' },
      { status: 500 }
    );
  }
} 


---
File: /app/api/blocks/[slot]/route.ts
---

import { NextRequest, NextResponse } from 'next/server';
import { getConnection } from '@/lib/solana';

export async function GET(
  request: NextRequest,
  context: { params: Promise<{ slot: string }> }
) {
  try {
    const params = await context.params;
    const { slot } = await params;
    const conn = await getConnection();

    if (!slot) {
      return NextResponse.json(
        { error: 'Slot parameter is required' },
        { status: 400 }
      );
    }

    const slotNumber = parseInt(slot);
    if (isNaN(slotNumber)) {
      return NextResponse.json(
        { error: 'Invalid slot number' },
        { status: 400 }
      );
    }

    const [block, blockTime] = await Promise.all([
      conn.getBlock(slotNumber, { maxSupportedTransactionVersion: 0 }),
      conn.getBlockTime(slotNumber),
    ]);

    if (!block) {
      return NextResponse.json(
        { error: 'Block not found' },
        { status: 404 }
      );
    }

    return NextResponse.json({ block, blockTime });
  } catch (error) {
    console.error('Error fetching block data:', error);
    return NextResponse.json(
      { error: 'Failed to fetch block data' },
      { status: 500 }
    );
  }
}


---
File: /app/api/chat/route.ts
---

import { NextResponse } from 'next/server';

export async function POST(req: Request) {
  if (!process.env.ANTHROPIC_API_KEY) {
    return NextResponse.json(
      { error: 'ANTHROPIC_API_KEY environment variable is not set' },
      { status: 500 }
    );
  }

  try {
    const { messages } = await req.json();

    const response = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': process.env.ANTHROPIC_API_KEY,
        'anthropic-version': '2023-06-01'
      },
      body: JSON.stringify({
        model: 'claude-3-opus-20240229',
        max_tokens: 1024,
        messages: messages.map((msg: { role: string; content: string; }) => ({
          role: msg.role === 'assistant' ? 'assistant' : 'user',
          content: msg.content
        }))
      })
    });

    if (!response.ok) {
      throw new Error(`Anthropic API error: ${response.statusText}`);
    }

    const data = await response.json();
    return NextResponse.json({ response: data.content[0].text });
  } catch (error) {
    console.error('Error in chat API route:', error);
    return NextResponse.json(
      { error: 'Failed to process chat request' },
      { status: 500 }
    );
  }
}



---
File: /app/api/check-account-type/route.ts
---

import { NextResponse } from 'next/server';
import { PublicKey } from '@solana/web3.js';
import { getMint } from '@solana/spl-token';
import { getConnection } from '@/lib/solana-connection';
import { isValidSolanaAddress } from '@/lib/utils';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const address = searchParams.get('address');

  if (!address) {
    return NextResponse.json({ error: 'Address is required' }, { status: 400 });
  }

  if (!isValidSolanaAddress(address)) {
    console.log('Invalid Solana address format:', address);
    return NextResponse.json({ type: 'unknown' });
  }

  try {
    console.log('Checking account type:', address);
    const connection = await getConnection();
    const pubkey = new PublicKey(address);
    const accountInfo = await connection.getAccountInfo(pubkey);
    
    if (!accountInfo) {
      console.log('Account not found:', address);
      return NextResponse.json({ type: 'unknown' });
    }

    // Check if it's a program (executable)
    if (accountInfo.executable) {
      console.log('Found program:', address, 'Size:', accountInfo.data.length);
      return NextResponse.json({ type: 'program' });
    }

    // Check if it's a token mint
    const TOKEN_PROGRAM_ID = new PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');
    const TOKEN_2022_PROGRAM_ID = new PublicKey('TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb');
    
    const owner = accountInfo.owner;
    if (owner.equals(TOKEN_PROGRAM_ID) || owner.equals(TOKEN_2022_PROGRAM_ID)) {
      try {
        // Verify it's a valid mint account
        const mintInfo = await getMint(connection, pubkey);
        if (mintInfo.isInitialized) {
          console.log('Found token mint:', address, 'Owner:', owner.toBase58());
          return NextResponse.json({ type: 'token' });
        }
      } catch (error) {
        console.log('Not a valid token mint:', address);
      }
    }

    // Regular account
    console.log('Found regular account:', address, 'Owner:', owner);
    return NextResponse.json({ type: 'account' });
  } catch (error) {
    console.error('Error checking account type:', error);
    return NextResponse.json({ type: 'unknown' });
  }
}



---
File: /app/api/check-token/route.ts
---

export const dynamic = 'force-dynamic';
import { NextResponse } from 'next/server';
import { PublicKey } from '@solana/web3.js';
import { getMint } from '@solana/spl-token';
import { getConnection } from '@/lib/solana-connection';
import { isValidSolanaAddress } from '@/lib/utils';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const address = searchParams.get('address');

  if (!address) {
    return NextResponse.json({ error: 'Address is required' }, { status: 400 });
  }

  if (!isValidSolanaAddress(address)) {
    console.log('Invalid Solana address format:', address);
    return NextResponse.json({ isToken: false });
  }

  try {
    console.log('Checking if address is token mint:', address);
    const connection = await getConnection();
    const pubkey = new PublicKey(address);
    
    // First check if account exists and get its owner
    const accountInfo = await connection.getAccountInfo(pubkey);
    if (!accountInfo?.owner) {
      console.log('Account not found or no owner:', address);
      return NextResponse.json({ isToken: false });
    }

    // Check if account is owned by Token Program
    const TOKEN_PROGRAM_ID = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA';
    const TOKEN_2022_PROGRAM_ID = 'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb';
    
    const owner = accountInfo.owner.toBase58();
    const isToken = owner === TOKEN_PROGRAM_ID || owner === TOKEN_2022_PROGRAM_ID;
    
    if (isToken) {
      console.log('Found token mint:', address, 'Owner:', owner);
    } else {
      console.log('Not a token mint:', address, 'Owner:', owner);
    }
    
    return NextResponse.json({ isToken });
  } catch (error) {
    // If error is not related to invalid mint, log it
    if (!(error instanceof Error) || !error.message.includes('Invalid mint')) {
      console.error('Error checking token mint:', error);
    } else {
      console.log('Not a valid token mint:', address);
    }
    return NextResponse.json({ isToken: false });
  }
}



---
File: /app/api/favicon/route.ts
---

import { promises as fs } from 'fs';
import { NextResponse } from 'next/server';
import path from 'path';

export async function GET() {
  try {
    const faviconPath = path.join(process.cwd(), 'public', 'favicon.svg');
    const faviconContent = await fs.readFile(faviconPath, 'utf-8');

    return new NextResponse(faviconContent, {
      headers: {
        'Content-Type': 'image/svg+xml',
        'Cache-Control': 'public, max-age=31536000, immutable',
      },
    });
  } catch (error) {
    console.error('Error serving favicon:', error);
    return new NextResponse('Favicon not found', { status: 404 });
  }
}


---
File: /app/api/getAnswer/route.ts
---

import { Readability } from "@mozilla/readability";
import jsdom, { JSDOM } from "jsdom";
import {
  TogetherAIStream,
  TogetherAIStreamPayload,
} from "@/utils/TogetherAIStream";
import Together from "together-ai";

export const maxDuration = 45;

export async function POST(request: Request) {
  if (!process.env.TOGETHER_API_KEY) {
    return new Response(
      JSON.stringify({ error: 'TOGETHER_API_KEY environment variable is not set' }),
      { 
        status: 500,
        headers: { 'Content-Type': 'application/json' }
      }
    );
  }

  const together = new Together({
    apiKey: process.env.TOGETHER_API_KEY,
    baseURL: "https://together.helicone.ai/v1",
    defaultHeaders: {
      "Helicone-Auth": `Bearer ${process.env.HELICONE_API_KEY}`,
    },
  });

  let { question, sources } = await request.json();

  console.log("[getAnswer] Fetching text from source URLS");
  let finalResults = await Promise.all(
    sources.map(async (result: any) => {
      try {
        // Fetch the source URL, or abort if it's been 3 seconds
        const response = await fetchWithTimeout(result.url);
        const html = await response.text();
        const virtualConsole = new jsdom.VirtualConsole();
        const dom = new JSDOM(html, { virtualConsole });

        const doc = dom.window.document;
        const parsed = new Readability(doc).parse();
        let parsedContent = parsed
          ? cleanedText(parsed.textContent)
          : "Nothing found";

        return {
          ...result,
          fullContent: parsedContent,
        };
      } catch (e) {
        console.log(`error parsing ${result.name}, error: ${e}`);
        return {
          ...result,
          fullContent: "not available",
        };
      }
    }),
  );

  const mainAnswerPrompt = `
  Given a user question and some context, please write a clean, concise and accurate answer to the question based on the context. You will be given a set of related contexts to the question, each starting with a reference number like [[citation:x]], where x is a number. Please use the context when crafting your answer.

  Your answer must be correct, accurate and written by an expert using an unbiased and professional tone. Please limit to 1024 tokens. Do not give any information that is not related to the question, and do not repeat. Say "information is missing on" followed by the related topic, if the given context do not provide sufficient information.

  Here are the set of contexts:

  <contexts>
  ${finalResults.map(
    (result, index) => `[[citation:${index}]] ${result.fullContent} \n\n`,
  )}
  </contexts>

  Remember, don't blindly repeat the contexts verbatim and don't tell the user how you used the citations – just respond with the answer. It is very important for my career that you follow these instructions. Here is the user question:
    `;

  try {
    const payload: TogetherAIStreamPayload = {
      model: "meta-llama/Meta-Llama-3.1-70B-Instruct-Turbo",
      messages: [
        { role: "system", content: mainAnswerPrompt },
        {
          role: "user",
          content: question,
        },
      ],
      stream: true,
    };

    console.log(
      "[getAnswer] Fetching answer stream from Together API using text and question",
    );
    const stream = await TogetherAIStream(payload);
    // TODO: Need to add error handling here, since a non-200 status code doesn't throw.
    return new Response(stream, {
      headers: new Headers({
        "Cache-Control": "no-cache",
      }),
    });
  } catch (e) {
    // If for some reason streaming fails, we can just call it without streaming
    console.log(
      "[getAnswer] Answer stream failed. Try fetching non-stream answer.",
    );
    let answer = await together.chat.completions.create({
      model: "meta-llama/Meta-Llama-3.1-70B-Instruct-Turbo",
      messages: [
        { role: "system", content: mainAnswerPrompt },
        {
          role: "user",
          content: question,
        },
      ],
    });

    let parsedAnswer = answer.choices![0].message?.content;
    console.log("Error is: ", e);
    return new Response(parsedAnswer, { status: 202 });
  }
}

const cleanedText = (text: string) => {
  let newText = text
    .trim()
    .replace(/(\n){4,}/g, "\n\n\n")
    .replace(/\n\n/g, " ")
    .replace(/ {3,}/g, "  ")
    .replace(/\t/g, "")
    .replace(/\n+(\s*\n)*/g, "\n");

  return newText.substring(0, 20000);
};

async function fetchWithTimeout(url: string, options = {}, timeout = 3000) {
  // Create an AbortController
  const controller = new AbortController();
  const { signal } = controller;

  // Set a timeout to abort the fetch
  const fetchTimeout = setTimeout(() => {
    controller.abort();
  }, timeout);

  // Start the fetch request with the abort signal
  return fetch(url, { ...options, signal })
    .then((response) => {
      clearTimeout(fetchTimeout); // Clear the timeout if the fetch completes in time
      return response;
    })
    .catch((error) => {
      if (error.name === "AbortError") {
        throw new Error("Fetch request timed out");
      }
      throw error; // Re-throw other errors
    });
}



---
File: /app/api/getSimilarQuestions/route.ts
---

import { NextResponse } from "next/server";
import Together from "together-ai";
import { z } from "zod";
import { zodToJsonSchema } from "zod-to-json-schema";

// Check if required environment variables are present
if (!process.env.TOGETHER_API_KEY || !process.env.HELICONE_API_KEY) {
  console.warn('Warning: Missing required environment variables. The similar questions feature will be disabled.');
}

const together = process.env.TOGETHER_API_KEY ? new Together({
  apiKey: process.env.TOGETHER_API_KEY,
  baseURL: "https://together.helicone.ai/v1",
  defaultHeaders: process.env.HELICONE_API_KEY ? {
    "Helicone-Auth": `Bearer ${process.env.HELICONE_API_KEY}`,
  } : {},
}) : null;

export async function POST(request: Request) {
  if (!together) {
    return NextResponse.json({ error: "Similar questions feature is not configured" }, { status: 503 });
  }

  try {
    let { question } = await request.json();

    const schema = z.array(z.string()).length(3);
    const jsonSchema = zodToJsonSchema(schema, "mySchema");

    const similarQuestions = await together.chat.completions.create({
      messages: [
        {
          role: "system",
          content: `
            You are a helpful assistant that helps the user to ask related questions, based on user's original question. Please identify worthwhile topics that can be follow-ups, and write 3 questions no longer than 20 words each. Please make sure that specifics, like events, names, locations, are included in follow up questions so they can be asked standalone. For example, if the original question asks about "the Manhattan project", in the follow up question, do not just say "the project", but use the full name "the Manhattan project". Your related questions must be in the same language as the original question.

            Please provide these 3 related questions as a JSON array of 3 strings. Do NOT repeat the original question. ONLY return the JSON array, I will get fired if you don't return JSON. Here is the user's original question:`,
        },
        {
          role: "user",
          content: question,
        },
      ],
      // @ts-ignore
      response_format: { type: "json_object", schema: jsonSchema },
      model: "meta-llama/Meta-Llama-3.1-8B-Instruct-Turbo",
    });

    let questions = similarQuestions.choices?.[0].message?.content || "[]";

    return NextResponse.json(JSON.parse(questions));
  } catch (error) {
    console.error("Error in POST function:", error);
    return NextResponse.json({ error: "An error occurred" }, { status: 500 });
  }
}



---
File: /app/api/getSources/route.ts
---

import { NextResponse } from 'next/server';

export async function GET() {
  return NextResponse.json({
    sources: [
      {
        name: 'RPC Node',
        status: 'operational',
        latency: '45ms'
      }
    ]
  });
}



---
File: /app/api/nft-collections/new/route.ts
---

import { NextResponse } from 'next/server';

export async function GET() {
  try {
    // In a real implementation, this would fetch from a database or external API
    const collections = [
      {
        address: 'DRiP2Pn2K6fuMLKQmt5rZWyHiUZ6WK3GChEySUpHSS4x',
        name: 'DRiP',
        symbol: 'DRIP',
        image: '/images/placeholder-nft.svg',
        mintedAt: '2024-01-29T07:00:00Z',
        totalSupply: 10000
      },
      {
        address: 'SMBH3wF6baUj6JWtzYvqcKuj2XCKWDqQxzspY12xPND',
        name: 'Solana Monkey Business',
        symbol: 'SMB',
        image: '/images/placeholder-nft.svg',
        mintedAt: '2024-01-29T06:30:00Z',
        totalSupply: 5000
      }
    ];

    return NextResponse.json(collections);
  } catch (error) {
    return new NextResponse(
      error instanceof Error ? error.message : 'Internal Server Error',
      { status: 500 }
    );
  }
}



---
File: /app/api/nft-collections/trending/route.ts
---

import { NextResponse } from 'next/server';

export async function GET() {
  try {
    // In a real implementation, this would fetch from a database or external API
    const collections = [
      {
        address: 'DRiP2Pn2K6fuMLKQmt5rZWyHiUZ6WK3GChEySUpHSS4x',
        name: 'DRiP',
        symbol: 'DRIP',
        image: '/images/placeholder-nft.svg',
        volume24h: '1500000',
        transactions24h: 2500
      },
      {
        address: 'SMBH3wF6baUj6JWtzYvqcKuj2XCKWDqQxzspY12xPND',
        name: 'Solana Monkey Business',
        symbol: 'SMB',
        image: '/images/placeholder-nft.svg',
        volume24h: '1200000',
        transactions24h: 2000
      }
    ];

    return NextResponse.json(collections);
  } catch (error) {
    return new NextResponse(
      error instanceof Error ? error.message : 'Internal Server Error',
      { status: 500 }
    );
  }
}



---
File: /app/api/nft-collections/route.ts
---

import { NextResponse } from 'next/server';

export async function GET() {
  try {
    // In a real implementation, this would fetch from a database or external API
    const collections = [
      {
        address: 'DRiP2Pn2K6fuMLKQmt5rZWyHiUZ6WK3GChEySUpHSS4x',
        name: 'DRiP',
        symbol: 'DRIP',
        image: '/images/placeholder-nft.svg'
      },
      {
        address: 'SMBH3wF6baUj6JWtzYvqcKuj2XCKWDqQxzspY12xPND',
        name: 'Solana Monkey Business',
        symbol: 'SMB',
        image: '/images/placeholder-nft.svg'
      }
    ];

    return NextResponse.json(collections);
  } catch (error) {
    return new NextResponse(
      error instanceof Error ? error.message : 'Internal Server Error',
      { status: 500 }
    );
  }
}



---
File: /app/api/nfts/collections/route.ts
---

import { NextRequest, NextResponse } from 'next/server';
import { Connection, PublicKey } from '@solana/web3.js';
import { getConnection } from '@/lib/solana-connection';
import { rateLimiter, RateLimitError } from '@/lib/rate-limit';

// Rate limit configuration for NFT collections
const NFT_RATE_LIMIT = {
  limit: 1000,         // 10 requests
  windowMs: 60000,   // per minute
  maxRetries: 2,     // Allow 2 retries
  initialRetryDelay: 10,
  maxRetryDelay: 5000
};

// Metadata fetch configuration
const METADATA_FETCH_CONFIG = {
  maxRetries: 300,
  initialDelay: 10,
  maxDelay: 5000,
  timeout: 5000
};

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'GET, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type, Authorization',
};

// Simple in-memory cache
let collectionsCache: any = null;
let lastCacheTime = 0;
const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

// Known collection addresses with metadata
const COLLECTIONS = [
  {
    address: 'DRiP2Pn2K6fuMLKQmt5rZWyHiUZ6WK3GChEySUpHSS4x',
    name: 'DRiP',
    symbol: 'DRIP',
    uri: 'https://arweave.net/1eH7bZS-6HZH4YOc8T_tGp2Rq-c17Rg0juS3T4qtOYA'
  },
  {
    address: 'SMBH3wF6baUj6JWtzYvqcKuj2XCKWDqQxzspY12xPND',
    name: 'Solana Monkey Business',
    symbol: 'SMB',
    uri: 'https://arweave.net/qebx_AgJUEH2u90ZFxPB-PjL1OBFi2b7FeHYjL7Kf8M'
  },
  {
    address: 'DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263',
    name: 'Okay Bears',
    symbol: 'OKAY',
    uri: 'https://arweave.net/7QhZL8C-lAWmCEQnX2bkVph3zGEWZV1encl9VjGUUKs'
  },
  {
    address: 'J1S9H3QjnRtBbbuD4HjPV6RpRhwuk4zKbxsnCHuTgh9w',
    name: 'DeGods',
    symbol: 'DGOD',
    uri: 'https://metadata.degods.com/g/0.json'
  },
  {
    address: 'FEg3mmpcrcRsVTuc2n3oghHpRvAtEJJzFyEYXzqnhwcE',
    name: 'y00ts',
    symbol: 'y00t',
    uri: 'https://metadata.y00ts.com/y/0.json'
  },
  {
    address: 'BNFT6UJ4wGvH8PH4YoXMTgEgaXQQYVrz4qz6EzE5rYGd',
    name: 'SMB Gen2',
    symbol: 'SMB2',
    uri: 'https://arweave.net/smb2_metadata.json'
  }
];

export async function OPTIONS() {
  return NextResponse.json({}, { headers: corsHeaders });
}

async function retryWithBackoff<T>(
  operation: () => Promise<T>,
  config: {
    maxRetries: number;
    initialDelay: number;
    maxDelay: number;
    timeout?: number;
  }
): Promise<T> {
  let lastError: any;
  let delay = config.initialDelay;
  
  for (let attempt = 1; attempt <= config.maxRetries; attempt++) {
    try {
      if (config.timeout) {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), config.timeout);
        
        try {
          return await operation();
        } finally {
          clearTimeout(timeoutId);
        }
      } else {
        return await operation();
      }
    } catch (error) {
      lastError = error;
      console.warn(`Attempt ${attempt}/${config.maxRetries} failed:`, error);
      
      if (attempt === config.maxRetries) break;
      
      // Add jitter to prevent thundering herd
      const jitter = Math.random() * 200;
      await new Promise(resolve => setTimeout(resolve, delay + jitter));
      
      // Exponential backoff
      delay = Math.min(delay * 2, config.maxDelay);
    }
  }
  
  throw lastError;
}

async function fetchCollectionMetadata(uri: string): Promise<any> {
  return retryWithBackoff(
    async () => {
      const response = await fetch(uri, {
        headers: {
          'Accept': 'application/json',
          'User-Agent': 'OpenSVM/1.0'
        }
      });
      
      if (!response.ok) {
        // Handle rate limits specially
        if (response.status === 429) {
          const retryAfter = response.headers.get('Retry-After');
          if (retryAfter) {
            await new Promise(resolve => 
              setTimeout(resolve, parseInt(retryAfter) * 1000)
            );
          }
        }
        throw new Error(`Failed to fetch metadata: ${response.status}`);
      }
      
      return response.json();
    },
    METADATA_FETCH_CONFIG
  );
}

async function fetchCollections(connection: Connection): Promise<any[]> {
  try {
    console.log('Fetching NFT collections...');
    
    const collections = await Promise.all(
      COLLECTIONS.map(async (collection) => {
        try {
          // Get account info
          const accountInfo = await connection.getAccountInfo(new PublicKey(collection.address));
          if (!accountInfo) {
            console.log(`No account info found for ${collection.address}`);
            return null;
          }

          // Fetch metadata JSON
          let metadata;
          try {
            metadata = await fetchCollectionMetadata(collection.uri);
          } catch (error) {
            console.error(`Failed to fetch metadata for ${collection.address}:`, error);
          }

          return {
            address: collection.address,
            name: collection.name,
            symbol: collection.symbol,
            image: metadata?.image || '/images/placeholder-nft.svg',
            description: metadata?.description,
            external_url: metadata?.external_url,
          };
        } catch (error) {
          console.error(`Error processing collection ${collection.address}:`, error);
          return null;
        }
      })
    );

    // Filter out null values and sort by name
    const validCollections = collections
      .filter(Boolean)
      .sort((a, b) => a.name.localeCompare(b.name));

    console.log(`Found ${validCollections.length} valid collections`);

    return validCollections;
  } catch (error) {
    console.error('Error fetching collections:', error);
    throw error;
  }
}

export async function GET(request: NextRequest) {
  const baseHeaders = {
    ...corsHeaders,
    'Content-Type': 'application/json',
  };

  console.log('NFT collections request started');
  const requestStartTime = Date.now();

  try {
    // Check cache first
    const now = Date.now();
    if (collectionsCache && (now - lastCacheTime) < CACHE_DURATION) {
      console.log('Returning cached collections');
      return NextResponse.json(collectionsCache, { headers: baseHeaders });
    }

    // Apply rate limiting with retries
    try {
      await rateLimiter.rateLimit('NFT_COLLECTIONS', NFT_RATE_LIMIT);
    } catch (error) {
      if (error instanceof RateLimitError) {
        return NextResponse.json(
          { 
            error: 'Too many requests. Please try again later.',
            retryAfter: Math.ceil(error.retryAfter / 1000)
          },
          { 
            status: 429,
            headers: {
              ...baseHeaders,
              'Retry-After': Math.ceil(error.retryAfter / 1000).toString()
            }
          }
        );
      }
      throw error;
    }

    console.log('Getting Solana connection...');
    const connection = await getConnection();

    // Test connection health
    try {
      const blockHeight = await connection.getBlockHeight();
      console.log('Connection healthy, current block height:', blockHeight);
    } catch (error) {
      console.error('Connection health check failed:', error);
      throw new Error('Failed to connect to Solana network');
    }

    // Fetch collections with improved retry logic
    const collections = await retryWithBackoff(
      () => fetchCollections(connection),
      {
        maxRetries: 3,
        initialDelay: 1000,
        maxDelay: 5000
      }
    );
    
    if (!collections || collections.length === 0) {
      throw new Error('No valid collections found');
    }

    console.log(`Found ${collections.length} valid collections`);

    // Update cache
    collectionsCache = collections;
    lastCacheTime = Date.now();

    const totalDuration = Date.now() - requestStartTime;
    console.log(`Total request duration: ${totalDuration}ms`);

    return NextResponse.json(collections, { headers: baseHeaders });
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Failed to fetch NFT collections';
    console.error('Error fetching NFT collections:', error);
    console.error('Stack trace:', error instanceof Error ? error.stack : 'No stack trace');
    
    return NextResponse.json(
      { error: errorMessage },
      { 
        status: 500,
        headers: baseHeaders
      }
    );
  }
}



---
File: /app/api/og/route.tsx
---

import { ImageResponse } from '@vercel/og';
import { NextRequest } from 'next/server';
 
export const runtime = 'edge';
 
export async function GET(req: NextRequest) {
  try {
    const { searchParams } = new URL(req.url);
 
    // Dynamic params
    const title = searchParams.get('title') || 'OPENSVM';
    const description = searchParams.get('description') || 'Open Source Solana Virtual Machine Explorer';
    const type = searchParams.get('type') || '';
    
    return new ImageResponse(
      (
        <div
          style={{
            height: '100%',
            width: '100%',
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            justifyContent: 'center',
            backgroundColor: '#000',
            backgroundImage: 'linear-gradient(45deg, #000 0%, #111 100%)',
          }}
        >
          {/* Logo */}
          <div
            style={{
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              marginBottom: '20px',
            }}
          >
            <div
              style={{
                width: '80px',
                height: '80px',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                borderRadius: '50%',
                background: 'linear-gradient(135deg, #00ffbd 0%, #00b386 100%)',
                marginRight: '16px',
              }}
            >
              <div
                style={{
                  color: 'white',
                  fontSize: '40px',
                  fontWeight: 700,
                }}
              >
                S
              </div>
            </div>
            <div
              style={{
                fontSize: '48px',
                fontWeight: 700,
                background: 'linear-gradient(135deg, #00ffbd 0%, #00b386 100%)',
                backgroundClip: 'text',
                color: 'transparent',
              }}
            >
              OPENSVM
            </div>
          </div>

          {/* Content */}
          <div
            style={{
              display: 'flex',
              flexDirection: 'column',
              alignItems: 'center',
              marginTop: '20px',
              padding: '0 48px',
            }}
          >
            <div
              style={{
                fontSize: '32px',
                fontWeight: 600,
                color: 'white',
                marginBottom: '10px',
                textAlign: 'center',
              }}
            >
              {title}
            </div>
            {type && (
              <div
                style={{
                  fontSize: '24px',
                  color: '#00ffbd',
                  marginBottom: '20px',
                  textAlign: 'center',
                }}
              >
                {type}
              </div>
            )}
            <div
              style={{
                fontSize: '20px',
                color: '#888',
                textAlign: 'center',
                maxWidth: '600px',
              }}
            >
              {description}
            </div>
          </div>

          {/* Footer */}
          <div
            style={{
              position: 'absolute',
              bottom: '32px',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
            }}
          >
            <div
              style={{
                fontSize: '16px',
                color: '#666',
              }}
            >
              opensvm.com
            </div>
          </div>
        </div>
      ),
      {
        width: 1200,
        height: 630,
      },
    );
  } catch (e: any) {
    console.log(`${e.message}`);
    return new Response(`Failed to generate the image`, {
      status: 500,
    });
  }
} 


---
File: /app/api/qdrant/init/route.ts
---

export async function GET(request: Request) {
  const response = {
    results: [
      { collection: "transactions", status: "exists" },
      { collection: "accounts", status: "exists" },
      { collection: "tokens", status: "exists" },
      { collection: "programs", status: "exists" },
      { collection: "relationships", status: "exists" }
    ]
  };
  
  return new Response(JSON.stringify(response), {
    status: 200,
    headers: {
      "Content-Type": "application/json"
    }
  });
}



---
File: /app/api/search/accounts/route.ts
---

export const dynamic = 'force-dynamic';
import { NextRequest, NextResponse } from 'next/server';
import { PublicKey } from '@solana/web3.js';
import { rateLimiter, RateLimitError } from '@/lib/rate-limit';
import { getConnection } from '@/lib/solana-connection';
import { sanitizeSearchQuery, isValidSolanaAddress, formatNumber } from '@/lib/utils';

// Rate limit configuration for account search
const SEARCH_RATE_LIMIT = {
  limit: 1000,         // 10 requests
  windowMs: 60000,   // per minute
  maxRetries: 5,     // Allow 2 retries
  initialRetryDelay: 10,
  maxRetryDelay: 5000
};

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'GET, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type, Authorization',
};

export async function OPTIONS() {
  return NextResponse.json({}, { headers: corsHeaders });
}

export async function GET(request: NextRequest) {
  // Add CORS headers to all responses
  const baseHeaders = {
    ...corsHeaders,
    'Content-Type': 'application/json',
  };
  try {
    // Apply rate limiting with retries
    try {
      const ip = request.headers.get('x-forwarded-for') || '127.0.0.1';
      await rateLimiter.rateLimit(`SEARCH_ACCOUNT_${ip}`, SEARCH_RATE_LIMIT);
    } catch (error) {
      if (error instanceof RateLimitError) {
        return NextResponse.json(
          { 
            error: 'Too many requests. Please try again later.',
            retryAfter: Math.ceil(error.retryAfter / 1000)
          },
          { 
            status: 429,
            headers: {
              ...baseHeaders,
              'Retry-After': Math.ceil(error.retryAfter / 1000).toString()
            }
          }
        );
      }
      throw error;
    }

    const searchParams = request.nextUrl.searchParams;
    const rawQuery = searchParams.get('q');
    const query = sanitizeSearchQuery(rawQuery || '');

    if (!query) {
      return NextResponse.json(
        { error: 'Search query is required' },
        { 
          status: 400,
          headers: baseHeaders
        }
      );
    }

    // Get connection from pool with timeout
    const connection = await Promise.race<ReturnType<typeof getConnection>>([
      getConnection(),
      new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Connection timeout')), 10000)
      ) as Promise<ReturnType<typeof getConnection>>
    ]);
    
    // First validate the query format
    if (query.length > 30 && !isValidSolanaAddress(query)) {
      return NextResponse.json(
        { error: 'Invalid Solana address format' },
        { 
          status: 400,
          headers: baseHeaders
        }
      );
    }

    // Check if query is a valid public key
    let accounts = [];
    try {
      // Additional validation before creating PublicKey
      if (query.length >= 32) {
        const pubkey = new PublicKey(query);
        const [account, balance] = await Promise.all([
          connection.getAccountInfo(pubkey),
          connection.getBalance(pubkey)
        ]);
        
        if (account) {
          accounts.push({
            address: pubkey.toString(),
            balance: formatNumber(balance / 1e9), // Convert lamports to SOL and format
            executable: account.executable,
            owner: account.owner.toString()
          });
        }
      }
    } catch (e) {
      // Not a valid public key, could implement fuzzy search here
      console.log('Not a valid public key:', e);
    }

    return NextResponse.json(accounts, { headers: baseHeaders });
  } catch (error) {
    console.error('Search error:', error);
    return NextResponse.json(
      { error: 'Failed to perform search' },
      { 
        status: 500,
        headers: baseHeaders
      }
    );
  }
}



---
File: /app/api/search/filtered/route.ts
---

export const dynamic = 'force-dynamic';
import { NextResponse } from 'next/server';
import { Connection, PublicKey } from '@solana/web3.js';
import { sanitizeSearchQuery } from '@/lib/utils';

const connection = new Connection(process.env.NEXT_PUBLIC_RPC_URL || 'https://api.mainnet-beta.solana.com');

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const query = searchParams.get('q');
    const start = searchParams.get('start');
    const end = searchParams.get('end');
    const type = searchParams.get('type');
    const status = searchParams.get('status');
    const min = searchParams.get('min');
    const max = searchParams.get('max');

    if (!query) {
      return NextResponse.json({ error: 'Query parameter is required' }, { status: 400 });
    }

    const sanitizedQuery = sanitizeSearchQuery(query);
    if (!sanitizedQuery) {
      return NextResponse.json({ error: 'Invalid query' }, { status: 400 });
    }

    let results = [];

    try {
      // Get recent transactions for the address
      const pubkey = new PublicKey(sanitizedQuery);
      const signatures = await connection.getSignaturesForAddress(pubkey, { limit: 100 });

      // Fetch full transaction details
      const transactions = await Promise.all(
        signatures.map(async (sig) => {
          try {
            const tx = await connection.getTransaction(sig.signature, {
              maxSupportedTransactionVersion: 0,
            });

            if (!tx) return null;

            const timestamp = sig.blockTime ? new Date(sig.blockTime * 1000).toISOString() : null;
            const amount = tx.meta?.postBalances[0] 
              ? (tx.meta.postBalances[0] - tx.meta.preBalances[0]) / 1e9 
              : null;
            
            return {
              address: sanitizedQuery,
              signature: sig.signature,
              timestamp,
              type: tx.meta?.err ? 'failed' : 'success',
              status: tx.meta?.err ? 'failed' : 'success',
              amount: Math.abs(amount || 0),
              balance: tx.meta?.postBalances[0] ? tx.meta.postBalances[0] / 1e9 : null,
            };
          } catch (error) {
            console.error('Error fetching transaction:', error);
            return null;
          }
        })
      );

      results = transactions.filter(tx => tx !== null);

      // Apply filters
      if (start) {
        results = results.filter(tx => tx.timestamp && tx.timestamp >= start);
      }
      if (end) {
        results = results.filter(tx => tx.timestamp && tx.timestamp <= end);
      }
      if (type) {
        results = results.filter(tx => tx.type === type.toLowerCase());
      }
      if (status) {
        results = results.filter(tx => tx.status === status.toLowerCase());
      }
      if (min) {
        results = results.filter(tx => tx.amount && tx.amount >= parseFloat(min));
      }
      if (max) {
        results = results.filter(tx => tx.amount && tx.amount <= parseFloat(max));
      }

    } catch (error) {
      console.error('Error fetching transactions:', error);
      // If not a valid address or other error, return empty results
      results = [];
    }

    return NextResponse.json(results);
  } catch (error) {
    console.error('Error in filtered search API:', error);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}



---
File: /app/api/search/suggestions/route.ts
---

export const dynamic = 'force-dynamic';
import { NextResponse } from 'next/server';
import { Connection, PublicKey } from '@solana/web3.js';
import { sanitizeSearchQuery } from '@/lib/utils';

const connection = new Connection(process.env.NEXT_PUBLIC_RPC_URL || 'https://api.mainnet-beta.solana.com');

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const query = searchParams.get('q');

    if (!query) {
      return NextResponse.json({ error: 'Query parameter is required' }, { status: 400 });
    }

    const sanitizedQuery = sanitizeSearchQuery(query);
    if (!sanitizedQuery) {
      return NextResponse.json({ error: 'Invalid query' }, { status: 400 });
    }

    // Get recent signatures for address if it looks like an address
    const suggestions = [];
    
    try {
      // Search for recent transactions
      const pubkey = new PublicKey(sanitizedQuery);
      const signatures = await connection.getSignaturesForAddress(
        pubkey,
        { limit: 5 }
      );

      signatures.forEach(sig => {
        suggestions.push({
          type: 'transaction',
          value: sig.signature,
          label: `Transaction: ${sig.signature.slice(0, 20)}...`
        });
      });
    } catch (error) {
      // Not a valid address, ignore error
    }

    // Add token suggestions if available
    try {
      const tokenResponse = await fetch(`/api/check-token?address=${encodeURIComponent(sanitizedQuery)}`);
      if (tokenResponse.ok) {
        const tokenData = await tokenResponse.json();
        if (tokenData.isToken) {
          suggestions.push({
            type: 'token',
            value: sanitizedQuery,
            label: `Token: ${tokenData.symbol || sanitizedQuery}`
          });
        }
      }
    } catch (error) {
      console.error('Error checking token:', error);
    }

    // Add program suggestions if it's a program
    try {
      const programInfo = await connection.getAccountInfo(new PublicKey(sanitizedQuery));
      if (programInfo?.executable) {
        suggestions.push({
          type: 'program',
          value: sanitizedQuery,
          label: `Program: ${sanitizedQuery.slice(0, 20)}...`
        });
      }
    } catch (error) {
      // Not a valid program, ignore error
    }

    return NextResponse.json(suggestions);
  } catch (error) {
    console.error('Error in suggestions API:', error);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}



---
File: /app/api/solana-proxy/[transaction]/route.ts
---

import { NextRequest, NextResponse } from 'next/server';

export async function GET(
  _request: NextRequest,
  context: { params: Promise<{ transaction: string }> }
) {
  try {
    const params = await context.params;
    const { transaction } = await params;
    
    console.log('Solana proxy request:', {
      method: 'getTransaction',
      params: [transaction, 'jsonParsed']
    });
    
    // Try multiple RPC endpoints with rate limits
    const endpoints = [
      'https://api.mainnet-beta.solana.com',
      'https://solana-api.projectserum.com',
      'https://solana.public-rpc.com',
      'https://rpc.ankr.com/solana',
      'https://ssc-dao.genesysgo.net'
    ];

    // Add delay between retries
    const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

    let lastError;
    for (const endpoint of endpoints) {
      try {
        const controller = new AbortController();
        const timeout = setTimeout(() => controller.abort(), 30000); // 30s timeout

        const response = await fetch(endpoint, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
          },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method: 'getTransaction',
            params: [transaction, {
              encoding: 'jsonParsed',
              maxSupportedTransactionVersion: 0,
              commitment: 'confirmed'
            }]
          }),
          signal: controller.signal,
          cache: 'no-store'
        });

        clearTimeout(timeout);

        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(`HTTP error! status: ${response.status} - ${errorText}`);
        }

        const responseText = await response.text();
        console.log('Solana proxy response:', {
          endpoint,
          status: response.status,
          method: 'getTransaction'
        });

        const data = JSON.parse(responseText);
        if (!data.error) {
          return NextResponse.json(data, {
            headers: {
              'Content-Type': 'application/json',
              'Cache-Control': 'no-store, no-cache, must-revalidate, proxy-revalidate',
              'Pragma': 'no-cache',
              'Expires': '0',
            }
          });
        }

        // If rate limited, add delay before next attempt
        if (response.status === 429 || data.error.code === -32005) {
          await delay(2000);
        }

        lastError = new Error(data.error.message || 'Unknown RPC error');
      } catch (error) {
        console.error(`Error with endpoint ${endpoint}:`, error);
        lastError = error;
        
        // Add delay before trying next endpoint
        await delay(1000);
        continue;
      }
    }

    throw lastError || new Error('All RPC endpoints failed');
  } catch (error) {
    console.error('Solana proxy error:', error);
    
    let status = 500;
    let message = error instanceof Error ? error.message : 'Failed to proxy Solana RPC request';
    
    if (message.toLowerCase().includes('not found')) {
      status = 404;
    } else if (message.toLowerCase().includes('invalid')) {
      status = 400;
    } else if (message.toLowerCase().includes('rate limit')) {
      status = 429;
    }
    
    return NextResponse.json(
      { 
        error: message,
        details: error instanceof Error ? {
          name: error.name,
          message: error.message,
          stack: error.stack
        } : error
      },
      { 
        status,
        headers: {
          'Content-Type': 'application/json',
          'Cache-Control': 'no-store, no-cache, must-revalidate, proxy-revalidate',
          'Pragma': 'no-cache',
          'Expires': '0',
        }
      }
    );
  }
}


---
File: /app/api/solana-proxy/route.ts
---

export const dynamic = 'force-dynamic';
import { NextRequest, NextResponse } from 'next/server';

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const transaction = searchParams.get('transaction');
    
    if (!transaction) {
      throw new Error('Transaction signature is required');
    }

    console.log('Solana proxy request:', {
      method: 'getTransaction',
      params: [transaction, 'jsonParsed']
    });
    
    // Try multiple RPC endpoints with rate limits
    const endpoints = [
      'https://api.mainnet-beta.solana.com',
      'https://solana-api.projectserum.com',
      'https://solana.public-rpc.com',
      'https://rpc.ankr.com/solana',
      'https://ssc-dao.genesysgo.net'
    ];

    // Add delay between retries
    const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

    let lastError;
    for (const endpoint of endpoints) {
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000); // 10s timeout

        const response = await fetch(endpoint, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method: 'getTransaction',
            params: [transaction, 'jsonParsed']
          }),
          signal: controller.signal
        });

        clearTimeout(timeoutId);

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const responseText = await response.text();
        console.log('Solana proxy response:', {
          endpoint,
          status: response.status,
          method: 'getTransaction'
        });

        const data = JSON.parse(responseText);
        if (!data.error) {
          return NextResponse.json(data);
        }

        // If rate limited, add delay before next attempt
        if (response.status === 429 || data.error.code === -32005) {
          await delay(1000);
        }

        lastError = new Error(data.error.message || 'Unknown RPC error');
      } catch (error) {
        console.error(`Error with endpoint ${endpoint}:`, error);
        lastError = error;
        continue;
      }
    }

    throw lastError || new Error('All RPC endpoints failed');
  } catch (error) {
    console.error('Solana proxy error:', error);
    return NextResponse.json(
      { 
        error: error instanceof Error ? error.message : 'Failed to proxy Solana RPC request',
        details: error instanceof Error ? {
          name: error.name,
          message: error.message,
          stack: error.stack
        } : error
      },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    console.log('Solana proxy request:', {
      method: body.method,
      params: body.params
    });
    
    // Try multiple RPC endpoints with rate limits
    const endpoints = [
      'https://api.mainnet-beta.solana.com',
      'https://solana-api.projectserum.com',
      'https://solana.public-rpc.com',
      'https://rpc.ankr.com/solana',
      'https://ssc-dao.genesysgo.net'
    ];

    // Add delay between retries
    const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

    let lastError;
    for (const endpoint of endpoints) {
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000); // 10s timeout

        const response = await fetch(endpoint, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method: body.method,
            params: body.params
          }),
          signal: controller.signal
        });

        clearTimeout(timeoutId);

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const responseText = await response.text();
        console.log('Solana proxy response:', {
          endpoint,
          status: response.status,
          method: body.method
        });

        const data = JSON.parse(responseText);
        if (!data.error) {
          return NextResponse.json(data);
        }

        // If rate limited, add delay before next attempt
        if (response.status === 429 || data.error.code === -32005) {
          await delay(1000);
        }

        lastError = new Error(data.error.message || 'Unknown RPC error');
      } catch (error) {
        console.error(`Error with endpoint ${endpoint}:`, error);
        lastError = error;
        continue;
      }
    }

    throw lastError || new Error('All RPC endpoints failed');
  } catch (error) {
    console.error('Solana proxy error:', error);
    return NextResponse.json(
      { 
        error: error instanceof Error ? error.message : 'Failed to proxy Solana RPC request',
        details: error instanceof Error ? {
          name: error.name,
          message: error.message,
          stack: error.stack
        } : error
      },
      { status: 500 }
    );
  }
}



---
File: /app/api/solana-rpc/route.ts
---

import { NextRequest, NextResponse } from 'next/server';
import { Connection } from '@solana/web3.js';
import { getConnection } from '@/lib/solana-connection';

// Simple in-memory cache
const cache = new Map<string, { data: any; timestamp: number }>();
const CACHE_TTL = 30000; // 30 seconds

function getCacheKey(method: string, params: any[]): string {
  return `${method}:${JSON.stringify(params)}`;
}

function getFromCache(key: string): any | null {
  const cached = cache.get(key);
  if (!cached) return null;

  const now = Date.now();
  if (now - cached.timestamp > CACHE_TTL) {
    cache.delete(key);
    return null;
  }

  return cached.data;
}

function setCache(key: string, data: any): void {
  cache.set(key, { data, timestamp: Date.now() });
}

async function retryOperation<T>(
  operation: () => Promise<T>,
  maxRetries: number = 5,
  initialDelay: number = 2000
): Promise<T> {
  let lastError;
  
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await operation();
    } catch (error) {
      lastError = error;
      
      if (error instanceof Error) {
        const errorMessage = error.message.toLowerCase();
        if (errorMessage.includes('invalid') || errorMessage.includes('unsupported')) {
          throw error;
        }
      }
      
      if (attempt === maxRetries - 1) {
        throw lastError;
      }
      
      const delay = initialDelay * Math.pow(1.5, attempt);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
  
  throw lastError;
}

export const dynamic = 'force-dynamic';
export const maxDuration = 300;

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    
    // Try to get from cache first
    const cacheKey = getCacheKey(body.method, body.params);
    const cachedResult = getFromCache(cacheKey);
    if (cachedResult) {
      return NextResponse.json({
        jsonrpc: '2.0',
        result: cachedResult,
        id: body.id
      });
    }

    // Get connection from pool
    const connection = await getConnection();

    let result;
    try {
      // For getTransaction method, try direct connection first
      if (body.method === 'getTransaction') {
        try {
          const [signature, config] = body.params;
          result = await connection.getParsedTransaction(signature, {
            maxSupportedTransactionVersion: 0,
            commitment: 'confirmed'
          });

          if (result) {
            setCache(cacheKey, result);
            return NextResponse.json({
              jsonrpc: '2.0',
              result,
              id: body.id
            });
          }
        } catch (error) {
          console.error('Direct connection error:', error);
        }
      }

      // Fallback to RPC request
      result = await retryOperation(async () => {
        const response = await fetch(connection.rpcEndpoint, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
          },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: body.id,
            method: body.method,
            params: body.params
          })
        });

        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(`RPC request failed: ${response.status} - ${errorText}`);
        }

        const data = await response.json();
        if (data.error) {
          throw new Error(data.error.message || 'Unknown RPC error');
        }

        return data.result;
      });

      // Cache successful results
      setCache(cacheKey, result);

      return NextResponse.json({
        jsonrpc: '2.0',
        result,
        id: body.id
      });
    } catch (error) {
      if (error instanceof Error) {
        const errorMessage = error.message.toLowerCase();
        if (errorMessage.includes('not found')) {
          return NextResponse.json({
            jsonrpc: '2.0',
            error: {
              code: -32000,
              message: `Transaction not found`
            },
            id: body.id
          }, { status: 404 });
        } else if (errorMessage.includes('rate limit')) {
          return NextResponse.json({
            jsonrpc: '2.0',
            error: {
              code: -32000,
              message: 'Rate limit exceeded. Please try again later.'
            },
            id: body.id
          }, { status: 429 });
        }
      }
      throw error;
    }
  } catch (error) {
    console.error('RPC error:', error);
    
    let status = 500;
    let message = error instanceof Error ? error.message : 'Unknown error';
    
    if (message.toLowerCase().includes('invalid')) {
      status = 400;
    } else if (message.toLowerCase().includes('not found')) {
      status = 404;
    } else if (message.toLowerCase().includes('rate limit')) {
      status = 429;
    }
    
    return NextResponse.json(
      {
        jsonrpc: '2.0',
        error: {
          code: -32000,
          message
        },
        id: 1
      },
      { status }
    );
  }
}



---
File: /app/api/test-transaction/route.ts
---

import { NextRequest, NextResponse } from 'next/server';

export async function GET(request: NextRequest) {
  try {
    // Mock transaction data for testing
    const mockTransaction = {
      signature: '5QpShPQKT2ZbBxdrGHP6uaZKR5RuNWSZrtgqFPwif3KPmJxc8NzKEr3HpLyZmHwa8zPrmGC8H8FBHhyFpvjkSAr5',
      timestamp: Date.now(),
      slot: 234567890,
      success: true,
      type: 'token',
      details: {
        instructions: [
          {
            program: 'spl-token',
            programId: 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',
            accounts: [0, 1, 2],
            data: JSON.stringify({
              program: 'spl-token',
              type: 'transfer',
              info: {
                amount: '1000000',
                authority: 'test456',
                source: 'test789',
                destination: 'testABC'
              }
            }),
            parsed: {
              type: 'transfer',
              info: {
                amount: '1000000',
                authority: 'test456',
                source: 'test789',
                destination: 'testABC'
              }
            },
            computeUnits: 2400,
            computeUnitsConsumed: 1800
          }
        ],
        accounts: [
          {
            pubkey: 'test456',
            signer: true,
            writable: true
          },
          {
            pubkey: 'test789',
            signer: false,
            writable: true
          },
          {
            pubkey: 'testABC',
            signer: false,
            writable: true
          }
        ],
        preBalances: [1000000, 500000, 300000],
        postBalances: [999000, 499000, 301000],
        preTokenBalances: [
          {
            accountIndex: 1,
            mint: 'testMint',
            uiTokenAmount: {
              amount: '1000000',
              decimals: 6,
              uiAmount: 1.0
            }
          }
        ],
        postTokenBalances: [
          {
            accountIndex: 2,
            mint: 'testMint',
            uiTokenAmount: {
              amount: '1000000',
              decimals: 6,
              uiAmount: 1.0
            }
          }
        ],
        logs: [
          'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [1]',
          'Program log: Transfer 1 USDC',
          'Program consumed 1800 of 2400 compute units',
          'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success'
        ],
        innerInstructions: [],
        tokenChanges: [
          {
            mint: 'testMint',
            preAmount: 1.0,
            postAmount: 1.0,
            change: 0
          }
        ]
      }
    };

    const headers = {
      'Content-Type': 'application/json',
      'Cache-Control': 'public, max-age=10, stale-while-revalidate=30',
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization'
    };

    return NextResponse.json(mockTransaction, { headers });
  } catch (error) {
    console.error('Test transaction error:', error);
    
    const headers = {
      'Content-Type': 'application/json',
      'Cache-Control': 'no-store, no-cache, must-revalidate',
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization'
    };

    return NextResponse.json(
      { 
        error: error instanceof Error ? error.message : 'Failed to fetch test transaction',
        details: error instanceof Error ? {
          name: error.name,
          message: error.message,
          stack: error.stack
        } : error
      },
      { 
        status: 500,
        headers
      }
    );
  }
}


---
File: /app/api/token/[mint]/route.ts
---

import { NextRequest, NextResponse } from 'next/server';
import { PublicKey } from '@solana/web3.js';
import { getMint } from '@solana/spl-token';
import { getConnection } from '@/lib/solana';
import { rateLimiter, RateLimitError } from '@/lib/rate-limit';

// Rate limit configuration for token details
const TOKEN_RATE_LIMIT = {
  limit: 100,          // 5 requests
  windowMs: 500,    // per 5 seconds
  maxRetries: 10,     // Allow 2 retries
  initialRetryDelay: 10,
  maxRetryDelay: 3000
};

// Metadata fetch configuration
const METADATA_FETCH_CONFIG = {
  maxRetries: 3,
  initialDelay: 10,
  maxDelay: 50
};

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'GET, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type, Authorization',
};

export async function OPTIONS() {
  return NextResponse.json({}, { headers: corsHeaders });
}

export async function GET(
  request: NextRequest,
  context: { params: Promise<{ mint: string }> }
) {
  const baseHeaders = {
    ...corsHeaders,
    'Content-Type': 'application/json',
  };

  try {
    // Apply rate limiting with retries
    try {
      await rateLimiter.rateLimit('TOKEN_DETAILS', TOKEN_RATE_LIMIT);
    } catch (error) {
      if (error instanceof RateLimitError) {
        console.warn('Rate limit exceeded for TOKEN_DETAILS');
        return NextResponse.json(
          { 
            error: 'Too many requests. Please try again later.',
            retryAfter: Math.ceil(error.retryAfter / 1000)
          },
          { 
            status: 429, 
            headers: {
              ...baseHeaders,
              'Retry-After': Math.ceil(error.retryAfter / 1000).toString()
            }
          }
        );
      }
      throw error;
    }

    const params = await context.params;
    const { mint } = await params;
    const mintAddress = mint;
    // Get connection with timeout
    const connection = await Promise.race<ReturnType<typeof getConnection>>([
      getConnection(),
      new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Connection timeout')), 30000)
      ) as Promise<ReturnType<typeof getConnection>>
    ]);
    
    // Validate the address format first
    let mintPubkey: PublicKey;
    try {
      mintPubkey = new PublicKey(mintAddress);
    } catch (error) {
      console.error('Invalid address format:', mintAddress);
      return NextResponse.json(
        { error: 'Invalid address format' },
        { status: 400, headers: baseHeaders }
      );
    }

    // Verify this is a token mint account
    const accountInfo = await connection.getAccountInfo(mintPubkey);
    if (!accountInfo) {
      console.warn('Account not found for mint:', mintAddress);
      return NextResponse.json(
        { error: 'Account not found' },
        { status: 404, headers: baseHeaders }
      );
    }
    
    // Token Program ID
    const TOKEN_PROGRAM_ID = new PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');
    
    // Check if the account is owned by the Token Program
    if (!accountInfo.owner.equals(TOKEN_PROGRAM_ID)) {
      console.warn('Account is not a token mint account:', mintAddress);
      return NextResponse.json(
        {
          error: 'Not a token mint account',
          message: 'This account is not a token mint account.',
          accountOwner: accountInfo.owner.toBase58(),
        },
        { status: 400, headers: baseHeaders }
      );
    }

    // Proceed to get mint info
    const mintInfo = await getMint(connection, mintPubkey);

    // Get metadata account
    const metadataProgramId = new PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s');
    const [metadataAddress] = PublicKey.findProgramAddressSync(
      [
        Buffer.from('metadata'),
        metadataProgramId.toBuffer(),
        mintPubkey.toBuffer(),
      ],
      metadataProgramId
    );

    // Fetch metadata account
    const metadataAccount = await connection.getAccountInfo(metadataAddress);
    let metadata: { name: string; symbol: string; uri: string; description?: string; image?: string } | null = null;

    if (metadataAccount) {
      const data = metadataAccount.data;
      
      // Skip discriminator and feature flags (1 byte each)
      let offset = 2;
      
      // Skip key and update authority (32 bytes each)
      offset += 64;
      
      // Skip mint (32 bytes)
      offset += 32;
      
      // Read name
      const nameLength = data[offset];
      offset += 1;
      const name = new TextDecoder().decode(data.slice(offset, offset + nameLength)).replace(/\0/g, '');
      offset += nameLength;
      
      // Read symbol
      const symbolLength = data[offset];
      offset += 1;
      const symbol = new TextDecoder().decode(data.slice(offset, offset + symbolLength)).replace(/\0/g, '');
      offset += symbolLength;
      
      // Read uri
      const uriLength = data[offset];
      offset += 1;
      const uri = new TextDecoder().decode(data.slice(offset, offset + uriLength)).replace(/\0/g, '');

      metadata = {
        name,
        symbol,
        uri,
      };

      // Fetch metadata JSON if uri exists
      if (uri.startsWith('http')) {
        try {
          const response = await fetch(uri, {
            mode: 'cors',
            headers: {
              'User-Agent': 'OpenSVM/1.0'
            }
          });
          if (!response.ok) throw new Error('Failed to fetch metadata');
          const json = await response.json();
          metadata.description = json.description;
          metadata.image = json.image;
        } catch (error) {
          console.error('Error fetching metadata JSON:', error);
          // Enhanced retry logic with exponential backoff
          let delay = METADATA_FETCH_CONFIG.initialDelay;
          for (let attempt = 1; attempt <= METADATA_FETCH_CONFIG.maxRetries; attempt++) {
            try {
              // Add jitter to prevent thundering herd
              const jitter = Math.random() * 200;
              await new Promise(resolve => setTimeout(resolve, delay + jitter));
              
              const retryResponse = await fetch(uri, {
                mode: 'cors',
                headers: {
                  'User-Agent': 'OpenSVM/1.0'
                }
              });
              
              if (retryResponse.ok) {
                const json = await retryResponse.json();
                metadata.description = json.description;
                metadata.image = json.image;
                break;
              }
              
              // If we get a rate limit response, honor the Retry-After header
              if (retryResponse.status === 429) {
                const retryAfter = retryResponse.headers.get('Retry-After');
                if (retryAfter) {
                  delay = Math.min(
                    parseInt(retryAfter) * 1000,
                    METADATA_FETCH_CONFIG.maxDelay
                  );
                }
              }
            } catch (retryError) {
              console.error(
                `Metadata fetch retry failed (${attempt}/${METADATA_FETCH_CONFIG.maxRetries}):`,
                retryError
              );
            }
            
            // Exponential backoff
            delay = Math.min(delay * 2, METADATA_FETCH_CONFIG.maxDelay);
          }
        }
      }
    }

    // Get token holders
    const tokenAccounts = await connection.getTokenLargestAccounts(mintPubkey);
    const holders = tokenAccounts.value.filter(account => Number(account.amount) > 0).length;

    // Get recent token transfers
    const signatures = await connection.getSignaturesForAddress(mintPubkey, { limit: 100 });
    const recentTransactions = await connection.getParsedTransactions(
      signatures.map(sig => sig.signature),
      { maxSupportedTransactionVersion: 0 }
    );

    // Calculate 24h volume from recent transactions
    const oneDayAgo = Date.now() - 24 * 60 * 60 * 1000;
    const volume24h = recentTransactions.reduce((total, tx) => {
      if (tx?.blockTime && tx.blockTime * 1000 > oneDayAgo) {
        return total + (tx.meta?.postTokenBalances?.reduce((txTotal, balance) => {
          if (balance.mint === mintAddress && balance.uiTokenAmount) {
            return txTotal + Number(balance.uiTokenAmount.uiAmount || 0);
          }
          return txTotal;
        }, 0) || 0);
      }
      return total;
    }, 0);

    const tokenData = {
      metadata,
      supply: Number(mintInfo.supply),
      decimals: mintInfo.decimals,
      holders,
      volume24h,
      isInitialized: mintInfo.isInitialized,
      freezeAuthority: mintInfo.freezeAuthority?.toBase58(),
      mintAuthority: mintInfo.mintAuthority?.toBase58()
    };

    return NextResponse.json(tokenData, { headers: baseHeaders });
  } catch (error) {
    console.error('Error fetching token details:', error);
    return NextResponse.json(
      { error: 'Failed to fetch token details' },
      { status: 500, headers: baseHeaders }
    );
  }
}



---
File: /app/api/token-stats/[account]/[mint]/route.ts
---

import { NextRequest, NextResponse } from 'next/server';
import { memoryCache } from '@/lib/cache';
import { queryFlipside } from '@/lib/flipside';

const CACHE_TTL = 300; // 5 minutes
const CACHE_ERROR_TTL = 60; // 1 minute
const QUERY_TIMEOUT = 5000; // 5 seconds
const API_TIMEOUT = 10000; // 10 seconds

interface TokenStats {
  mint: string;
  txCount: number;
  volume: number;
  lastUpdated: number;
}

type TokenTransfers = {
  mint: string;
  total_tx_count: number;
  total_volume: number;
}

// Background refresh function
async function refreshTokenStats(account: string, mint: string, cacheKey: string) {
  try {
    const stats = await getTokenStats(account, mint);
    memoryCache.set(cacheKey, stats, CACHE_TTL);
  } catch (error) {
    console.error('Error refreshing token stats:', error);
  }
}

async function getTokenStats(account: string, mint: string): Promise<TokenStats> {
  const cacheKey = `token-stats-${account}-${mint}`;
  const cachedData = memoryCache.get<TokenStats>(cacheKey);
  if (cachedData !== null) {
    return cachedData;
  }

  // Add timeout to prevent hanging
  const timeoutPromise = new Promise<TokenStats>((_, reject) => {
    setTimeout(() => reject(new Error('Flipside query timeout')), QUERY_TIMEOUT);
  });

  const query = `
    WITH transfer_windows AS (
      -- Recent transfers (last hour, minute granularity)
      SELECT 
        DATE_TRUNC('minute', block_timestamp) as ts,
        COUNT(DISTINCT tx_id) as tx_count,
        SUM(CASE 
          WHEN amount > 0 AND amount < 1e12 
          THEN amount / POW(10, 6) -- USDC has 6 decimals
          ELSE 0 
        END) as volume
      FROM solana.core.fact_transfers
      WHERE block_timestamp >= DATEADD('hour', -1, CURRENT_TIMESTAMP())
      AND mint = '${mint}'
      AND (tx_to = '${account}' OR tx_from = '${account}')
      GROUP BY 1
      
      UNION ALL
      
      -- Historical transfers (last 24 hours, hour granularity)
      SELECT 
        DATE_TRUNC('hour', block_timestamp) as ts,
        COUNT(DISTINCT tx_id) as tx_count,
        SUM(CASE 
          WHEN amount > 0 AND amount < 1e12 
          THEN amount / POW(10, 6) -- USDC has 6 decimals
          ELSE 0 
        END) as volume
      FROM solana.core.fact_transfers
      WHERE block_timestamp >= DATEADD('hour', -24, CURRENT_TIMESTAMP())
      AND block_timestamp < DATEADD('hour', -1, CURRENT_TIMESTAMP())
      AND mint = '${mint}'
      AND (tx_to = '${account}' OR tx_from = '${account}')
      GROUP BY 1
    ),
    aggregated_stats AS (
      SELECT 
        SUM(tx_count) as total_tx_count,
        SUM(volume) as total_volume
      FROM transfer_windows
    )
    SELECT 
      '${mint}' as mint,
      COALESCE(total_tx_count, 0) as total_tx_count,
      COALESCE(total_volume, 0) as total_volume
    FROM aggregated_stats
  `;

  try {
    // Race between query and timeout
    const results = await Promise.race([
      queryFlipside<TokenTransfers>(query),
      timeoutPromise
    ]);

    if (Array.isArray(results) && results.length > 0) {
      const stats = {
        mint: results[0]?.mint || mint,
        txCount: Number(results[0]?.total_tx_count) || 0,
        volume: Number(results[0]?.total_volume) || 0,
        lastUpdated: Date.now()
      };
      memoryCache.set(cacheKey, stats, CACHE_TTL);
      return stats;
    }

    // If query fails or returns no results, try getting cached data
    const cachedStats = memoryCache.get<TokenStats>(cacheKey);
    if (cachedStats !== null) {
      return cachedStats;
    }

    return {
      mint,
      txCount: 0,
      volume: 0,
      lastUpdated: Date.now()
    };
  } catch (error) {
    console.error('Error querying Flipside:', error);
    // Return empty data and cache it to prevent repeated timeouts
    const emptyStats = {
      mint,
      txCount: 0,
      volume: 0,
      lastUpdated: Date.now()
    };
    memoryCache.set(cacheKey, emptyStats, CACHE_ERROR_TTL);
    return emptyStats;
  }
}

export async function GET(
  request: NextRequest,
  context: { params: Promise<{ account: string; mint: string }> }
) {
  try {
    const params = await context.params;
    const { account, mint } = await params;

    // Add overall API timeout
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => reject(new Error('API timeout')), API_TIMEOUT);
    });

    const cacheKey = `token-stats-${account}-${mint}`;
    const cachedStats = memoryCache.get<TokenStats>(cacheKey);
    
    // Return cached data and refresh in background if stale
    if (cachedStats) {
      const age = Date.now() - cachedStats.lastUpdated;
      if (age > CACHE_TTL * 1000) {
        // Refresh in background if cache is stale
        refreshTokenStats(account, mint, cacheKey).catch(console.error);
      }
      return NextResponse.json(cachedStats, {
        headers: {
          'Cache-Control': 'public, s-maxage=300, stale-while-revalidate=60'
        }
      });
    }

    // Race between data fetching and timeout
    const stats = await Promise.race([
      getTokenStats(account, mint),
      timeoutPromise
    ]) as TokenStats;

    memoryCache.set(cacheKey, stats, CACHE_TTL);

    return NextResponse.json(stats, {
      headers: {
        'Cache-Control': 'public, s-maxage=300, stale-while-revalidate=60'
      }
    });
  } catch (error) {
    console.error('Error fetching token stats:', error);
    return NextResponse.json(
      { error: 'Failed to fetch token stats' },
      { status: 500 }
    );
  }
}



---
File: /app/api/transaction/[signature]/route.ts
---

import { NextRequest } from 'next/server';
import { DetailedTransactionInfo } from '@/lib/solana';
import { getConnection } from '@/lib/solana-connection';
import { ParsedTransactionWithMeta } from '@solana/web3.js';

const defaultHeaders = {
  'Content-Type': 'application/json',
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'GET, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type, Authorization'
};

export async function OPTIONS() {
  return new Response(null, {
    status: 200,
    headers: {
      ...defaultHeaders,
      'Access-Control-Max-Age': '86400',
    },
  });
}

export async function GET(
  request: NextRequest,
  context: { params: Promise<{ signature: string }> }
) {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout

  try {
    // Get signature from params - properly awaited in Next.js 13+
    const params = await context.params;
    const { signature } = await params;

    if (!signature) {
      console.error('Transaction signature is missing');
      return new Response(
        JSON.stringify({ error: 'Transaction signature is required' }),
        { 
          status: 400,
          headers: defaultHeaders
        }
      );
    }

    // Get connection from pool
    const connection = await getConnection();

    // Fetch transaction with timeout
    const tx = await Promise.race([
      connection.getParsedTransaction(signature, {
        maxSupportedTransactionVersion: 0,
        commitment: 'confirmed'
      }),
      new Promise((_, reject) => {
        setTimeout(() => reject(new Error('RPC request timed out')), 8000);
      })
    ]) as ParsedTransactionWithMeta | null;

    clearTimeout(timeoutId);

    if (!tx) {
      return new Response(
        JSON.stringify({ error: 'Transaction not found' }),
        { 
          status: 404,
          headers: defaultHeaders
        }
      );
    }

    // Transform transaction data
    const transactionInfo: DetailedTransactionInfo = {
      signature,
      timestamp: tx.blockTime ? tx.blockTime * 1000 : Date.now(),
      slot: tx.slot,
      success: tx.meta?.err === null,
      type: 'unknown',
      details: {
        instructions: tx.transaction.message.instructions.map((ix: any) => {
          try {
            if ('parsed' in ix) {
              return {
                program: ix.program || '',
                programId: ix.programId?.toString() || '',
                parsed: ix.parsed || {},
                accounts: ix.accounts?.map((acc: any) => acc?.toString() || '') || [],
                data: JSON.stringify(ix.parsed || {}),
                computeUnits: undefined,
                computeUnitsConsumed: undefined
              };
            } else {
              return {
                programId: ix.programId?.toString() || '',
                accounts: ix.accounts?.map((acc: any) => acc?.toString() || '') || [],
                data: ix.data || '',
                computeUnits: undefined,
                computeUnitsConsumed: undefined
              };
            }
          } catch (error) {
            console.error('Error converting instruction:', error);
            return {
              program: '',
              programId: '',
              parsed: {},
              accounts: [],
              data: '',
              computeUnits: undefined,
              computeUnitsConsumed: undefined
            };
          }
        }),
        accounts: tx.transaction.message.accountKeys.map((key: any) => ({
          pubkey: key?.pubkey?.toString() || '',
          signer: key?.signer || false,
          writable: key?.writable || false
        })),
        preBalances: tx.meta?.preBalances || [],
        postBalances: tx.meta?.postBalances || [],
        preTokenBalances: tx.meta?.preTokenBalances || [],
        postTokenBalances: tx.meta?.postTokenBalances || [],
        logs: tx.meta?.logMessages || [],
        innerInstructions: tx.meta?.innerInstructions?.map(inner => ({
          index: inner.index,
          instructions: inner.instructions.map((ix: any) => {
            try {
              if ('parsed' in ix) {
                return {
                  program: ix.program || '',
                  programId: ix.programId?.toString() || '',
                  parsed: ix.parsed || {},
                  accounts: ix.accounts?.map((acc: any) => acc?.toString() || '') || [],
                  data: JSON.stringify(ix.parsed || {}),
                  computeUnits: undefined,
                  computeUnitsConsumed: undefined
                };
              } else {
                return {
                  programId: ix.programId?.toString() || '',
                  accounts: ix.accounts?.map((acc: any) => acc?.toString() || '') || [],
                  data: ix.data || '',
                  computeUnits: undefined,
                  computeUnitsConsumed: undefined
                };
              }
            } catch (error) {
              console.error('Error converting inner instruction:', error);
              return {
                program: '',
                programId: '',
                parsed: {},
                accounts: [],
                data: '',
                computeUnits: undefined,
                computeUnitsConsumed: undefined
              };
            }
          })
        })) || []
      }
    };

    // Try to determine transaction type and extract relevant details
    if (tx.meta?.preTokenBalances?.length && tx.meta.postTokenBalances?.length) {
      transactionInfo.type = 'token';
      // Extract token transfer details if available
      transactionInfo.details.tokenChanges = tx.meta.postTokenBalances
        .map(post => {
          const pre = tx.meta?.preTokenBalances?.find(p => p.accountIndex === post.accountIndex);
          return {
            mint: post.mint || '',
            preAmount: pre?.uiTokenAmount?.uiAmount || 0,
            postAmount: post.uiTokenAmount?.uiAmount || 0,
            change: (post.uiTokenAmount?.uiAmount || 0) - (pre?.uiTokenAmount?.uiAmount || 0)
          };
        })
        .filter(change => change.mint && (change.preAmount !== 0 || change.postAmount !== 0));
    } else if (tx.meta?.preBalances?.length && tx.meta.postBalances?.length) {
      transactionInfo.type = 'sol';
      // Extract SOL transfer details
      transactionInfo.details.solChanges = tx.meta.postBalances
        .map((post, i) => ({
          accountIndex: i,
          preBalance: tx.meta?.preBalances?.[i] || 0,
          postBalance: post || 0,
          change: (post || 0) - (tx.meta?.preBalances?.[i] || 0)
        }))
        .filter(change => change.change !== 0);
    }

    return new Response(
      JSON.stringify(transactionInfo),
      {
        status: 200,
        headers: defaultHeaders
      }
    );
  } catch (error) {
    clearTimeout(timeoutId);
    console.error('Transaction error:', error);
    
    let status = 500;
    let message = 'Failed to fetch transaction';

    if (error instanceof Error) {
      if (error.name === 'AbortError' || error.message.includes('timed out')) {
        status = 504;
        message = 'Request timed out. Please try again.';
      } else if (error.message.includes('429') || error.message.includes('Too many requests')) {
        status = 429;
        message = 'Rate limit exceeded. Please try again in a few moments.';
      } else if (error.message.includes('403') || error.message.includes('Forbidden')) {
        status = 403;
        message = 'Access denied. Please check your permissions.';
      } else if (error.message.includes('404') || error.message.includes('not found')) {
        status = 404;
        message = 'Transaction not found. Please check the signature and try again.';
      } else if (error.message.includes('500') || error.message.includes('Internal')) {
        status = 500;
        message = 'Server error. Please try again later.';
      }
    }
    
    return new Response(
      JSON.stringify({ 
        error: message,
        details: error instanceof Error ? {
          name: error.name,
          message: error.message,
          stack: error.stack
        } : error
      }),
      { 
        status,
        headers: defaultHeaders
      }
    );
  }
}


---
File: /app/api/transaction/route.ts
---

export const dynamic = 'force-dynamic';
import { NextRequest, NextResponse } from 'next/server';

export async function GET(request: NextRequest) {
  try {
    const signature = request.nextUrl.searchParams.get('signature');

    if (!signature) {
      return NextResponse.json({ error: 'Transaction signature is required' }, { status: 400 });
    }

    // Return mock data for development
    const txDetails = {
      signature,
      timestamp: Date.now(),
      slot: 234567890,
      success: true,
      type: 'token',
      details: {
        instructions: [
          {
            program: 'spl-token',
            accounts: [0, 1, 2],
            data: '{"type":"transfer","info":{"amount":"1000000","authority":"DtdSSG8ZJRZVv5Jx7K1MeWp7Zxcu19GD5wQRGRpQ9uMF","source":"ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL","destination":"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"}}',
            parsed: {
              type: "transfer",
              info: {
                amount: '1000000',
                authority: 'DtdSSG8ZJRZVv5Jx7K1MeWp7Zxcu19GD5wQRGRpQ9uMF',
                source: 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL',
                destination: 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'
              }
            },
            computeUnits: 2400,
            computeUnitsConsumed: 1800
          }
        ],
        accounts: [
          {
            pubkey: { toString() { return 'DtdSSG8ZJRZVv5Jx7K1MeWp7Zxcu19GD5wQRGRpQ9uMF'; } },
            signer: true,
            writable: true
          },
          {
            pubkey: { toString() { return 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'; } },
            signer: false,
            writable: true
          },
          {
            pubkey: { toString() { return 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'; } },
            signer: false,
            writable: true
          }
        ],
        preBalances: [1000000, 500000, 300000],
        postBalances: [999000, 499000, 301000],
        preTokenBalances: [
          {
            accountIndex: 1,
            mint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
            uiTokenAmount: {
              amount: '1000000',
              decimals: 6,
              uiAmount: 1.0
            }
          }
        ],
        postTokenBalances: [
          {
            accountIndex: 2,
            mint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
            uiTokenAmount: {
              amount: '1000000',
              decimals: 6,
              uiAmount: 1.0
            }
          }
        ],
        logs: [
          'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [1]',
          'Program log: Transfer 1 USDC',
          'Program consumed 1800 of 2400 compute units',
          'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA success'
        ],
        innerInstructions: []
      }
    };
    return NextResponse.json(txDetails);

  } catch (error) {
    console.error('Transaction error:', error);
    return NextResponse.json(
      { 
        error: error instanceof Error ? error.message : 'Failed to fetch transaction',
        details: error instanceof Error ? {
          name: error.name,
          message: error.message,
          stack: error.stack
        } : error
      },
      { status: 500 }
    );
  }
}


---
File: /app/block/[slot]/metadata.ts
---

import { Metadata } from 'next';

export async function generateMetadata({
  params,
}: {
  params: { slot: string };
}): Promise<Metadata> {
  return {
    title: `Block #${params.slot} | OPENSVM`,
    description: `View details of Solana block #${params.slot} on OPENSVM`,
  };
} 


---
File: /app/block/[slot]/opengraph-image.tsx
---

import { ImageResponse } from 'next/og';
import { getConnection } from '@/lib/solana';
import { formatNumber } from '@/lib/utils';

export const runtime = 'edge';
export const alt = 'Block Details';
export const size = {
  width: 1200,
  height: 630,
};
export const contentType = 'image/png';

export default async function Image({ params }: { params: { slot: string } }) {
  try {
    const conn = await getConnection();
    const slotNumber = parseInt(params.slot);
    const [block, blockTime] = await Promise.all([
      conn.getBlock(slotNumber, { maxSupportedTransactionVersion: 0 }),
      conn.getBlockTime(slotNumber),
    ]);

    if (!block) {
      throw new Error('Block not found');
    }

    const totalRewards = block.rewards.reduce((acc, r) => acc + r.lamports, 0) / 1e9;

    return new ImageResponse(
      (
        <div
          style={{
            height: '100%',
            width: '100%',
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            justifyContent: 'center',
            backgroundColor: '#000',
            backgroundImage: 'linear-gradient(45deg, #000 0%, #111 100%)',
          }}
        >
          {/* Logo */}
          <div
            style={{
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              marginBottom: '20px',
            }}
          >
            <div
              style={{
                width: '80px',
                height: '80px',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                borderRadius: '50%',
                background: 'linear-gradient(135deg, #00ffbd 0%, #00b386 100%)',
                marginRight: '16px',
              }}
            >
              <div
                style={{
                  color: 'white',
                  fontSize: '40px',
                  fontWeight: 700,
                }}
              >
                S
              </div>
            </div>
            <div
              style={{
                fontSize: '48px',
                fontWeight: 700,
                background: 'linear-gradient(135deg, #00ffbd 0%, #00b386 100%)',
                backgroundClip: 'text',
                color: 'transparent',
              }}
            >
              OPENSVM
            </div>
          </div>

          {/* Content */}
          <div
            style={{
              display: 'flex',
              flexDirection: 'column',
              alignItems: 'center',
              marginTop: '20px',
              padding: '0 48px',
            }}
          >
            <div
              style={{
                fontSize: '32px',
                fontWeight: 600,
                color: 'white',
                marginBottom: '10px',
                textAlign: 'center',
              }}
            >
              Block #{formatNumber(slotNumber)}
            </div>
            <div
              style={{
                fontSize: '24px',
                color: '#00ffbd',
                marginBottom: '20px',
                textAlign: 'center',
              }}
            >
              {blockTime ? new Date(blockTime * 1000).toLocaleString() : 'Unknown time'}
            </div>
            <div
              style={{
                fontSize: '20px',
                color: '#888',
                textAlign: 'center',
                maxWidth: '600px',
              }}
            >
              {formatNumber(block.transactions.length)} Transactions • {formatNumber(totalRewards)} SOL in Rewards
            </div>
            <div
              style={{
                fontSize: '16px',
                color: '#666',
                marginTop: '20px',
                textAlign: 'center',
              }}
            >
              Parent Slot: {formatNumber(block.parentSlot)}
            </div>
          </div>

          {/* Footer */}
          <div
            style={{
              position: 'absolute',
              bottom: '32px',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
            }}
          >
            <div
              style={{
                fontSize: '16px',
                color: '#666',
              }}
            >
              opensvm.com
            </div>
          </div>
        </div>
      ),
      {
        width: 1200,
        height: 630,
      },
    );
  } catch (e: any) {
    console.log(`${e.message}`);
    return new Response(`Failed to generate the image`, {
      status: 500,
    });
  }
} 


---
File: /app/block/[slot]/page.tsx
---

'use client';

import { useParams } from 'next/navigation';
import BlockDetails from '@/components/BlockDetails';

export default function BlockPage() {
  const params = useParams();
  const slot = params?.slot as string;

  return (
    <div className="container mx-auto p-6">
      <h1 className="text-2xl font-bold mb-6">Block Details</h1>
      <BlockDetails slot={slot} />
    </div>
  );
}


---
File: /app/block/layout.tsx
---

import { Metadata } from 'next';

export const metadata: Metadata = {
  title: 'Block Details | OPENSVM',
  description: 'View Solana block details on OPENSVM',
};

export default function BlockLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <div className="min-h-screen bg-background">
      {children}
    </div>
  );
} 


---
File: /app/blocks/page.tsx
---

export default function BlocksPage() {
  return (
    <div className="container mx-auto py-8">
      <div className="mb-8">
        <h1 className="text-4xl font-bold mb-2">Recent Blocks</h1>
        <p className="text-muted-foreground">
          View latest blocks and transactions on the Solana network.
        </p>
      </div>
      <div className="rounded-md border p-8 text-center">
        <p className="text-muted-foreground">Block explorer coming soon...</p>
      </div>
    </div>
  );
}



---
File: /app/docs/[slug]/page.tsx
---

import { promises as fs } from 'fs';
import path from 'path';
import { notFound } from 'next/navigation';
import { Metadata } from 'next';
import ReactMarkdown from 'react-markdown';

interface Props {
  params: Promise<{ slug: string }>;
  searchParams: Promise<{ [key: string]: string | string[] | undefined }>;
}

export async function generateMetadata({ params }: Props): Promise<Metadata> {
  const resolvedParams = await params;
  const title = resolvedParams.slug.replace(/-/g, ' ');
  return {
    title: `${title} - Documentation`,
  };
}

export default async function DocPage({ params }: Props) {
  const resolvedParams = await params;
  const { slug } = resolvedParams;
  
  // Use path.join with __dirname to get the correct path in both dev and prod
  const docsDir = path.join(process.cwd(), 'agent_notes', 'vtable_study', 'vtable_docs');
  const filePath = path.join(docsDir, `${slug}.md`);

  try {
    // Verify directory exists
    try {
      await fs.access(docsDir);
    } catch (error) {
      console.error(`Docs directory not found: ${docsDir}`);
      notFound();
    }

    const content = await fs.readFile(filePath, 'utf8');

    return (
      <div className="container mx-auto px-4 py-8 prose dark:prose-invert max-w-none">
        <ReactMarkdown>{content}</ReactMarkdown>
      </div>
    );
  } catch (error) {
    console.error(`Error reading doc file: ${filePath}`, error);
    notFound();
  }
}


---
File: /app/docs/page.tsx
---

import { promises as fs } from 'fs';
import path from 'path';
import Link from 'next/link';

export const metadata = {
  title: 'Documentation',
};

export default async function DocsPage() {
  const docsDir = path.join(process.cwd(), 'agent_notes', 'vtable_study', 'vtable_docs');

  try {
    // Verify directory exists
    try {
      await fs.access(docsDir);
    } catch (error) {
      console.error(`Docs directory not found: ${docsDir}`);
      return (
        <div className="container mx-auto px-4 py-8">
          <h1 className="text-3xl font-bold mb-6">Documentation</h1>
          <p className="text-red-500">Documentation directory not found. Please ensure all documentation files are properly installed.</p>
        </div>
      );
    }

    const files = await fs.readdir(docsDir);
    const mdFiles = files.filter(file => file.endsWith('.md'));

    if (mdFiles.length === 0) {
      return (
        <div className="container mx-auto px-4 py-8">
          <h1 className="text-3xl font-bold mb-6">Documentation</h1>
          <p>No documentation files found.</p>
        </div>
      );
    }

    return (
      <div className="container mx-auto px-4 py-8">
        <h1 className="text-3xl font-bold mb-6">Documentation</h1>
        <div className="grid gap-4">
          {mdFiles.map((file) => (
            <Link 
              key={file}
              href={`/docs/${encodeURIComponent(file.replace('.md', ''))}`}
              className="p-4 border rounded hover:bg-gray-100 dark:hover:bg-gray-800"
            >
              {file.replace('.md', '').replace(/-/g, ' ')}
            </Link>
          ))}
        </div>
      </div>
    );
  } catch (error) {
    console.error('Error loading documentation:', error);
    return (
      <div className="container mx-auto px-4 py-8">
        <h1 className="text-3xl font-bold mb-6">Documentation</h1>
        <p className="text-red-500">Error loading documentation. Please try again later.</p>
      </div>
    );
  }
}


---
File: /app/networks/page.tsx
---

"use client";

import { NetworkCharts } from '@/components/NetworkCharts';
import { NetworksTable } from '@/components/NetworksTable';

export default function NetworksPage() {
  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold mb-8">Network Performance</h1>
      <NetworkCharts networkId="solana" isLive={true} />
      <div className="mt-8">
        <NetworksTable />
      </div>
    </div>
  );
}



---
File: /app/nfts/new/page.tsx
---

'use client';

import { useState, useEffect } from 'react';
import Image from 'next/image';

interface NewNFTCollection {
  address: string;
  name: string;
  symbol: string;
  image: string;
  mintedAt: string;
  totalSupply: number;
}

const fetchNewCollections = async (): Promise<NewNFTCollection[]> => {
  const response = await fetch('/api/nft-collections/new');
  if (!response.ok) {
    throw new Error(await response.text());
  }
  return response.json();
};

export default function NewNFTsPage() {
  const [collections, setCollections] = useState<NewNFTCollection[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [retryCount, setRetryCount] = useState(0);

  useEffect(() => {
    let mounted = true;
    let retryTimeout: NodeJS.Timeout;

    const fetchCollections = async () => {
      try {
        const data = await fetchNewCollections();
        if (mounted) {
          setCollections(data);
          setError(null);
        }
      } catch (err) {
        if (mounted) {
          const errorMessage = err instanceof Error ? err.message : 'Failed to fetch new collections';
          setError(errorMessage);
          if (retryCount < 2) {
            const nextRetry = () => {
              if (mounted) {
                setRetryCount(prev => prev + 1);
              }
            };
            retryTimeout = setTimeout(nextRetry, 1000);
          }
        }
      } finally {
        if (mounted) {
          setLoading(false);
        }
      }
    };

    fetchCollections();

    return () => {
      mounted = false;
      if (retryTimeout) {
        clearTimeout(retryTimeout);
      }
    };
  }, [retryCount]);

  if (loading) {
    return (
      <div className="container mx-auto py-8">
        <div className="mb-8">
          <h1 className="text-4xl font-bold mb-2">New Mints</h1>
          <p className="text-muted-foreground">
            Recently minted NFT collections on the Solana network.
          </p>
        </div>
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {[...Array(6)].map((_, i) => (
            <div key={i} data-testid="nft-skeleton" className="rounded-lg border p-4 animate-pulse">
              <div className="w-full h-48 bg-muted mb-4" />
              <div className="h-4 bg-muted w-3/4 mb-2" />
              <div className="h-4 bg-muted w-1/2" />
            </div>
          ))}
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="container mx-auto py-8">
        <div className="mb-8">
          <h1 className="text-4xl font-bold mb-2">New Mints</h1>
          <p className="text-muted-foreground">
            Recently minted NFT collections on the Solana network.
          </p>
        </div>
        <div className="rounded-md border p-8 text-center">
          <p className="text-red-600" data-testid="error-message">{error}</p>
        </div>
      </div>
    );
  }

  if (collections.length === 0) {
    return (
      <div className="container mx-auto py-8">
        <div className="mb-8">
          <h1 className="text-4xl font-bold mb-2">New Mints</h1>
          <p className="text-muted-foreground">
            Recently minted NFT collections on the Solana network.
          </p>
        </div>
        <div className="rounded-md border p-8 text-center">
          <p className="text-muted-foreground">No new collections found</p>
        </div>
      </div>
    );
  }

  return (
    <div className="container mx-auto py-8">
      <div className="mb-8">
        <h1 className="text-4xl font-bold mb-2">New Mints</h1>
        <p className="text-muted-foreground">
          Recently minted NFT collections on the Solana network.
        </p>
      </div>
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        {collections.map((collection) => (
          <div
            key={collection.name}
            data-testid="nft-collection"
            className="rounded-lg border p-4"
          >
            {collection.image.startsWith('/') || collection.image.startsWith('http') ? (
              <Image
                src={collection.image}
                alt={collection.name}
                width={400}
                height={300}
                className="w-full h-48 object-cover rounded-md mb-4"
                onError={(e) => {
                  e.currentTarget.src = '/images/placeholder-nft.svg';
                }}
              />
            ) : (
              <Image
                src="/images/placeholder-nft.svg"
                alt={collection.name}
                width={400}
                height={300}
                className="w-full h-48 object-cover rounded-md mb-4"
              />
            )}
            <h3 className="font-semibold text-lg mb-2">{collection.name}</h3>
            <p className="text-muted-foreground mb-2">{collection.symbol}</p>
            <div className="flex justify-between text-sm">
              <div>
                <p className="text-muted-foreground">Minted</p>
                <p className="font-medium">
                  {new Date(collection.mintedAt).toLocaleDateString()}
                </p>
              </div>
              <div className="text-right">
                <p className="text-muted-foreground">Total Supply</p>
                <p className="font-medium">{collection.totalSupply.toLocaleString()}</p>
              </div>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}



---
File: /app/nfts/trending/page.tsx
---

'use client';

import { useState, useEffect } from 'react';
import Image from 'next/image';

interface TrendingNFTCollection {
  address: string;
  name: string;
  symbol: string;
  image: string;
  volume24h: string;
  transactions24h: number;
}

const fetchTrendingCollections = async (): Promise<TrendingNFTCollection[]> => {
  const response = await fetch('/api/nft-collections/trending');
  if (!response.ok) {
    throw new Error(await response.text());
  }
  return response.json();
};

export default function TrendingNFTsPage() {
  const [collections, setCollections] = useState<TrendingNFTCollection[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [retryCount, setRetryCount] = useState(0);

  useEffect(() => {
    let mounted = true;
    let retryTimeout: NodeJS.Timeout;

    const fetchCollections = async () => {
      try {
        const data = await fetchTrendingCollections();
        if (mounted) {
          setCollections(data);
          setError(null);
        }
      } catch (err) {
        if (mounted) {
          const errorMessage = err instanceof Error ? err.message : 'Failed to fetch trending collections';
          setError(errorMessage);
          if (retryCount < 2) {
            const nextRetry = () => {
              if (mounted) {
                setRetryCount(prev => prev + 1);
              }
            };
            retryTimeout = setTimeout(nextRetry, 1000);
          }
        }
      } finally {
        if (mounted) {
          setLoading(false);
        }
      }
    };

    fetchCollections();

    return () => {
      mounted = false;
      if (retryTimeout) {
        clearTimeout(retryTimeout);
      }
    };
  }, [retryCount]);

  if (loading) {
    return (
      <div className="container mx-auto py-8">
        <div className="mb-8">
          <h1 className="text-4xl font-bold mb-2">Trending NFTs</h1>
          <p className="text-muted-foreground">
            Most active NFT collections in the last 24 hours.
          </p>
        </div>
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {[...Array(6)].map((_, i) => (
            <div key={i} data-testid="nft-skeleton" className="rounded-lg border p-4 animate-pulse">
              <div className="w-full h-48 bg-muted mb-4" />
              <div className="h-4 bg-muted w-3/4 mb-2" />
              <div className="h-4 bg-muted w-1/2" />
            </div>
          ))}
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="container mx-auto py-8">
        <div className="mb-8">
          <h1 className="text-4xl font-bold mb-2">Trending NFTs</h1>
          <p className="text-muted-foreground">
            Most active NFT collections in the last 24 hours.
          </p>
        </div>
        <div className="rounded-md border p-8 text-center">
          <p className="text-red-600" data-testid="error-message">{error}</p>
        </div>
      </div>
    );
  }

  if (collections.length === 0) {
    return (
      <div className="container mx-auto py-8">
        <div className="mb-8">
          <h1 className="text-4xl font-bold mb-2">Trending NFTs</h1>
          <p className="text-muted-foreground">
            Most active NFT collections in the last 24 hours.
          </p>
        </div>
        <div className="rounded-md border p-8 text-center">
          <p className="text-muted-foreground">No trending collections found</p>
        </div>
      </div>
    );
  }

  return (
    <div className="container mx-auto py-8">
      <div className="mb-8">
        <h1 className="text-4xl font-bold mb-2">Trending NFTs</h1>
        <p className="text-muted-foreground">
          Most active NFT collections in the last 24 hours.
        </p>
      </div>
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        {collections.map((collection) => (
          <div
            key={collection.name}
            data-testid="nft-collection"
            className="rounded-lg border p-4"
          >
            {collection.image.startsWith('/') || collection.image.startsWith('http') ? (
              <Image
                src={collection.image}
                alt={collection.name}
                width={400}
                height={300}
                className="w-full h-48 object-cover rounded-md mb-4"
                onError={(e) => {
                  e.currentTarget.src = '/images/placeholder-nft.svg';
                }}
              />
            ) : (
              <Image
                src="/images/placeholder-nft.svg"
                alt={collection.name}
                width={400}
                height={300}
                className="w-full h-48 object-cover rounded-md mb-4"
              />
            )}
            <h3 className="font-semibold text-lg mb-2">{collection.name}</h3>
            <p className="text-muted-foreground mb-2">{collection.symbol}</p>
            <div className="flex justify-between text-sm">
              <div>
                <p className="text-muted-foreground">24h Volume</p>
                <p className="font-medium">{Number(collection.volume24h).toLocaleString()} SOL</p>
              </div>
              <div className="text-right">
                <p className="text-muted-foreground">24h Transactions</p>
                <p className="font-medium">{collection.transactions24h.toLocaleString()}</p>
              </div>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}



---
File: /app/nfts/page.tsx
---

'use client';

import { useState, useEffect } from 'react';
import Image from 'next/image';

interface NFTCollection {
  address: string;
  name: string;
  symbol: string;
  image: string;
}

const fetchNFTCollections = async (): Promise<NFTCollection[]> => {
  const response = await fetch('/api/nft-collections');
  if (!response.ok) {
    throw new Error(await response.text());
  }
  return response.json();
};

export default function NFTsPage() {
  const [collections, setCollections] = useState<NFTCollection[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [retryCount, setRetryCount] = useState(0);

  useEffect(() => {
    let mounted = true;
    let retryTimeout: NodeJS.Timeout;

    const fetchCollections = async () => {
      try {
        const response = await fetch('/api/nft-collections');
        const data = await response.json();
        if (mounted) {
          setCollections(data);
          setError(null);
        }
      } catch (err) {
        if (mounted) {
          const errorMessage = err instanceof Error ? err.message : 'Failed to fetch NFT collections';
          setError(errorMessage);
          if (retryCount < 2) {
            const nextRetry = () => {
              if (mounted) {
                setRetryCount(prev => prev + 1);
              }
            };
            retryTimeout = setTimeout(nextRetry, 1000);
          }
        }
      } finally {
        if (mounted) {
          setLoading(false);
        }
      }
    };

    fetchCollections();

    return () => {
      mounted = false;
      if (retryTimeout) {
        clearTimeout(retryTimeout);
      }
    };
  }, [retryCount]);

  if (loading) {
    return (
      <div className="container mx-auto py-8">
        <div className="mb-8">
          <h1 className="text-4xl font-bold mb-2">NFT Collections</h1>
          <p className="text-muted-foreground">
            Browse NFT collections on the Solana network.
          </p>
        </div>
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {[...Array(6)].map((_, i) => (
            <div key={i} data-testid="nft-skeleton" className="rounded-lg border p-4 animate-pulse">
              <div className="w-full h-48 bg-muted mb-4" />
              <div className="h-4 bg-muted w-3/4 mb-2" />
              <div className="h-4 bg-muted w-1/2" />
            </div>
          ))}
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="container mx-auto py-8">
        <div className="mb-8">
          <h1 className="text-4xl font-bold mb-2">NFT Collections</h1>
          <p className="text-muted-foreground">
            Browse NFT collections on the Solana network.
          </p>
        </div>
        <div className="rounded-md border p-8 text-center">
          <p className="text-red-600" data-testid="error-message">{error}</p>
        </div>
      </div>
    );
  }

  if (collections.length === 0) {
    return (
      <div className="container mx-auto py-8">
        <div className="mb-8">
          <h1 className="text-4xl font-bold mb-2">NFT Collections</h1>
          <p className="text-muted-foreground">
            Browse NFT collections on the Solana network.
          </p>
        </div>
        <div className="rounded-md border p-8 text-center">
          <p className="text-muted-foreground">No NFT collections found</p>
        </div>
      </div>
    );
  }

  return (
    <div className="container mx-auto py-8">
      <div className="mb-8">
        <h1 className="text-4xl font-bold mb-2">NFT Collections</h1>
        <p className="text-muted-foreground">
          Browse NFT collections on the Solana network.
        </p>
      </div>
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        {collections.map((collection) => (
          <div
            key={collection.name}
            data-testid="nft-collection"
            className="rounded-lg border p-4"
          >
            {collection.image.startsWith('/') || collection.image.startsWith('http') ? (
              <Image
                src={collection.image}
                alt={collection.name}
                width={400}
                height={300}
                className="w-full h-48 object-cover rounded-md mb-4"
                onError={(e) => {
                  e.currentTarget.src = '/images/placeholder-nft.svg';
                }}
              />
            ) : (
              <Image
                src="/images/placeholder-nft.svg"
                alt={collection.name}
                width={400}
                height={300}
                className="w-full h-48 object-cover rounded-md mb-4"
              />
            )}
            <h3 className="font-semibold text-lg mb-2">{collection.name}</h3>
            <p className="text-muted-foreground">{collection.symbol}</p>
          </div>
        ))}
      </div>
    </div>
  );
}



---
File: /app/program/[address]/disassembly-view.tsx
---

'use client';

import { decodeInstruction } from '../../../lib/bpf';

interface DisassemblyViewProps {
  data: number[];
}

const toHex = (num: number, width: number = 2): string => {
  const hex = num >>> 0; // Convert to unsigned 32-bit integer
  return hex.toString(16).padStart(width, '0').toLowerCase();
};

const DisassemblyView: React.FC<DisassemblyViewProps> = ({ data }) => {
  return (
    <div className="font-mono text-sm">
      <div className="space-y-1">
        {/* Header */}
        <div className="flex items-center space-x-4 text-xs text-gray-500 border-b border-white/5 pb-2 mb-4">
          <div className="w-24 shrink-0">Offset</div>
          <div className="w-48 shrink-0">Bytes</div>
          <div className="w-48 shrink-0">Components</div>
          <div className="flex-1">Instruction</div>
          <div className="w-96 shrink-0 text-right">Description</div>
        </div>

        {/* Instructions */}
        {Array.from({ length: Math.min(data.length, 1024) }, (_, i) => {
          if (i % 8 !== 0) return null;
          const bytes = data.slice(i, i + 8);
          if (bytes.length < 8) return null;
          
          // Parse BPF instruction components (little-endian)
          const opcode = bytes[0];
          const dst_reg = bytes[1] & 0xf;
          const src_reg = (bytes[1] >> 4) & 0xf;
          const offset = new Int16Array(new Uint8Array([bytes[2], bytes[3]]).buffer)[0];
          const imm = new Int32Array(new Uint8Array([bytes[4], bytes[5], bytes[6], bytes[7]]).buffer)[0];

          // Create BPF instruction object
          const instruction = {
            opcode,
            dst_reg,
            src_reg,
            offset,
            imm
          };

          // Get decoded instruction with register info
          const decoded = decodeInstruction(instruction);
          
          return (
            <div key={i} className="flex items-center space-x-4 py-1 hover:bg-white/[0.02] group">
              {/* Offset */}
              <div className="w-24 shrink-0">
                <span className="text-blue-400/60">{toHex(i, 8)}</span>
              </div>

              {/* Bytes */}
              <div className="w-48 shrink-0 text-gray-400 font-light tracking-wider">
                {bytes.map((b, idx) => (
                  <span key={idx} className={idx === 0 ? 'text-yellow-400/80' : ''}>
                    {toHex(b)}{idx < 7 ? ' ' : ''}
                  </span>
                ))}
              </div>

              {/* Components */}
              <div className="w-48 shrink-0 text-gray-400/80 font-light">
                <span className="text-yellow-400/80">op:{toHex(bytes[0], 2)}</span>
                <span className="text-blue-400/80"> r{bytes[1] & 0xf}</span>
                <span className="text-gray-500">,</span>
                <span className="text-blue-400/80">r{(bytes[1] >> 4) & 0xf}</span>
                {offset !== 0 && <span className="text-purple-400/80"> +{offset}</span>}
                {imm !== 0 && <span className="text-green-400/80"> #{imm}</span>}
              </div>

              {/* Decoded Instruction */}
              <div className="flex-1 text-white group-hover:text-white/90 transition-colors">
                <span className="text-yellow-400/80">{decoded.mnemonic}</span>
                <span className="text-gray-300"> {decoded.operands.join(', ')}</span>
              </div>

              {/* Description */}
              <div className="w-96 shrink-0 text-right">
                {/* C-like syntax */}
                <span className="text-gray-500 text-sm">{decoded.comment}</span>
                {/* Register descriptions */}
                {decoded.regInfo && decoded.regInfo.length > 0 && (
                  <div className="text-xs text-gray-600 mt-1">
                    {decoded.regInfo.map((info, idx) => (
                      <div key={idx}>{info}</div>
                    ))}
                  </div>
                )}
              </div>
            </div>
          );
        }).filter(Boolean)}
      </div>
    </div>
  );
};

export default DisassemblyView;



---
File: /app/program/[address]/hex-view.tsx
---

'use client';

import { useEffect, useRef, useState, useCallback } from 'react';

interface HexViewProps {
  data: number[];
  selectedByte?: number | null;
  onByteSelect?: (offset: number | null) => void;
  selectionRange?: [number, number] | null;
}

const ROW_HEIGHT = 24;
const BUFFER_SIZE = 20;

export default function HexView({
  data,
  selectedByte,
  onByteSelect,
  selectionRange,
}: HexViewProps) {
  const containerRef = useRef<HTMLDivElement>(null);
  const [visibleRange, setVisibleRange] = useState({ start: 0, end: 50 });

  // Format helpers
  const toHex = (n: number) => n.toString(16).padStart(2, '0').toLowerCase();
  const toOffset = (n: number) => n.toString(16).padStart(8, '0').toLowerCase();
  const toAscii = (byte: number) => byte >= 32 && byte <= 126 ? String.fromCharCode(byte) : '.';

  // Handle scroll to update visible range
  const handleScroll = useCallback(() => {
    if (!containerRef.current) return;
    
    const container = containerRef.current;
    const scrollTop = container.scrollTop;
    const viewportHeight = container.clientHeight;
    
    const startRow = Math.max(0, Math.floor(scrollTop / ROW_HEIGHT) - BUFFER_SIZE);
    const endRow = Math.min(
      Math.ceil(data.length / 16),
      Math.ceil((scrollTop + viewportHeight) / ROW_HEIGHT) + BUFFER_SIZE
    );

    setVisibleRange({ start: startRow, end: endRow });
  }, [data.length]);

  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    handleScroll();
    container.addEventListener('scroll', handleScroll);
    window.addEventListener('resize', handleScroll);

    return () => {
      container.removeEventListener('scroll', handleScroll);
      window.removeEventListener('resize', handleScroll);
    };
  }, [handleScroll]);

  useEffect(() => {
    if (selectedByte === null || !containerRef.current) return;
    
    const row = Math.floor(selectedByte / 16);
    const container = containerRef.current;
    const rowTop = row * ROW_HEIGHT;
    const scrollTop = container.scrollTop;
    const viewportHeight = container.clientHeight;

    if (rowTop < scrollTop || rowTop + ROW_HEIGHT > scrollTop + viewportHeight) {
      container.scrollTo({
        top: rowTop - viewportHeight / 2,
        behavior: 'smooth'
      });
    }
  }, [selectedByte]);

  const visibleRows = [];
  for (let i = visibleRange.start; i < visibleRange.end; i++) {
    const baseOffset = i * 16;
    const bytes = data.slice(baseOffset, baseOffset + 16);
    if (bytes.length === 0) break;

    const hex = bytes.map((byte, idx) => {
      const offset = baseOffset + idx;
      const isSelected = offset === selectedByte;
      const isInRange = selectionRange && 
        offset >= selectionRange[0] && 
        offset <= selectionRange[1];
      
      return (
        <span
          key={offset}
          onClick={() => onByteSelect?.(offset)}
          className={`
            inline-block w-[2ch] text-center cursor-pointer select-none
            hover:text-blue-400 hover:bg-blue-500/10
            ${isSelected ? 'bg-blue-500 text-white' : ''}
            ${isInRange ? 'bg-blue-500/20' : ''}
            ${idx % 2 === 0 ? 'mr-[1ch]' : 'mr-[2ch]'}
          `}
        >
          {toHex(byte)}
        </span>
      );
    });

    const ascii = bytes.map((byte, idx) => {
      const offset = baseOffset + idx;
      const isSelected = offset === selectedByte;
      const isInRange = selectionRange && 
        offset >= selectionRange[0] && 
        offset <= selectionRange[1];

      return (
        <span
          key={offset}
          onClick={() => onByteSelect?.(offset)}
          className={`
            inline-block w-[1ch] cursor-pointer select-none
            hover:text-blue-400 hover:bg-blue-500/10
            ${isSelected ? 'bg-blue-500 text-white' : ''}
            ${isInRange ? 'bg-blue-500/20' : ''}
          `}
        >
          {toAscii(byte)}
        </span>
      );
    });

    visibleRows.push(
      <div
        key={i}
        className="flex items-center hover:bg-white/5"
        style={{
          position: 'absolute',
          top: i * ROW_HEIGHT,
          left: 0,
          right: 0,
          height: ROW_HEIGHT,
          padding: '0 1rem'
        }}
      >
        <div className="w-[10ch] font-mono text-gray-500">
          {toOffset(baseOffset)}
        </div>
        <div className="w-[52ch] font-mono">
          {hex}
        </div>
        <div className="w-[2ch] text-center font-mono text-gray-500">│</div>
        <div className="font-mono">
          {ascii}
        </div>
      </div>
    );
  }

  const totalHeight = Math.ceil(data.length / 16) * ROW_HEIGHT;

  return (
    <div className="p-4 space-y-4">
      {/* Header */}
      <div className="flex items-center text-sm text-gray-500 font-mono sticky top-0 bg-black z-10 pl-4">
        <div className="w-[10ch]">Offset</div>
        <div className="w-[52ch] flex">
          {[...Array(16)].map((_, i) => (
            <div
              key={i}
              className={`w-[2ch] text-center ${i % 2 === 0 ? 'mr-[1ch]' : 'mr-[2ch]'}`}
            >
              {toHex(i)}
            </div>
          ))}
        </div>
        <div className="w-[2ch] text-center">│</div>
        <div>ASCII</div>
      </div>

      {/* Virtualized content */}
      <div 
        ref={containerRef}
        className="relative overflow-auto"
        style={{ height: 'calc(100vh - 32rem)' }}
      >
        <div style={{ height: totalHeight, position: 'relative' }}>
          {visibleRows}
        </div>
      </div>
    </div>
  );
}



---
File: /app/program/[address]/hilbert.worker.ts
---

// Pre-compute Hilbert curve mappings
const rot = (x: number): number => {
  switch(x) {
    case 1: return 2;
    case 2: return 1;
    default: return x;
  }
};

const graycode = (x: number): number => {
  switch(x) {
    case 3: return 2;
    case 2: return 3;
    default: return x;
  }
};

const hilbert_index = (curve: number, x: number, y: number): number => {
  let h = 0;
  let e = 0;
  let d = 0;
  for (let i = 0; i < curve; i++) {
    const off = curve - i - 1;
    const a = (y >> off) & 1;
    const b = (x >> off) & 1;
    let l = a | b << 1;
    l = l ^ e;
    if (d === 0) l = rot(l);
    const w = graycode(l);
    if (w == 3) e = 3-e;
    h = (h << 2) | w;
    if (w === 0 || w == 3) d ^= 1;
  }
  return h;
};

// Color lookup table
const byteRanges = [
  { start: 0x00, end: 0x00, label: 'NULL', color: '#1a1a1a' },
  { start: 0x01, end: 0x08, label: 'Control 1', color: '#00ff00' },
  { start: 0x09, end: 0x0D, label: 'Whitespace', color: '#00cc00' },
  { start: 0x0E, end: 0x1F, label: 'Control 2', color: '#009900' },
  { start: 0x20, end: 0x2F, label: 'Punctuation 1', color: '#66ffff' },
  { start: 0x30, end: 0x39, label: 'Digits', color: '#00ffff' },
  { start: 0x3A, end: 0x40, label: 'Punctuation 2', color: '#00cccc' },
  { start: 0x41, end: 0x5A, label: 'Uppercase', color: '#3399ff' },
  { start: 0x5B, end: 0x60, label: 'Punctuation 3', color: '#0066cc' },
  { start: 0x61, end: 0x7A, label: 'Lowercase', color: '#0033cc' },
  { start: 0x7B, end: 0x7E, label: 'Punctuation 4', color: '#000099' },
  { start: 0x7F, end: 0x7F, label: 'DEL', color: '#ff0000' },
  { start: 0x80, end: 0x9F, label: 'Extended Control', color: '#ff66ff' },
  { start: 0xA0, end: 0xBF, label: 'Extended ASCII 1', color: '#ff00ff' },
  { start: 0xC0, end: 0xDF, label: 'Extended ASCII 2', color: '#cc00cc' },
  { start: 0xE0, end: 0xEF, label: 'Extended ASCII 3', color: '#990099' },
  { start: 0xF0, end: 0xF7, label: 'High Control 1', color: '#ffff00' },
  { start: 0xF8, end: 0xFE, label: 'High Control 2', color: '#cccc00' },
  { start: 0xFF, end: 0xFF, label: '0xFF', color: '#ffffff' }
];

const colorTable = new Array(256).fill('#000000').map((_, i) => {
  for (const range of byteRanges) {
    if (i >= range.start && i <= range.end) {
      return range.color;
    }
  }
  return '#000000';
});

// Pre-compute RGB values for color table
const rgbTable = new Uint8Array(256 * 3);
colorTable.forEach((color, i) => {
  const r = parseInt(color.slice(1,3), 16);
  const g = parseInt(color.slice(3,5), 16);
  const b = parseInt(color.slice(5,7), 16);
  rgbTable[i * 3] = r;
  rgbTable[i * 3 + 1] = g;
  rgbTable[i * 3 + 2] = b;
});

// Process image data in chunks
interface WorkerMessage {
  data: ArrayBuffer;
  baseSize: number;
}

self.onmessage = (e: MessageEvent<WorkerMessage>) => {
  const { data, baseSize } = e.data;
  const uint8Data = new Uint8Array(data);
  
  // Calculate the Hilbert curve order based on baseSize
  const order = Math.ceil(Math.log2(baseSize));
  const gridSize = 1 << order; // Power of 2 that's >= baseSize
  
  // Create lookup table for this specific size
  const hilbertLookup = new Uint32Array(gridSize * gridSize);
  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      hilbertLookup[y * gridSize + x] = hilbert_index(order, x, y);
    }
  }

  const totalPixels = baseSize * baseSize;
  const CHUNK_SIZE = 200000;
  const maxHilbertIndex = gridSize * gridSize - 1;
  const dataScale = uint8Data.length / maxHilbertIndex;

  // Process in chunks
  const processChunk = (start: number) => {
    const end = Math.min(start + CHUNK_SIZE, totalPixels);
    const imageData = new Uint8ClampedArray((end - start) * 4);

    for (let i = 0; i < imageData.length; i += 4) {
      const pixelIndex = start + (i / 4);
      const x = pixelIndex % baseSize;
      const y = Math.floor(pixelIndex / baseSize);
      
      // Skip if we're outside the valid grid area
      if (x >= gridSize || y >= gridSize) {
        imageData[i] = 0;
        imageData[i+1] = 0;
        imageData[i+2] = 0;
        imageData[i+3] = 255;
        continue;
      }
      
      const hilbertIndex = hilbertLookup[y * gridSize + x];
      const dataOffset = Math.min(Math.floor(hilbertIndex * dataScale), uint8Data.length - 1);
      
      const byte = uint8Data[dataOffset];
      const rgbOffset = byte * 3;
      imageData[i] = rgbTable[rgbOffset];
      imageData[i+1] = rgbTable[rgbOffset + 1];
      imageData[i+2] = rgbTable[rgbOffset + 2];
      imageData[i+3] = 255;
    }

    const transfer: Transferable[] = [imageData.buffer];
    self.postMessage({ imageData, chunkStart: start, chunkEnd: end }, { transfer });

    // Process next chunk if needed
    if (end < totalPixels) {
      setTimeout(() => processChunk(end), 0);
    }
  };

  // Start processing first chunk
  processChunk(0);
};



---
File: /app/program/[address]/layout.tsx
---

import { ReactNode } from 'react';

interface LayoutProps {
  children: ReactNode;
  params: Promise<{ address: string }>;
}

export default async function ProgramLayout({
  children,
  params,
}: LayoutProps) {
  await params; // Ensure params are resolved
  return children;
}



---
File: /app/program/[address]/opengraph-image.tsx
---

import { ImageResponse } from '@vercel/og';
import { getAccountInfo } from '@/lib/solana';

export const runtime = 'edge';
export const alt = 'Program Details';
export const size = {
  width: 1200,
  height: 630,
};
export const contentType = 'image/png';

export default async function Image({ params }: { params: { address: string } }) {
  try {
    const program = await getAccountInfo(params.address);
    
    const title = 'Program Overview';
    const description = program?.executable 
      ? 'Solana Program Account'
      : 'Account not found or not a program';

    return new ImageResponse(
      (
        <div
          style={{
            height: '100%',
            width: '100%',
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            justifyContent: 'center',
            backgroundColor: '#000',
            backgroundImage: 'linear-gradient(45deg, #000 0%, #111 100%)',
          }}
        >
          {/* Logo */}
          <div
            style={{
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              marginBottom: '20px',
            }}
          >
            <div
              style={{
                width: '80px',
                height: '80px',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                borderRadius: '50%',
                background: 'linear-gradient(135deg, #00ffbd 0%, #00b386 100%)',
                marginRight: '16px',
              }}
            >
              <div
                style={{
                  color: 'white',
                  fontSize: '40px',
                  fontWeight: 700,
                }}
              >
                S
              </div>
            </div>
            <div
              style={{
                fontSize: '48px',
                fontWeight: 700,
                background: 'linear-gradient(135deg, #00ffbd 0%, #00b386 100%)',
                backgroundClip: 'text',
                color: 'transparent',
              }}
            >
              OPENSVM
            </div>
          </div>

          {/* Content */}
          <div
            style={{
              display: 'flex',
              flexDirection: 'column',
              alignItems: 'center',
              marginTop: '20px',
              padding: '0 48px',
            }}
          >
            <div
              style={{
                fontSize: '32px',
                fontWeight: 600,
                color: 'white',
                marginBottom: '10px',
                textAlign: 'center',
              }}
            >
              {title}
            </div>
            {program?.executable && (
              <div
                style={{
                  fontSize: '24px',
                  color: '#00ffbd',
                  marginBottom: '20px',
                  textAlign: 'center',
                }}
              >
                Executable Program
              </div>
            )}
            <div
              style={{
                fontSize: '20px',
                color: '#888',
                textAlign: 'center',
                maxWidth: '600px',
              }}
            >
              {description}
            </div>
            {program && (
              <div
                style={{
                  fontSize: '16px',
                  color: '#666',
                  marginTop: '20px',
                  textAlign: 'center',
                }}
              >
                {params.address.slice(0, 20)}...{params.address.slice(-20)}
              </div>
            )}
          </div>

          {/* Footer */}
          <div
            style={{
              position: 'absolute',
              bottom: '32px',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
            }}
          >
            <div
              style={{
                fontSize: '16px',
                color: '#666',
              }}
            >
              opensvm.com
            </div>
          </div>
        </div>
      ),
      {
        width: 1200,
        height: 630,
      },
    );
  } catch (e: any) {
    console.log(`${e.message}`);
    return new Response(`Failed to generate the image`, {
      status: 500,
    });
  }
} 


---
File: /app/program/[address]/page.tsx
---

'use client';

import { Suspense } from 'react';
import { useParams } from 'next/navigation';
import ProgramContentClient from './program-content-client';

function LoadingSpinner() {
  return (
    <div className="flex items-center justify-center py-12">
      <div className="space-y-4 text-center">
        <div className="w-16 h-16 border-4 border-blue-500 border-t-transparent rounded-full animate-spin mx-auto" />
        <div className="text-gray-400">Loading program data...</div>
      </div>
    </div>
  );
}

export default function Page() {
  const params = useParams();
  const address = params?.address as string;

  return (
    <div className="min-h-screen bg-black text-white">
      <div className="max-w-7xl mx-auto p-6">
        <Suspense fallback={<LoadingSpinner />}>
          <ProgramContentClient address={address} />
        </Suspense>
      </div>
    </div>
  );
}

export const dynamic = 'force-dynamic';



---
File: /app/program/[address]/program-content-client.tsx
---

'use client';

import { useState, useEffect } from 'react';
import { Connection, PublicKey, Commitment, AccountInfo } from '@solana/web3.js';
import DisassemblyView from './disassembly-view';
import HexView from './hex-view';

// Use reliable RPC endpoints with fallback
const RPC_ENDPOINTS = [
  'https://solana-mainnet.core.chainstack.com/263c9f53f4e4cdb897c0edc4a64cd007',
  'https://api.mainnet-beta.solana.com',
  'https://solana-api.projectserum.com',
];
let currentEndpointIndex = 0;
const COMMITMENT: Commitment = 'processed';

// BPF Upgradeable Loader program ID
const BPF_LOADER_UPGRADEABLE = new PublicKey('BPFLoaderUpgradeab1e11111111111111111111111');

interface ProgramInfo {
  address: string;
  owner: string;
  dataSize: number;
  isUpgradeable: boolean;
  programDataAddress?: string;
  data: number[];
}

async function sleep(ms: number) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

interface GetProgramDataOptions {
  retries?: number;
  signal?: AbortSignal;
}

async function getProgramData(
  address: string, 
  options: GetProgramDataOptions = { retries: 5 }
): Promise<ProgramInfo> {
  const { retries = 5, signal } = options;
  try {
    const endpoint = RPC_ENDPOINTS[currentEndpointIndex];
    console.log(`Trying endpoint ${currentEndpointIndex + 1}/${RPC_ENDPOINTS.length}: ${endpoint}`);
    
    const connection = new Connection(endpoint, {
      commitment: COMMITMENT,
      confirmTransactionInitialTimeout: 30000,
      // Don't disable WebSocket - needed for Next.js HMR
    });
    
    const programId = new PublicKey(address);
    const programInfo = await Promise.race([
      connection.getAccountInfo(programId),
      new Promise<AccountInfo<Buffer> | null>((_, reject) => {
        const timeout = setTimeout(() => reject(new Error('Timeout')), 10000);
        signal?.addEventListener('abort', () => {
          clearTimeout(timeout);
          reject(new Error('Request aborted'));
        });
      })
    ]);
    
    if (!programInfo) {
      throw new Error('Program not found');
    }

    // Check if this is an upgradeable program
    if (programInfo.owner.equals(BPF_LOADER_UPGRADEABLE)) {
      // The first 4 bytes are a version prefix, next 32 bytes are the programdata address
      const programDataAddress = new PublicKey(programInfo.data.slice(4, 36));
      
      // Get the programdata account which contains the actual program data
      const programDataInfo = await Promise.race([
        connection.getAccountInfo(programDataAddress),
        new Promise<AccountInfo<Buffer> | null>((_, reject) => 
          setTimeout(() => reject(new Error('Timeout')), 10000)
        )
      ]);
      
      if (!programDataInfo) {
        throw new Error('Program data account not found');
      }

      // The program data starts after the metadata (8 bytes slot, 32 bytes authority)
      const dataStart = 8 + 32;

      return {
        address,
        owner: programInfo.owner.toBase58(),
        dataSize: programDataInfo.data.length - dataStart,
        isUpgradeable: true,
        programDataAddress: programDataAddress.toBase58(),
        data: [...programDataInfo.data.slice(dataStart)]
      };
    } else {
      return {
        address,
        owner: programInfo.owner.toBase58(),
        dataSize: programInfo.data.length,
        isUpgradeable: false,
        data: [...programInfo.data]
      };
    }
  } catch (error) {
    console.error(`Error with endpoint ${currentEndpointIndex + 1}/${RPC_ENDPOINTS.length}:`, error);
    
    if (retries > 0 && !signal?.aborted) {
      // Try next endpoint
      currentEndpointIndex = (currentEndpointIndex + 1) % RPC_ENDPOINTS.length;
      
      // Exponential backoff with jitter
      const delay = Math.min(1000 * Math.pow(2, 5 - retries) + Math.random() * 1000, 10000);
      console.log(`Retrying with endpoint ${currentEndpointIndex + 1}/${RPC_ENDPOINTS.length} in ${delay}ms... (${retries} retries left)`);
      await sleep(delay);
      return getProgramData(address, { ...options, retries: retries - 1 });
    }
    throw error;
  }
}

function formatSize(bytes: number): string {
  if (bytes === 0) return '0 B';
  const k = 1024;
  const sizes = ['B', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(2))} ${sizes[i]}`;
}

function LoadingSpinner() {
  return (
    <div className="flex items-center justify-center py-12">
      <div className="space-y-4 text-center">
        <div className="w-16 h-16 border-4 border-blue-500 border-t-transparent rounded-full animate-spin mx-auto" />
        <div className="text-gray-400">Loading program data...</div>
        <div className="text-sm text-gray-500">Using endpoint {currentEndpointIndex + 1} of {RPC_ENDPOINTS.length}</div>
      </div>
    </div>
  );
}

interface Props {
  address: string;
}

export default function ProgramContentClient({ address }: Props) {
  const [programInfo, setProgramInfo] = useState<ProgramInfo | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [loading, setLoading] = useState(true);
  const [selectedByte, setSelectedByte] = useState<number | null>(null);
  const [selectionRange, setSelectionRange] = useState<[number, number] | null>(null);
      const [activeView, setActiveView] = useState<'disassembly'>('disassembly');
      const [showHexView, setShowHexView] = useState(false);

  useEffect(() => {
    let isMounted = true;
    let retryTimeout: NodeJS.Timeout | null = null;
    let abortController = new AbortController();

    const loadData = async () => {
      try {
        const info = await getProgramData(address, { signal: abortController.signal });
        if (isMounted) {
          setProgramInfo(info);
          setError(null);
          setLoading(false);
        }
      } catch (err) {
        if (isMounted) {
          console.error('Failed to load program:', err);
          setError(err instanceof Error ? err.message : 'Failed to load program data');
          setProgramInfo(null);
          setLoading(false);
          
          if (!abortController.signal.aborted) {
            // Auto-retry after 5 seconds
            retryTimeout = setTimeout(() => {
              if (isMounted) {
                console.log('Auto-retrying...');
                loadData();
              }
            }, 5000);
          }
        }
      }
    };

    loadData();

    return () => {
      isMounted = false;
      abortController.abort();
      if (retryTimeout) {
        clearTimeout(retryTimeout);
      }
    };
  }, [address]);

  if (loading) {
    return <LoadingSpinner />;
  }

  if (error) {
    return (
      <div className="bg-red-500/10 border border-red-500/20 p-4 rounded-lg">
        <div className="flex items-center space-x-2">
          <svg 
            className="w-5 h-5 text-red-400" 
            fill="none" 
            stroke="currentColor" 
            viewBox="0 0 24 24"
          >
            <path 
              strokeLinecap="round" 
              strokeLinejoin="round" 
              strokeWidth={2} 
              d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" 
            />
          </svg>
          <div className="font-medium text-red-400">Error loading program</div>
        </div>
        <div className="mt-2 text-sm text-red-400/90">{error}</div>
        <div className="mt-3 text-sm text-red-400/75">
          {error.includes('timeout') ? (
            'The request timed out. Please check your network connection.'
          ) : (
            'Retrying automatically...'
          )}
        </div>
      </div>
    );
  }

  if (!programInfo) {
    return null;
  }

  const handleSelectionChange = (start: number, end: number) => {
    setSelectionRange([start, end]);
  };

  const handleByteSelect = (offset: number | null) => {
    setSelectedByte(offset);
  };

  return (
    <div className="space-y-8 max-w-[1920px] mx-auto px-4 pb-8">
      {/* Program Info */}
      <div className="space-y-6">
        <div className="flex items-center space-x-4">
          <h1 className="text-2xl font-bold">Program Details</h1>
          <div className="px-3 py-1 rounded-full bg-blue-500/10 border border-blue-500/20 text-blue-400 text-sm">
            {programInfo.isUpgradeable ? 'Upgradeable' : 'Non-upgradeable'}
          </div>
        </div>

        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          <div className="space-y-4">
            <div className="space-y-2">
              <label className="text-sm text-gray-400">Program Address</label>
              <div className="p-3 bg-white/5 rounded-lg font-mono text-sm break-all">
                {programInfo.address}
              </div>
            </div>

            <div className="space-y-2">
              <label className="text-sm text-gray-400">Owner</label>
              <div className="p-3 bg-white/5 rounded-lg font-mono text-sm break-all">
                {programInfo.owner}
              </div>
            </div>
          </div>

          <div className="space-y-4">
            <div className="space-y-2">
              <label className="text-sm text-gray-400">Program Size</label>
              <div className="p-3 bg-white/5 rounded-lg font-mono text-sm">
                {formatSize(programInfo.dataSize)}
              </div>
            </div>

            {programInfo.programDataAddress && (
              <div className="space-y-2">
                <label className="text-sm text-gray-400">Program Data Address</label>
                <div className="p-3 bg-white/5 rounded-lg font-mono text-sm break-all">
                  {programInfo.programDataAddress}
                </div>
              </div>
            )}
          </div>
        </div>
      </div>

      {/* View Selection */}
      <div className="flex items-center justify-between border-b border-white/10 pb-4">
        <div className="flex items-center space-x-4">
          <div className="flex items-center space-x-2">
            <button
              onClick={() => setActiveView('disassembly')}
              className="px-4 py-2 rounded-lg font-medium bg-blue-500 text-white"
            >
              Disassembly
            </button>
          </div>
        </div>
      </div>

      {activeView === 'disassembly' && (
        <div className="bg-black border border-white/10 rounded-lg overflow-hidden h-[calc(100vh-24rem)]">
          <div className="p-4 border-b border-white/10">
            <div className="text-sm text-gray-400">
              Disassembly View
            </div>
          </div>
          <div className="h-[calc(100%-3rem)] overflow-auto">
            <DisassemblyView data={programInfo?.data || []} />
          </div>
        </div>
      )}
    </div>
  );
}



---
File: /app/program/[address]/program-visualizer.tsx
---

'use client';

import { useEffect, useRef, useState } from 'react';
import { decodeInstruction, type DecodedInstruction } from '@/lib/bpf';

interface ProgramVisualizerProps {
  data: number[];
  selectedInstruction?: number | null;
  onInstructionSelect?: (offset: number | null) => void;
  onSelectionChange?: (start: number, end: number) => void;
}

// Updated color scheme with better contrast and consistency
const InstructionColors = {
  ALU: '#60a5fa',     // Bright blue for arithmetic
  ALU64: '#3b82f6',   // Darker blue for 64-bit arithmetic
  JMP: '#f472b6',     // Pink for jumps
  JMP32: '#ec4899',   // Darker pink for 32-bit jumps
  LD: '#4ade80',      // Green for loads
  LDX: '#22c55e',     // Darker green for load from register
  ST: '#facc15',      // Yellow for stores
  STX: '#eab308',     // Darker yellow for store to register
  UNKNOWN: '#ef4444'  // Red for unknown instructions
} as const;

const ProgramVisualizer: React.FC<ProgramVisualizerProps> = ({
  data,
  selectedInstruction,
  onInstructionSelect,
  onSelectionChange
}) => {
  const [decodedInstructions, setDecodedInstructions] = useState<DecodedInstruction[]>([]);
  const [selectedIndex, setSelectedIndex] = useState<number | null>(null);
  const containerRef = useRef<HTMLDivElement>(null);

  // Decode instructions on data change
  useEffect(() => {
    const instructions: DecodedInstruction[] = [];
    for (let i = 0; i < data.length; i += 8) {
      const bytes = data.slice(i, i + 8);
      if (bytes.length === 8) {
        const instruction = bytes.reduce((acc, byte, idx) => {
          return acc + (BigInt(byte) << BigInt(idx * 8));
        }, BigInt(0));
        instructions.push(decodeInstruction(instruction));
      }
    }
    setDecodedInstructions(instructions);
  }, [data]);

  const getInstructionColor = (instruction: DecodedInstruction): string => {
    const mnemonic = instruction.mnemonic.toLowerCase();
    if (mnemonic.includes('add') || mnemonic.includes('sub') || 
        mnemonic.includes('mul') || mnemonic.includes('div') ||
        mnemonic.includes('mod') || mnemonic.includes('neg')) {
      return instruction.mnemonic.includes('32') ? InstructionColors.ALU : InstructionColors.ALU64;
    }
    if (mnemonic.includes('j') || mnemonic === 'call' || mnemonic === 'exit') {
      return instruction.mnemonic.includes('32') ? InstructionColors.JMP32 : InstructionColors.JMP;
    }
    if (mnemonic.startsWith('ld')) return mnemonic.includes('x') ? InstructionColors.LDX : InstructionColors.LD;
    if (mnemonic.startsWith('st')) return mnemonic.includes('x') ? InstructionColors.STX : InstructionColors.ST;
    if (mnemonic === 'unknown') return InstructionColors.UNKNOWN;
    return InstructionColors.ALU64;
  };

  const handleInstructionClick = (index: number) => {
    setSelectedIndex(index);
    onInstructionSelect?.(index);
  };

  return (
    <div ref={containerRef} className="flex flex-col h-full overflow-hidden bg-gray-900">
      <div className="flex-none px-4 py-3 border-b border-gray-800 bg-gray-900/90 backdrop-blur supports-[backdrop-filter]:bg-gray-900/80">
        <div className="flex items-center justify-between">
          <h2 className="text-lg font-medium text-gray-100">eBPF Program Instructions</h2>
          <div className="text-sm text-gray-400">
            {decodedInstructions.length} instructions
          </div>
        </div>
      </div>
      
      <div className="flex-1 overflow-auto">
        <div className="p-3 space-y-1.5">
          {decodedInstructions.map((instruction, index) => (
            <div
              key={index}
              className={`group relative rounded-md transition-all duration-150 ${
                selectedIndex === index 
                  ? 'bg-gray-800/80 ring-1 ring-gray-700' 
                  : 'hover:bg-gray-800/50'
              }`}
              onClick={() => handleInstructionClick(index)}
            >
              <div className="px-3 py-2">
                <div className="flex items-start gap-3">
                  <div className="flex-none pt-1.5">
                    <div 
                      className="w-2 h-2 rounded-full ring-1 ring-white/10"
                      style={{ backgroundColor: getInstructionColor(instruction) }}
                    />
                  </div>
                  <div className="flex-1 min-w-0">
                    <div className="flex items-baseline gap-3 flex-wrap">
                      <span className="flex-none text-gray-500 text-sm font-mono">
                        {index.toString().padStart(4, '0')}
                      </span>
                      <div className="flex-1 flex items-baseline gap-2 min-w-0">
                        <span className="text-gray-100 font-mono font-medium">
                          {instruction.mnemonic}
                        </span>
                        <span className="text-gray-400 font-mono truncate">
                          {instruction.operands.join(', ')}
                        </span>
                      </div>
                    </div>
                    {instruction.comment && (
                      <div className="mt-1 text-gray-500 text-sm">
                        {instruction.comment}
                      </div>
                    )}
                    {instruction.regInfo && instruction.regInfo.length > 0 && (
                      <div className="mt-1 text-gray-600 text-xs">
                        {instruction.regInfo.join(' | ')}
                      </div>
                    )}
                  </div>
                </div>
              </div>
            </div>
          ))}
        </div>
      </div>

      <div className="flex-none border-t border-gray-800 bg-gray-900/90 backdrop-blur supports-[backdrop-filter]:bg-gray-900/80">
        <div className="px-3 py-2 overflow-x-auto">
          <div className="flex flex-wrap gap-2">
            {Object.entries(InstructionColors).map(([type, color]) => (
              <div 
                key={type} 
                className="flex items-center gap-2 px-2 py-1 rounded bg-gray-800/50"
              >
                <div 
                  className="w-2.5 h-2.5 rounded-full ring-1 ring-white/10"
                  style={{ backgroundColor: color }}
                />
                <span className="text-gray-400 text-xs font-medium">{type}</span>
              </div>
            ))}
          </div>
        </div>
      </div>
    </div>
  );
};

export default ProgramVisualizer;



---
File: /app/programs/page.tsx
---

export default function ProgramsPage() {
  return (
    <div className="container mx-auto py-8">
      <div className="mb-8">
        <h1 className="text-4xl font-bold mb-2">Programs</h1>
        <p className="text-muted-foreground">
          Explore Solana programs and their activity across the network.
        </p>
      </div>
      <div className="rounded-md border p-8 text-center">
        <p className="text-muted-foreground">Program explorer coming soon...</p>
      </div>
    </div>
  );
}



---
File: /app/providers/SolanaProvider.tsx
---

'use client';

import { ConnectionProvider } from '@solana/wallet-adapter-react';
import { useSettings } from '@/lib/settings';
import { useEffect, useState } from 'react';
import { Connection } from '@solana/web3.js';
import { connectionPool, updateRpcEndpoint } from '@/lib/solana-connection';

export function SolanaProvider({ children }: { children: React.ReactNode }) {
  const { rpcEndpoint } = useSettings();
  const [endpoint, setEndpoint] = useState<string>('');
  
  useEffect(() => {
    // Update the connection pool when endpoint changes
    updateRpcEndpoint(rpcEndpoint.url);
    
    // Get connection from pool and extract endpoint
    const init = async () => {
      const conn = await connectionPool.getConnection();
      setEndpoint(conn.rpcEndpoint);
    };
    
    init();
  }, [rpcEndpoint.url]);

  if (!endpoint) {
    return null; // Or loading state
  }

  return (
    <ConnectionProvider endpoint={endpoint} config={{ commitment: 'confirmed' }}>
      {children}
    </ConnectionProvider>
  );
}



---
File: /app/search/page.tsx
---

'use client';

import React, { Suspense, useEffect, useState } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import { Card, CardHeader, CardContent } from '@/components/ui/card';
import { Skeleton } from '@/components/ui/skeleton';
import AutocompleteSearchBar from '@/components/AutocompleteSearchBar';
import { Select } from '@/components/ui/select';
import { sanitizeSearchQuery, formatNumber, isValidSolanaAddress, isValidTransactionSignature } from '@/lib/utils';

interface SearchResult {
  address: string;
  balance?: number;
  type?: string;
  timestamp?: string;
  status?: 'success' | 'failed';
  amount?: number;
}

interface SearchState {
  currentPage: number;
  itemsPerPage: number;
  sortField: string;
  sortDirection: 'asc' | 'desc';
}

function SearchResults() {
  const [searchState, setSearchState] = useState<SearchState>({
    currentPage: 1,
    itemsPerPage: 25,
    sortField: 'timestamp',
    sortDirection: 'desc'
  });
  const [expandedRow, setExpandedRow] = useState<string | null>(null);
  const searchParams = useSearchParams();
  const query = searchParams?.get('q') || '';
  const router = useRouter();
  const [searchResults, setSearchResults] = useState<any>(null);
  const [error, setError] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);

  // Handle redirects on mount
  useEffect(() => {
    async function handleRedirect() {
      if (!query) return;

      setIsLoading(true);
      try {
        // Check if query is a block number
        if (/^\d+$/.test(query)) {
          router.push(`/block/${query}`);
          return;
        }
        
        // Check if query is a transaction signature (88 chars)
        if (isValidTransactionSignature(query)) {
          router.push(`/tx/${query}`);
          return;
        }
        
        // Check if query is a valid Solana address
        if (isValidSolanaAddress(query)) {
          try {
            // Check account type using API
            const response = await fetch(`/api/check-account-type?address=${encodeURIComponent(query)}`);
            const data = await response.json();
            
            switch (data.type) {
              case 'token':
                console.log('Redirecting to token page:', query);
                router.push(`/token/${query}`);
                return;
              case 'program':
                console.log('Redirecting to program page:', query);
                router.push(`/program/${query}`);
                return;
              case 'account':
              default:
                console.log('Redirecting to account page:', query);
                router.push(`/account/${query}`);
                return;
            }
          } catch (error) {
            console.error('Error checking account type:', error);
            // On error, default to account page
            router.push(`/account/${query}`);
            return;
          }
        }
      } finally {
        setIsLoading(false);
      }
    }

    handleRedirect();
  }, [query, router]);
  
  // Handle general search
  useEffect(() => {
    async function performSearch() {
      if (!query) {
        setSearchResults(null);
        return;
      }

      const sanitizedQuery = sanitizeSearchQuery(query);
      if (!sanitizedQuery) {
        setSearchResults(null);
        return;
      }

      try {
        setIsLoading(true);
        
        // Build URL with filters
        let searchUrl = `/api/search/filtered?q=${encodeURIComponent(sanitizedQuery)}`;
        const searchParams = new URLSearchParams(window.location.search);
        
        // Add filters from URL if present
        if (searchParams.get('start')) searchUrl += `&start=${searchParams.get('start')}`;
        if (searchParams.get('end')) searchUrl += `&end=${searchParams.get('end')}`;
        if (searchParams.get('type')) searchUrl += `&type=${searchParams.get('type')}`;
        if (searchParams.get('status')) searchUrl += `&status=${searchParams.get('status')}`;
        if (searchParams.get('min')) searchUrl += `&min=${searchParams.get('min')}`;
        if (searchParams.get('max')) searchUrl += `&max=${searchParams.get('max')}`;
        
        const response = await fetch(searchUrl);
        if (!response.ok) throw new Error('Failed to fetch results');
        const results = await response.json();
        
        if (results.error) {
          setError(results.error);
          setSearchResults([]);
        } else {
          setSearchResults(results);
          setError(null);
        }
      } catch (e) {
        setError('Failed to perform search');
        console.error(e);
        setSearchResults([]);
      } finally {
        setIsLoading(false);
      }
    }

    performSearch();
  }, [query]);

  if (!query) {
    return (
      <div className="container mx-auto px-4 py-8">
        <h1 className="text-2xl font-bold mb-6">Please enter a search query</h1>
      </div>
    );
  }

  if (isLoading) {
    return (
      <div className="container mx-auto px-4 py-8">
        <h1 className="text-2xl font-bold mb-6">Loading...</h1>
        <Card>
          <CardHeader>
            <h2 className="text-lg font-semibold">Loading Results</h2>
          </CardHeader>
          <CardContent>
            <Skeleton className="h-24 w-full" />
          </CardContent>
        </Card>
      </div>
    );
  }

  const handleSort = (field: string) => {
    setSearchState(prev => ({
      ...prev,
      sortField: field,
      sortDirection: prev.sortField === field && prev.sortDirection === 'asc' ? 'desc' : 'asc'
    }));
  };

  const handlePageChange = (page: number) => {
    setSearchState(prev => ({
      ...prev,
      currentPage: page
    }));
  };

  const handleItemsPerPageChange = (items: number) => {
    setSearchState(prev => ({
      ...prev,
      itemsPerPage: items,
      currentPage: 1
    }));
  };

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="mb-8">
        <AutocompleteSearchBar />
      </div>
      
      <h1 className="text-2xl font-bold mb-6">Search Results for "{query}"</h1>
      
      {/* Results Controls */}
      <div className="flex justify-between items-center mb-4">
        <div className="flex items-center gap-4">
          <Select
            value={searchState.itemsPerPage.toString()}
            onChange={(e) => handleItemsPerPageChange(parseInt(e.target.value))}
          >
            <option value="25">25 per page</option>
            <option value="50">50 per page</option>
            <option value="100">100 per page</option>
          </Select>
        </div>
        <div className="flex items-center gap-2">
          <span className="text-sm text-gray-500">
            Page {searchState.currentPage} of {Math.ceil((searchResults?.length || 0) / searchState.itemsPerPage)}
          </span>
          <button
            onClick={() => handlePageChange(searchState.currentPage - 1)}
            disabled={searchState.currentPage === 1}
            className="px-3 py-1 rounded border disabled:opacity-50"
          >
            Previous
          </button>
          <button
            onClick={() => handlePageChange(searchState.currentPage + 1)}
            disabled={searchState.currentPage >= Math.ceil((searchResults?.length || 0) / searchState.itemsPerPage)}
            className="px-3 py-1 rounded border disabled:opacity-50"
          >
            Next
          </button>
        </div>
      </div>
      
      {error ? (
        <div className="bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg p-4 mb-6">
          <p className="text-red-600 dark:text-red-400">{error}</p>
        </div>
      ) : (
        <div className="grid grid-cols-1 gap-6">
          <Card>
            <CardHeader>
              <div className="flex justify-between items-center">
                <h2 className="text-lg font-semibold">Results</h2>
                <div className="flex gap-4">
                  <button
                    onClick={() => handleSort('timestamp')}
                    className="text-sm text-gray-500 hover:text-gray-900"
                  >
                    Date {searchState.sortField === 'timestamp' && (searchState.sortDirection === 'asc' ? '↑' : '↓')}
                  </button>
                  <button
                    onClick={() => handleSort('amount')}
                    className="text-sm text-gray-500 hover:text-gray-900"
                  >
                    Amount {searchState.sortField === 'amount' && (searchState.sortDirection === 'asc' ? '↑' : '↓')}
                  </button>
                  <button
                    onClick={() => handleSort('type')}
                    className="text-sm text-gray-500 hover:text-gray-900"
                  >
                    Type {searchState.sortField === 'type' && (searchState.sortDirection === 'asc' ? '↑' : '↓')}
                  </button>
                </div>
              </div>
            </CardHeader>
            <CardContent>
              {searchResults?.error ? (
                <p className="text-red-500">{searchResults.error}</p>
              ) : searchResults?.length ? (
                <div className="space-y-4">
                  {searchResults
                    .sort((a: SearchResult, b: SearchResult) => {
                      const aValue = a[searchState.sortField as keyof SearchResult];
                      const bValue = b[searchState.sortField as keyof SearchResult];
                      if (!aValue || !bValue) return 0;
                      return searchState.sortDirection === 'asc' 
                        ? aValue > bValue ? 1 : -1
                        : aValue < bValue ? 1 : -1;
                    })
                    .slice(
                      (searchState.currentPage - 1) * searchState.itemsPerPage,
                      searchState.currentPage * searchState.itemsPerPage
                    )
                    .map((result: SearchResult) => (
                      <div 
                        key={result.address}
                        className="border rounded-lg overflow-hidden"
                      >
                        <div 
                          className="p-4 cursor-pointer hover:bg-gray-50"
                          onClick={() => setExpandedRow(expandedRow === result.address ? null : result.address)}
                        >
                          <div className="flex justify-between items-center">
                            <div className="flex-1">
                              <p className="font-mono text-sm">{result.address}</p>
                              {result.balance && (
                                <p className="text-sm text-gray-500">Balance: {formatNumber(result.balance)} SOL</p>
                              )}
                            </div>
                            <div className="flex items-center gap-4">
                              {result.type && (
                                <span className="px-2 py-1 text-xs rounded bg-gray-100">{result.type}</span>
                              )}
                              {result.status && (
                                <span className={`px-2 py-1 text-xs rounded ${
                                  result.status === 'success' ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'
                                }`}>
                                  {result.status}
                                </span>
                              )}
                              {result.amount && (
                                <span className="text-sm font-medium">{formatNumber(result.amount)} SOL</span>
                              )}
                            </div>
                          </div>
                        </div>
                        
                        {/* Expanded Details */}
                        {expandedRow === result.address && (
                          <div className="p-4 bg-gray-50 border-t">
                            <div className="grid grid-cols-2 gap-4">
                              <div>
                                <h4 className="text-sm font-medium text-gray-500">Timestamp</h4>
                                <p className="text-sm">{result.timestamp || 'N/A'}</p>
                              </div>
                              <div>
                                <h4 className="text-sm font-medium text-gray-500">Type</h4>
                                <p className="text-sm">{result.type || 'N/A'}</p>
                              </div>
                              <div>
                                <h4 className="text-sm font-medium text-gray-500">Status</h4>
                                <p className="text-sm">{result.status || 'N/A'}</p>
                              </div>
                              <div>
                                <h4 className="text-sm font-medium text-gray-500">Amount</h4>
                                <p className="text-sm">{result.amount ? `${formatNumber(result.amount)} SOL` : 'N/A'}</p>
                              </div>
                            </div>
                          </div>
                        )}
                      </div>
                    ))}
                </div>
              ) : (
                <p className="text-gray-500">No results found</p>
              )}
            </CardContent>
          </Card>
        </div>
      )}
    </div>
  );
}

export default function SearchPage() {
  return (
    <Suspense
      fallback={
        <div className="container mx-auto px-4 py-8">
          <h1 className="text-2xl font-bold mb-6">Loading...</h1>
          <Card>
            <CardHeader>
              <h2 className="text-lg font-semibold">Loading Results</h2>
            </CardHeader>
            <CardContent>
              <Skeleton className="h-24 w-full" />
            </CardContent>
          </Card>
        </div>
      }
    >
      <SearchResults />
    </Suspense>
  );
}



---
File: /app/slots/page.tsx
---

export default function SlotsPage() {
  return (
    <div className="container mx-auto py-8">
      <div className="mb-8">
        <h1 className="text-4xl font-bold mb-2">Slots</h1>
        <p className="text-muted-foreground">
          Browse slot details and validator information on the Solana network.
        </p>
      </div>
      <div className="rounded-md border p-8 text-center">
        <p className="text-muted-foreground">Slot explorer coming soon...</p>
      </div>
    </div>
  );
}



---
File: /app/solana/page.tsx
---

// @ts-nocheck

"use client";

import { useEffect, useState } from "react";
import { Connection, SystemProgram } from "@solana/web3.js";

const HELIUS_RPC = "https://mainnet.helius-rpc.com/?api-key=2eb1ae21-40d0-4b6d-adde-ccb3d56ad570";

export default function SolanaExplorer() {
  const [supplyStats, setSupplyStats] = useState<{
    circulating: number;
    nonCirculating: number;
  } | null>(null);
  const [networkStats, setNetworkStats] = useState<{
    tps: number;
    blockHeight: number;
  } | null>(null);
  const [transactions, setTransactions] = useState<Array<{
    signature: string;
    timestamp: string;
    block: number;
    type: string;
  }>>([]);
  const [error, setError] = useState<string | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const connection = new Connection(HELIUS_RPC);

    const fetchData = async () => {
      try {
        // Fetch supply stats
        const supply = await connection.getSupply();
        setSupplyStats({
          circulating: supply.value.circulating / 1e9,
          nonCirculating: supply.value.nonCirculating / 1e9,
        });

        // Fetch network stats
        const [slot, performance] = await Promise.all([
          connection.getSlot(),
          connection.getRecentPerformanceSamples(1),
        ]);
        
        setNetworkStats({
          tps: Math.round(performance[0]?.numTransactions / performance[0]?.samplePeriodSecs || 0),
          blockHeight: slot,
        });

        // Fetch recent transactions
        const signatures = await connection.getSignaturesForAddress(
          SystemProgram.programId,
          { limit: 5 }
        );

        const txData = signatures.map(sig => ({
          signature: sig.signature,
          timestamp: new Date(sig.blockTime! * 1000).toLocaleString(),
          block: sig.slot,
          type: sig.memo || "Transaction",
        }));

        setTransactions(txData);
        setLoading(false);
        setError(null);
      } catch (err) {
        console.error("Error fetching data:", err);
        setError("Failed to fetch blockchain data.");
        setLoading(false);
      }
    };

    fetchData();
  }, []); // Only fetch once on mount

  if (error) {
    return (
      <div className="p-4 bg-white rounded-lg shadow">
        <p className="text-red-500">{error}</p>
      </div>
    );
  }

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 gap-2 p-2">
      <div className="p-3 bg-white rounded-md shadow">
        <h2 className="text-lg font-semibold mb-2">SOL Supply Stats</h2>
        {loading ? (
          <p>Loading...</p>
        ) : (
          <div className="space-y-1">
            <p>Circulating Supply: {supplyStats?.circulating.toFixed(2)} SOL</p>
            <p>Non-circulating Supply: {supplyStats?.nonCirculating.toFixed(2)} SOL</p>
          </div>
        )}
      </div>

      <div className="p-3 bg-white rounded-md shadow">
        <h2 className="text-lg font-semibold mb-2">Network Stats</h2>
        {loading ? (
          <p>Loading...</p>
        ) : (
          <div className="space-y-1">
            <p>Current TPS: {networkStats?.tps}</p>
            <p>Block Height: {networkStats?.blockHeight}</p>
          </div>
        )}
      </div>

      <div className="p-3 bg-white rounded-md shadow col-span-full mt-2">
        <h2 className="text-lg font-semibold mb-2">Latest Transactions</h2>
        {loading ? (
          <p>Loading...</p>
        ) : (
          <div className="overflow-x-auto">
            <table className="min-w-full border-collapse">
              <thead>
                <tr>
                  <th className="px-3 py-1 border text-left">Signature</th>
                  <th className="px-3 py-1 border text-left">Timestamp</th>
                  <th className="px-3 py-1 border text-left">Block</th>
                  <th className="px-3 py-1 border text-left">Type</th>
                </tr>
              </thead>
              <tbody>
                {transactions.map((tx, index) => (
                  <tr key={index} className="hover:bg-gray-50">
                    <td className="px-3 py-1 border">{tx.signature}</td>
                    <td className="px-3 py-1 border">{tx.timestamp}</td>
                    <td className="px-3 py-1 border">{tx.block}</td>
                    <td className="px-3 py-1 border">{tx.type}</td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        )}
      </div>
    </div>
  );
}



---
File: /app/styles/vtable.css
---

/* VTable container */
.vtable-container {
  position: relative;
  width: 100%;
  height: 600px;
  overflow: hidden;
  background: var(--background);
}

.vtable {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  width: 100%;
  height: 100%;
  background: transparent;
}

/* Canvas container */
.vtable canvas {
  position: absolute !important;
  top: 0 !important;
  left: 0 !important;
  width: 100% !important;
  height: 100% !important;
  background: transparent !important;
}

/* Cell content */
.vtable-cell {
  display: flex;
  align-items: center;
  height: 100%;
  padding: 8px 12px;
  font-family: var(--font-family);
  font-size: var(--base-font-size);
  line-height: 1.5;
  color: var(--foreground);
}

/* Links */
.vtable-cell a {
  color: hsl(var(--primary));
  text-decoration: none;
}

.vtable-cell a:hover {
  text-decoration: underline;
}

/* Headers */
.vtable-header {
  font-weight: 600;
  background-color: var(--secondary);
  border-bottom: 1px solid var(--border);
}

/* Rows */
.vtable-row {
  border-bottom: 1px solid var(--border);
}

.vtable-row:hover {
  background-color: var(--muted);
}

/* Cells */
.vtable-cell {
  padding: 8px 12px;
  border-right: 1px solid var(--border);
}

.vtable-cell:last-child {
  border-right: none;
}

/* Loading state */
.vtable-loading {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(var(--background), 0.8);
}

.vtable-loading-spinner {
  width: 32px;
  height: 32px;
  border: 3px solid var(--border);
  border-top-color: var(--primary);
  border-radius: 50%;
  animation: vtable-spin 1s linear infinite;
}

@keyframes vtable-spin {
  to {
    transform: rotate(360deg);
  }
}

/* Error state */
.vtable-error {
  padding: 16px;
  color: var(--destructive);
  text-align: center;
}

/* Empty state */
.vtable-empty {
  padding: 16px;
  color: var(--muted-foreground);
  text-align: center;
}

/* Theme-specific styles */
.theme-cyberpunk .vtable,
.theme-high-contrast .vtable,
.theme-dos .vtable,
.theme-paper .vtable,
.theme-solarized .vtable {
  --vtable-foreground: var(--foreground);
  --vtable-background: var(--background);
  --vtable-border: var(--border);
  --vtable-header: var(--secondary);
  --vtable-hover: var(--muted);
}

/* Table styles */
.vtable [class*="vtable-cell"] {
  color: var(--vtable-foreground) !important;
  background-color: var(--vtable-background) !important;
  border-color: var(--vtable-border) !important;
}

.vtable [class*="vtable-header-cell"] {
  color: var(--vtable-foreground) !important;
  background-color: var(--vtable-header) !important;
  border-color: var(--vtable-border) !important;
}

.vtable [class*="vtable-cell"]:hover {
  background-color: var(--vtable-hover) !important;
}

/* Force theme colors */
.vtable [style*="background"],
.vtable [style*="background-color"] {
  background-color: var(--vtable-background) !important;
}

.vtable [style*="color"]:not(a) {
  color: var(--vtable-foreground) !important;
}

.vtable [style*="border-color"] {
  border-color: var(--vtable-border) !important;
}

/* Header override */
.vtable [class*="vtable-header"] [style*="background"],
.vtable [class*="vtable-header"] [style*="background-color"] {
  background-color: var(--vtable-header) !important;
}

/* Hover override */
.vtable [class*="vtable-cell"]:hover [style*="background"],
.vtable [class*="vtable-cell"]:hover [style*="background-color"] {
  background-color: var(--vtable-hover) !important;
}



---
File: /app/test/transfers/page.tsx
---

'use client';

import { TransfersTable } from '@/components/TransfersTable';
import { useSearchParams } from 'next/navigation';

const DEFAULT_ADDRESS = 'DfiQz1pkh3FhKz4ZqHyBQHrKR5HRMhMFYgUZS8h6yRet';

export default function TransfersTestPage() {
  const searchParams = useSearchParams();
  const address = searchParams.get('address') || DEFAULT_ADDRESS;

  if (!address) {
    return <div>No address provided</div>;
  }

  return (
    <div className="min-h-screen bg-black p-4">
      <div className="container mx-auto">
        <h1 className="text-2xl font-bold text-white mb-4">
          Transfers Table Test Page
        </h1>
        <div className="bg-neutral-900 rounded-lg p-4">
          <TransfersTable address={address} />
        </div>
      </div>
    </div>
  );
}


---
File: /app/test/layout.tsx
---

export default function TestLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <div className="min-h-screen bg-black text-white">
      <div className="max-w-7xl mx-auto">
        {children}
      </div>
    </div>
  );
}



---
File: /app/test/page.tsx
---

"use client";

import { VTableWrapper } from '@/components/vtable';
import { useState } from 'react';

const testData = [
  { id: 1, name: 'John Doe', age: 30, city: 'New York' },
  { id: 2, name: 'Jane Smith', age: 25, city: 'Los Angeles' },
  { id: 3, name: 'Bob Johnson', age: 35, city: 'Chicago' },
  { id: 4, name: 'Alice Brown', age: 28, city: 'Houston' },
  { id: 5, name: 'Charlie Wilson', age: 32, city: 'Phoenix' },
];

const columns = [
  { field: 'id', title: 'ID', width: 80, sortable: true },
  { field: 'name', title: 'Name', width: 200, sortable: true },
  { field: 'age', title: 'Age', width: 100, sortable: true },
  { field: 'city', title: 'City', width: 150, sortable: true },
];

export default function TestPage() {
  const [data, setData] = useState(testData);

  const handleSort = (field: string, order: 'asc' | 'desc' | null) => {
    if (!order) {
      setData(testData);
      return;
    }

    const sortedData = [...data].sort((a, b) => {
      const aValue = a[field as keyof typeof a];
      const bValue = b[field as keyof typeof b];
      
      if (aValue === bValue) return 0;
      
      const modifier = order === 'asc' ? 1 : -1;
      return aValue > bValue ? modifier : -modifier;
    });

    setData(sortedData);
  };

  const handleSelectionChange = (selection: any) => {
    console.log('Selection:', selection);
  };

  return (
    <div className="container mx-auto p-4">
      <h1 className="text-2xl font-bold mb-4">VTable Test</h1>
      <div className="border border-neutral-800 rounded-lg overflow-hidden">
        <VTableWrapper
          columns={columns}
          data={data}
          onSort={handleSort}
          onSelectionChange={handleSelectionChange}
        />
      </div>
    </div>
  );
}



---
File: /app/test/test-page-client.tsx
---

'use client';

import { useEffect, useRef } from 'react';
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

export default function TestPageClient() {
  const containerRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
// sourcery skip: use-braces
    if (!containerRef.current) return;

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    // Camera setup
    const camera = new THREE.PerspectiveCamera(
      75,
      containerRef.current.clientWidth / containerRef.current.clientHeight,
      0.1,
      1000
    );
    camera.position.z = 5;

    // Renderer setup
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(containerRef.current.clientWidth, containerRef.current.clientHeight);
    containerRef.current.appendChild(renderer.domElement);

    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // Create a simple cube
    const geometry = new THREE.BoxGeometry();
    const material = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
    const cube = new THREE.Mesh(geometry, material);
    scene.add(cube);

    // Add lights
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(1, 1, 1);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0x404040));

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      cube.rotation.x += 0.01;
      cube.rotation.y += 0.01;
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // Handle resize
    function handleResize() {
      if (!containerRef.current) return;
      const width = containerRef.current.clientWidth;
      const height = containerRef.current.clientHeight;
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
    }
    window.addEventListener('resize', handleResize);

    // Cleanup
    return () => {
      window.removeEventListener('resize', handleResize);
      if (containerRef.current) {
        // eslint-disable-next-line react-hooks/exhaustive-deps
        containerRef.current.removeChild(renderer.domElement);
      }
      geometry.dispose();
      material.dispose();
    };
  }, []);

  return (
    <div className="p-4">
      <div ref={containerRef} className="h-[600px] bg-black border border-white/10 rounded-lg overflow-hidden" />
    </div>
  );
}



---
File: /app/token/[mint]/opengraph-image.tsx
---

import { ImageResponse } from '@vercel/og';
import { getTokenInfo } from '@/lib/solana';
import { formatNumber } from '@/lib/utils';

export const runtime = 'edge';
export const alt = 'Token Details';
export const size = {
  width: 1200,
  height: 630,
};
export const contentType = 'image/png';

export default async function Image({ params }: { params: { mint: string } }) {
  try {
    const token = await getTokenInfo(params.mint);
    
    const title = token?.name || 'Token Overview';
    const description = `Supply: ${formatNumber(token?.totalSupply || 0)} • Decimals: ${token?.decimals || 0}`;

    return new ImageResponse(
      (
        <div
          style={{
            height: '100%',
            width: '100%',
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            justifyContent: 'center',
            backgroundColor: '#000',
            backgroundImage: 'linear-gradient(45deg, #000 0%, #111 100%)',
          }}
        >
          {/* Logo */}
          <div
            style={{
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              marginBottom: '20px',
            }}
          >
            <div
              style={{
                width: '80px',
                height: '80px',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                borderRadius: '50%',
                background: 'linear-gradient(135deg, #00ffbd 0%, #00b386 100%)',
                marginRight: '16px',
              }}
            >
              <div
                style={{
                  color: 'white',
                  fontSize: '40px',
                  fontWeight: 700,
                }}
              >
                S
              </div>
            </div>
            <div
              style={{
                fontSize: '48px',
                fontWeight: 700,
                background: 'linear-gradient(135deg, #00ffbd 0%, #00b386 100%)',
                backgroundClip: 'text',
                color: 'transparent',
              }}
            >
              OPENSVM
            </div>
          </div>

          {/* Content */}
          <div
            style={{
              display: 'flex',
              flexDirection: 'column',
              alignItems: 'center',
              marginTop: '20px',
              padding: '0 48px',
            }}
          >
            <div
              style={{
                fontSize: '32px',
                fontWeight: 600,
                color: 'white',
                marginBottom: '10px',
                textAlign: 'center',
              }}
            >
              {title}
            </div>
            {token && (
              <div
                style={{
                  fontSize: '24px',
                  color: '#00ffbd',
                  marginBottom: '20px',
                  textAlign: 'center',
                }}
              >
                {description}
              </div>
            )}
            <div
              style={{
                fontSize: '20px',
                color: '#888',
                textAlign: 'center',
                maxWidth: '600px',
              }}
            >
              {token?.symbol || 'Unknown Token'}
            </div>
            {token && (
              <div
                style={{
                  fontSize: '16px',
                  color: '#666',
                  marginTop: '20px',
                  textAlign: 'center',
                }}
              >
                {params.mint.slice(0, 20)}...{params.mint.slice(-20)}
              </div>
            )}
          </div>

          {/* Footer */}
          <div
            style={{
              position: 'absolute',
              bottom: '32px',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
            }}
          >
            <div
              style={{
                fontSize: '16px',
                color: '#666',
              }}
            >
              opensvm.com
            </div>
          </div>
        </div>
      ),
      {
        width: 1200,
        height: 630,
      },
    );
  } catch (e: any) {
    console.log(`${e.message}`);
    return new Response(`Failed to generate the image`, {
      status: 500,
    });
  }
}


---
File: /app/token/[mint]/page.tsx
---

import { Metadata } from 'next';
import TokenDetails from '@/components/TokenDetails';

interface PageProps {
  params: Promise<{ mint: string }>;
}

export async function generateMetadata({
  params,
}: PageProps): Promise<Metadata> {
  const resolvedParams = await params;
  return {
    title: `Token ${resolvedParams.mint} | OPENSVM`,
    description: `View details of Solana token ${resolvedParams.mint} on OPENSVM`,
  };
}

export default async function TokenPage({
  params,
}: PageProps) {
  const resolvedParams = await params;
  return <TokenDetails mint={resolvedParams.mint} />;
} 


---
File: /app/tokens/gainers/page.tsx
---

export default function TokenGainersPage() {
  return (
    <div className="container mx-auto py-8">
      <div className="mb-8">
        <h1 className="text-4xl font-bold mb-2">Top Gainers</h1>
        <p className="text-muted-foreground">
          Tokens with the highest price increases in the last 24 hours.
        </p>
      </div>
      <div className="rounded-md border p-8 text-center">
        <p className="text-muted-foreground">Token gainers data coming soon...</p>
      </div>
    </div>
  );
}



---
File: /app/tokens/new/page.tsx
---

export default function NewTokensPage() {
  return (
    <div className="container mx-auto py-8">
      <div className="mb-8">
        <h1 className="text-4xl font-bold mb-2">New Listings</h1>
        <p className="text-muted-foreground">
          Recently listed tokens on the Solana network.
        </p>
      </div>
      <div className="rounded-md border p-8 text-center">
        <p className="text-muted-foreground">New token listings coming soon...</p>
      </div>
    </div>
  );
}



---
File: /app/tokens/page.tsx
---

export default function TokensPage() {
  return (
    <div className="container mx-auto py-8">
      <div className="mb-8">
        <h1 className="text-4xl font-bold mb-2">All Tokens</h1>
        <p className="text-muted-foreground">
          Browse all tokens and their metrics on the Solana network.
        </p>
      </div>
      <div className="rounded-md border p-8 text-center">
        <p className="text-muted-foreground">Token explorer coming soon...</p>
      </div>
    </div>
  );
}



---
File: /app/tx/[signature]/opengraph-image.tsx
---

import { ImageResponse } from '@vercel/og';
import { getTransactionDetails } from '@/lib/solana';

export const runtime = 'edge';
export const alt = 'Transaction Details';
export const size = {
  width: 1200,
  height: 630,
};
export const contentType = 'image/png';

export default async function Image({ params }: { params: { signature: string } }) {
  try {
    const tx = await getTransactionDetails(params.signature);
    
    const title = tx ? `Transaction ${tx.success ? 'Success' : 'Failed'}` : 'Transaction Details';
    const description = tx 
      ? `${tx.type} • Slot ${tx.slot}`
      : 'Solana Transaction Explorer';

    return new ImageResponse(
      (
        <div
          style={{
            height: '100%',
            width: '100%',
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            justifyContent: 'center',
            backgroundColor: '#000',
            backgroundImage: 'linear-gradient(45deg, #000 0%, #111 100%)',
          }}
        >
          {/* Logo */}
          <div
            style={{
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              marginBottom: '20px',
            }}
          >
            <div
              style={{
                width: '80px',
                height: '80px',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                borderRadius: '50%',
                background: 'linear-gradient(135deg, #00ffbd 0%, #00b386 100%)',
                marginRight: '16px',
              }}
            >
              <div
                style={{
                  color: 'white',
                  fontSize: '40px',
                  fontWeight: 700,
                }}
              >
                S
              </div>
            </div>
            <div
              style={{
                fontSize: '48px',
                fontWeight: 700,
                background: 'linear-gradient(135deg, #00ffbd 0%, #00b386 100%)',
                backgroundClip: 'text',
                color: 'transparent',
              }}
            >
              OPENSVM
            </div>
          </div>

          {/* Content */}
          <div
            style={{
              display: 'flex',
              flexDirection: 'column',
              alignItems: 'center',
              marginTop: '20px',
              padding: '0 48px',
            }}
          >
            <div
              style={{
                fontSize: '32px',
                fontWeight: 600,
                color: 'white',
                marginBottom: '10px',
                textAlign: 'center',
              }}
            >
              {title}
            </div>
            {tx && (
              <div
                style={{
                  fontSize: '24px',
                  color: tx.success ? '#00ffbd' : '#ff4d4d',
                  marginBottom: '20px',
                  textAlign: 'center',
                }}
              >
                {tx.type}
              </div>
            )}
            <div
              style={{
                fontSize: '20px',
                color: '#888',
                textAlign: 'center',
                maxWidth: '600px',
              }}
            >
              {description}
            </div>
            {tx && (
              <div
                style={{
                  fontSize: '16px',
                  color: '#666',
                  marginTop: '20px',
                  textAlign: 'center',
                }}
              >
                {tx.signature.slice(0, 20)}...{tx.signature.slice(-20)}
              </div>
            )}
          </div>

          {/* Footer */}
          <div
            style={{
              position: 'absolute',
              bottom: '32px',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
            }}
          >
            <div
              style={{
                fontSize: '16px',
                color: '#666',
              }}
            >
              opensvm.com
            </div>
          </div>
        </div>
      ),
      {
        width: 1200,
        height: 630,
      },
    );
  } catch (e: any) {
    console.log(`${e.message}`);
    return new Response(`Failed to generate the image`, {
      status: 500,
    });
  }
}


---
File: /app/tx/[signature]/page.tsx
---

import { Suspense } from 'react';
import TransactionContent from './TransactionContent';
import LoadingSpinner from '@/components/LoadingSpinner';
import { ErrorBoundary } from '@/components/ErrorBoundary';

interface Props {
  params: Promise<{ signature: string }>;
}

export default async function TransactionPage({ params }: Props) {
  // Await the params in the server component
  const { signature } = await params;

  return (
    <ErrorBoundary>
      <div className="container mx-auto px-4 py-8">
        <Suspense fallback={<LoadingSpinner />}>
          <TransactionContent signature={signature} />
        </Suspense>
      </div>
    </ErrorBoundary>
  );
}



---
File: /app/tx/[signature]/TransactionContent.tsx
---

'use client';

import { DetailedTransactionInfo } from '@/lib/solana';
import dynamic from 'next/dynamic';
import LoadingSpinner from '@/components/LoadingSpinner';
import React, { Suspense, useEffect, useState } from 'react';
import { ErrorBoundary } from '@/components/ErrorBoundary';

// Dynamically import components with no SSR and proper loading states
const TransactionNodeDetails = dynamic(
  () => import('@/components/TransactionNodeDetails').catch(err => {
    console.error('Failed to load TransactionNodeDetails:', err);
    return () => <div>Error loading transaction details</div>;
  }),
  {
    loading: () => <LoadingSpinner />,
    ssr: false
  }
);

const TransactionAnalysis = dynamic(
  () => import('@/components/TransactionAnalysis').catch(err => {
    console.error('Failed to load TransactionAnalysis:', err);
    return () => <div>Error loading transaction analysis</div>;
  }),
  {
    loading: () => <LoadingSpinner />,
    ssr: false
  }
);

// Skip EnhancedTransactionVisualizer for now since it requires d3
const TransactionOverview = ({ tx, signature }: { tx: DetailedTransactionInfo; signature: string }) => (
  <div className="bg-background rounded-lg p-6 shadow-lg border border-border">
    <h2 className="text-xl font-semibold mb-4 text-foreground">Transaction Overview</h2>
    <div className="text-sm space-y-4">
      <div className="break-all">
        <span className="text-muted-foreground block mb-1">Signature</span>
        <code className="bg-muted px-2 py-1 rounded text-foreground">{signature}</code>
      </div>
      <div>
        <span className="text-muted-foreground block mb-1">Status</span>
        <span className={tx?.success ? 'text-success font-medium' : 'text-destructive font-medium'}>
          {tx?.success ? 'Success' : 'Failed'}
        </span>
      </div>
      <div>
        <span className="text-muted-foreground block mb-1">Type</span>
        <span className="capitalize text-foreground">{tx?.type || 'Unknown'}</span>
      </div>
      <div>
        <span className="text-muted-foreground block mb-1">Timestamp</span>
        <span className="text-foreground">
          {tx?.timestamp ? new Date(tx.timestamp).toLocaleString() : 'Unknown'}
        </span>
      </div>
      <div>
        <span className="text-muted-foreground block mb-1">Slot</span>
        <span className="text-foreground">{tx?.slot?.toLocaleString() || 'Unknown'}</span>
      </div>
    </div>
  </div>
);

async function getTransactionDetails(signature: string): Promise<DetailedTransactionInfo> {
  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 15000); // 15 second timeout

    // First try the test endpoint
    const testResponse = await fetch('/api/test-transaction', {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      },
      signal: controller.signal
    });

    if (testResponse.ok) {
      const testData = await testResponse.json();
      clearTimeout(timeoutId);
      return testData;
    }

    // If test endpoint fails, try the main endpoint
    const response = await fetch(`/api/transaction/${signature}`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      },
      signal: controller.signal
    });

    clearTimeout(timeoutId);

    if (!response.ok) {
      const errorText = await response.text();
      let errorMessage = 'Failed to fetch transaction';
      let errorDetails = '';
      
      try {
        const errorData = JSON.parse(errorText);
        errorMessage = errorData.error || errorMessage;
        errorDetails = errorData.details ? JSON.stringify(errorData.details, null, 2) : '';
      } catch {
        errorMessage = errorText || errorMessage;
      }

      if (response.status === 404) {
        throw new Error('Transaction not found. Please check the signature and try again.');
      }
      if (response.status === 429) {
        throw new Error('Too many requests. Please try again in a few moments.');
      }
      if (response.status === 403) {
        throw new Error('Access denied. Please check your permissions.');
      }
      if (response.status === 500) {
        throw new Error(`Server error: ${errorMessage}${errorDetails ? `\n\nDetails:\n${errorDetails}` : ''}`);
      }
      throw new Error(`${errorMessage}${errorDetails ? `\n\nDetails:\n${errorDetails}` : ''}`);
    }

    const tx = await response.json();
    if (!tx) {
      throw new Error('Transaction data is empty. Please try again.');
    }

    return tx;
  } catch (error) {
    console.error('Error fetching transaction:', error);
    if (error instanceof Error) {
      if (error.name === 'AbortError') {
        throw new Error('Request timed out. Please try again.');
      }
      throw error;
    }
    throw new Error('Failed to fetch transaction details');
  }
}

function ErrorDisplay({ error, signature }: { error: Error; signature: string }) {
  const [retrying, setRetrying] = useState(false);

  const handleRetry = async () => {
    setRetrying(true);
    try {
      window.location.reload();
    } catch {
      setRetrying(false);
    }
  };

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="bg-background rounded-lg p-6 shadow-lg border border-destructive/20">
        <h2 className="text-xl font-semibold text-destructive mb-4">Error Loading Transaction</h2>
        <p className="text-foreground mb-4 whitespace-pre-wrap">{error.message}</p>
        <div className="text-sm text-muted-foreground">
          <p className="mb-2">Transaction signature:</p>
          <code className="bg-muted px-2 py-1 rounded break-all">{signature}</code>
        </div>
        <div className="mt-6 text-sm text-muted-foreground">
          <p>Possible reasons:</p>
          <ul className="list-disc list-inside mt-2 space-y-1 text-foreground">
            <li>The transaction signature is invalid</li>
            <li>The transaction has been pruned from the ledger</li>
            <li>Network connectivity issues</li>
            <li>RPC node rate limits</li>
            <li>Server-side processing errors</li>
          </ul>
        </div>
        <div className="mt-6">
          <button
            onClick={handleRetry}
            disabled={retrying}
            className="px-4 py-2 bg-primary text-primary-foreground rounded hover:bg-primary/90 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
          >
            {retrying ? (
              <span className="flex items-center">
                <LoadingSpinner className="w-4 h-4 mr-2" />
                Retrying...
              </span>
            ) : (
              'Try Again'
            )}
          </button>
        </div>
      </div>
    </div>
  );
}

function LoadingState({ signature }: { signature: string }) {
  const [showSlowLoadingMessage, setShowSlowLoadingMessage] = useState(false);

  useEffect(() => {
    const timer = setTimeout(() => {
      setShowSlowLoadingMessage(true);
    }, 5000);

    return () => clearTimeout(timer);
  }, []);

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="bg-background rounded-lg p-6 shadow-lg border border-border">
        <div className="flex items-center justify-center mb-4">
          <LoadingSpinner />
        </div>
        <p className="text-center text-foreground mb-4">Loading transaction details...</p>
        {showSlowLoadingMessage && (
          <p className="text-center text-muted-foreground text-sm mb-4">
            This is taking longer than usual. Please wait...
          </p>
        )}
        <div className="text-sm text-muted-foreground text-center">
          <p className="mb-2">Transaction signature:</p>
          <code className="bg-muted px-2 py-1 rounded break-all">{signature}</code>
        </div>
      </div>
    </div>
  );
}

export default function TransactionContent({ signature }: { signature: string }) {
  const [tx, setTx] = useState<DetailedTransactionInfo | null>(null);
  const [error, setError] = useState<Error | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const fetchTransaction = async () => {
      try {
        const data = await getTransactionDetails(signature);
        setTx(data);
      } catch (err) {
        setError(err as Error);
      } finally {
        setLoading(false);
      }
    };

    fetchTransaction();
  }, [signature]);

  if (loading) {
    return <LoadingState signature={signature} />;
  }

  if (error || !tx) {
    return <ErrorDisplay error={error || new Error('Failed to load transaction')} signature={signature} />;
  }

  return (
    <ErrorBoundary>
      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        {/* Left Panel: Transaction Details */}
        <div className="lg:col-span-1 space-y-6">
          <TransactionOverview tx={tx} signature={signature} />
          <ErrorBoundary fallback={<div>Error loading transaction details</div>}>
            <Suspense fallback={<LoadingSpinner />}>
              <div className="bg-background rounded-lg p-6 shadow-lg border border-border">
                <TransactionNodeDetails tx={tx} />
              </div>
            </Suspense>
          </ErrorBoundary>
        </div>

        {/* Middle Panel: Analysis */}
        <div className="lg:col-span-2 space-y-6">
          <ErrorBoundary fallback={<div>Error loading transaction analysis</div>}>
            <Suspense fallback={<LoadingSpinner />}>
              <div className="bg-background rounded-lg p-6 shadow-lg border border-border">
                <h2 className="text-xl font-semibold mb-4 text-foreground">Transaction Analysis</h2>
                <TransactionAnalysis tx={tx} />
              </div>
            </Suspense>
          </ErrorBoundary>
        </div>
      </div>
    </ErrorBoundary>
  );
}


---
File: /app/tx/page.tsx
---

import React from 'react';

export default function TransactionPage() {
  return (
    <div className="container mx-auto px-4 py-8">
      <div className="bg-background rounded-lg p-6 shadow-lg border border-border">
        <h1 className="text-2xl font-semibold mb-4 text-foreground">Transaction Explorer</h1>
        <p className="text-muted-foreground">
          Enter a transaction signature in the URL to view its details.
        </p>
      </div>
    </div>
  );
}


---
File: /app/globals.css
---

@tailwind base;
@tailwind components;
@tailwind utilities;

/* Import VTable styles */
@import './styles/vtable.css';

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 240 10% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 240 10% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 240 10% 3.9%;
    --primary: 142.1 76.2% 36.3%;
    --primary-foreground: 355.7 100% 97.3%;
    --secondary: 240 4.8% 95.9%;
    --secondary-foreground: 240 5.9% 10%;
    --muted: 240 4.8% 95.9%;
    --muted-foreground: 240 3.8% 46.1%;
    --accent: 240 4.8% 95.9%;
    --accent-foreground: 240 5.9% 10%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 240 5.9% 90%;
    --input: 240 5.9% 90%;
    --ring: 142.1 76.2% 36.3%;
    --radius: 0.5rem;

    /* Font families */
    --font-berkeley: 'Berkeley Mono', monospace;
    --font-inter: 'Inter', sans-serif;
    --font-jetbrains: 'JetBrains Mono', monospace;
    --font-family: var(--font-berkeley);

    /* Base font size - controlled by settings */
    --base-font-size: 16px;
  }

  .theme-high-contrast {
    --background: 0 0% 0%;
    --foreground: 0 0% 100%;
    --card: 0 0% 0%;
    --card-foreground: 0 0% 100%;
    --popover: 0 0% 0%;
    --popover-foreground: 0 0% 100%;
    --primary: 120 100% 50%;
    --primary-foreground: 0 0% 0%;
    --secondary: 0 0% 10%;
    --secondary-foreground: 0 0% 100%;
    --muted: 0 0% 15%;
    --muted-foreground: 0 0% 63%;
    --accent: 120 100% 50%;
    --accent-foreground: 0 0% 0%;
    --border: 0 0% 20%;
    --input: 0 0% 20%;
    --ring: 120 100% 50%;
  }

  .theme-dos {
    --background: 240 100% 26%;
    --foreground: 0 0% 100%;
    --card: 240 100% 26%;
    --card-foreground: 0 0% 100%;
    --popover: 240 100% 26%;
    --popover-foreground: 0 0% 100%;
    --primary: 180 100% 50%;
    --primary-foreground: 240 100% 26%;
    --secondary: 240 100% 20%;
    --secondary-foreground: 0 0% 100%;
    --muted: 240 100% 20%;
    --muted-foreground: 0 0% 63%;
    --accent: 180 100% 50%;
    --accent-foreground: 240 100% 26%;
    --destructive: 0 100% 67%;
    --destructive-foreground: 0 0% 100%;
    --border: 0 0% 100%;
    --input: 240 100% 26%;
    --ring: 180 100% 50%;
    --radius: 0px;
  }

  .theme-cyberpunk {
    --background: 300 89% 5%;
    --foreground: 300 100% 98%;
    --card: 300 89% 5%;
    --card-foreground: 300 100% 98%;
    --popover: 300 89% 5%;
    --popover-foreground: 300 100% 98%;
    --primary: 326 100% 50%;
    --primary-foreground: 300 0% 0%;
    --secondary: 266 100% 64%;
    --secondary-foreground: 300 0% 0%;
    --muted: 300 50% 10%;
    --muted-foreground: 300 50% 80%;
    --accent: 326 100% 50%;
    --accent-foreground: 300 0% 0%;
    --destructive: 0 100% 67%;
    --destructive-foreground: 300 100% 98%;
    --border: 326 100% 50%;
    --input: 300 50% 10%;
    --ring: 326 100% 40%;
    --radius: 0px;
  }

  .theme-paper {
    --background: 45 29% 97%;
    --foreground: 20 14.3% 4.1%;
    --card: 0 0% 100%;
    --card-foreground: 20 14.3% 4.1%;
    --popover: 0 0% 100%;
    --popover-foreground: 20 14.3% 4.1%;
    --primary: 24 9.8% 10%;
    --primary-foreground: 60 9.1% 97.8%;
    --secondary: 60 4.8% 95.9%;
    --secondary-foreground: 24 9.8% 10%;
    --muted: 60 4.8% 95.9%;
    --muted-foreground: 25 5.3% 44.7%;
    --accent: 60 4.8% 95.9%;
    --accent-foreground: 24 9.8% 10%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 60 9.1% 97.8%;
    --border: 20 5.9% 90%;
    --input: 20 5.9% 90%;
    --ring: 24 5.4% 63.9%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
    font-family: var(--font-family);
    font-size: var(--base-font-size);
  }
}

/* Berkeley Mono */
@font-face {
  font-family: 'Berkeley Mono';
  src: url('/fonts/BerkeleyMono-Regular.woff2') format('woff2');
  font-weight: 500;
  font-style: normal;
}

@font-face {
  font-family: 'Berkeley Mono';
  src: url('/fonts/BerkeleyMono-Bold.woff2') format('woff2');
  font-weight: 700;
  font-style: normal;
}

/* Inter */
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

/* JetBrains Mono */
@import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&display=swap');



---
File: /app/layout.tsx
---

import type { Metadata } from "next";
import "./globals.css";
import { Navbar } from "@/components/Navbar";
import { Providers } from './providers';

export const metadata: Metadata = {
  title: "OpenSVM - AI Explorer and RPC nodes provider for all SVM networks (Solana Virtual Machine)",
  description: "Explore all SVM networks with AI assistance, or create your Solana Network Extension for free.",
  icons: {
    icon: '/favicon.svg',
    shortcut: '/favicon.svg',
    apple: '/favicon.svg',
    other: {
      rel: 'icon',
      url: '/favicon.svg',
    },
  },
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en" suppressHydrationWarning>
      <head>
        <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
      </head>
      <body>
        <Providers>
          <Navbar>
            {children}
          </Navbar>
        </Providers>
      </body>
    </html>
  );
}



---
File: /app/page.tsx
---

'use client';

import { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { Input } from '@/components/ui/input';
import { Button } from '@/components/ui/button';
import { Search } from 'lucide-react';
import { getConnection, getRPCLatency } from '@/lib/solana';
import { AIChatSidebar } from '@/components/ai/AIChatSidebar';
import { RecentBlocks } from '@/components/RecentBlocks';
import { TransactionsInBlock } from '@/components/TransactionsInBlock';
import { NetworkResponseChart } from '@/components/NetworkResponseChart';

type TransactionType = 'Success' | 'Failed';

interface Block {
  slot: number;
  transactions?: {
    signature: string;
    type: TransactionType;
    timestamp: number | null;
  }[];
}

interface NetworkStats {
  epoch: number;
  epochProgress: number;
  blockHeight: number;
  activeValidators: number | null;
  tps: number;
  successRate: number;
}

export default function HomePage() {
  const router = useRouter();
  const [searchQuery, setSearchQuery] = useState('');
  const [stats, setStats] = useState<NetworkStats | null>(null);
  const [blocks, setBlocks] = useState<Block[]>([]);
  const [selectedBlock, setSelectedBlock] = useState<Block | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [isAIChatOpen, setIsAIChatOpen] = useState(false);
  const [sidebarWidth, setSidebarWidth] = useState(400);
  const [isResizing, setIsResizing] = useState(false);
  const [networkData, setNetworkData] = useState<{ timestamp: number; successRate: number; latency: number; }[]>([]);

  useEffect(() => {
    let mounted = true;

    async function fetchData() {
      try {
        setIsLoading(true);
        const connection = await getConnection();
        const latency = await getRPCLatency();
        
        // Get current slot and blocks in one batch
        const slot = await connection.getSlot();
        const startSlot = Math.max(0, slot - 9);
        const slots = await connection.getBlocks(startSlot, slot);
        
        if (!mounted) return;

        // Update blocks
        const blockData = slots.map(slot => ({ slot }));
        setBlocks(blockData);

        // Get epoch info and other stats
        const epochInfo = await connection.getEpochInfo();
        const validators = await connection.getVoteAccounts();
        const perfSamples = await connection.getRecentPerformanceSamples(1);
        
        if (!mounted) return;

        const tps = perfSamples[0] ? Math.round(perfSamples[0].numTransactions / perfSamples[0].samplePeriodSecs) : 0;
        
        const newStats = {
          epoch: epochInfo.epoch,
          epochProgress: (epochInfo.slotIndex / epochInfo.slotsInEpoch) * 100,
          blockHeight: epochInfo.absoluteSlot,
          activeValidators: validators.current.length + validators.delinquent.length,
          tps,
          successRate: 100,
        };
        
        setStats(newStats);

        // Update network data
        setNetworkData(prev => {
          const newData = [...prev, {
            timestamp: Date.now(),
            successRate: newStats.successRate,
            latency
          }];
          return newData.slice(-30); // Keep last 30 data points
        });
      } catch (err) {
        console.error('Error fetching data:', err);
      } finally {
        if (mounted) {
          setIsLoading(false);
        }
      }
    }

    fetchData();
    // Refresh every 30 seconds
    const interval = setInterval(fetchData, 30000);

    return () => {
      mounted = false;
      clearInterval(interval);
    };
  }, []);

  const handleSearch = (e: React.FormEvent) => {
    e.preventDefault();
    if (!searchQuery) return;
    router.push(`/search?q=${encodeURIComponent(searchQuery)}`);
  };

  const handleBlockSelect = async (block: Block) => {
    try {
      const connection = await getConnection();
      const blockInfo = await connection.getBlock(block.slot, {
        maxSupportedTransactionVersion: 0
      });
      
      if (blockInfo) {
        const blockWithTx: Block = {
          ...block,
          transactions: blockInfo.transactions.map(tx => ({
            signature: tx.transaction.signatures[0],
            type: tx.meta?.err ? ('Failed' as const) : ('Success' as const),
            timestamp: blockInfo.blockTime
          }))
        };
        setSelectedBlock(blockWithTx);
      }
    } catch (err) {
      console.error('Error fetching block transactions:', err);
    }
  };

  return (
    <div className="relative">
      <main 
        className="min-h-screen bg-background"
        style={{ 
          width: isAIChatOpen ? `calc(100% - ${sidebarWidth}px)` : '100%',
          transition: !isResizing ? 'all 300ms ease-in-out' : 'none',
          marginRight: isAIChatOpen ? `${sidebarWidth}px` : 0
        }}
      >
        {/* Hero Section */}
        <div className="container mx-auto px-4 py-12">
          <div className="text-center mb-12">
            <h1 className="text-4xl md:text-6xl font-bold text-foreground mb-4">
              OpenSVM Explorer
            </h1>
            <p className="text-xl text-muted-foreground">
              The quieter you become, the more you are able to hear.
            </p>
          </div>

          {/* Search Bar */}
          <div className="max-w-2xl mx-auto mb-16">
            <form onSubmit={handleSearch} className="relative">
              <Input
                type="text"
                placeholder="Search transactions, blocks, programs and tokens..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                className="w-full h-12 pl-12 pr-4 bg-muted/50 border-0"
              />
              <Search className="absolute left-4 top-1/2 transform -translate-y-1/2 text-muted-foreground" size={20} />
              <Button 
                type="submit"
                className="absolute right-2 top-1/2 transform -translate-y-1/2 px-6"
              >
                Search
              </Button>
            </form>
          </div>

          {/* Stats Grid */}
          <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-12">
            <div className="bg-background border border-border rounded-lg p-6">
              <div className="text-3xl font-mono text-foreground mb-2">
                {stats?.blockHeight?.toLocaleString() ?? '...'}
              </div>
              <div className="text-sm text-muted-foreground">
                Blocks Processed
              </div>
            </div>
            <div className="bg-background border border-border rounded-lg p-6">
              <div className="text-3xl font-mono text-foreground mb-2">
                {stats?.activeValidators?.toLocaleString() ?? '...'}
              </div>
              <div className="text-sm text-muted-foreground">
                Active Validators
              </div>
            </div>
            <div className="bg-background border border-border rounded-lg p-6">
              <div className="text-3xl font-mono text-foreground mb-2">
                {stats?.tps?.toLocaleString() ?? '...'}
              </div>
              <div className="text-sm text-muted-foreground">
                TPS
              </div>
            </div>
          </div>

          {/* Network Stats */}
          <div className="bg-background border border-border rounded-lg p-6 mb-12">
            <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
              <div>
                <div className="text-sm text-muted-foreground mb-2">Current Epoch</div>
                <div className="text-2xl font-mono text-foreground">{stats?.epoch ?? '...'}</div>
                <div className="w-full bg-muted h-1 mt-2 rounded-full overflow-hidden">
                  <div 
                    className="bg-primary h-1" 
                    style={{ width: `${stats?.epochProgress ?? 0}%` }}
                  />
                </div>
              </div>
              <div>
                <div className="text-sm text-muted-foreground mb-2">Network Load</div>
                <div className="text-2xl font-mono text-foreground">
                  {stats?.epochProgress?.toFixed(2) ?? '0'}%
                </div>
              </div>
              <div>
                <div className="text-sm text-muted-foreground mb-2">Block Height</div>
                <div className="text-2xl font-mono text-foreground">
                  {stats?.blockHeight?.toLocaleString() ?? '...'}
                </div>
              </div>
            </div>
          </div>

          {/* Recent Activity */}
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div className="bg-background border border-border rounded-lg p-6">
              <RecentBlocks 
                blocks={blocks}
                onBlockSelect={handleBlockSelect}
                isLoading={isLoading}
              />
            </div>
            <div className="bg-background border border-border rounded-lg p-6">
              <TransactionsInBlock block={selectedBlock} />
            </div>
          </div>

          {/* Network Performance Section */}
          <div className="mt-6">
            <div className="bg-background border border-border rounded-lg p-6">
              <h2 className="text-lg font-semibold text-foreground mb-4">Network Performance</h2>
              <div className="h-[300px]">
                <NetworkResponseChart data={networkData} />
              </div>
            </div>
          </div>

          {/* AI Assistant Button */}
          <div className="fixed bottom-6 right-6">
            <Button
              className="bg-[#00DC82] text-black hover:bg-[#00DC82]/90 h-12 px-6 rounded-full shadow-lg"
              onClick={() => setIsAIChatOpen(true)}
            >
              AI Assistant
            </Button>
          </div>
        </div>
      </main>

      {/* AI Chat Sidebar */}
      <AIChatSidebar 
        isOpen={isAIChatOpen}
        onClose={() => setIsAIChatOpen(false)}
        onWidthChange={setSidebarWidth}
        onResizeStart={() => setIsResizing(true)}
        onResizeEnd={() => setIsResizing(false)}
        initialWidth={sidebarWidth}
      />
    </div>
  );
}



---
File: /app/providers.tsx
---

'use client';

import { SettingsProvider } from '@/lib/settings';
import { ThemeProvider } from '@/lib/theme';
import { SolanaProvider } from '@/app/providers/SolanaProvider';

export function Providers({ children }: { children: React.ReactNode }) {
  return (
    <ThemeProvider>
      <SettingsProvider>
        <SolanaProvider>
          {children}
        </SolanaProvider>
      </SettingsProvider>
    </ThemeProvider>
  );
}

