    println!("{:#?}", account);

    Ok(())
}
```

### !params

#### !! pubkey

!type string
!required

Pubkey of account to query, as base-58 encoded string.

#### !! 1

!type object

Configuration object.

##### !! commitment

!type string

The commitment describes how finalized a block is at that point in time. See
[Configuring State Commitment](/docs/rpc#configuring-state-commitment).

##### !! encoding

!type string
!values base58 base64 base64+zstd jsonParsed

Encoding format for Account data. See
[Parsed Responses](/docs/rpc#parsed-responses).

- `base58` is slow and limited to less than 129 bytes of Account data.
- `base64` will return base64 encoded data for Account data of any size.
- `base64+zstd` compresses the Account data using
  [Zstandard](https://facebook.github.io/zstd/) and base64-encodes the result.
- `jsonParsed` encoding attempts to use program-specific state parsers to return
  more human-readable and explicit account state data.
- If `jsonParsed` is requested but a parser cannot be found, the field falls
  back to `base64` encoding, detectable when the `data` field is type `string`.

##### !! dataSlice

!type object

Request a slice of the account&apos;s data.

- `length: <usize>` - number of bytes to return
- `offset: <usize>` - byte offset from which to start reading

<Callout type="info">
  Data slicing is only available for `base58`, `base64`, or `base64+zstd`
  encodings.
</Callout>

##### !! minContextSlot

!type string

The minimum slot that the request can be evaluated at.

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  "result": {
    "context": { "apiVersion": "2.0.15", "slot": 341197053 },
    // !hover(1:8) result
    "value": {
      // !hover data
      "data": ["", "base58"],
      // !hover executable
      "executable": false,
      // !hover lamports
      "lamports": 88849814690250,
      // !hover owner
      "owner": "11111111111111111111111111111111",
      // !hover rentEpoch
      "rentEpoch": 18446744073709551615,
      // !hover space
      "space": 0
    }
  },
  "id": 1
}
```

!type object | null

If the requested account doesn't exist result will be `null`. Otherwise, an
object containing:

#### !! data

!type \[string,encoding\] | object

Data associated with the account, either as encoded binary data or JSON format
`{<program>: <state>}` - depending on encoding parameter

#### !! executable

!type bool

Boolean indicating if the account contains a program (and is strictly read-only)

#### !! lamports
!type u64

Number of lamports assigned to this account

#### !! owner

!type string

base-58 encoded Pubkey of the program this account has been assigned to

#### !! rentEpoch

!type u64

The epoch at which this account will next owe rent, as u64

#### !! space

!type u64

The data size of the account

</APIMethod>
---
title: getBalance
hideTableOfContents: true
h1: getBalance RPC Method
---

Returns the lamport balance of the account of provided Pubkey

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getBalance",
  "params": [
    // !hover pubkey
    "83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri",
    {
      // !hover commitment
      "commitment": "finalized"
    }
  ]
}
```

```ts !!request title="Kit"
import { address, createSolanaRpc } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

// !hover pubkey
const publicKey = address("83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri");
const balance = await rpc.getBalance(publicKey).send();

console.log("Account Balance:", balance);
```

```ts !!request title="web3.js"
import { Connection, PublicKey, clusterApiUrl } from "@solana/web3.js";

const connection = new Connection(clusterApiUrl("devnet"), "confirmed");
// !hover pubkey
const publicKey = new PublicKey("83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri");
const balance = await connection.getBalance(publicKey);

console.log("Account Balance:", JSON.stringify(balance, null, 2));
```

```rs !!request title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig, native_token::LAMPORTS_PER_SOL, pubkey::Pubkey,
};
use std::str::FromStr;

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

    // !hover pubkey
    let pubkey = Pubkey::from_str("83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri")?;
    let balance = client.get_balance(&pubkey).await?;

    println!("{:#?} SOL", balance / LAMPORTS_PER_SOL);

    Ok(())
}
```

### !params

#### !! pubkey

!type string
!required

Pubkey of account to query, as base-58 encoded string.

#### !! 1

!type object

Configuration object.

##### !! commitment

!type string

The commitment describes how finalized a block is at that point in time. See
[Configuring State Commitment](/docs/rpc#configuring-state-commitment).

##### !! minContextSlot

!type number

The minimum slot that the request can be evaluated at.

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  "result": {
    "context": { "slot": 1 },
    // !hover result
    "value": 0
  },
  "id": 1
}
```

!type u64

RpcResponse JSON object with value field set to the balance.

</APIMethod>
---
title: getBlock
hideTableOfContents: true
h1: getBlock RPC Method
---

Returns identity and transaction information about a confirmed block in the
ledger

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getBlock",
  "params": [
    // !hover slot number
    378967388,
    // !hover(1:6) 1
    {
      // !hover commitment
      "commitment": "finalized",
      // !hover encoding
      "encoding": "json",
      // !hover transactionDetails
      "transactionDetails": "full",
      // !hover maxSupportedTransactionVersion
      "maxSupportedTransactionVersion": 0,
      // !hover rewards
      "rewards": false
    }
  ]
}
```

```ts !!request title="Kit"
import { createSolanaRpc } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

// !hover slot number
const slot_number = BigInt(377261141);

let block = await rpc
  .getBlock(
    slot_number,
    // !hover(1:6) 1
    {
      // !hover commitment
      commitment: "finalized",
      // !hover encoding
      encoding: "json",
      // !hover transactionDetails
      transactionDetails: "full",
      // !hover maxSupportedTransactionVersion
      maxSupportedTransactionVersion: 0,
      // !hover rewards
      rewards: false,
    },
  )
  .send();

console.log("block:", block);
```

```ts !!request title="web3.js"
import { Connection, clusterApiUrl } from "@solana/web3.js";

const connection = new Connection(clusterApiUrl("devnet"), "confirmed");

// !hover slot number
const slot_number = 377261141;

const block = await connection.getBlock(
  slot_number,
  // !hover(1:6) 1
  {
    // !hover commitment
    commitment: "finalized",
    // !hover transactionDetails
    transactionDetails: "full",
    // !hover maxSupportedTransactionVersion
    maxSupportedTransactionVersion: 0,
    // !hover rewards
    rewards: false,
  },
);

console.log("block:", block);
```

```rs !!request title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::commitment_config::CommitmentConfig;
use solana_transaction_status_client_types::{TransactionDetails, UiTransactionEncoding};

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

    // !hover slot number
    let slot_number = 377261141;

  // !hover(1:6) 1
    let config = solana_client::rpc_config::RpcBlockConfig {
        // !hover encoding
        encoding: UiTransactionEncoding::Base58.into(),
        // !hover transactionDetails
        transaction_details: TransactionDetails::Full.into(),
        // !hover rewards
        rewards: None,
        // !hover commitment
        commitment: CommitmentConfig::finalized().into(),
        // !hover maxSupportedTransactionVersion
        max_supported_transaction_version: Some(0),
    };
    let block = client.get_block_with_config(slot_number, config).await?;

    println!("Block: {:#?}", block);

    Ok(())
}
```

### !params

#### !! slot number

!type u64
!required

Slot number.

#### !! 1

!type object

Configuration object.

##### !! commitment

!type string
!values confirmed finalized
!default finalized

The commitment describes how finalized a block is at that point in time. See
[Configuring State Commitment](/docs/rpc#configuring-state-commitment).

- `processed` is not supported.

##### !! encoding

!type string
!values json jsonParsed base58 base64
!default json

Encoding format for each returned transaction. See
[Parsed Responses](/docs/rpc#parsed-responses).

- `jsonParsed` attempts to use program-specific instruction parsers to return
  more human-readable and explicit data in the
  `transaction.message.instructions` list.
- If `jsonParsed` is requested but a parser cannot be found, the instruction
  falls back to regular JSON encoding (`accounts`, `data`, and `programIdIndex`
  fields).

##### !! transactionDetails

!type string
!values full accounts signatures none
!default full

Level of transaction detail to return.

- If `accounts` are requested, transaction details only include signatures and
  an annotated list of accounts in each transaction.
- Transaction metadata is limited to only: fee, err, pre_balances,
  post_balances, pre_token_balances, and post_token_balances.

##### !! maxSupportedTransactionVersion

!type number
!values 0
!default 0

Currently, the only valid value for this parameter is `0`.
Setting it to `0` allows you to fetch all transactions, including both Versioned and legacy transactions.

This parameter determines the maximum transaction version that will be returned in the response.
If you request a transaction with a higher version than this value, an error will be returned.
If you omit this parameter, only legacy transactions will be returnedâ€”any versioned transaction will result in an error.


##### !! rewards

!type bool

Whether to populate the rewards array. If parameter not provided, the default
includes rewards.

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover(1:52) result
  "result": {
    // !hover blockHeight
    "blockHeight": 428,
    // !hover blockTime
    "blockTime": null,
    // !hover blockhash
    "blockhash": "3Eq21vXNB5s86c62bVuUfTeaMif1N2kUqRPBmGRJhyTA",
    // !hover parentSlot
    "parentSlot": 429,
    // !hover previousBlockhash
    "previousBlockhash": "mfcyqEXB3DnHXki6KjjmZck6YjmZLvpAByy2fj4nh6B",
    // !hover(1:45) transactions
    "transactions": [
      {
        // !collapse(1:13) collapsed
        "meta": {
          "err": null,
          "fee": 5000,
          "innerInstructions": [],
          "logMessages": [],
          "postBalances": [499998932500, 26858640, 1, 1, 1],
          "postTokenBalances": [],
          "preBalances": [499998937500, 26858640, 1, 1, 1],
          "preTokenBalances": [],
          "rewards": null,
          "status": {
            "Ok": null
          }
        },
        // !collapse(1:26) collapsed
        "transaction": {
          "message": {
            "accountKeys": [
              "3UVYmECPPMZSCqWKfENfuoTv51fTDTWicX9xmBD2euKe",
              "AjozzgE83A3x1sHNUR64hfH7zaEBWeMaFuAN9kQgujrc",
              "SysvarS1otHashes111111111111111111111111111",
              "SysvarC1ock11111111111111111111111111111111",
              "Vote111111111111111111111111111111111111111"
            ],
            "header": {
              "numReadonlySignedAccounts": 0,
              "numReadonlyUnsignedAccounts": 3,
              "numRequiredSignatures": 1
            },
            "instructions": [
              {
                "accounts": [1, 2, 3, 0],
                "data": "37u9WtQpcm6ULa3WRQHmj49EPs4if7o9f1jSRVZpm2dvihR9C8jY4NqEwXUbLwx15HBSNcP1",
                "programIdIndex": 4
              }
            ],
            "recentBlockhash": "mfcyqEXB3DnHXki6KjjmZck6YjmZLvpAByy2fj4nh6B"
          },
          "signatures": [
            "2nBhEBYYvfaAe16UMNqRHre4YNSskvuYgx3M6E4JP1oDYvZEJHvoPzyUidNgNX5r9sTyN1J9UxtbCXy2rqYcuyuv"
          ]
        }
      }
    ]
  },
  "id": 1
}
```

!type object | null

If specified block is not confirmed result will be `null`. Otherwise, an object
containing:

##### !! blockHeight

!type u64 | null

The number of blocks beneath this block.

##### !! blockTime

!type i64 | null

Estimated production time, as Unix timestamp (seconds since the Unix epoch).
`null` if not available.

##### !! blockhash

!type string

The blockhash of this block, as base-58 encoded string

##### !! parentSlot

!type u64

The slot index of this block's parent

##### !! previousBlockhash

!type string

The blockhash of this block's parent, as base-58 encoded string; if the parent
block is not available due to ledger cleanup, this field will return
"11111111111111111111111111111111"

##### !! transactions

!type array

Present if "full" transaction details are requested; an array of JSON objects
containing:

- `transaction: <object|[string,encoding]>` -
  [Transaction](/docs/rpc/json-structures#transactions) object, either in JSON
  format or encoded binary data, depending on encoding parameter.
- `meta: <object>` - Transaction status
  [metadata object](/docs/rpc/json-structures#transaction-status-metadata) or
  `null`.

</APIMethod>
---
title: getBlockCommitment
hideTableOfContents: true
h1: getBlockCommitment RPC Method
---

Returns commitment for particular block

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getBlockCommitment",
  "params": [
    // !hover slot number
    5
  ]
}
```

```ts !!request title="Kit"
import { createSolanaRpc } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

// !hover slot number
const slot_number = BigInt(5);

let blockCommitment = await rpc.getBlockCommitment(slot_number).send();

console.log("block commitment:", blockCommitment);
```

### !params

#### !! slot number

!type u64
!required

Block number, identified by Slot.

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover(1:6) result
  "result": {
    // !hover(1:4) commitment
    "commitment": [
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 10, 32
    ],
    // !hover totalStake
    "totalStake": 42
  },
  "id": 1
}
```

!type object

The result field will be a JSON object containing:

##### !! commitment

!type array | null

Array of u64 integers logging the amount of cluster stake in lamports that has
voted on the block at each depth from 0 to `MAX_LOCKOUT_HISTORY`.

##### !! totalStake

!type number

Total active stake, in lamports, of the current epoch.

</APIMethod>
---
title: getBlockHeight
hideTableOfContents: true
h1: getBlockHeight RPC Method
---

Returns the current block height of the node

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getBlockHeight",
  "params": [
    {
      // !hover commitment
      "commitment": "finalized"
    }
  ]
}
```

```ts !!request title="Kit"
import { createSolanaRpc } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

let blockHeight = await rpc.getBlockHeight().send();

console.log("block height:", blockHeight);
```

```ts !!request title="web3.js"
import { Connection, clusterApiUrl } from "@solana/web3.js";

const connection = new Connection(clusterApiUrl("devnet"), "confirmed");

let blockHeight = await connection.getBlockHeight();

console.log("block height:", blockHeight);
```

```rs !!request title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::commitment_config::CommitmentConfig;

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

    let block_height = client.get_block_height().await?;

    println!("Block height: {:#?}", block_height);

    Ok(())
}
```

### !params

#### !! 0

!type object

Configuration object

##### !! commitment

!type string

The commitment describes how finalized a block is at that point in time. See
[Configuring State Commitment](/docs/rpc#configuring-state-commitment).

##### !! minContextSlot

!type number

The minimum slot that the request can be evaluated at.

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover result
  "result": 1233,
  "id": 1
}
```

!type u64

Current block height.

</APIMethod>
---
title: getBlockProduction
hideTableOfContents: true
h1: getBlockProduction RPC Method
---

Returns recent block production information from the current or previous epoch.

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getBlockProduction",
  "params": [
    // !hover(1:3) 0
    {
      // !hover commitment
      "commitment": "finalized"
    }
  ]
}
```

```ts !!request title="Kit"
import { createSolanaRpc } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

let blockProduction = await rpc.getBlockProduction().send();

console.log("block production:", blockProduction);
```

```ts !!request title="web3.js"
import { Connection, clusterApiUrl } from "@solana/web3.js";

const connection = new Connection(clusterApiUrl("devnet"), "confirmed");

let blockProduction = await connection.getBlockProduction();

console.log("block production:", blockProduction);
```

```rs !!request title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::commitment_config::CommitmentConfig;

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

    let block_production = client.get_block_production().await?;

    println!("Block production: {:#?}", block_production);

    Ok(())
}
```

### !params

#### !! 0

!type object

Configuration object

##### !! commitment

!type string

The commitment describes how finalized a block is at that point in time. See
[Configuring State Commitment](/docs/rpc#configuring-state-commitment).

##### !! identity

!type string

Only return results for this validator identity (base-58 encoded).

##### !! range

!type object

Slot range to return block production for. If parameter not provided, defaults
to current epoch.

- `firstSlot: <u64>` - first slot to return block production information for
  (inclusive)
- (optional) `lastSlot: <u64>` - last slot to return block production
  information for (inclusive). If parameter not provided, defaults to the
  highest slot

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  "result": {
    "context": {
      "slot": 9887
    },
    // !hover(1:9) result
    "value": {
      // !hover(1:3) byIdentity
      "byIdentity": {
        "85iYT5RuzRTDgjyRa3cP8SYhM2j21fj7NhfJ3peu1DPr": [9888, 9886]
      },
      // !hover(1:4) range
      "range": {
        "firstSlot": 0,
        "lastSlot": 9887
      }
    }
  },
  "id": 1
}
```

!type object

The result will be an RpcResponse JSON object with value equal to:

##### !! byIdentity

!type object

A dictionary of validator identities, as base-58 encoded strings. Value is a two
element array containing the number of leader slots and the number of blocks
produced.

##### !! range

!type object

Block production slot range

- `firstSlot: <u64>` - first slot of the block production information
  (inclusive)
- `lastSlot: <u64>` - last slot of block production information (inclusive)

</APIMethod>
---
title: getBlocks
hideTableOfContents: true
h1: getBlocks RPC Method
---

Returns a list of confirmed blocks between two slots

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getBlocks",
  "params": [
    // !hover start slot
    5,
    // !hover end slot
    10,
    // !hover(1:3) 2
    {
      // !hover commitment
      "commitment": "finalized"
    }
  ]
}
```

```ts !!request title="Kit"
import { createSolanaRpc } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

// !hover start slot
let startSlot = BigInt(377268280);
// !hover end slot
let endSlot = BigInt(377268285);
let blocks = await rpc.getBlocks(startSlot, endSlot).send();

console.log("Blocks produced:", blocks);
```


```ts !!request title="web3.js"
import { Connection, clusterApiUrl } from "@solana/web3.js";

const connection = new Connection(clusterApiUrl("devnet"), "confirmed");

// !hover start slot
let startSlot = 377268280;
// !hover end slot
let endSlot = 377268285;
let blocks = await connection.getBlocks(startSlot, endSlot);

console.log("Blocks produced:", blocks);
```


```rs !!request title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::commitment_config::CommitmentConfig;

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

    // !hover start slot
    let start_slot = 377268280;
    // !hover end slot
    let end_slot = 377268285;
    let blocks = client.get_blocks(start_slot, Some(end_slot)).await?;

    println!("Blocks produced: {:#?}", blocks);

    Ok(())
}
```

### !params

#### !! start slot

!type u64
!required

Start slot

#### !! end slot

!type u64

End slot (must be no more than 500,000 blocks higher than the `start_slot`)

#### !! 2

!type object

Configuration object

##### !! commitment

!type string

The commitment describes how finalized a block is at that point in time. See
[Configuring State Commitment](/docs/rpc#configuring-state-commitment).

- "processed" is not supported

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover result
  "result": [5, 6, 7, 8, 9, 10],
  "id": 1
}
```

!type array

An array of u64 integers listing confirmed blocks between `start_slot` and
either `end_slot` - if provided, or latest confirmed slot, inclusive. Max range
allowed is 500,000 slots.

</APIMethod>
---
title: getBlocksWithLimit
hideTableOfContents: true
h1: getBlocksWithLimit RPC Method
---

Returns a list of confirmed blocks starting at the given slot

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getBlocksWithLimit",
  "params": [
    // !hover start slot
    5,
    // !hover limit
    3
  ],
  // !hover(1:3) 2
  {
    // !hover commitment
    "commitment": "finalized"
  }
}
```

```ts !!request title="Kit"
import { createSolanaRpc } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

// !hover start slot
let startSlot = BigInt(377268280);
// !hover limit
let limit = 5;
let blocks = await rpc.getBlocksWithLimit(startSlot, limit).send();

console.log("blocks produced:", blocks);
```

```rs !!request title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::commitment_config::CommitmentConfig;

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

    // !hover start slot
    let start_slot = 377268280;
    // !hover limit
    let limit = 5;

    let blocks = client.get_blocks_with_limit(start_slot, limit).await?;

    println!("Blocks produced: {:?}", blocks);

    Ok(())
}
```

### !params

#### !! start slot

!type u64
!required

Start slot

#### !! limit

!type u64

Limit (must be no more than 500,000 blocks higher than the `start_slot`)

#### !! 2

!type object

Configuration object

##### !! commitment

!type string

The commitment describes how finalized a block is at that point in time. See
[Configuring State Commitment](/docs/rpc#configuring-state-commitment).

- "processed" is not supported

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover result
  "result": [5, 6, 7],
  "id": 1
}
```

!type array

An array of u64 integers listing confirmed blocks starting at `start_slot` for
up to `limit` blocks, inclusive.

</APIMethod>
---
title: getBlockTime
hideTableOfContents: true
h1: getBlockTime RPC Method
---

Returns the estimated production time of a block.

<Callout type="info">
  Each validator reports their UTC time to the ledger on a regular interval by
  intermittently adding a timestamp to a Vote for a particular block. A
  requested block's time is calculated from the stake-weighted mean of the Vote
  timestamps in a set of recent blocks recorded on the ledger.
</Callout>

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getBlockTime",
  "params": [
    // !hover slot number
    5
  ]
}
```

```ts !!request title="Kit"
import { createSolanaRpc } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

// !hover slot number
let slotNumber = BigInt(377268280);
let blockTime = await rpc.getBlockTime(slotNumber).send();

console.log("Block time:", blockTime);
```

```ts !!request title="web3.js"
import { Connection, clusterApiUrl } from "@solana/web3.js";

const connection = new Connection(clusterApiUrl("devnet"), "confirmed");

// !hover slot number
let slotNumber = 377268280;
let blockTime = await connection.getBlockTime(slotNumber);

console.log("Block time:", blockTime);
```

```rs !!request title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::commitment_config::CommitmentConfig;

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

    // !hover slot number
    let slot_number = 377268280;

    let block_time = client.get_block_time(slot_number).await?;

    println!("Blocks time: {:?}", block_time);

    Ok(())
}
```

### !params

#### !! slot number

!type u64
!required

Block number, identified by Slot

### !!result available

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover result
  "result": 1574721591,
  "id": 1
}
```

!type i64

Estimated production time, as Unix timestamp (seconds since the Unix epoch)

### !!result unavailable

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover(1:4) result
  "error": {
    "code": -32004,
    "message": "Block not available for slot 150"
  },
  "id": 1
}
```

!type object

Error object

</APIMethod>
---
title: getClusterNodes
hideTableOfContents: true
h1: getClusterNodes RPC Method
---

Returns information about all the nodes participating in the cluster

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getClusterNodes"
}
```

```ts !!request title="Kit"
import { createSolanaRpc } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

let nodes = await rpc.getClusterNodes().send();

console.log(nodes);
```

```ts !!request title="web3.js"
import { Connection, clusterApiUrl } from "@solana/web3.js";

const connection = new Connection(clusterApiUrl("devnet"), "confirmed");

let nodes = await connection.getClusterNodes();

console.log(nodes);
```

```rs !!request title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::commitment_config::CommitmentConfig;

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

    let block_time = client.get_cluster_nodes().await?;

    println!("{:#?}", block_time);

    Ok(())
}
```

### !params

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover(1:9) result
  "result": [
    {
      // !hover featureSet
      "featureSet": 3073396398,
      // !hover gossip
      "gossip": "10.239.6.48:8001",
      // !hover pubkey
      "pubkey": "9QzsJf7LPLj8GkXbYT3LFDKqsj2hHG7TA3xinJHu8epQ",
      // !hover rpc
      "rpc": "10.239.6.48:8899",
      // !hover shredVersion
      "shredVersion": 2405,
      // !hover tpu
      "tpu": "10.239.6.48:8856",
      // !hover version
      "version": "1.0.0 c375ce1f"
    }
  ],
  "id": 1
}
```

!type array

The result field will be an array of JSON objects, each with the following sub
fields:

##### !! featureSet

!type u32 | null

The unique identifier of the node's feature set

##### !! gossip

!type string | null

Gossip network address for the node

##### !! pubkey

!type string

Node public key, as base-58 encoded string

##### !! rpc

!type string | null

JSON RPC network address for the node, or `null` if the JSON RPC service is not
enabled


##### !! shredVersion

!type u16 | null

The shred version the node has been configured to use

##### !! tpu

!type string | null

TPU network address for the node

##### !! version

!type string | null

The software version of the node, or `null` if the version information is not
available

</APIMethod>
---
title: getEpochInfo
hideTableOfContents: true
h1: getEpochInfo RPC Method
---

Returns information about the current epoch

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getEpochInfo",
  "params": [
    // !hover(1:3) 0
    {
      // !hover commitment
      "commitment": "finalized"
    }
  ]
}
```

```ts !!request title="Kit"
import { createSolanaRpc } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

let epochInfo = await rpc.getEpochInfo().send();

console.log(epochInfo);
```

```ts !!request title="web3.js"
import { Connection, clusterApiUrl } from "@solana/web3.js";

const connection = new Connection(clusterApiUrl("devnet"), "confirmed");

let epochInfo = await connection.getEpochInfo();

console.log(epochInfo);
```

```rs !!request title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::commitment_config::CommitmentConfig;

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

    let epoch_info = client.get_epoch_info().await?;

    println!("{:#?}", epoch_info);

    Ok(())
}
```

### !params

#### !! 0

!type object

Configuration object.

##### !! commitment

!type string

The commitment describes how finalized a block is at that point in time. See
[Configuring State Commitment](/docs/rpc#configuring-state-commitment).

##### !! minContextSlot

!type number

The minimum slot that the request can be evaluated at.

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover(1:8) result
  "result": {
    // !hover absoluteSlot
    "absoluteSlot": 166598,
    // !hover blockHeight
    "blockHeight": 166500,
    // !hover epoch
    "epoch": 27,
    // !hover slotIndex
    "slotIndex": 2790,
    // !hover slotsInEpoch
    "slotsInEpoch": 8192,
    // !hover transactionCount
    "transactionCount": 22661093
  },
  "id": 1
}
```

!type object

The result field will be an object with the following fields:

##### !! absoluteSlot

!type u64

The current slot

##### !! blockHeight

!type u64

The current block height

##### !! epoch

!type u64

The current epoch

##### !! slotIndex

!type u64

The current slot relative to the start of the current epoch

##### !! slotsInEpoch

!type u64

The number of slots in this epoch

##### !! transactionCount

!type u64 | null

Total number of transactions processed without error since genesis

</APIMethod>
---
title: getEpochSchedule
hideTableOfContents: true
h1: getEpochSchedule RPC Method
---

Returns the epoch schedule information from this cluster

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getEpochSchedule"
}
```

```ts !!request title="Kit"
import { createSolanaRpc } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

let epochSchedule = await rpc.getEpochSchedule().send();

console.log(epochSchedule);
```

```ts !!request title="web3.js"
import { Connection, clusterApiUrl } from "@solana/web3.js";

const connection = new Connection(clusterApiUrl("devnet"), "confirmed");

let epochSchedule = await connection.getEpochSchedule();

console.log(epochSchedule);
```

```rs !!request title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::commitment_config::CommitmentConfig;

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

    let epoch_schedule = client.get_epoch_schedule().await?;

    println!("{:#?}", epoch_schedule);

    Ok(())
}
```

### !params

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover(1:7) result
  "result": {
    // !hover firstNormalEpoch
    "firstNormalEpoch": 8,
    // !hover firstNormalSlot
    "firstNormalSlot": 8160,
    // !hover leaderScheduleSlotOffset
    "leaderScheduleSlotOffset": 8192,
    // !hover slotsPerEpoch
    "slotsPerEpoch": 8192,
    // !hover warmup
    "warmup": true
  },
  "id": 1
}
```

!type object

The result field will be an object with the following fields:

##### !! firstNormalEpoch

!type u64

First normal-length epoch, `log2(slotsPerEpoch) - log2(MINIMUM_SLOTS_PER_EPOCH)`

##### !! firstNormalSlot

!type u64

Minimum number of slots in an epoch,
`MINIMUM_SLOTS_PER_EPOCH * (2.pow(firstNormalEpoch) - 1)`

##### !! leaderScheduleSlotOffset

!type u64

The number of slots before beginning of an epoch to calculate a leader schedule
for that epoch.

##### !! slotsPerEpoch

!type u64

The maximum number of slots in each epoch.

##### !! warmup

!type bool

Whether epochs start short and grow.

</APIMethod>
---
title: getFeeForMessage
hideTableOfContents: true
h1: getFeeForMessage RPC Method
---

Get the fee the network will charge for a particular Message

<Callout type="warn" title={"Version Restriction"}>
  This method is only available in `solana-core` v1.9 or newer. Please use
  [getFees](/docs/rpc/deprecated/getfees) for `solana-core` v1.8 and below.
</Callout>

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getFeeForMessage",
  "params": [
    // !hover message
    "AQABAgIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQAA",
    // !hover(1:3) 1
    {
      // !hover commitment
      "commitment": "processed"
    }
  ]
}
```

```ts !!request title="Kit"
import {
  createSolanaRpc,
  getBase64Encoder,
  type TransactionMessageBytesBase64,
} from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

// !hover message
let message =
  "AQABAgIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQAA";

let fee = await rpc
  .getFeeForMessage(message as TransactionMessageBytesBase64)
  .send();

console.log(fee);
```

```ts !!request title="web3.js"
import { Connection, Message, clusterApiUrl } from "@solana/web3.js";

const connection = new Connection(clusterApiUrl("devnet"), "confirmed");

// !hover message
let b64Message =
  "AQABAgIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQAA";
let message = Message.from(Buffer.from(b64Message, "base64"));

let fee = await connection.getFeeForMessage(message);

console.log(fee);
```

```rs !!request title="Rust"
use anyhow::Result;
use base64::{Engine as _, engine::general_purpose};

use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{commitment_config::CommitmentConfig, message::Message};

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

    // !hover message
    let base_64_message = "AQABAgIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQAA";
    let bytes = general_purpose::STANDARD.decode(base_64_message).unwrap();
    let message: Message = bincode::deserialize(&bytes).unwrap();

    let fee = client.get_fee_for_message(&message).await?;

    println!("{:#?}", fee);

    Ok(())
}
```

### !params

#### !! message

!type string
!required

Base-64 encoded Message

#### !! 1

!type object

Configuration object.

##### !! commitment

!type string

The commitment describes how finalized a block is at that point in time. See
[Configuring State Commitment](/docs/rpc#configuring-state-commitment).

##### !! minContextSlot

!type number

The minimum slot that the request can be evaluated at.

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  "result": {
    "context": { "slot": 5068 },
    // !hover result
    "value": 5000
  },
  "id": 1
}
```

!type u64 | null

Fee corresponding to the message at the specified blockhash

</APIMethod>
---
title: getFirstAvailableBlock
hideTableOfContents: true
h1: getFirstAvailableBlock RPC Method
---

Returns the slot of the lowest confirmed block that has not been purged from the
ledger

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getFirstAvailableBlock"
}
```

```ts !!request title="Kit"
import { createSolanaRpc } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

let firstAvailableBlock = await rpc.getFirstAvailableBlock().send();

console.log(firstAvailableBlock);
```

```ts !!request title="web3.js"
import { Connection, clusterApiUrl } from "@solana/web3.js";

const connection = new Connection(clusterApiUrl("devnet"), "confirmed");

let firstAvailableBlock = await connection.getFirstAvailableBlock();

console.log(firstAvailableBlock);
```

```rs !!request title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::commitment_config::CommitmentConfig;

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

    let first_available_block = client.get_first_available_block().await?;

    println!("{:#?}", first_available_block);

    Ok(())
}
```

### !params

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover result
  "result": 250000,
  "id": 1
}
```

!type u64

Slot

</APIMethod>
---
title: getGenesisHash
hideTableOfContents: true
h1: getGenesisHash RPC Method
---

Returns the genesis hash

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getGenesisHash"
}
```

```ts !!request title="Kit"
import { createSolanaRpc } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

let genesisHash = await rpc.getGenesisHash().send();

console.log(genesisHash);
```

```ts !!request title="web3.js"
import { Connection, clusterApiUrl } from "@solana/web3.js";

const connection = new Connection(clusterApiUrl("devnet"), "confirmed");

let genesisHash = await connection.getGenesisHash();

console.log(genesisHash);
```

```rs !!request title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::commitment_config::CommitmentConfig;

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

    let genesis_hash = client.get_genesis_hash().await?;

    println!("{:#?}", genesis_hash);

    Ok(())
}
```

### !params

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover result
  "result": "GH7ome3EiwEr7tu9JuTh2dpYWBJK3z69Xm1ZE3MEE6JC",
  "id": 1
}
```

!type string

A Hash as base-58 encoded string

</APIMethod>
---
title: getHealth
hideTableOfContents: true
h1: getHealth RPC Method
---

Returns the current health of the node. A healthy node is one that is within
`HEALTH_CHECK_SLOT_DISTANCE` slots of the latest cluster confirmed slot.

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getHealth"
}
```

```ts !!request title="Kit"
import { createSolanaRpc } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

let health = await rpc.getHealth().send();

console.log(health);
```

```rs !!request title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::commitment_config::CommitmentConfig;

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

    let health = client.get_health().await?;

    println!("{:#?}", health);

    Ok(())
}
```

### !params

### !!result Healthy

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover result
  "result": "ok",
  "id": 1
}
```

!type string

If the node is healthy: "ok"

### !!result Unhealthy

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover(1:5) result
  "error": {
    "code": -32005,
    "message": "Node is unhealthy",
    "data": { "numSlotsBehind": 42 }
  },
  "id": 1
}
```

!type object

If the node is unhealthy, a JSON RPC error response is returned. The specifics
of the error response are **UNSTABLE** and may change in the future

</APIMethod>
---
title: getHighestSnapshotSlot
hideTableOfContents: true
h1: getHighestSnapshotSlot RPC Method
---

Returns the highest slot information that the node has snapshots for.

This will find the highest full snapshot slot, and the highest incremental
snapshot slot _based on_ the full snapshot slot, if there is one.

<Callout type="warn" title={"Version Restriction"}>
  This method is only available in `solana-core` v1.9 or newer. Please use
  [getSnapshotSlot](/docs/rpc/http/getsnapshotslot) for `solana-core` v1.8 and
  below.
</Callout>

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getHighestSnapshotSlot"
}
```

```ts !!request title="Kit"
import { createSolanaRpc } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

let hightestSnapshotSlot = await rpc.getHighestSnapshotSlot().send();

console.log(hightestSnapshotSlot);
```

```rs !!request title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::commitment_config::CommitmentConfig;

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

    let highest_snapshot_slot = client.get_highest_snapshot_slot().await?;

    println!("{:#?}", highest_snapshot_slot);

    Ok(())
}
```

### !params

### !!result Snapshot

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover(1:4) result
  "result": {
    // !hover full
    "full": 100,
    // !hover incremental
    "incremental": 110
  },
  "id": 1
}
```

!type object

When the node has a snapshot, this returns a JSON object with the following
fields:

##### !! full

!type u64

The highest full snapshot slot

##### !! incremental

!type u64 | null

The highest incremental snapshot slot _based on_ `full`

### !!result No Snapshot

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover(1:4) result
  "error": {
    "code": -32008,
    "message": "No snapshot"
  },
  "id": 1
}
```

!type object

If the node has no snapshot, a JSON RPC error response is returned.

</APIMethod>
---
title: getIdentity
hideTableOfContents: true
h1: getIdentity RPC Method
---

Returns the identity pubkey for the current node

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getIdentity"
}
```

```ts !!request title="Kit"
import { createSolanaRpc } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

let identity = await rpc.getIdentity().send();

console.log(identity);
```

```rs !!request title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::commitment_config::CommitmentConfig;

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

    let identity = client.get_identity().await?;

    println!("{:#?}", identity);

    Ok(())
}
```

### !params

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover(1:3) result
  "result": {
    // !hover identity
    "identity": "2r1F4iWqVcb8M1DbAjQuFpebkQHY9hcVU4WuW2DJBppN"
  },
  "id": 1
}
```

!type object

The result field will be a JSON object with the following fields:

##### !! identity

!type string

The identity pubkey of the current node (as a base-58 encoded string)

</APIMethod>
---
title: getInflationGovernor
hideTableOfContents: true
h1: getInflationGovernor RPC Method
---

Returns the current inflation governor

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getInflationGovernor",
  "params": [
    // !hover(1:3) 0
    {
      // !hover commitment
      "commitment": "finalized"
    }
  ]
}
```

```ts !!request title="Kit"
import { createSolanaRpc, type Commitment } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

// !hover commitment
let commitment: Commitment = "finalized";
let inflationGovener = await rpc.getInflationGovernor({ commitment }).send();

console.log(inflationGovener);
```

```ts !!request title="web3.js"
import { Connection, clusterApiUrl } from "@solana/web3.js";

const connection = new Connection(clusterApiUrl("devnet"), "confirmed");

// !hover commitment
let commitment = "finalized";
let inflationGovener = await connection.getInflationGovernor();

console.log(inflationGovener);
```

```rs !!request title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::commitment_config::CommitmentConfig;

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

    let inflation_govener = client.get_inflation_governor().await?;

    println!("{:#?}", inflation_govener);

    Ok(())
}
```

### !params

#### !! 0

!type object

Configuration object.

##### !! commitment

!type string

The commitment describes how finalized a block is at that point in time. See
[Configuring State Commitment](/docs/rpc#configuring-state-commitment).

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover(1:7) result
  "result": {
    // !hover foundation
    "foundation": 0.05,
    // !hover foundationTerm
    "foundationTerm": 7,
    // !hover initial
    "initial": 0.15,
    // !hover taper
    "taper": 0.15,
    // !hover terminal
    "terminal": 0.015
  },
  "id": 1
}
```

!type object

The result field will be a JSON object with the following fields:

##### !! foundation

!type f64

Percentage of total inflation allocated to the foundation

##### !! foundationTerm

!type f64

Duration of foundation pool inflation in years

##### !! initial

!type f64

Initial inflation percentage from time 0

##### !! taper

!type f64

Rate per year at which inflation is lowered. (Rate reduction is derived using
the target slot time in genesis config)

##### !! terminal

!type f64

Terminal inflation percentage

</APIMethod>
---
title: getInflationRate
hideTableOfContents: true
h1: getInflationRate RPC Method
---

Returns the specific inflation values for the current epoch

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getInflationRate"
}
```

```ts !!request title="Kit"
import { createSolanaRpc } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

let inflationRate = await rpc.getInflationRate().send();

console.log(inflationRate);
```

```ts !!request title="web3.js"
import { Connection, clusterApiUrl } from "@solana/web3.js";

const connection = new Connection(clusterApiUrl("devnet"), "confirmed");

let inflationRate = await connection.getInflationRate();

console.log(inflationRate);
```

```rs !!request title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::commitment_config::CommitmentConfig;

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

    let inflation_rate = client.get_inflation_rate().await?;

    println!("{:#?}", inflation_rate);

    Ok(())
}
```

### !params

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover(1:6) result
  "result": {
    // !hover total
    "total": 0.149,
    // !hover validator
    "validator": 0.148,
    // !hover foundation
    "foundation": 0.001,
    // !hover epoch
    "epoch": 100
  },
  "id": 1
}
```

!type object

The result field will be a JSON object with the following fields:

##### !! total

!type f64

Total inflation

##### !! validator

!type f64

Inflation allocated to validators

##### !! foundation

!type f64

Inflation allocated to the foundation

##### !! epoch

!type u64

Epoch for which these values are valid

</APIMethod>
---
title: getInflationReward
hideTableOfContents: true
h1: getInflationReward RPC Method
---

Returns the inflation / staking reward for a list of addresses for an epoch

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getInflationReward",
  "params": [
    // !hover(1:4) 0
    [
      "6dmNQ5jwLeLk5REvio1JcMshcbvkYMwy26sJ8pbkvStu",
      "BGsqMegLpV6n6Ve146sSX2dTjUMj3M92HnU8BbNRMhF2"
    ],
    // !hover(1:3) 1
    {
      // !hover epoch
      "epoch": 800,
      // !hover commitment
      "commitment": "finalized"
    }
  ]
}
```

```ts !!request title="Kit"
import { address, createSolanaRpc } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

// !hover(1:4) 0
let addresses = [
  address("6dmNQ5jwLeLk5REvio1JcMshcbvkYMwy26sJ8pbkvStu"),
  address("BGsqMegLpV6n6Ve146sSX2dTjUMj3M92HnU8BbNRMhF2"),
];

// !hover epoch
let epoch = BigInt(2);

let inflationReward = await rpc.getInflationReward(addresses, { epoch }).send();

console.log(inflationReward);
```

```ts !!request title="web3.js"
import { Connection, PublicKey, clusterApiUrl } from "@solana/web3.js";

const connection = new Connection(clusterApiUrl("devnet"), "confirmed");

// !hover(1:4) 0
let addresses = [
  new PublicKey("6dmNQ5jwLeLk5REvio1JcMshcbvkYMwy26sJ8pbkvStu"),
  new PublicKey("BGsqMegLpV6n6Ve146sSX2dTjUMj3M92HnU8BbNRMhF2"),
];

// !hover epoch
let epoch = 2;

let inflationReward = await connection.getInflationReward(addresses, epoch);

console.log(inflationReward);
```

```rs !!request title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{commitment_config::CommitmentConfig, pubkey};

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

    // !hover(1:4) 0
    let addresses = [
        pubkey!("6dmNQ5jwLeLk5REvio1JcMshcbvkYMwy26sJ8pbkvStu"),
        pubkey!("BGsqMegLpV6n6Ve146sSX2dTjUMj3M92HnU8BbNRMhF2"),
    ];

    // !hover epoch
    let epoch = 2;

    let inflation_reward = client.get_inflation_reward(&addresses, Some(epoch)).await?;

    println!("{:#?}", inflation_reward);

    Ok(())
}
```

### !params

#### !! 0

!type array

An array of addresses to query, as base-58 encoded strings

#### !! 1

!type object

Configuration object containing the following fields:

##### !! commitment

!type string

The commitment describes how finalized a block is at that point in time. See
[Configuring State Commitment](/docs/rpc#configuring-state-commitment).

##### !! epoch

!type u64

An epoch for which the reward occurs. If omitted, the previous epoch will be
used

##### !! minContextSlot

!type number

The minimum slot that the request can be evaluated at

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover(1:9) result
  "result": [
    {
      // !hover epoch
      "epoch": 2,
      // !hover effectiveSlot
      "effectiveSlot": 224,
      // !hover amount
      "amount": 2500,
      // !hover postBalance
      "postBalance": 499999442500
    },
    null
  ],
  "id": 1
}
```

!type array

The result field will be a JSON array of objects containing:

##### !! epoch

!type u64

Epoch for which reward occurred

##### !! effectiveSlot

!type u64

The slot in which the rewards are effective

##### !! amount

!type u64

Reward amount in lamports

##### !! postBalance

!type u64

Post balance of the account in lamports

##### !! commission

!type u8 | undefined

Vote account commission when the reward was credited

</APIMethod>
---
title: getLargestAccounts
hideTableOfContents: true
h1: getLargestAccounts RPC Method
---

Returns the 20 largest accounts, by lamport balance (results may be cached up to
two hours)

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getLargestAccounts",
  "params": [
    // !hover(1:3) 0
    {
      // !hover commitment
      "commitment": "finalized"
    }
  ]
}
```

```ts !!request title="Kit"
import { createSolanaRpc } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

let largestAccounts = await rpc.getLargestAccounts().send();

console.log(largestAccounts);
```

```ts !!request title="web3.js"
import {
  Connection,
  clusterApiUrl,
  type GetLargestAccountsConfig,
} from "@solana/web3.js";

const connection = new Connection(clusterApiUrl("devnet"), "confirmed");

// !hover(1:4) 0
let config: GetLargestAccountsConfig = {
  // !hover commitment
  commitment: "finalized",
  // !hover filter
  filter: "circulating",
};

let largestAccounts = await connection.getLargestAccounts(config);

console.log(largestAccounts);
```

```rs !!request title="Rust"
use anyhow::Result;
use solana_client::{
    nonblocking::rpc_client::RpcClient,
    rpc_config::{RpcLargestAccountsConfig, RpcLargestAccountsFilter},
};
use solana_sdk::commitment_config::CommitmentConfig;

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

    // !hover(1:5) 0
    let config = RpcLargestAccountsConfig {
        // !hover commitment
        commitment: CommitmentConfig::finalized().into(),
        // !hover filter
        filter: RpcLargestAccountsFilter::Circulating.into(),
        sort_results: true.into(),
    };
    let largest_accounts = client.get_largest_accounts_with_config(config).await?;

    println!("{:#?}", largest_accounts);

    Ok(())
}
```

### !params

#### !! 0

!type object

Configuration object containing the following fields:

##### !! commitment

!type string

The commitment describes how finalized a block is at that point in time. See
[Configuring State Commitment](/docs/rpc#configuring-state-commitment).

##### !! filter

!type string
!values circulating nonCirculating

Filter results by account type

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  "result": {
    "context": { "slot": 54 },
    "value": [
      {
        // !hover address
        "address": "99P8ZgtJYe1buSK8JXkvpLh8xPsCFuLYhz9hQFNw93WJ",
        // !hover lamports
        "lamports": 999974
      },
      {
        "address": "uPwWLo16MVehpyWqsLkK3Ka8nLowWvAHbBChqv2FZeL",
        "lamports": 42
      }
    ]
  },
  "id": 1
}
```

!type array

The result will be an RpcResponse JSON object with `value` equal to an array of
objects containing:

##### !! address

!type string

Base-58 encoded address of the account

##### !! lamports

!type u64

Number of lamports in the account

</APIMethod>
---
title: getLatestBlockhash
hideTableOfContents: true
h1: getLatestBlockhash RPC Method
---

Returns the latest blockhash

<Callout type="warn" title={"Version Restriction"}>
  This method is only available in `solana-core` v1.9 or newer. Please use
  [getRecentBlockhash](/docs/rpc/http/getrecentblockhash) for `solana-core` v1.8
  and below.
</Callout>

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getLatestBlockhash",
  "params": [
    // !hover(1:3) 0
    {
      // !hover commitment
      "commitment": "processed"
    }
  ]
}
```

```ts !!request title="Kit"
import { createSolanaRpc, type Commitment } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

// !hover commitment
let commitment: Commitment = "processed";
let latestBlockhash = await rpc.getLatestBlockhash({ commitment }).send();

console.log(latestBlockhash);
```

```ts !!request title="web3.js"
import { Connection, clusterApiUrl, type Commitment } from "@solana/web3.js";

const connection = new Connection(clusterApiUrl("devnet"), "confirmed");

// !hover commitment
let commitment: Commitment = "processed";
let latestBlockhash = await connection.getLatestBlockhash(commitment);

console.log(latestBlockhash);
```

```rs !!request title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::commitment_config::CommitmentConfig;

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

    // !hover commitment
    let commitment = CommitmentConfig::processed();
    let latest_blockhash = client
        .get_latest_blockhash_with_commitment(commitment)
        .await?;

    println!("{:#?}", latest_blockhash);

    Ok(())
}
```

### !params

#### !! 0

!type object

Configuration object containing the following fields:

##### !! commitment

!type string

The commitment describes how finalized a block is at that point in time. See
[Configuring State Commitment](/docs/rpc#configuring-state-commitment).

##### !! minContextSlot

!type number

The minimum slot that the request can be evaluated at

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  "result": {
    "context": {
      "slot": 2792
    },
    // !hover(1:4) result
    "value": {
      // !hover blockhash
      "blockhash": "EkSnNWid2cvwEVnVx9aBqawnmiCNiDgp3gUdkDPTKN1N",
      // !hover lastValidBlockHeight
      "lastValidBlockHeight": 3090
    }
  },
  "id": 1
}
```

!type object

RpcResponse JSON object with `value` field set to a JSON object including:

##### !! blockhash

!type string

A Hash as base-58 encoded string

##### !! lastValidBlockHeight

!type u64

Last [block height](/docs/references/terminology#block-height) at which the
blockhash will be valid

</APIMethod>
---
title: getLeaderSchedule
hideTableOfContents: true
h1: getLeaderSchedule RPC Method
---

Returns the leader schedule for an epoch

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getLeaderSchedule",
  "params": [
    // !hover slot number
    null,
    // !hover(1:3) 1
    {
      // !hover commitment
      "commitment": "processed",
      // !hover identity
      "identity": "dv2eQHeP4RFrJZ6UeiZWoc3XTtmtZCUKxxCApCDcRNV"
    }
  ]
}
```


```ts !!request title="Kit"
import { address, createSolanaRpc, type Commitment } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

// !hover slot number
let slotNumber = null;

// !hover identity
let identity = address("dv1ZAGvdsz5hHLwWXsVnM94hWf1pjbKVau1QVkaMJ92");
// !hover commitment
let commitment: Commitment = "finalized";

let leaderSchedule = await rpc
  .getLeaderSchedule(slotNumber, { identity, commitment })
  .send();

console.log(leaderSchedule);
```

```ts !!request title="web3.js"
import { Connection, clusterApiUrl } from "@solana/web3.js";

const connection = new Connection(clusterApiUrl("devnet"), "confirmed");

let leaderSchedule = await connection.getLeaderSchedule();

console.log(leaderSchedule);
```

```rs !!request title="Rust"
use anyhow::Result;
use solana_client::{nonblocking::rpc_client::RpcClient, rpc_config::RpcLeaderScheduleConfig};
use solana_sdk::commitment_config::CommitmentConfig;

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

    // !hover slot number
    let slot_number = None;
    // !hover(1:4) 1
    let config = RpcLeaderScheduleConfig {
        // !hover identity
        identity: String::from("dv1ZAGvdsz5hHLwWXsVnM94hWf1pjbKVau1QVkaMJ92").into(),
        // !hover commitment
        commitment: CommitmentConfig::finalized().into(),
    };
    let leader_schedule = client
        .get_leader_schedule_with_config(slot_number, config)
        .await?;

    println!("{:#?}", leader_schedule);

    Ok(())
}
```

### !params

#### !! slot number

!type u64

Fetch the leader schedule for the epoch that corresponds to the provided slot.
If unspecified, the leader schedule for the current epoch is fetched.

#### !! 1

!type object

Configuration object containing the following fields:

##### !! commitment

!type string

The commitment describes how finalized a block is at that point in time. See
[Configuring State Commitment](/docs/rpc#configuring-state-commitment).

##### !! identity

!type string

Only return results for this validator identity (base-58 encoded)

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover(1:8) result
  "result": {
    "4Qkev8aNZcqFNSRhQzwyLMFSsi94jHqE8WNVTJzTP99F": [
      0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
      21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,
      39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56,
      57, 58, 59, 60, 61, 62, 63
    ]
  },
  "id": 1
}
```

!type object | null

Returns `null` if requested epoch is not found, otherwise returns an object
where:

- Keys are validator identities (as base-58 encoded strings)
- Values are arrays of leader slot indices relative to the first slot in the
  requested epoch

</APIMethod>
---
title: getMaxRetransmitSlot
hideTableOfContents: true
h1: getMaxRetransmitSlot RPC Method
---

Get the max slot seen from retransmit stage.

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getMaxRetransmitSlot"
}
```

```ts !!request title="Kit"
import { createSolanaRpc } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

let maxRetransmitSlot = await rpc.getMaxRetransmitSlot().send();

console.log(maxRetransmitSlot);
```

```rs !!request title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::commitment_config::CommitmentConfig;

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

    let max_retransmit_slot = client.get_max_retransmit_slot().await?;

    println!("{:#?}", max_retransmit_slot);

    Ok(())
}
```

### !params

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover result
  "result": 1234,
  "id": 1
}
```

!type u64

Slot number

</APIMethod>
---
title: getMaxShredInsertSlot
hideTableOfContents: true
h1: getMaxShredInsertSlot RPC Method
---

Get the max slot seen from after shred insert.

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getMaxShredInsertSlot"
}
```

```ts !!request title="Kit"
import { createSolanaRpc } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

let maxShredInsertSlot = await rpc.getMaxShredInsertSlot().send();

console.log(maxShredInsertSlot);
```

```rs !!request title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::commitment_config::CommitmentConfig;

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

    let max_shred_insert_slot = client.get_max_shred_insert_slot().await?;

    println!("{:#?}", max_shred_insert_slot);

    Ok(())
}
```

### !params

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover result
  "result": 1234,
  "id": 1
}
```

!type u64

Slot number

</APIMethod>
---
title: getMinimumBalanceForRentExemption
hideTableOfContents: true
h1: getMinimumBalanceForRentExemption RPC Method
---

Returns minimum balance required to make account rent exempt.

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getMinimumBalanceForRentExemption",
  "params": [
    // !hover length
    50,
    // !hover(1:3) 1
    {
      // !hover commitment
      "commitment": "processed",
    }
  ]
}
```

```ts !!request title="Kit"
import { createSolanaRpc } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

// !hover length
let dataLength = BigInt(50);
let minBalForRentExemption = await rpc
  .getMinimumBalanceForRentExemption(dataLength)
  .send();

console.log(minBalForRentExemption);
```

```ts !!request title="web3.js"
import { Connection, clusterApiUrl } from "@solana/web3.js";

const connection = new Connection(clusterApiUrl("devnet"), "confirmed");

// !hover length
let dataLength = 50;
let minBalForRentExemption =
  await connection.getMinimumBalanceForRentExemption(dataLength);

console.log(minBalForRentExemption);
```

```rs !!request title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::commitment_config::CommitmentConfig;

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

    // !hover length
    let data_len = 50;

    let min_bal_for_rent_exemption = client
        .get_minimum_balance_for_rent_exemption(data_len)
        .await?;

    println!("{:#?}", min_bal_for_rent_exemption);

    Ok(())
}
```

### !params

#### !! length

!type usize
!required

The Account's data length

#### !! 1

!type object

Configuration object containing the following fields:

##### !! commitment

!type string

The commitment describes how finalized a block is at that point in time. See
[Configuring State Commitment](/docs/rpc#configuring-state-commitment).

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover result
  "result": 500,
  "id": 1
}
```

!type u64

Minimum lamports required in the Account to remain rent free

</APIMethod>
---
title: getMultipleAccounts
hideTableOfContents: true
h1: getMultipleAccounts RPC Method
---

Returns the account information for a list of Pubkeys.

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getMultipleAccounts",
  "params": [
    // !hover(1:4) 0
    [
      "vines1vzrYbzLMRdu58ou5XTby4qAqVRLmqo36NKPTg",
      "4fYNw3dojWmQ4dXtSGE9epjRGy9pFSx62YypT7avPYvA"
    ],
    // !hover(1:3) 1
    {
      // !hover encoding
      "encoding": "base58",
      // !hover commitment
      "commitment": "finalized"
    }
  ]
}
```

```ts !!request title="Kit"
import { address, createSolanaRpc } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

// !hover(1:4) 0
let addresses = [
  address("vines1vzrYbzLMRdu58ou5XTby4qAqVRLmqo36NKPTg"),
  address("4fYNw3dojWmQ4dXtSGE9epjRGy9pFSx62YypT7avPYvA"),
];

// !hover(1:3) 1
let config = {
  // !hover encoding
  encoding: "base58",
  // !hover commitment
  commitment: "finalized",
};

let accounts = await rpc.getMultipleAccounts(addresses, config).send();

console.log(accounts);
```

```ts !!request title="web3.js"
import {
  Connection,
  PublicKey,
  clusterApiUrl,
  type GetMultipleAccountsConfig,
} from "@solana/web3.js";

const connection = new Connection(clusterApiUrl("devnet"), "confirmed");

// !hover(1:4) 0
let addresses = [
  new PublicKey("vines1vzrYbzLMRdu58ou5XTby4qAqVRLmqo36NKPTg"),
  new PublicKey("4fYNw3dojWmQ4dXtSGE9epjRGy9pFSx62YypT7avPYvA"),
];

// !hover(1:3) 1
let config: GetMultipleAccountsConfig = {
  // !hover commitment
  commitment: "finalized",
};

let accounts = await connection.getMultipleAccountsInfo(addresses, config);

console.log(accounts);
```

```rs !!request title="Rust"
use anyhow::Result;
use solana_account_decoder::UiAccountEncoding;
use solana_client::{nonblocking::rpc_client::RpcClient, rpc_config::RpcAccountInfoConfig};
use solana_sdk::{commitment_config::CommitmentConfig, pubkey};

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

    // !hover(1:4) 0
    let addresses = [
        pubkey!("vines1vzrYbzLMRdu58ou5XTby4qAqVRLmqo36NKPTg"),
        pubkey!("4fYNw3dojWmQ4dXtSGE9epjRGy9pFSx62YypT7avPYvA"),
    ];

    // !hover(1:6) 1
    let config = RpcAccountInfoConfig {
        // !hover encoding
        encoding: UiAccountEncoding::Base58.into(),
        // !hover dataSlice
        data_slice: None,
        // !hover commitment
        commitment: CommitmentConfig::finalized().into(),
        // !hover minContextSlot
        min_context_slot: None,
    };

    let accounts = client
        .get_multiple_accounts_with_config(&addresses, config)
        .await?;

    println!("{:#?}", accounts);

    Ok(())
}
```

### !params

#### !! 0

!type array
!required

An array of Pubkeys to query, as base-58 encoded strings (up to a maximum
of 100)

#### !! 1

!type object

Configuration object containing the following fields:

##### !! commitment

!type string

The commitment describes how finalized a block is at that point in time. See
[Configuring State Commitment](/docs/rpc#configuring-state-commitment).

##### !! minContextSlot

!type number

The minimum slot that the request can be evaluated at

##### !! dataSlice

!type object

Request a slice of the account's data.

- `length: <usize>` - number of bytes to return
- `offset: <usize>` - byte offset from which to start reading

<Callout type="info">
  Data slicing is only available for `base58`, `base64`, or `base64+zstd`
  encodings.
</Callout>

##### !! encoding

!type string
!values jsonParsed base58 base64 base64+zstd
!default base64

Encoding format for the returned Account data

- `base58` is slow and limited to less than 129 bytes of Account data.
- `base64` will return base64 encoded data for Account data of any size.
- `base64+zstd` compresses the Account data using
  [Zstandard](https://facebook.github.io/zstd/) and base64-encodes the result.
- `jsonParsed` encoding attempts to use program-specific state parsers to return
  more human-readable and explicit account state data.
- If `jsonParsed` is requested but a parser cannot be found, the field falls
  back to `base64` encoding, detectable when the `data` field is type
  `<string>`.

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  "result": {
    "context": { "apiVersion": "2.0.15", "slot": 341197247 },
    // !hover(1:18) result
    "value": [
      {
        // !hover data
        "data": ["", "base58"],
        // !hover executable
        "executable": false,
        // !hover lamports
        "lamports": 88849814690250,
        // !hover owner
        "owner": "11111111111111111111111111111111",
        // !hover rentEpoch
        "rentEpoch": 18446744073709551615,
        // !hover space
        "space": 0
      },
      {
        "data": ["", "base58"],
        "executable": false,
        "lamports": 998763433,
        "owner": "2WRuhE4GJFoE23DYzp2ij6ZnuQ8p9mJeU6gDgfsjR4or",
        "rentEpoch": 18446744073709551615,
        "space": 0
      }
    ]
  },
  "id": 1
}
```

!type array

The result will be an array containing either:

- `null` - if the account at that Pubkey doesn't exist, or
- Account objects with the following fields:

##### !! data

!type [string,encoding] | object

Data associated with the account, either as encoded binary data or JSON format
`{<program>: <state>}` - depending on encoding parameter

##### !! executable

!type bool

Boolean indicating if the account contains a program (and is strictly read-only)

##### !! lamports

!type u64

Number of lamports assigned to this account

##### !! owner

!type string

Base-58 encoded Pubkey of the program this account has been assigned to

##### !! rentEpoch

!type u64

The epoch at which this account will next owe rent

##### !! space

!type u64

The data size of the account

</APIMethod>
---
title: getProgramAccounts
hideTableOfContents: true
h1: getProgramAccounts RPC Method
---

Returns all accounts owned by the provided program Pubkey

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getProgramAccounts",
  "params": [
    // !hover pubkey
    "4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T",
    // !hover(1:11) 1
    {
      // !hover commitment
      "commitment": "finalized",
      // !hover(1:9) filters
      "filters": [
        { "dataSize": 17 },
        {
          "memcmp": {
            "offset": 4,
            "bytes": "3Mc6vR"
          }
        }
      ]
    }
  ]
}
```

```ts !!request title="Kit"
import { address, createSolanaRpc } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

// !hover pubkey
let program = address("4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T");

let accounts = await rpc
  .getProgramAccounts(
    program,
    // !hover(1:15) 1
    {
      // !hover commitment
      commitment: "finalized",
      // !hover(1:12) filters
      filters: [
        {
          dataSize: BigInt(17),
        },
        {
          memcmp: {
            bytes: "3Mc6vR",
            offset: BigInt(4),
          },
        },
      ],
    },
  )
  .send();

console.log(accounts);
```

```ts !!request title="web3.js"
import {
  Connection,
  PublicKey,
  clusterApiUrl,
  type GetProgramAccountsConfig,
} from "@solana/web3.js";

const connection = new Connection(clusterApiUrl("devnet"), "confirmed");

// !hover pubkey
let programId = new PublicKey("4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T");

// !hover(1:15) 1
let config: GetProgramAccountsConfig = {
  // !hover commitment
  commitment: "finalized",
  // !hover(1:12) filters
  filters: [
    {
      dataSize: 17,
    },
    {
      memcmp: {
        bytes: "3Mc6vR",
        offset: 4,
      },
    },
  ],
};

let accounts = await connection.getProgramAccounts(programId, config);

console.log(accounts);
```

```rs !!request title="Rust"
use anyhow::Result;
use solana_client::{
    nonblocking::rpc_client::RpcClient,
    rpc_config::{RpcAccountInfoConfig, RpcProgramAccountsConfig},
    rpc_filter::{Memcmp, MemcmpEncodedBytes, RpcFilterType},
};
use solana_sdk::{commitment_config::CommitmentConfig, pubkey};

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

    // !hover pubkey
    let program = pubkey!("4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T");

    // !hover(1:18) 1
    let config = RpcProgramAccountsConfig {
        // !hover(1:8) filters
        filters: vec![
            RpcFilterType::DataSize(17),
            RpcFilterType::Memcmp(Memcmp::new(
                4,
                MemcmpEncodedBytes::Base64("3Mc6vR".to_string()),
            )),
        ]
        .into(),
        account_config: RpcAccountInfoConfig {
            // !hover encoding
            encoding: None,
            // !hover dataSlice
            data_slice: None,
            // !hover commitment
            commitment: None,
            // !hover minContextSlot
            min_context_slot: None,
        },
        // !hover withContext
        with_context: None,
        sort_results: true.into(),
    };

    let accounts = client
        .get_program_accounts_with_config(&program, config)
        .await?;

    println!("{:#?}", accounts);

    Ok(())
}

```

### !params

#### !! pubkey

!type string
!required

Pubkey of program, as base-58 encoded string

#### !! 1

!type object

Configuration object containing the following fields:

##### !! commitment

!type string

The commitment describes how finalized a block is at that point in time. See
[Configuring State Commitment](/docs/rpc#configuring-state-commitment).

##### !! minContextSlot

!type number

The minimum slot that the request can be evaluated at

##### !! withContext

!type bool

Wrap the result in an RpcResponse JSON object

##### !! encoding

!type string
!values jsonParsed base58 base64 base64+zstd
!default json

Encoding format for the returned Account data

- `base58` is slow and limited to less than 129 bytes of Account data.
- `base64` will return base64 encoded data for Account data of any size.
- `base64+zstd` compresses the Account data using
  [Zstandard](https://facebook.github.io/zstd/) and base64-encodes the result.
- `jsonParsed` encoding attempts to use program-specific state parsers to return
  more human-readable and explicit account state data.
- If `jsonParsed` is requested but a parser cannot be found, the field falls
  back to `base64` encoding, detectable when the `data` field is type
  `<string>`.

##### !! dataSlice

!type object

Request a slice of the account's data.

- `length: <usize>` - number of bytes to return
- `offset: <usize>` - byte offset from which to start reading

<Callout type="info">
  Data slicing is only available for `base58`, `base64`, or `base64+zstd`
  encodings.
</Callout>

##### !! filters

!type array

Filter results using up to 4 filter objects.

<Callout type="info">
  The resultant account(s) must meet **ALL** filter criteria to be included in
  the returned results
</Callout>

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover(1:12) result
  "result": [
    {
      // !hover pubkey
      "pubkey": "CxELquR1gPP8wHe33gZ4QxqGB3sZ9RSwsJ2KshVewkFY",
      // !hover(1:8) account
      "account": {
        // !hover data
        "data": "2R9jLfiAQ9bgdcw6h8s44439",
        // !hover executable
        "executable": false,
        // !hover lamports
        "lamports": 15298080,
        // !hover owner
        "owner": "4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T",
        // !hover rentEpoch
        "rentEpoch": 28,
        // !hover space
        "space": 42
      }
    }
  ],
  "id": 1
}
```

!type array

By default, returns an array of JSON objects. If `withContext` flag is set, the
array will be wrapped in an RpcResponse JSON object.

Each object contains:

##### !! pubkey

!type string

The account Pubkey as base-58 encoded string

##### !! account

!type object

A JSON object containing:

- `lamports: <u64>` - number of lamports assigned to this account, as a u64
- `owner: <string>` - base-58 encoded Pubkey of the program this account has
  been assigned to
- `data: <[string,encoding]|object>` - data associated with the account, either
  as encoded binary data or JSON format `{<program>: <state>}` - depending on
  encoding parameter
- `executable: <bool>` - boolean indicating if the account contains a program
  (and is strictly read-only)
- `rentEpoch: <u64>` - the epoch at which this account will next owe rent, as
  u64
- `space: <u64>` - the data size of the account

</APIMethod>
---
title: getRecentPerformanceSamples
hideTableOfContents: true
h1: getRecentPerformanceSamples RPC Method
---

Returns a list of recent performance samples, in reverse slot order. Performance
samples are taken every 60 seconds and include the number of transactions and
slots that occur in a given time window.

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getRecentPerformanceSamples",
  "params": [
    // !hover number of samples
    2
  ]
}
```

```ts !!request title="Kit"
import { createSolanaRpc } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

// !hover number of samples
let limit = 2;

let performanceSamples = await rpc.getRecentPerformanceSamples(limit).send();

console.log(performanceSamples);
```

```ts !!request title="web3.js"
import { Connection, clusterApiUrl } from "@solana/web3.js";

const connection = new Connection(clusterApiUrl("devnet"), "confirmed");

// !hover number of samples
let limit = 2;

let performanceSamples = await connection.getRecentPerformanceSamples(limit);

console.log(performanceSamples);
```

```rs !!request title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::commitment_config::CommitmentConfig;

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

// !hover number of samples
    let limit = 2;
    let performance_samples = client.get_recent_performance_samples(limit.into()).await?;

    println!("{:#?}", performance_samples);

    Ok(())
}
```

### !params

#### !! number of samples

!type usize

Number of samples to return (maximum 720)

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover(1:16) result
  "result": [
    {
      // !hover slot
      "slot": 348125,
      // !hover numTransactions
      "numTransactions": 126,
      // !hover numSlots
      "numSlots": 126,
      // !hover samplePeriodSecs
      "samplePeriodSecs": 60,
      // !hover numNonVoteTransactions
      "numNonVoteTransactions": 1
    },
    {
      "slot": 347999,
      "numTransactions": 126,
      "numSlots": 126,
      "samplePeriodSecs": 60,
      "numNonVoteTransactions": 1
    }
  ],
  "id": 1
}
```

!type array

An array of performance sample objects containing:

##### !! slot

!type u64

Slot in which sample was taken at

##### !! numTransactions

!type u64

Number of transactions processed during the sample period

##### !! numSlots

!type u64

Number of slots completed during the sample period

##### !! samplePeriodSecs

!type u16

Number of seconds in a sample window

##### !! numNonVoteTransactions

!type u64

Number of non-vote transactions processed during the sample period

<Callout type="info">
  `numNonVoteTransactions` is present starting with v1.15. To get a number of
  voting transactions compute: `numTransactions - numNonVoteTransactions`
</Callout>

</APIMethod>
---
title: getRecentPrioritizationFees
hideTableOfContents: true
h1: getRecentPrioritizationFees RPC Method
---

Returns a list of prioritization fees from recent blocks.

<Callout type="info">
  Currently, a node's prioritization-fee cache stores data from up to 150
  blocks.
</Callout>

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getRecentPrioritizationFees",
  "params": [
    // !hover address
    ["CxELquR1gPP8wHe33gZ4QxqGB3sZ9RSwsJ2KshVewkFY"]
  ]
}
```

```ts !!request title="Kit"
import { address, createSolanaRpc } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

// !hover address
let addresses = [address("CxELquR1gPP8wHe33gZ4QxqGB3sZ9RSwsJ2KshVewkFY")];
let prioritizationFees = await rpc
  .getRecentPrioritizationFees(addresses)
  .send();

console.log(prioritizationFees);
```

```ts !!request title="web3.js"
import { Connection, PublicKey, clusterApiUrl } from "@solana/web3.js";

const connection = new Connection(clusterApiUrl("devnet"), "confirmed");

// !hover address
let addresses = [new PublicKey("CxELquR1gPP8wHe33gZ4QxqGB3sZ9RSwsJ2KshVewkFY")];

let prioritizationFees = await connection.getRecentPrioritizationFees({
  lockedWritableAccounts: addresses,
});

console.log(prioritizationFees);
```

```rs !!request title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{commitment_config::CommitmentConfig, pubkey};

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

    // !hover address
    let addresses = [pubkey!("CxELquR1gPP8wHe33gZ4QxqGB3sZ9RSwsJ2KshVewkFY")];
    let prioritization_fees = client.get_recent_prioritization_fees(&addresses).await?;

    println!("{:#?}", prioritization_fees);

    Ok(())
}
```

### !params

#### !! address

!type array

An array of Account addresses (up to a maximum of 128 addresses), as base-58
encoded strings

<Callout type="info">
  If this parameter is provided, the response will reflect a fee to land a
  transaction locking all of the provided accounts as writable.
</Callout>

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover(1:22) result
  "result": [
    {
      // !hover slot
      "slot": 348125,
      // !hover prioritizationFee
      "prioritizationFee": 0
    },
    {
      "slot": 348126,
      "prioritizationFee": 1000
    },
    {
      "slot": 348127,
      "prioritizationFee": 500
    },
    {
      "slot": 348128,
      "prioritizationFee": 0
    },
    {
      "slot": 348129,
      "prioritizationFee": 1234
    }
  ],
  "id": 1
}
```

!type array

An array of prioritization fee objects containing:

##### !! slot

!type u64

Slot in which the fee was observed

##### !! prioritizationFee

!type u64

The per-compute-unit fee paid by at least one successfully landed transaction,
specified in increments of micro-lamports (0.000001 lamports)

</APIMethod>
---
title: getSignaturesForAddress
hideTableOfContents: true
h1: getSignaturesForAddress RPC Method
---

Returns signatures for confirmed transactions that include the given address in
their `accountKeys` list. Returns signatures backwards in time from the provided
signature or most recent confirmed block

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getSignaturesForAddress",
  "params": [
    // !hover address
    "Vote111111111111111111111111111111111111111",
    // !hover(1:6) 1
    {
      // !hover commitment
      "commitment": "finalized",
      // !hover limit
      "limit": 1
    }
  ]
}
```

```ts !!request title="Kit"
import { address, createSolanaRpc } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

// !hover address
let addr = address("Vote111111111111111111111111111111111111111");

// !hover(1:3) 1
let signaturesForConfig = {
  // !hover limit
  limit: 1,
};

let signatures = await rpc
  .getSignaturesForAddress(addr, signaturesForConfig)
  .send();

console.log(signatures);
```

```ts !!request title="web3.js"
import {
  Connection,
  PublicKey,
  clusterApiUrl,
  type SignaturesForAddressOptions,
} from "@solana/web3.js";

const connection = new Connection(clusterApiUrl("devnet"), "confirmed");

// !hover(1:3) 1
let signaturesOptions: SignaturesForAddressOptions = {
  // !hover limit
  limit: 1,
};

// !hover address
let address = new PublicKey("Vote111111111111111111111111111111111111111");
let signatures = await connection.getSignaturesForAddress(
  address,
  signaturesOptions,
);

console.log(signatures);
```

```rs !!request title="Rust"
use anyhow::Result;
use solana_client::{
    nonblocking::rpc_client::RpcClient, rpc_client::GetConfirmedSignaturesForAddress2Config,
};
use solana_sdk::{commitment_config::CommitmentConfig, pubkey};

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

    // !hover address
    let address = pubkey!("Vote111111111111111111111111111111111111111");

    // !hover(1:6) 1
    let signatures_for_config = GetConfirmedSignaturesForAddress2Config {
        // !hover before
        before: None,
        // !hover until
        until: None,
        // !hover limit
        limit: Some(1),
        // !hover commitment
        commitment: CommitmentConfig::finalized().into(),
    };

    let signatures = client
        .get_signatures_for_address_with_config(&address, signatures_for_config)
        .await?;

    println!("{:#?}", signatures);

    Ok(())
}
```

### !params

#### !! address

!type string
!required

Account address as base-58 encoded string

#### !! 1

!type object

Configuration object containing the following fields:

##### !! commitment

!type string

The commitment describes how finalized a block is at that point in time. See
[Configuring State Commitment](/docs/rpc#configuring-state-commitment).

##### !! minContextSlot

!type number

The minimum slot that the request can be evaluated at

##### !! limit

!type number

Maximum transaction signatures to return (between 1 and 1,000).

Default: `1000`

##### !! before

!type string

Start searching backwards from this transaction signature. If not provided the
search starts from the top of the highest max confirmed block.

##### !! until

!type string

Search until this transaction signature, if found before limit reached

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover(1:10) result
  "result": [
    {
      // !hover signature
      "signature": "5h6xBEauJ3PK6SWCZ1PGjBvj8vDdWG3KpwATGy1ARAXFSDwt8GFXM7W5Ncn16wmqokgpiKRLuS83KUxyZyv2sUYv",
      // !hover slot
      "slot": 114,
      // !hover err
      "err": null,
      // !hover memo
      "memo": null,
      // !hover blockTime
      "blockTime": null,
      // !hover confirmationStatus
      "confirmationStatus": "finalized"
    }
  ],
  "id": 1
}
```

!type array

An array of transaction signature information objects, ordered from **newest**
to **oldest** transaction, containing:

##### !! signature

!type string

Transaction signature as base-58 encoded string

##### !! slot

!type u64

The slot that contains the block with the transaction

##### !! err

!type object | null

Error if transaction failed, null if transaction succeeded. See
[TransactionError definitions](https://github.com/solana-labs/solana/blob/c0c60386544ec9a9ec7119229f37386d9f070523/sdk/src/transaction/error.rs#L13)
for more info.

##### !! memo

!type string | null

Memo associated with the transaction, null if no memo is present

##### !! blockTime

!type i64 | null

Estimated production time, as Unix timestamp (seconds since the Unix epoch) of
when transaction was processed. null if not available.

##### !! confirmationStatus

!type string | null

The transaction's cluster confirmation status; Either `processed`, `confirmed`,
or `finalized`. See [Commitment](/docs/rpc/#configuring-state-commitment) for
more on optimistic confirmation.

</APIMethod>
---
title: getSignatureStatuses
hideTableOfContents: true
h1: getSignatureStatuses RPC Method
---

Returns the statuses of a list of signatures. Each signature must be a
[txid](/docs/references/terminology#transaction-id), the first signature of a
transaction.

<Callout type="info">
  Unless the `searchTransactionHistory` configuration parameter is included,
  this method only searches the recent status cache of signatures, which retains
  statuses for all active slots plus `MAX_RECENT_BLOCKHASHES` rooted slots.
</Callout>

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getSignatureStatuses",
  "params": [
    // !hover(1:3) 0
    [
      "5VERv8NMvzbJMEkV8xnrLkEaWRtSz9CosKDYjCJjBRnbJLgp8uirBgmQpjKhoR4tjF3ZpRzrFmBV6UjKdiSZkQUW"
    ],
    // !hover(1:3) 1
    {
      // !hover searchTransactionHistory
      "searchTransactionHistory": true
    }
  ]
}
```

```ts !!request title="Kit"
import { createSolanaRpc, type Signature } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

// !hover(1:3) 0
let signatures = [
  "4cdd1oX7cfVALfr26tP52BZ6cSzrgnNGtYD7BFhm6FFeZV5sPTnRvg6NRn8yC6DbEikXcrNChBM5vVJnTgKhGhVu" as unknown as Signature,
];

// !hover(1:3) 1
let config = {
  // !hover searchTransactionHistory
  searchTransactionHistory: true,
};

let signatureStatus = await rpc.getSignatureStatuses(signatures, config).send();

console.log(signatureStatus);
```

```ts !!request title="web3.js"
import {
  Connection,
  clusterApiUrl,
  type SignatureStatusConfig,
} from "@solana/web3.js";

const connection = new Connection(clusterApiUrl("devnet"), "confirmed");

// !hover(1:3) 0
let signatures = [
  "4cdd1oX7cfVALfr26tP52BZ6cSzrgnNGtYD7BFhm6FFeZV5sPTnRvg6NRn8yC6DbEikXcrNChBM5vVJnTgKhGhVu",
];

// !hover(1:3) 1
let config: SignatureStatusConfig = {
  // !hover searchTransactionHistory
  searchTransactionHistory: true,
};

let signatureStatus = await connection.getSignatureStatuses(signatures, config);
console.log(signatureStatus);
```

```rs !!request title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{commitment_config::CommitmentConfig, signature::Signature};
use std::str::FromStr;

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

    // !hover(1:3) 0
    let signatures_str = [
        "4cdd1oX7cfVALfr26tP52BZ6cSzrgnNGtYD7BFhm6FFeZV5sPTnRvg6NRn8yC6DbEikXcrNChBM5vVJnTgKhGhVu",
    ];
    let signatures = signatures_str.map(|sig| Signature::from_str(sig).unwrap());

    let signature_status = client
        .get_signature_statuses_with_history(&signatures)
        .await?;

    println!("{:#?}", signature_status);

    Ok(())
}
```

### !params

#### !! 0

!type array
!required

An array of transaction signatures to confirm, as base-58 encoded strings (up to
a maximum of 256)

#### !! 1

!type object

Configuration object containing the following fields:

##### !! searchTransactionHistory

!type bool

if `true` - a Solana node will search its ledger cache for any signatures not
found in the recent status cache

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  "result": {
    "context": {
      "slot": 82
    },
    // !hover(1:12) result
    "value": [
      {
        // !hover slot
        "slot": 48,
        // !hover confirmations
        "confirmations": null,
        // !hover err
        "err": null,
        // !hover status
        "status": {
          "Ok": null
        },
        // !hover confirmationStatus
        "confirmationStatus": "finalized"
      },
      null
    ]
  },
  "id": 1
}
```

!type array

An array of `RpcResponse<object>` consisting of either `null` or an object
containing the following fields:

##### !! slot

!type u64

The slot the transaction was processed

##### !! confirmations

!type usize | null

Number of blocks since signature confirmation, `null` if rooted, as well as
finalized by a supermajority of the cluster

##### !! err

!type object | null

Error if transaction failed, `null` if transaction succeeded. See
[TransactionError definitions](https://github.com/anza-xyz/solana-sdk/blob/50dfbd088c51b7229c67d432d8c8801dafaa7904/transaction-error/src/lib.rs#L15)

##### !! status

!type object

**DEPRECATED** Transaction status

- `"Ok": <null>` - Transaction was successful
- `"Err": <ERR>` - Transaction failed with TransactionError

##### !! confirmationStatus

!type string | null

The transaction's cluster confirmation status; Either `processed`, `confirmed`,
or `finalized`. See [Commitment](/docs/rpc/#configuring-state-commitment) for
more on optimistic confirmation.

</APIMethod>
---
title: getSlot
hideTableOfContents: true
h1: getSlot RPC Method
---

Returns the slot that has reached the
[given or default commitment level](/docs/rpc/#configuring-state-commitment)

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getSlot",
  "params": [
    // !hover(1:3) 0
    {
      // !hover commitment
      "commitment": "finalized"
    }
  ]
}
```

```ts !!request title="Kit"
import { createSolanaRpc } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

let slot = await rpc.getSlot().send();

console.log(slot);
```

```ts !!request title="web3.js"
import { Connection, clusterApiUrl, type GetSlotConfig } from "@solana/web3.js";

const connection = new Connection(clusterApiUrl("devnet"), "confirmed");

// !hover(1:3)  0
let config: GetSlotConfig = {
  // !hover  commitment
  commitment: "finalized",
};

let slot = await connection.getSlot(config);

console.log(slot);
```

```rs !!request title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::commitment_config::CommitmentConfig;

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

    let slot = client.get_slot().await?;

    println!("{}", slot);

    Ok(())
}
```

### !params

#### !! 0

!type object

Configuration object containing the following fields:

##### !! commitment

!type string

The commitment describes how finalized a block is at that point in time. See
[Configuring State Commitment](/docs/rpc#configuring-state-commitment).

##### !! minContextSlot

!type number

The minimum slot that the request can be evaluated at

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover result
  "result": 1234,
  "id": 1
}
```

!type u64

Current slot

</APIMethod>
---
title: getSlotLeader
hideTableOfContents: true
h1: getSlotLeader RPC Method
---

Returns the current slot leader

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getSlotLeader",
  "params": [
    // !hover(1:3) 0
    {
      // !hover commitment
      "commitment": "finalized"
    }
  ]
}
```

```ts !!request title="Kit"
import { createSolanaRpc } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

let slotLeader = await rpc.getSlotLeader().send();

console.log(slotLeader);
```

```ts !!request title="web3.js"
import { Connection, clusterApiUrl } from "@solana/web3.js";

const connection = new Connection(clusterApiUrl("devnet"), "confirmed");

let slotLeader = await connection.getSlotLeader();

console.log(slotLeader);
```

### !params

#### !! 0

!type object

Configuration object containing the following fields:

##### !! commitment

!type string

The commitment describes how finalized a block is at that point in time. See
[Configuring State Commitment](/docs/rpc#configuring-state-commitment).

##### !! minContextSlot

!type number

The minimum slot that the request can be evaluated at

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover result
  "result": "ENvAW7JScgYq6o4zKZwewtkzzJgDzuJAFxYasvmEQdpS",
  "id": 1
}
```

!type string

Node identity Pubkey as base-58 encoded string

</APIMethod>
---
title: getSlotLeaders
hideTableOfContents: true
h1: getSlotLeaders RPC Method
---

Returns the slot leaders for a given slot range

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getSlotLeaders",
  "params": [
    // !hover start slot
    100,
    // !hover limit
    10
  ]
}
```

```ts !!request title="Kit"
import { createSolanaRpc } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

// !hover start slot
let startSlot = BigInt(378037836);
// !hover limit
let limit = 10;

let slotLeaders = await rpc.getSlotLeaders(startSlot, limit).send();

console.log(slotLeaders);
```

```ts !!request title="web3.js"
import { Connection, clusterApiUrl } from "@solana/web3.js";

const connection = new Connection(clusterApiUrl("devnet"), "confirmed");

// !hover start slot
let startSlot = 378037836;
// !hover limit
let limit = 10;

let slotLeaders = await connection.getSlotLeaders(startSlot, limit);

console.log(slotLeaders);
```

```rs !!request title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::commitment_config::CommitmentConfig;

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

    // !hover start slot
    let start_slot = 378037836;
    // !hover limit
    let limit = 10;

    let slot_leaders = client.get_slot_leaders(start_slot, limit).await?;

    println!("{:#?}", slot_leaders);

    Ok(())
}
```

### !params

#### !! start slot

!type u64
!required

Start slot, as u64 integer

#### !! limit

!type u64
!required

Limit, as u64 integer (between 1 and 5,000)

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover(1:12) result
  "result": [
    "ChorusmmK7i1AxXeiTtQgQZhQNiXYU84ULeaYF1EH15n",
    "ChorusmmK7i1AxXeiTtQgQZhQNiXYU84ULeaYF1EH15n",
    "ChorusmmK7i1AxXeiTtQgQZhQNiXYU84ULeaYF1EH15n",
    "ChorusmmK7i1AxXeiTtQgQZhQNiXYU84ULeaYF1EH15n",
    "Awes4Tr6TX8JDzEhCZY2QVNimT6iD1zWHzf1vNyGvpLM",
    "Awes4Tr6TX8JDzEhCZY2QVNimT6iD1zWHzf1vNyGvpLM",
    "Awes4Tr6TX8JDzEhCZY2QVNimT6iD1zWHzf1vNyGvpLM",
    "Awes4Tr6TX8JDzEhCZY2QVNimT6iD1zWHzf1vNyGvpLM",
    "DWvDTSh3qfn88UoQTEKRV2JnLt5jtJAVoiCo3ivtMwXP",
    "DWvDTSh3qfn88UoQTEKRV2JnLt5jtJAVoiCo3ivtMwXP"
  ],
  "id": 1
}
```

!type array

Array of Node identity public keys as base-58 encoded strings.

</APIMethod>
---
title: getStakeMinimumDelegation
hideTableOfContents: true
h1: getStakeMinimumDelegation RPC Method
---

Returns the stake minimum delegation, in lamports.

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getStakeMinimumDelegation",
  "params": [
    // !hover(1:3) 0
    {
      // !hover commitment
      "commitment": "finalized"
    }
  ]
}
```

```ts !!request title="Kit"
import { createSolanaRpc } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

let stakeMinDelegation = await rpc.getStakeMinimumDelegation().send();

console.log(stakeMinDelegation);
```

```ts !!request title="web3.js"
import { Connection, clusterApiUrl } from "@solana/web3.js";

const connection = new Connection(clusterApiUrl("devnet"), "confirmed");

let stakeMinDelegation = await connection.getStakeMinimumDelegation();

console.log(stakeMinDelegation);
```

```rs !!request title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::commitment_config::CommitmentConfig;

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

    let min_stake_delegation = client.get_stake_minimum_delegation().await?;

    println!("{}", min_stake_delegation);

    Ok(())
}
```

### !params

#### !! 0

!type object

Configuration object containing the following fields:

##### !! commitment

!type string

The commitment describes how finalized a block is at that point in time. See
[Configuring State Commitment](/docs/rpc#configuring-state-commitment).

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  "result": {
    "context": { "slot": 501 },
    // !hover result
    "value": 1000000000
  },
  "id": 1
}
```

!type u64

The stake minimum delegation, in lamports

</APIMethod>
---
title: getSupply
hideTableOfContents: true
h1: getSupply RPC Method
---

Returns information about the current supply.

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getSupply",
  "params": [
    // !hover(1:3) 0
    {
      // !hover commitment
      "commitment": "finalized"
    }
  ]
}
```

```ts !!request title="Kit"
import { createSolanaRpc } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

let supply = await rpc.getSupply().send();

console.log(supply);
```

```ts !!request title="web3.js"
import { Connection, clusterApiUrl } from "@solana/web3.js";

const connection = new Connection(clusterApiUrl("devnet"), "confirmed");

let supply = await connection.getSupply();

console.log(supply);
```

### !params

#### !! 0

!type object

Configuration object containing the following fields:

##### !! commitment

!type string

The commitment describes how finalized a block is at that point in time. See
[Configuring State Commitment](/docs/rpc#configuring-state-commitment).

##### !! excludeNonCirculatingAccountsList

!type bool

Exclude non circulating accounts list from response

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  "result": {
    "context": { "slot": 1114 },
    // !hover(1:11) result
    "value": {
      // !hover total
      "total": 1016000,
      // !hover circulating
      "circulating": 16000,
      // !hover nonCirculating
      "nonCirculating": 1000000,
      // !hover(1:6) nonCirculatingAccounts
      "nonCirculatingAccounts": [
        "FEy8pTbP5fEoqMV1GdTz83byuA8EKByqYat1PKDgVAq5",
        "9huDUZfxoJ7wGMTffUE7vh1xePqef7gyrLJu9NApncqA",
        "3mi1GmwEE3zo2jmfDuzvjSX9ovRXsDUKHvsntpkhuLJ9",
        "BYxEJTDerkaRWBem3XgnVcdhppktBXa2HbkHPKj2Ui4Z"
      ]
    }
  },
  "id": 1
}
```

!type object

The result will be a JSON object containing:

##### !! circulating

!type u64

Circulating supply in lamports

##### !! nonCirculating

!type u64

Non-circulating supply in lamports

##### !! nonCirculatingAccounts

!type array

An array of account addresses of non-circulating accounts, as strings. If
`excludeNonCirculatingAccountsList` is enabled, the returned array will be
empty.

##### !! total

!type u64

Total supply in lamports

</APIMethod>
---
title: getTokenAccountBalance
hideTableOfContents: true
h1: getTokenAccountBalance RPC Method
---

Returns the token balance of an SPL Token account.

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getTokenAccountBalance",
  "params": [
    // !hover pubkey
    "7fUAJdStEuGbc3sM84cKRL6yYaaSstyLSU4ve5oovLS7",
    {
      // !hover commitment
      "commitment": "finalized"
    }
  ]
}
```

```ts !!request title="Kit"
import { address, createSolanaRpc } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

// !hover pubkey
let tokenAddress = address("48gpnn8nsmkvkgso7462Z1nFhUrprGQ71u1YLBPzizbY");

let tokenBalance = await rpc.getTokenAccountBalance(tokenAddress).send();

console.log(tokenBalance);
```

```ts !!request title="web3.js"
import { Connection, PublicKey, clusterApiUrl } from "@solana/web3.js";

const connection = new Connection(clusterApiUrl("devnet"), "confirmed");

// !hover pubkey
let tokenAddress = new PublicKey(
  "48gpnn8nsmkvkgso7462Z1nFhUrprGQ71u1YLBPzizbY",
);

let tokenBalance = await connection.getTokenAccountBalance(tokenAddress);

console.log(tokenBalance);
```

```rs !!request title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{commitment_config::CommitmentConfig, pubkey};

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

    // !hover pubkey
    let token_address = pubkey!("48gpnn8nsmkvkgso7462Z1nFhUrprGQ71u1YLBPzizbY");
    let token_acc_bal = client.get_token_account_balance(&token_address).await?;

    println!("{:#?}", token_acc_bal);

    Ok(())
}
```

### !params

#### !! pubkey

!type string
!required

Pubkey of Token account to query, as base-58 encoded string

#### !! 1

!type object

Configuration object containing the following fields:

##### !! commitment

!type string

The commitment describes how finalized a block is at that point in time. See
[Configuring State Commitment](/docs/rpc#configuring-state-commitment).

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  "result": {
    "context": { "slot": 1114 },
    // !hover(1:6) value
    "value": {
      // !hover amount
      "amount": "9864",
      // !hover decimals
      "decimals": 2,
      // !hover uiAmount
      "uiAmount": 98.64,
      // !hover uiAmountString
      "uiAmountString": "98.64"
    }
  },
  "id": 1
}
```

!type object

The result will be a JSON object containing:

##### !! amount

!type string

The raw balance without decimals, a string representation of u64

##### !! decimals

!type u8

Number of base 10 digits to the right of the decimal place

##### !! uiAmount

!type number | null

The balance, using mint-prescribed decimals **DEPRECATED**

##### !! uiAmountString

!type string

The balance as a string, using mint-prescribed decimals

</APIMethod>

<Callout type="info">
  For more details on returned data, the [Token Balances
  Structure](/docs/rpc/json-structures#token-balances) response from
  [getBlock](/docs/rpc/http/getblock) follows a similar structure.
</Callout>
---
title: getTokenAccountsByDelegate
hideTableOfContents: true
h1: getTokenAccountsByDelegate RPC Method
---

Returns all SPL Token accounts by approved Delegate.

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getTokenAccountsByDelegate",
  "params": [
    // !hover pubkey
    "4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T",
    // !hover(1:3) 1
    {
      // !hover programId
      "programId": "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
    },
    // !hover(1:3) 2
    {
      // !hover commitment
      "commitment": "finalized",
      // !hover encoding
      "encoding": "jsonParsed"
    }
  ]
}
```

```ts !!request title="Kit"
import { address, createSolanaRpc } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

// !hover pubkey
let delegate = address("4kg8oh3jdNtn7j2wcS7TrUua31AgbLzDVkBZgTAe44aF");

// !hover programId
let tokenProgram = address("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");

let tokenAccByDelegate = await rpc
  .getTokenAccountsByDelegate(delegate, { programId: tokenProgram })
  .send();

console.log(tokenAccByDelegate);
```

```rs !!request title="Rust"
use anyhow::Result;
use solana_client::{nonblocking::rpc_client::RpcClient, rpc_request::TokenAccountsFilter};
use solana_sdk::{commitment_config::CommitmentConfig, pubkey};

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

    // !hover pubkey
    let delegate = pubkey!("4kg8oh3jdNtn7j2wcS7TrUua31AgbLzDVkBZgTAe44aF");

    // !hover programId
    let token_program = pubkey!("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");

    let token_acc_by_del = client
        .get_token_accounts_by_delegate_with_commitment(
            &delegate,
            TokenAccountsFilter::ProgramId(token_program),
            CommitmentConfig::finalized(),
        )
        .await?;

    println!("{:#?}", token_acc_by_del);

    Ok(())
```

### !params

#### !! pubkey

!type string
!required

Pubkey of account delegate to query, as base-58 encoded string

#### !! 1

!type object
!required

A JSON object with one of the following fields:

##### !! mint

!type string

Pubkey of the specific token Mint to limit accounts to, as base-58 encoded
string; or

##### !! programId

!type string

Pubkey of the Token program that owns the accounts, as base-58 encoded string

#### !! 2

!type object

Configuration object containing the following fields:

##### !! commitment

!type string

The commitment describes how finalized a block is at that point in time. See
[Configuring State Commitment](/docs/rpc#configuring-state-commitment).

##### !! minContextSlot

!type number

The minimum slot that the request can be evaluated at

##### !! dataSlice

!type object

Request a slice of the account's data.

- `length: <usize>` - number of bytes to return
- `offset: <usize>` - byte offset from which to start reading

<Callout type="info">
  Data slicing is only available for `base58`, `base64`, or `base64+zstd`
  encodings.
</Callout>

##### !! encoding

!type string
!values base58 base64 base64+zstd jsonParsed

Encoding format for Account data

- `base58` is slow and limited to less than 129 bytes of Account data.
- `base64` will return base64 encoded data for Account data of any size.
- `base64+zstd` compresses the Account data using
  [Zstandard](https://facebook.github.io/zstd/) and base64-encodes the result.
- `jsonParsed` encoding attempts to use program-specific state parsers to return
  more human-readable and explicit account state data.
- If `jsonParsed` is requested but a parser cannot be found, the field falls
  back to `base64` encoding, detectable when the `data` field is type `string`.

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  "result": {
    "context": { "slot": 1114 },
    "value": [
      {
        // !hover pubkey
        "pubkey": "28YTZEwqtMHWrhWcvv34se7pjS7wctgqzCPB3gReCFKp",
        // !hover(1:33) account
        "account": {
          "data": {
            "program": "spl-token",
            "parsed": {
              "info": {
                "tokenAmount": {
                  "amount": "1",
                  "decimals": 1,
                  "uiAmount": 0.1,
                  "uiAmountString": "0.1"
                },
                "delegate": "4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T",
                "delegatedAmount": {
                  "amount": "1",
                  "decimals": 1,
                  "uiAmount": 0.1,
                  "uiAmountString": "0.1"
                },
                "state": "initialized",
                "isNative": false,
                "mint": "3wyAj7Rt1TWVPZVteFJPLa26JmLvdb1CAKEFZm3NY75E",
                "owner": "CnPoSPKXu7wJqxe59Fs72tkBeALovhsCxYeFwPCQH9TD"
              },
              "type": "account"
            },
            "space": 165
          },
          "executable": false,
          "lamports": 1726080,
          "owner": "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
          "rentEpoch": 4,
          "space": 165
        }
      }
    ]
  },
  "id": 1
}
```

!type array

An array of JSON objects containing:

##### !! pubkey

!type string

The account Pubkey as base-58 encoded string

##### !! account

!type object

A JSON object containing:

- `lamports: <u64>` - number of lamports assigned to this account, as a u64
- `owner: <string>` - base-58 encoded Pubkey of the program this account has
  been assigned to
- `data: <object>` - Token state data associated with the account, either as
  encoded binary data or in JSON format `{<program>: <state>}`
- `executable: <bool>` - boolean indicating if the account contains a program
  (and is strictly read-only)
- `rentEpoch: <u64>` - the epoch at which this account will next owe rent, as
  u64
- `space: <u64>` - the data size of the account

When the data is requested with the `jsonParsed` encoding a format similar to
that of the [Token Balances Structure](/docs/rpc/json-structures#token-balances)
can be expected inside the structure, both for the `tokenAmount` and the
`delegatedAmount` - with the latter being an optional object.

</APIMethod>
---
title: getTokenAccountsByOwner
hideTableOfContents: true
h1: getTokenAccountsByOwner RPC Method
---

Returns all SPL Token accounts by token owner.

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getTokenAccountsByOwner",
  "params": [
    // !hover pubkey
    "A1TMhSGzQxMr1TboBKtgixKz1sS6REASMxPo1qsyTSJd",
    // !hover(1:3) 1
    {
      // !hover programId
      "programId": "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
    },
    // !hover(1:3) 2
    {
      // !hover commitment
      "commitment": "finalized",
      // !hover encoding
      "encoding": "jsonParsed"
    }
  ]
}
```

```ts !!request title="Kit"
import { address, createSolanaRpc } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

// !hover pubkey
let owner = address("4kg8oh3jdNtn7j2wcS7TrUua31AgbLzDVkBZgTAe44aF");

// !hover programId
let tokenProgram = address("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");

let tokenAccounts = await rpc
  .getTokenAccountsByOwner(
    owner,
    { programId: tokenProgram },
    // !hover encoding
    { encoding: "base64" },
  )
  .send();

console.log(tokenAccounts);
```

```ts !!request title="web3.js"
import { Connection, PublicKey, clusterApiUrl } from "@solana/web3.js";

const connection = new Connection(clusterApiUrl("devnet"), "confirmed");

// !hover pubkey
let owner = new PublicKey("4kg8oh3jdNtn7j2wcS7TrUua31AgbLzDVkBZgTAe44aF");

// !hover programId
let tokenProgram = new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");

let tokenAccounts = await connection.getTokenAccountsByOwner(owner, {
  programId: tokenProgram,
});

console.log(tokenAccounts);
```

```rs !!request title="Rust"
use anyhow::Result;
use solana_client::{nonblocking::rpc_client::RpcClient, rpc_request::TokenAccountsFilter};
use solana_sdk::{commitment_config::CommitmentConfig, pubkey};

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

    // !hover pubkey
    let owner = pubkey!("4kg8oh3jdNtn7j2wcS7TrUua31AgbLzDVkBZgTAe44aF");

    // !hover programId
    let token_program = pubkey!("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");

    let token_accounts = client
        .get_token_accounts_by_owner(&owner, TokenAccountsFilter::ProgramId(token_program))
        .await?;

    println!("{:#?}", token_accounts);

    Ok(())
}
```

### !params

#### !! pubkey

!type string
!required

Pubkey of account owner to query, as base-58 encoded string

#### !! 1

!type object
!required

A JSON object with one of the following fields:

##### !! mint

!type string

Pubkey of the specific token Mint to limit accounts to, as base-58 encoded
string

##### !! programId

!type string

Pubkey of the Token program that owns the accounts, as base-58 encoded string

#### !! 2

!type object

Configuration object containing the following fields:

##### !! commitment

!type string

The commitment describes how finalized a block is at that point in time. See
[Configuring State Commitment](/docs/rpc#configuring-state-commitment).

##### !! minContextSlot

!type number

The minimum slot that the request can be evaluated at

##### !! dataSlice

!type object

Request a slice of the account's data.

- `length: <usize>` - number of bytes to return
- `offset: <usize>` - byte offset from which to start reading

<Callout type="info">
  Data slicing is only available for `base58`, `base64`, or `base64+zstd`
  encodings.
</Callout>

##### !! encoding

!type string
!values base58 base64 base64+zstd jsonParsed

Encoding format for Account data

- `base58` is slow and limited to less than 129 bytes of Account data.
- `base64` will return base64 encoded data for Account data of any size.
- `base64+zstd` compresses the Account data using
  [Zstandard](https://facebook.github.io/zstd/) and base64-encodes the result.
- `jsonParsed` encoding attempts to use program-specific state parsers to return
  more human-readable and explicit account state data.
- If `jsonParsed` is requested but a parser cannot be found, the field falls
  back to `base64` encoding, detectable when the `data` field is type `string`.

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  "result": {
    "context": { "apiVersion": "2.0.15", "slot": 341197933 },
    "value": [
      {
        // !hover pubkey
        "pubkey": "BGocb4GEpbTFm8UFV2VsDSaBXHELPfAXrvd4vtt8QWrA",
        // !hover(1:27) account
        "account": {
          "data": {
            "program": "spl-token",
            "parsed": {
              "info": {
                "isNative": false,
                "mint": "2cHr7QS3xfuSV8wdxo3ztuF4xbiarF6Nrgx3qpx3HzXR",
                "owner": "A1TMhSGzQxMr1TboBKtgixKz1sS6REASMxPo1qsyTSJd",
                "state": "initialized",
                "tokenAmount": {
                  "amount": "420000000000000",
                  "decimals": 6,
                  "uiAmount": 420000000.0,
                  "uiAmountString": "420000000"
                }
              },
              "type": "account"
            },
            "space": 165
          },
          "executable": false,
          "lamports": 2039280,
          "owner": "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
          "rentEpoch": 18446744073709551615,
          "space": 165
        }
      }
    ]
  },
  "id": 1
}
```

!type array

An array of JSON objects containing:

##### !! pubkey

!type string

The account Pubkey as base-58 encoded string

##### !! account

!type object

A JSON object containing:

- `lamports: <u64>` - number of lamports assigned to this account, as a u64
- `owner: <string>` - base-58 encoded Pubkey of the program this account has
  been assigned to
- `data: <object>` - Token state data associated with the account, either as
  encoded binary data or in JSON format `{<program>: <state>}`
- `executable: <bool>` - boolean indicating if the account contains a program
  (and is strictly read-only)
- `rentEpoch: <u64>` - the epoch at which this account will next owe rent, as
  u64
- `space: <u64>` - the data size of the account

When the data is requested with the `jsonParsed` encoding a format similar to
that of the [Token Balances Structure](/docs/rpc/json-structures#token-balances)
can be expected inside the structure, both for the `tokenAmount` and the
`delegatedAmount` - with the latter being an optional object.

</APIMethod>
---
title: getTokenLargestAccounts
hideTableOfContents: true
h1: getTokenLargestAccounts RPC Method
---

Returns the 20 largest accounts of a particular SPL Token type.

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getTokenLargestAccounts",
  "params": [
    // !hover pubkey
    "3wyAj7Rt1TWVPZVteFJPLa26JmLvdb1CAKEFZm3NY75E",
    // !hover(1:3) 1
    {
      // !hover commitment
      "commitment": "finalized"
    }
  ]
}
```

```ts !!request title="Kit"
import { address, createSolanaRpc } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

// !hover pubkey
let mint = address("Gh9ZwEmdLJ8DscKNTkTqPbNwLNNBjuSzaG9Vp2KGtKJr");

let largestHolders = await rpc.getTokenLargestAccounts(mint).send();

console.log(largestHolders);
```

```ts !!request title="web3.js"
import { Connection, PublicKey, clusterApiUrl } from "@solana/web3.js";

const connection = new Connection(clusterApiUrl("devnet"), "confirmed");

// !hover pubkey
let mint = new PublicKey!("Gh9ZwEmdLJ8DscKNTkTqPbNwLNNBjuSzaG9Vp2KGtKJr");

let largestHolders = await connection.getTokenLargestAccounts(mint);

console.log(largestHolders);
```

```rs !!request title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{commitment_config::CommitmentConfig, pubkey};

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

    // !hover pubkey
    let mint = pubkey!("Gh9ZwEmdLJ8DscKNTkTqPbNwLNNBjuSzaG9Vp2KGtKJr");

    let largest_holders = client.get_token_largest_accounts(&mint).await?;

    println!("{:#?}", largest_holders);

    Ok(())
}
```

### !params

#### !! pubkey

!type string
!required

Pubkey of the token Mint to query, as base-58 encoded string

#### !! 1

!type object

Configuration object containing the following fields:

##### !! commitment

!type string

The commitment describes how finalized a block is at that point in time. See
[Configuring State Commitment](/docs/rpc#configuring-state-commitment).

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  "result": {
    "context": { "slot": 1114 },
    // !hover(1:16) result
    "value": [
      {
        // !hover address
        "address": "FYjHNoFtSQ5uijKrZFyYAxvEr87hsKXkXcxkcmkBAf4r",
        // !hover amount
        "amount": "771",
        // !hover decimals
        "decimals": 2,
        // !hover uiAmount
        "uiAmount": 7.71,
        // !hover uiAmountString
        "uiAmountString": "7.71"
      },
      {
        "address": "BnsywxTcaYeNUtzrPxQUvzAWxfzZe3ZLUJ4wMMuLESnu",
        "amount": "229",
        "decimals": 2,
        "uiAmount": 2.29,
        "uiAmountString": "2.29"
      }
    ]
  },
  "id": 1
}
```

!type array

An array of JSON objects containing:

##### !! address

!type string

The address of the token account

##### !! amount

!type string

The raw token account balance without decimals, a string representation of u64

##### !! decimals

!type u8

Number of base 10 digits to the right of the decimal place

##### !! uiAmount

!type number | null

The token account balance, using mint-prescribed decimals **DEPRECATED**

##### !! uiAmountString

!type string

The token account balance as a string, using mint-prescribed decimals

</APIMethod>
---
title: getTokenSupply
hideTableOfContents: true
h1: getTokenSupply RPC Method
---

Returns the total supply of an SPL Token type.

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getTokenSupply",
  "params": [
    // !hover pubkey
    "3wyAj7Rt1TWVPZVteFJPLa26JmLvdb1CAKEFZm3NY75E",
    // !hover(1:3) 1
    {
      // !hover commitment
      "commitment": "finalized"
    }
  ]
}
```

```ts !!request title="Kit"
import { address, createSolanaRpc } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

// !hover pubkey
let mint = address("Gh9ZwEmdLJ8DscKNTkTqPbNwLNNBjuSzaG9Vp2KGtKJr");

let tokenSupply = await rpc.getTokenSupply(mint).send();

console.log(tokenSupply);
```

```ts !!request title="web3.js"
import { Connection, PublicKey, clusterApiUrl } from "@solana/web3.js";

const connection = new Connection(clusterApiUrl("devnet"), "confirmed");

// !hover pubkey
let mint = new PublicKey!("Gh9ZwEmdLJ8DscKNTkTqPbNwLNNBjuSzaG9Vp2KGtKJr");

let tokenSupply = await connection.getTokenSupply(mint);

console.log(tokenSupply);
```

```rs !!request title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{commitment_config::CommitmentConfig, pubkey};

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

    // !hover pubkey
    let mint = pubkey!("Gh9ZwEmdLJ8DscKNTkTqPbNwLNNBjuSzaG9Vp2KGtKJr");

    let token_supply = client.get_token_supply(&mint).await?;

    println!("{:#?}", token_supply);

    Ok(())
}
```

### !params

#### !! pubkey

!type string
!required

Pubkey of the token Mint to query, as base-58 encoded string

#### !! 1

!type object

Configuration object containing the following fields:

##### !! commitment

!type string

The commitment describes how finalized a block is at that point in time. See
[Configuring State Commitment](/docs/rpc#configuring-state-commitment).

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  "result": {
    "context": { "slot": 1114 },
    // !hover(1:6) result
    "value": {
      // !hover amount
      "amount": "100000",
      // !hover decimals
      "decimals": 2,
      // !hover uiAmount
      "uiAmount": 1000,
      // !hover uiAmountString
      "uiAmountString": "1000"
    }
  },
  "id": 1
}
```

!type object

A JSON object containing:

##### !! amount

!type string

The raw total token supply without decimals, a string representation of u64

##### !! decimals

!type u8

Number of base 10 digits to the right of the decimal place

##### !! uiAmount

!type number | null
!deprecated

The total token supply, using mint-prescribed decimals

##### !! uiAmountString

!type string

The total token supply as a string, using mint-prescribed decimals

</APIMethod>
---
title: getTransaction
hideTableOfContents: true
h1: getTransaction RPC Method
---

Returns transaction details for a confirmed transaction

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getTransaction",
  "params": [
    // !hover signature
    "5Pj5fCupXLUePYn18JkY8SrRaWFiUctuDTRwvUy2ML9yvkENLb1QMYbcBGcBXRrSVDjp7RjUwk9a3rLC6gpvtYpZ",
    // !hover(1:5) config
    {
      // !hover commitment
      "commitment": "confirmed",
      // !hover maxSupportedTransactionVersion
      "maxSupportedTransactionVersion": 0,
      // !hover encoding
      "encoding": "json"
    }
  ]
}
```

```ts !!request title="Kit"
import { createSolanaRpc, type Signature } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

// !hover signature
let signature =
  "5zSQuTcWsPy2cVAshBXWuJJXLwMD1GbgMpz3iq4xgwiV1s6mxYRbYb7qBiRGZd1xvDcYhQQRBKoNcnW8eKtcyZWg";

let transaction = await rpc.getTransaction(signature as Signature).send();

console.log(transaction);
```

```ts !!request title="web3.js"
import {
  Connection,
  PublicKey,
  clusterApiUrl,
  type GetVersionedTransactionConfig,
} from "@solana/web3.js";

const connection = new Connection(clusterApiUrl("devnet"), "confirmed");

// !hover signature
let signature =
  "5zSQuTcWsPy2cVAshBXWuJJXLwMD1GbgMpz3iq4xgwiV1s6mxYRbYb7qBiRGZd1xvDcYhQQRBKoNcnW8eKtcyZWg";

// !hover(1:3) 1
let config: GetVersionedTransactionConfig = {
  // !hover commitment
  commitment: "finalized",
  // !hover maxSupportedTransactionVersion
  maxSupportedTransactionVersion: 0,
};

let transaction = await connection.getTransaction(signature, config);

console.log(transaction);
```

```rs !!request title="Rust"
use anyhow::Result;
use solana_client::{nonblocking::rpc_client::RpcClient, rpc_config::RpcTransactionConfig};
use solana_sdk::{commitment_config::CommitmentConfig, signature::Signature};
use solana_transaction_status_client_types::UiTransactionEncoding;
use std::str::FromStr;

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

    // !hover(1:3) signature
    let tx_sig = Signature::from_str(
        "5zSQuTcWsPy2cVAshBXWuJJXLwMD1GbgMpz3iq4xgwiV1s6mxYRbYb7qBiRGZd1xvDcYhQQRBKoNcnW8eKtcyZWg",
    )?;

    // !hover(1:5) 1
    let config = RpcTransactionConfig {
        // !hover commitment
        commitment: CommitmentConfig::finalized().into(),
        // !hover encoding
        encoding: UiTransactionEncoding::Base64.into(),
        // !hover maxSupportedTransactionVersion
        max_supported_transaction_version: Some(0),
    };

    let transaction = client.get_transaction_with_config(&tx_sig, config).await?;

    println!("{:#?}", transaction);

    Ok(())
}
```

### !params

#### !! signature

!type string
!required

Transaction signature, as base-58 encoded string

#### !! config

!type object

Configuration object containing the following fields:

##### !! commitment

!type string
!values confirmed finalized
!default finalized

The commitment describes how finalized a block is at that point in time. See
[Configuring State Commitment](/docs/rpc#configuring-state-commitment).

- `processed` is not supported.

##### !! maxSupportedTransactionVersion

!type number
!values 0
!default 0

Currently, the only valid value for this parameter is `0`.
Setting it to `0` allows you to fetch all transactions, including both Versioned and legacy transactions.

This parameter determines the maximum transaction version that will be returned in the response.
If you request a transaction with a higher version than this value, an error will be returned.
If you omit this parameter, only legacy transactions will be returnedâ€”any versioned transaction will result in an error.


##### !! encoding

!type string
!values json jsonParsed base64 base58
!default json

Encoding for the returned Transaction

- `jsonParsed` encoding attempts to use program-specific state parsers to return
  more human-readable and explicit data in the
  `transaction.message.instructions` list.
- If `jsonParsed` is requested but a parser cannot be found, the instruction
  falls back to regular JSON encoding (`accounts`, `data`, and `programIdIndex`
  fields).

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover(1:64) result
  "result": {
    // !hover blockTime
    "blockTime": 1746479684,
    // !hover(1:30) meta
    // !collapse(1:30) collapsed
    "meta": {
      "computeUnitsConsumed": 150,
      "err": null,
      "fee": 5000,
      "innerInstructions": [],
      "loadedAddresses": {
        "readonly": [],
        "writable": []
      },
      "logMessages": [
        "Program 11111111111111111111111111111111 invoke [1]",
        "Program 11111111111111111111111111111111 success"
      ],
      "postBalances": [
        989995000,
        10000000,
        1
      ],
      "postTokenBalances": [],
      "preBalances": [
        1000000000,
        0,
        1
      ],
      "preTokenBalances": [],
      "rewards": [],
      "status": {
        "Ok": null
      }
    },
    // !hover slot
    "slot": 378917547,
    // !hover(1:29) transaction
    // !collapse(1:29) collapsed
    "transaction": {
      "message": {
        "accountKeys": [
          "7BvfixZx7Rwywf6EJFgRW6acEQ2FLSFJr4n3kLLVeEes",
          "6KtbxYovphtE3eHjPjr2sWwDfgaDwtAn2FcojDyzZWT6",
          "11111111111111111111111111111111"
        ],
        "header": {
          "numReadonlySignedAccounts": 0,
          "numReadonlyUnsignedAccounts": 1,
          "numRequiredSignatures": 1
        },
        "instructions": [
          {
            "accounts": [
              0,
              1
            ],
            "data": "3Bxs4NN8M2Yn4TLb",
            "programIdIndex": 2,
            "stackHeight": null
          }
        ],
        "recentBlockhash": "23dwTHxFhSzqohXhdni5LwpuSRpgN36YvVMCAM2VXQSf"
      },
      "signatures": [
        "5Pj5fCupXLUePYn18JkY8SrRaWFiUctuDTRwvUy2ML9yvkENLb1QMYbcBGcBXRrSVDjp7RjUwk9a3rLC6gpvtYpZ"
      ]
    },
    // !hover version
    "version": "legacy"
  },
  "id": 1
}
```

!type object | null

Returns `null` if transaction is not found or not confirmed, otherwise returns
an object containing:

##### !! blockTime

!type i64 | null

Estimated production time, as Unix timestamp (seconds since the Unix epoch) of
when the transaction was processed. null if not available

##### !! meta

!type object | null

Transaction status
[metadata object](/docs/rpc/json-structures#transaction-status-metadata) or
`null`.

##### !! slot

!type u64

The slot this transaction was processed in

##### !! transaction

!type object | [string,encoding]

[Transaction](/docs/rpc/json-structures#transactions) object, either in JSON
format or encoded binary data, depending on encoding parameter

##### !! version

!type "legacy" | number | undefined

Transaction version. Undefined if `maxSupportedTransactionVersion` is not set in
request params.

</APIMethod>
---
title: getTransactionCount
hideTableOfContents: true
h1: getTransactionCount RPC Method
---

Returns the current Transaction count from the ledger

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getTransactionCount",
  "params": [
    // !hover(1:3) 0
    {
      // !hover commitment
      "commitment": "finalized"
    }
  ]
}
```

```ts !!request title="Kit"
import { createSolanaRpc } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

let txCount = await rpc.getTransactionCount().send();

console.log(txCount);
```

```ts !!request title="web3.js"
import { Connection, clusterApiUrl } from "@solana/web3.js";

const connection = new Connection(clusterApiUrl("devnet"), "confirmed");

let txCount = await connection.getTransactionCount();

console.log(txCount);
```

```rs !!request title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::commitment_config::CommitmentConfig;

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

    let tx_count = client.get_transaction_count().await?;

    println!("{:#?}", tx_count);

    Ok(())
}
```

### !params

#### !! 0

!type object
!optional

Configuration object containing the following fields:

##### !! commitment

!type string

The commitment describes how finalized a block is at that point in time. See
[Configuring State Commitment](/docs/rpc#configuring-state-commitment).

##### !! minContextSlot

!type number

The minimum slot that the request can be evaluated at

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover result
  "result": 268,
  "id": 1
}
```

!type u64

The current Transaction count from the ledger

</APIMethod>
---
title: getVersion
hideTableOfContents: true
h1: getVersion RPC Method
---

Returns the current Solana version running on the node

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getVersion"
}
```

```ts !!request title="Kit"
import { createSolanaRpc } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

let version = await rpc.getVersion().send();

console.log(version);
```

```ts !!request title="web3.js"
import { Connection, clusterApiUrl } from "@solana/web3.js";

const connection = new Connection(clusterApiUrl("devnet"), "confirmed");

let version = await connection.getVersion();

console.log(version);
```

```rs !!request title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::commitment_config::CommitmentConfig;

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

    let version = client.get_version().await?;

    println!("{}", version);

    Ok(())
}
```

### !params

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover(1:4) result
  "result": {
    // !hover solana-core
    "solana-core": "1.16.7",
    // !hover feature-set
    "feature-set": 2891131721
  },
  "id": 1
}
```

!type object

A JSON object containing:

##### !! solana-core

!type string

Software version of solana-core

##### !! feature-set

!type u32

Unique identifier of the current software's feature set

</APIMethod>
---
title: getVoteAccounts
hideTableOfContents: true
h1: getVoteAccounts RPC Method
---

Returns the account info and associated stake for all the voting accounts in the
current bank.

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getVoteAccounts",
  "params": [
    // !hover(1:3) 0
    {
      // !hover commitment
      "commitment": "finalized",
      // !hover votePubkey
      "votePubkey": "i7NyKBMJCA9bLM2nsGyAGCKHECuR2L5eh4GqFciuwNT"
    }
  ]
}
```

```ts !!request title="Kit"
import { address, createSolanaRpc } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

// !hover votePubkey
let votePubkey = address("5ZWgXcyqrrNpQHCme5SdC5hCeYb2o3fEJhF7Gok3bTVN");

let voteAccounts = await rpc
  .getVoteAccounts({
    votePubkey,
  })
  .send();

console.log(voteAccounts);
```

```ts !!request title="web3.js"
import { Connection, PublicKey, clusterApiUrl } from "@solana/web3.js";

const connection = new Connection(clusterApiUrl("devnet"), "confirmed");

let version = await connection.getVoteAccounts();

console.log(version);
```

```rs !!request title="Rust"
use anyhow::Result;
use solana_client::{nonblocking::rpc_client::RpcClient, rpc_config::RpcGetVoteAccountsConfig};
use solana_sdk::commitment_config::CommitmentConfig;

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

    // !hover votePubkey
    let vote_pubkey = String::from("5ZWgXcyqrrNpQHCme5SdC5hCeYb2o3fEJhF7Gok3bTVN");

    let config = RpcGetVoteAccountsConfig {
        vote_pubkey: Some(vote_pubkey),
        commitment: CommitmentConfig::finalized().into(),
        keep_unstaked_delinquents: None,
        delinquent_slot_distance: None,
    };

    let vote_accounts = client.get_vote_accounts_with_config(config).await?;

    println!("{:#?}", vote_accounts);

    Ok(())
}
```

### !params

#### !! 0

!type object
!optional

Configuration object containing the following fields:

##### !! commitment

!type string

The commitment describes how finalized a block is at that point in time. See
[Configuring State Commitment](/docs/rpc#configuring-state-commitment).

##### !! votePubkey

!type string

Only return results for this validator vote address (base-58 encoded)

##### !! keepUnstakedDelinquents

!type bool

Do not filter out delinquent validators with no stake

##### !! delinquentSlotDistance

!type u64

Specify the number of slots behind the tip that a validator must fall to be
considered delinquent. **NOTE:** For the sake of consistency between ecosystem
products, _it is **not** recommended that this argument be specified._

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover(1:21) result
  "result": {
    "current": [
      {
        // !hover activatedStake
        "activatedStake": 38263229364446900,
        // !hover commission
        "commission": 95,
        // !hover(1:7) epochCredits
        "epochCredits": [
          [902, 1383125544, 1376213656],
          [903, 1390037304, 1383125544],
          [904, 1396949288, 1390037304],
          [905, 1403861272, 1396949288],
          [906, 1406766600, 1403861272]
        ],
        // !hover epochVoteAccount
        "epochVoteAccount": true,
        // !hover lastVote
        "lastVote": 391573587,
        // !hover nodePubkey
        "nodePubkey": "dv2eQHeP4RFrJZ6UeiZWoc3XTtmtZCUKxxCApCDcRNV",
        // !hover rootSlot
        "rootSlot": 391573556,
        // !hover votePubkey
        "votePubkey": "i7NyKBMJCA9bLM2nsGyAGCKHECuR2L5eh4GqFciuwNT"
      }
    ],
    "delinquent": []
  },
  "id": 1
}
```

!type object

The result field will be a JSON object of `current` and `delinquent` accounts,
each containing an array of JSON objects with the following sub fields:

##### !! activatedStake

!type u64

The stake, in lamports, delegated to this vote account and active in this epoch

##### !! commission

!type number

Percentage (0-100) of rewards payout owed to the vote account

##### !! epochCredits

!type array

Latest history of earned credits for up to five epochs, as an array of arrays
containing: `[epoch, credits, previousCredits]`

##### !! epochVoteAccount

!type bool

Whether the vote account is staked for this epoch

##### !! lastVote

!type u64

Most recent slot voted on by this vote account

##### !! nodePubkey

!type string

Validator identity, as base-58 encoded string

##### !! rootSlot

!type u64

Current root slot for this vote account

##### !! votePubkey

!type string

Vote account address, as base-58 encoded string


</APIMethod>
---
title: HTTP Methods
seoTitle: Solana RPC HTTP Methods
hideTableOfContents: false
h1: Solana RPC HTTP Methods
---

Solana nodes accept HTTP requests using the
[JSON-RPC 2.0](https://www.jsonrpc.org/specification) specification.

> For JavaScript applications, use the
> [@solana/web3.js](https://github.com/solana-labs/solana-web3.js) library as a
> convenient interface for the RPC methods to interact with a Solana node. For
> an PubSub connection to a Solana node, use the
> [Websocket API](/docs/rpc/websocket/).

## RPC HTTP Endpoint

Default port: `8899`

- http://localhost:8899
- http://192.168.1.88:8899

## Request Formatting

To make a JSON-RPC request, send an HTTP POST request with a
`Content-Type: application/json` header. The JSON request data should contain 4
fields:

- `jsonrpc: <string>` - set to `"2.0"`
- `id: <string | number | null>` - a unique identifier for the request,
  generated by the client. Typically a string or number, though null is
  technically allowed but not advised
- `method: <string>` - a string containing the method to be invoked
- `params: <array>` - a JSON array of ordered parameter values

Example using curl:

```shell
curl https://api.devnet.solana.com -s -X POST -H "Content-Type: application/json" -d '
  {
    "jsonrpc": "2.0",
    "id": 1,
    "method": "getBalance",
    "params": [
      "83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri"
    ]
  }
'
```

The response output will be a JSON object with the following fields:

- `jsonrpc: <string>` - matching the request specification
- `id: <number>` - matching the request identifier
- `result: <array|number|object|string>` - requested data or success
  confirmation

Requests can be sent in batches by sending an array of JSON-RPC request objects
as the data for a single POST.

### Example Request

The commitment parameter should be included as the last element in the `params`
array:

```shell
curl https://api.devnet.solana.com -s -X POST -H "Content-Type: application/json" -d '
  {
    "jsonrpc": "2.0",
    "id": 1,
    "method": "getBalance",
    "params": [
      "83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri",
      {
        "commitment": "finalized"
      }
    ]
  }
'
```

## Definitions

- Hash: A SHA-256 hash of a chunk of data.
- Pubkey: The public key of a Ed25519 key-pair.
- Transaction: A list of Solana instructions signed by a client keypair to
  authorize those actions.
- Signature: An Ed25519 signature of transaction's payload data including
  instructions. This can be used to identify transactions.

## Health Check

Although not a JSON RPC API, a `GET /health` at the RPC HTTP Endpoint provides a
health-check mechanism for use by load balancers or other network
infrastructure. This request will always return a HTTP 200 OK response with a
body of "ok", "behind" or "unknown":

- `ok`: The node is within `HEALTH_CHECK_SLOT_DISTANCE` slots from the latest
  cluster confirmed slot
- `behind { distance }`: The node is behind `distance` slots from the latest
  cluster confirmed slot where `distance > HEALTH_CHECK_SLOT_DISTANCE`
- `unknown`: The node is unable to determine where it stands in relation to the
  cluster
---
title: isBlockhashValid
hideTableOfContents: true
h1: isBlockhashValid RPC Method
---

Returns whether a blockhash is still valid or not

<Callout type="warn" title={"Version Restriction"}>
  This method is only available in `solana-core` v1.9 or newer. Please use
  [getFeeCalculatorForBlockhash](/docs/rpc/http/getfeecalculatorforblockhash)
  for `solana-core` v1.8 and below.
</Callout>

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 45,
  "method": "isBlockhashValid",
  "params": [
    // !hover blockhash
    "J7rBdM6AecPDEZp8aPq5iPSNKVkU5Q76F3oAV4eW5wsW",
    // !hover(1:3) config
    {
      // !hover commitment
      "commitment": "processed"
    }
  ]
}
```

```ts !!request title="Kit"
import { createSolanaRpc, type Blockhash } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

// !hover blockhash
let blockhash = "J7rBdM6AecPDEZp8aPq5iPSNKVkU5Q76F3oAV4eW5wsW";

let isValid = await rpc.isBlockhashValid(blockhash as Blockhash).send();

console.log(isValid);
```

```ts !!request title="web3.js"
import { Connection, clusterApiUrl } from "@solana/web3.js";

const connection = new Connection(clusterApiUrl("devnet"), "confirmed");

// !hover blockhash
let blockhash = "J7rBdM6AecPDEZp8aPq5iPSNKVkU5Q76F3oAV4eW5wsW";

let isValid = await connection.isBlockhashValid(blockhash);

console.log(isValid);
```

```rs !!request title="Rust"
use std::str::FromStr;

use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{commitment_config::CommitmentConfig, hash::Hash};

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

    // !hover blockhash
    let blockhash = Hash::from_str("J7rBdM6AecPDEZp8aPq5iPSNKVkU5Q76F3oAV4eW5wsW")?;

    let is_valid = client
        .is_blockhash_valid(&blockhash, CommitmentConfig::finalized())
        .await?;

    println!("{:#?}", is_valid);

    Ok(())
}
```

### !params

#### !! blockhash

!type string
!required

The blockhash of the block to evaluate, as base-58 encoded string

#### !! config

!type object

Configuration object containing the following fields:

##### !! commitment

!type string

The commitment describes how finalized a block is at that point in time. See
[Configuring State Commitment](/docs/rpc#configuring-state-commitment).

##### !! minContextSlot

!type number

The minimum slot that the request can be evaluated at

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  "result": {
    "context": { "slot": 2483 },
    // !hover result
    "value": false
  },
  "id": 45
}
```

!type bool

Whether the blockhash is still valid

</APIMethod>
{
  "title": "HTTP Methods",
  "pages": [
    "getaccountinfo",
    "getbalance",
    "getblock",
    "getblockcommitment",
    "getblockheight",
    "getblockproduction",
    "getblocks",
    "getblockswithlimit",
    "getblocktime",
    "getclusternodes",
    "getepochinfo",
    "getepochschedule",
    "getfeeformessage",
    "getfirstavailableblock",
    "getgenesishash",
    "gethealth",
    "gethighestsnapshotslot",
    "getidentity",
    "getinflationgovernor",
    "getinflationrate",
    "getinflationreward",
    "getlargestaccounts",
    "getlatestblockhash",
    "getleaderschedule",
    "getmaxretransmitslot",
    "getmaxshredinsertslot",
    "getminimumbalanceforrentexemption",
    "getmultipleaccounts",
    "getprogramaccounts",
    "getrecentperformancesamples",
    "getrecentprioritizationfees",
    "getsignaturesforaddress",
    "getsignaturestatuses",
    "getslot",
    "getslotleader",
    "getslotleaders",
    "getstakeminimumdelegation",
    "getsupply",
    "gettokenaccountbalance",
    "gettokenaccountsbydelegate",
    "gettokenaccountsbyowner",
    "gettokenlargestaccounts",
    "gettokensupply",
    "gettransaction",
    "gettransactioncount",
    "getversion",
    "getvoteaccounts",
    "isblockhashvalid",
    "minimumledgerslot",
    "requestairdrop",
    "sendtransaction",
    "simulatetransaction"
  ],
  "defaultOpen": true
}
---
title: minimumLedgerSlot
hideTableOfContents: true
h1: minimumLedgerSlot RPC Method
---

Returns the lowest slot that the node has information about in its ledger.

<Callout type="info">
  This value may increase over time if the node is configured to purge older
  ledger data
</Callout>

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "minimumLedgerSlot"
}
```

```ts !!request title="Kit"
import { createSolanaRpc } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

let minLedgerSlot = await rpc.minimumLedgerSlot().send();

console.log(minLedgerSlot);
```

```ts !!request title="web3.js"
import { Connection, clusterApiUrl } from "@solana/web3.js";

const connection = new Connection(clusterApiUrl("devnet"), "confirmed");

let minLedgerSlot = await connection.getMinimumLedgerSlot();

console.log(minLedgerSlot);
```

```rs !!request title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::commitment_config::CommitmentConfig;

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

    let min_ledger_slot = client.minimum_ledger_slot().await?;

    println!("{}", min_ledger_slot);

    Ok(())
}
```

### !params

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover result
  "result": 1234,
  "id": 1
}
```

!type u64

The minimum ledger slot number

</APIMethod>
---
title: requestAirdrop
hideTableOfContents: true
h1: requestAirdrop RPC Method
---

Requests an airdrop of lamports to a Pubkey

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "requestAirdrop",
  "params": [
    // !hover pubkey
    "83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri",
    // !hover lamports
    1000000000,
    // !hover(1:3) config
    {
      // !hover commitment
      "commitment": "finalized"
    }
  ]
}
```

```ts !!request title="Kit"
import { address, createSolanaRpc, lamports } from "@solana/kit";
import { LAMPORTS_PER_SOL } from "@solana/web3.js";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

// !hover pubkey
let receiver = address("4kg8oh3jdNtn7j2wcS7TrUua31AgbLzDVkBZgTAe44aF");

// !hover lamports
let airdropAmt = lamports(BigInt(1 * LAMPORTS_PER_SOL));

let signature = await rpc.requestAirdrop(receiver, airdropAmt).send();

console.log(signature);
```

```ts !!request title="web3.js"
import {
  Connection,
  LAMPORTS_PER_SOL,
  PublicKey,
  clusterApiUrl,
} from "@solana/web3.js";

const connection = new Connection(clusterApiUrl("devnet"), "confirmed");

// !hover pubkey
let receiver = new PublicKey("4kg8oh3jdNtn7j2wcS7TrUua31AgbLzDVkBZgTAe44aF");

// !hover lamports
let airdropAmt = 1 * LAMPORTS_PER_SOL;

let sig = await connection.requestAirdrop(receiver, airdropAmt);

console.log(sig);
```

```rs !!request title="Rust"
use anyhow::Result;
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{commitment_config::CommitmentConfig, native_token::LAMPORTS_PER_SOL, pubkey};

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

    // !hover pubkey
    let receiver = pubkey!("4kg8oh3jdNtn7j2wcS7TrUua31AgbLzDVkBZgTAe44aF");

    // !hover lamports
    let lamports = 1 * LAMPORTS_PER_SOL;

    let transaction_signature = client.request_airdrop(&receiver, lamports).await?;
    loop {
        if client.confirm_transaction(&transaction_signature).await? {
            break;
        }
    }

    println!("{}", transaction_signature);

    Ok(())
}
```

### !params

#### !! pubkey

!type string
!required

Pubkey of account to receive lamports, as a base-58 encoded string

#### !! lamports

!type u64
!required

Amount of lamports to airdrop

#### !! config

!type object

Configuration object containing the following fields:

##### !! commitment

!type string

The commitment describes how finalized a block is at that point in time. See
[Configuring State Commitment](/docs/rpc#configuring-state-commitment).

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover result
  "result": "5VERv8NMvzbJMEkV8xnrLkEaWRtSz9CosKDYjCJjBRnbJLgp8uirBgmQpjKhoR4tjF3ZpRzrFmBV6UjKdiSZkQUW",
  "id": 1
}
```

!type string

Transaction Signature of the airdrop, as a base-58 encoded string

</APIMethod>
---
title: sendTransaction
hideTableOfContents: true
h1: sendTransaction RPC Method
---

Submits a signed transaction to the cluster for processing.

This method does not alter the transaction in any way; it relays the transaction
created by clients to the node as-is.

If the node's rpc service receives the transaction, this method immediately
succeeds, without waiting for any confirmations. A successful response from this
method does not guarantee the transaction is processed or confirmed by the
cluster.

While the rpc service will reasonably retry to submit it, the transaction could
be rejected if transaction's `recent_blockhash` expires before it lands.

Use [`getSignatureStatuses`](/docs/rpc/http/getsignaturestatuses) to ensure a
transaction is processed and confirmed.

Before submitting, the following preflight checks are performed:

1. The transaction signatures are verified
2. The transaction is simulated against the bank slot specified by the preflight
   commitment. On failure an error will be returned. Preflight checks may be
   disabled if desired. It is recommended to specify the same commitment and
   preflight commitment to avoid confusing behavior.

The returned signature is the first signature in the transaction, which is used
to identify the transaction
([transaction id](/docs/references/terminology#transaction-id)). This identifier
can be easily extracted from the transaction data before submission.

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "sendTransaction",
  "params": [
    // !hover transaction
    "4hXTCkRzt9WyecNzV1XPgCDfGAZzQKNxLXgynz5QDuWWPSAZBZSHptvWRL3BjCvzUXRdKvHL2b7yGrRQcWyaqsaBCncVG7BFggS8w9snUts67BSh3EqKpXLUm5UMHfD7ZBe9GhARjbNQMLJ1QD3Spr6oMTBU6EhdB4RD8CP2xUxr2u3d6fos36PD98XS6oX8TQjLpsMwncs5DAMiD4nNnR8NBfyghGCWvCVifVwvA8B8TJxE1aiyiv2L429BCWfyzAme5sZW8rDb14NeCQHhZbtNqfXhcp2tAnaAT"
  ]
}
```

```ts !!request title="Kit"
import {
  createSolanaRpc,
  type Base64EncodedWireTransaction,
} from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

// !hover transaction
const base64Tx =
  "AbC/XNkPUUZ7/51SaG1wbG0ojrWHIGzVL73M8hRnDr73RkBAZc0ZnikluvcCeprAmqHDJrcPxPUbvEJMVBIiVQeAAQABAzfDSQC/GjcggrLsDpYz7jAlT+Gca846HqtFb8UQMM9cCWPIi4AX32PV8HrY7/1WgoRc3IATttceZsUMeQ1qx7UAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIgsVWEgMTiOYp63gTtuYGw+izfm6wKQdivpiXQBpNnYAQICAAEMAgAAAEBCDwAAAAAAAA==";

const signature = await rpc
  .sendTransaction(base64Tx as Base64EncodedWireTransaction, {
    encoding: "base64",
  })
  .send();

console.log(signature);
```

```ts !!request title="web3.js"
import {
  Connection,
  VersionedTransaction,
  clusterApiUrl,
} from "@solana/web3.js";

const connection = new Connection(clusterApiUrl("devnet"), "confirmed");

const base64Tx =
  "AbuRLtc5C9bZtAUT4F4Y2H5SRRUK1HwOFZOK3V4qm/78MDJt+M2de/RCCaI3iTyodDepmrkUWbss0XRHS0lk5AOAAQABAzfDSQC/GjcggrLsDpYz7jAlT+Gca846HqtFb8UQMM9cCWPIi4AX32PV8HrY7/1WgoRc3IATttceZsUMeQ1qx7UAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD2dTRgcJmzcoGH1R3c2WqtHah2H19KvbC1p6BxLDqfoAQICAAEMAgAAAADKmjsAAAAAAA==";

// !hover transaction
let tx = VersionedTransaction.deserialize(Buffer.from(base64Tx, "base64"));

let sig = await connection.sendTransaction(tx);

console.log(sig);
```

```rs !!request title="Rust"
use anyhow::Result;
use base64::{Engine as _, engine::general_purpose};
use solana_client::{nonblocking::rpc_client::RpcClient, rpc_config::RpcSendTransactionConfig};
use solana_sdk::{
    commitment_config::{CommitmentConfig, CommitmentLevel},
    transaction::VersionedTransaction,
};
use solana_transaction_status_client_types::UiTransactionEncoding;

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

    // !hover transaction
    let b64_tx = "AbuRLtc5C9bZtAUT4F4Y2H5SRRUK1HwOFZOK3V4qm/78MDJt+M2de/RCCaI3iTyodDepmrkUWbss0XRHS0lk5AOAAQABAzfDSQC/GjcggrLsDpYz7jAlT+Gca846HqtFb8UQMM9cCWPIi4AX32PV8HrY7/1WgoRc3IATttceZsUMeQ1qx7UAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD2dTRgcJmzcoGH1R3c2WqtHah2H19KvbC1p6BxLDqfoAQICAAEMAgAAAADKmjsAAAAAAA==";
    let tx_bytes = general_purpose::STANDARD.decode(b64_tx).unwrap();
    let tx: VersionedTransaction = bincode::deserialize(&tx_bytes).unwrap();

    // !hover(1:7) config
    let config = RpcSendTransactionConfig {
        // !hover skipPreflight
        skip_preflight: true,
        // !hover preflightCommitment
        preflight_commitment: CommitmentLevel::Finalized.into(),
        // !hover encoding
        encoding: UiTransactionEncoding::Base64.into(),
        // !hover maxRetries
        max_retries: None,
        // !hover  minContextSlot
        min_context_slot: None,
    };

    match client.send_transaction_with_config(&tx, config).await {
        Ok(signature) => println!("Transaction Signature: {}", signature),
        Err(err) => eprintln!("Error transferring tokens: {}", err),
    }

    Ok(())
}
```

### !params

#### !! transaction

!type string
!required

Fully-signed Transaction, as encoded string.

#### !! config

!type object

Configuration object containing the following fields:

##### !! encoding

!type string
!values base58 base64
!default base58

Encoding used for the transaction data. Values: `base58` (_slow_,
**DEPRECATED**), or `base64`.

##### !! skipPreflight

!type bool

When `true`, skip the preflight transaction checks. Default: `false`.

##### !! preflightCommitment

!type string

Commitment level to use for preflight. See
[Configuring State Commitment](/docs/rpc/index.mdx#configuring-state-commitment).
Default `finalized`.

##### !! maxRetries

!type usize

Maximum number of times for the RPC node to retry sending the transaction to the
leader. If this parameter not provided, the RPC node will retry the transaction
until it is finalized or until the blockhash expires.

##### !! minContextSlot

!type number
!optional

Set the minimum slot at which to perform preflight transaction checks

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover result
  "result": "2id3YC2jK9G5Wo2phDx4gJVAew8DcY5NAojnVuao8rkxwPYPe8cSwE5GzhEgJA2y8fVjDEo6iR6ykBvDxrTQrtpb",
  "id": 1
}
```

!type string

First Transaction Signature embedded in the transaction, as base-58 encoded
string ([transaction id](/docs/references/terminology#transaction-id))

</APIMethod>
---
title: simulateTransaction
hideTableOfContents: true
h1: simulateTransaction RPC Method
---

Simulate sending a transaction

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "simulateTransaction",
  "params": [
    // !hover transaction
    "AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEEjNmKiZGiOtSZ+g0//wH5kEQo3+UzictY+KlLV8hjXcs44M/Xnr+1SlZsqS6cFMQc46yj9PIsxqkycxJmXT+veJjIvefX4nhY9rY+B5qreeqTHu4mG6Xtxr5udn4MN8PnBt324e51j94YQl285GzN2rYa/E2DuQ0n/r35KNihi/zamQ6EeyeeVDvPVgUO2W3Lgt9hT+CfyqHvIa11egFPCgEDAwIBAAkDZAAAAAAAAAA=",
    // !hover(1:5) config
    {
      // !hover commitment
      "commitment": "confirmed",
      // !hover encoding
      "encoding": "base64",
      // !hover replaceRecentBlockhash
      "replaceRecentBlockhash": true
    }
  ]
}
```

```ts !!request title="Kit"
import {
  createSolanaRpc,
  type Base64EncodedWireTransaction,
} from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

// !hover(1:2) transaction
const base64Tx: Base64EncodedWireTransaction =
  "AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEEjNmKiZGiOtSZ+g0//wH5kEQo3+UzictY+KlLV8hjXcs44M/Xnr+1SlZsqS6cFMQc46yj9PIsxqkycxJmXT+veJjIvefX4nhY9rY+B5qreeqTHu4mG6Xtxr5udn4MN8PnBt324e51j94YQl285GzN2rYa/E2DuQ0n/r35KNihi/zamQ6EeyeeVDvPVgUO2W3Lgt9hT+CfyqHvIa11egFPCgEDAwIBAAkDZAAAAAAAAAA=" as Base64EncodedWireTransaction;

// !hover(1:9) config
let simulateTxConfig = {
  // !hover commitment
  commitment: "finalized",
  // !hover encoding
  encoding: "base64",
  // !hover replaceRecentBlockhash
  replaceRecentBlockhash: true,
  // !hover sigVerify
  sigVerify: false,
  // !hover minContextSlot
  minContextSlot: undefined,
  // !hover innerInstructions
  innerInstructions: undefined,
  // !hover accounts
  accounts: undefined,
};

let simulateResult = await rpc
  .simulateTransaction(base64Tx, simulateTxConfig)
  .send();

console.log(simulateResult);
```

```ts !!request title="web3.js"
import {
  Connection,
  VersionedTransaction,
  clusterApiUrl,
  type SimulateTransactionConfig,
} from "@solana/web3.js";

const connection = new Connection(clusterApiUrl("devnet"), "confirmed");

// !hover(1:2) transaction
const base64Tx =
  "AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEEjNmKiZGiOtSZ+g0//wH5kEQo3+UzictY+KlLV8hjXcs44M/Xnr+1SlZsqS6cFMQc46yj9PIsxqkycxJmXT+veJjIvefX4nhY9rY+B5qreeqTHu4mG6Xtxr5udn4MN8PnBt324e51j94YQl285GzN2rYa/E2DuQ0n/r35KNihi/zamQ6EeyeeVDvPVgUO2W3Lgt9hT+CfyqHvIa11egFPCgEDAwIBAAkDZAAAAAAAAAA=";

let tx = VersionedTransaction.deserialize(Buffer.from(base64Tx, "base64"));

// !hover(1:9) config
let simulateTxConfig: SimulateTransactionConfig = {
  // !hover commitment
  commitment: "finalized",
  // !hover replaceRecentBlockhash
  replaceRecentBlockhash: true,
  // !hover sigVerify
  sigVerify: false,
  // !hover minContextSlot
  minContextSlot: undefined,
  // !hover innerInstructions
  innerInstructions: undefined,
  // !hover accounts
  accounts: undefined,
};

let simulateResult = await connection.simulateTransaction(tx, simulateTxConfig);

console.log(simulateResult);
```

```rs !!request title="Rust"
use anyhow::Result;
use base64::{Engine as _, engine::general_purpose};
use solana_client::{nonblocking::rpc_client::RpcClient, rpc_config::RpcSimulateTransactionConfig};
use solana_sdk::{commitment_config::CommitmentConfig, transaction::VersionedTransaction};
use solana_transaction_status_client_types::UiTransactionEncoding;

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed(),
    );

    // !hover(1:2) transaction
    let b64_tx = "AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEEjNmKiZGiOtSZ+g0//wH5kEQo3+UzictY+KlLV8hjXcs44M/Xnr+1SlZsqS6cFMQc46yj9PIsxqkycxJmXT+veJjIvefX4nhY9rY+B5qreeqTHu4mG6Xtxr5udn4MN8PnBt324e51j94YQl285GzN2rYa/E2DuQ0n/r35KNihi/zamQ6EeyeeVDvPVgUO2W3Lgt9hT+CfyqHvIa11egFPCgEDAwIBAAkDZAAAAAAAAAA=";
    let tx_bytes = general_purpose::STANDARD.decode(b64_tx).unwrap();
    let tx: VersionedTransaction = bincode::deserialize(&tx_bytes).unwrap();

    // !hover(1:9) config
    let config = RpcSimulateTransactionConfig {
        // !hover commitment
        commitment: CommitmentConfig::finalized().into(),
        // !hover encoding
        encoding: UiTransactionEncoding::Base64.into(),
        // !hover replaceRecentBlockhash
        replace_recent_blockhash: true,
        // !hover sigVerify
        sig_verify: false,
        // !hover minContextSlot
        min_context_slot: None,
        // !hover innerInstructions
        inner_instructions: false,
        // !hover accounts
        accounts: None,
    };

    let simulate_result = client.simulate_transaction_with_config(&tx, config).await?;

    println!("{:#?}", simulate_result);

    Ok(())
}
```

### !params

#### !! transaction

!type string
!required

Transaction, as an encoded string.

<Callout type="info">
  The transaction must have a valid blockhash, but is not required to be signed.
</Callout>

#### !! config

!type object
!optional

Configuration object containing the following fields:

##### !! commitment

!type string

Commitment level to simulate the transaction at. See
[Configuring State Commitment](/docs/rpc/index.mdx#configuring-state-commitment).
Default `finalized`.

##### !! encoding

!type string
!values base58 base64
!default base58

Encoding used for the transaction data. Values: `base58` (_slow_,
**DEPRECATED**), or `base64`.


##### !! replaceRecentBlockhash

!type bool
!defaultValue false

If `true` the transaction recent blockhash will be replaced with the most recent
blockhash (conflicts with `sigVerify`)

##### !! sigVerify

!type bool
!defaultValue false

If `true` the transaction signatures will be verified (conflicts with
`replaceRecentBlockhash`)

##### !! minContextSlot

!type number
!optional

The minimum slot that the request can be evaluated at


##### !! innerInstructions

!type bool
!defaultValue false

If `true` the response will include
[inner instructions](/docs/rpc/json-structures#inner-instructions). These inner
instructions will be `jsonParsed` where possible, otherwise `json`.

##### !! accounts

!type object
!optional

Accounts configuration object containing the following fields:

- `addresses`: An array of accounts to return, as base-58 encoded strings
- `encoding`: Encoding for returned Account data. Note: `jsonParsed` encoding
  attempts to use program-specific state parsers to return more human-readable
  and explicit account state data. If `jsonParsed` is requested but a
  [parser cannot be found](https://github.com/solana-labs/solana/blob/cfd0a00ae2ba85a6d76757df8b4fa38ed242d185/account-decoder/src/parse_account_data.rs#L98-L100),
  the field falls back to `base64` encoding, detectable when the returned
  `accounts.data` field is type `string`.

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  "result": {
    "context": {
      "apiVersion": "2.3.3",
      "slot": 393226680
    },
    // !hover(1:18) value
    "value": {
      // !hover accounts
      "accounts": null,
      // !hover err
      "err": null,
      // !hover innerInstructions
      "innerInstructions": null,
      // !hover loadedAccountsDataSize
      "loadedAccountsDataSize": 413,
      // !hover(1:6) logs
      "logs": [
        "Program TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb invoke [1]",
        "Program log: Instruction: Transfer",
        "Program TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb consumed 1714 of 200000 compute units",
        "Program TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb success"
      ],
      // !hover(1:4) replacementBlockhash
      "replacementBlockhash": {
        "blockhash": "6oFLsE7kmgJx9PjR4R63VRNtpAVJ648gCTr3nq5Hihit",
        "lastValidBlockHeight": 381186895
      },
      // !hover returnData
      "returnData": null,
      // !hover unitsConsumed
      "unitsConsumed": 1714
    }
  },
  "id": 1
}
```

!type object

The result will contain:

##### !! accounts

!type array|null

Array of accounts with the same length as the `accounts.addresses` array in the
request. Each element is either:

- `null` - if the account doesn't exist or if `err` is not null
- An object containing:
  - `lamports: <u64>` - number of lamports assigned to this account
  - `owner: <string>` - base-58 encoded Pubkey of the program this account has
    been assigned to
  - `data: <[string, encoding]|object>` - data associated with the account,
    either as encoded binary data or JSON format `{<program>: <state>}`
  - `executable: <bool>` - boolean indicating if the account contains a program
  - `rentEpoch: <u64>` - the epoch at which this account will next owe rent

##### !! err

!type object|string|null

Error if transaction failed, null if transaction succeeded. See
[TransactionError definitions](https://github.com/solana-labs/solana/blob/c0c60386544ec9a9ec7119229f37386d9f070523/sdk/src/transaction/error.rs#L13)

##### !! innerInstructions

!type object|undefined

Defined only if `innerInstructions` was set to `true`. The value is a list of
[inner instructions](/docs/rpc/json-structures#inner-instructions).

##### !! loadedAccountsDataSize

!type u32|undefined

The number of bytes of all accounts loaded by this transaction

##### !! logs

!type array|null

Array of log messages the transaction instructions output during execution, null
if simulation failed before the transaction was able to execute

##### !! replacementBlockhash

!type object|null

The blockhash used to simulate the transaction, containing:

- `blockhash: <string>` - the blockhash used to simulate the transaction
- `lastValidBlockHeight: <u64>` - the last valid block height at which the
  blockhash is valid

##### !! returnData

!type object|null

The most-recent return data generated by an instruction in the transaction,
containing:

- `programId: <string>` - the program that generated the return data, as base-58
  encoded Pubkey
- `data: <[string, encoding]>` - the return data itself, as base-64 encoded
  binary data

##### !! unitsConsumed

!type u64|undefined

The number of compute budget units consumed during the processing of this
transaction

</APIMethod>
---
title: voteSubscribe
hideTableOfContents: true
h1: voteSubscribe RPC Method
---

Subscribe to receive notification anytime a new vote is observed in gossip.
These votes are pre-consensus therefore there is no guarantee these votes will
enter the ledger.

<Callout type="warn" title={"Unstable Method"}>
  This subscription is unstable and only available if the validator was started
  with the `--rpc-pubsub-enable-vote-subscription` flag. The format of this
  subscription may change in the future.
</Callout>

<APIMethod>

```jsonc !!request
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "voteSubscribe"
}
```

### !params

**None**

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover result
  "result": 0,
  "id": 1
}
```

!type integer

subscription id (needed to unsubscribe)

</APIMethod>

#### Notification Format:

The notification will be an object with the following fields:

- `hash: <string>` - The vote hash
- `slots: <array>` - The slots covered by the vote, as an array of u64 integers
- `timestamp: <i64|null>` - The timestamp of the vote
- `signature: <string>` - The signature of the transaction that contained this
  vote
- `votePubkey: <string>` - The public key of the vote account, as base-58
  encoded string

```json
{
  "jsonrpc": "2.0",
  "method": "voteNotification",
  "params": {
    "result": {
      "hash": "8Rshv2oMkPu5E4opXTRyuyBeZBqQ4S477VG26wUTFxUM",
      "slots": [1, 2],
      "timestamp": null
    },
    "subscription": 0
  }
}
```
---
title: voteUnsubscribe
hideTableOfContents: true
h1: voteUnsubscribe RPC Method
---

Unsubscribe from vote notifications

<APIMethod>

```jsonc !!request
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "voteUnsubscribe",
  "params": [
    // !hover 0
    0
  ]
}
```

### !params

#### !! 0

!type integer  
!required

subscription id to cancel

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover result
  "result": true,
  "id": 1
}
```

!type boolean

unsubscribe success message

</APIMethod># OpenSVM Project Structure

## Root Directory Organization

```
opensvm/
â”œâ”€â”€ app/                  # Next.js App Router (pages and API routes)
â”œâ”€â”€ components/           # React components (reusable UI)
â”œâ”€â”€ lib/                  # Core libraries and utilities
â”œâ”€â”€ types/                # TypeScript type definitions
â”œâ”€â”€ utils/                # Utility functions
â”œâ”€â”€ public/               # Static assets
â”œâ”€â”€ docs/                 # Documentation
â”œâ”€â”€ __tests__/            # Unit tests
â”œâ”€â”€ e2e/                  # End-to-end tests
â””â”€â”€ scripts/              # Build and utility scripts
```

## App Directory (Next.js App Router)

```
app/
â”œâ”€â”€ api/                  # API routes
â”‚   â”œâ”€â”€ account-*/        # Account-related endpoints
â”‚   â”œâ”€â”€ ai-response/      # AI assistant endpoints
â”‚   â”œâ”€â”€ analytics/        # Analytics endpoints
â”‚   â”œâ”€â”€ anomaly/          # Anomaly detection endpoints
â”‚   â”œâ”€â”€ auth/             # Authentication endpoints
â”‚   â”œâ”€â”€ block*/           # Block data endpoints
â”‚   â”œâ”€â”€ chat/             # Chat/AI endpoints
â”‚   â”œâ”€â”€ nft*/             # NFT-related endpoints
â”‚   â”œâ”€â”€ search/           # Search endpoints
â”‚   â”œâ”€â”€ solana-*/         # Solana integration endpoints
â”‚   â”œâ”€â”€ sse-*/            # Server-sent events endpoints
â”‚   â”œâ”€â”€ stream/           # Streaming endpoints
â”‚   â”œâ”€â”€ token*/           # Token-related endpoints
â”‚   â”œâ”€â”€ transaction/      # Transaction endpoints
â”‚   â””â”€â”€ user-*/           # User-related endpoints
â”œâ”€â”€ account/[address]/    # Account explorer pages
â”œâ”€â”€ block/[slot]/         # Block explorer pages
â”œâ”€â”€ tx/[signature]/       # Transaction explorer pages
â”œâ”€â”€ token/[mint]/         # Token explorer pages
â”œâ”€â”€ program/[address]/    # Program explorer pages
â”œâ”€â”€ analytics/            # Analytics dashboard pages
â”œâ”€â”€ chat/                 # AI chat interface
â”œâ”€â”€ monitoring/           # Network monitoring pages
â”œâ”€â”€ wallet-path-finding/  # Wallet connection analysis
â”œâ”€â”€ components/           # Page-specific components
â”œâ”€â”€ providers/            # React context providers
â”œâ”€â”€ styles/               # Page-specific styles
â””â”€â”€ layout.tsx            # Root layout component
```

## Components Directory

```
components/
â”œâ”€â”€ ui/                   # Base UI components (buttons, inputs, etc.)
â”œâ”€â”€ ai/                   # AI-related components
â”‚   â”œâ”€â”€ actions/          # AI action components
â”‚   â”œâ”€â”€ capabilities/     # AI capability components
â”‚   â”œâ”€â”€ core/             # Core AI components
â”‚   â”œâ”€â”€ hooks/            # AI-related hooks
â”‚   â”œâ”€â”€ layouts/          # AI interface layouts
â”‚   â”œâ”€â”€ modals/           # AI modal components
â”‚   â””â”€â”€ types/            # AI type definitions
â”œâ”€â”€ analytics/            # Analytics visualization components
â”œâ”€â”€ blockchain-visualizations/ # Blockchain data visualizations
â”œâ”€â”€ referrals/            # Referral system components
â”œâ”€â”€ search/               # Search-related components
â”œâ”€â”€ solana/               # Solana-specific components
â”œâ”€â”€ transaction-graph/    # Transaction visualization components
â”œâ”€â”€ user-history/         # User history components
â””â”€â”€ [ComponentName].tsx   # Individual components
```

## Lib Directory (Core Logic)

```
lib/
â”œâ”€â”€ ai/                   # AI functionality
â”œâ”€â”€ cache/                # Caching implementations
â”œâ”€â”€ constants/            # Application constants
â”œâ”€â”€ data-cache/           # Data caching utilities
â”œâ”€â”€ data-sources/         # External data source integrations
â”œâ”€â”€ hooks/                # Custom React hooks
â”œâ”€â”€ sacred/               # Core business logic
â”œâ”€â”€ server/               # Server-side utilities
â”œâ”€â”€ types/                # Shared type definitions
â”œâ”€â”€ utils/                # General utilities
â”œâ”€â”€ validation/           # Input validation schemas
â”œâ”€â”€ workers/              # Web workers
â”œâ”€â”€ solana.ts             # Solana blockchain utilities
â”œâ”€â”€ transaction-parser.ts # Transaction parsing logic
â”œâ”€â”€ auth.ts               # Authentication utilities
â”œâ”€â”€ cache.ts              # Caching layer
â””â”€â”€ utils.ts              # General utility functions
```

## File Naming Conventions

### Components
- **PascalCase** for component files: `TransactionTable.tsx`
- **camelCase** for utility components: `vtable.tsx`
- **kebab-case** for directories: `transaction-graph/`

### API Routes
- **kebab-case** for route directories: `account-stats/`
- **camelCase** for dynamic routes: `[address]/`

### Utilities and Libraries
- **kebab-case** for multi-word files: `solana-connection.ts`
- **camelCase** for single concept files: `utils.ts`

## Import Path Conventions

### Absolute Imports
Use `@/` prefix for all internal imports:
```typescript
import { TransactionTable } from '@/components/TransactionTable';
import { parseTransaction } from '@/lib/transaction-parser';
import { SolanaAgent } from '@/lib/ai/core/agent';
```

### Relative Imports
Avoid relative imports except for closely related files in the same directory.

## Component Organization Patterns

### Feature-Based Grouping
Components are organized by feature area (ai/, analytics/, solana/) rather than by type.

### Barrel Exports
Use index.ts files for clean imports:
```typescript
// components/ai/index.ts
export { AIAssistant } from './AIAssistant';
export { AIChatDialog } from './AIChatDialog';
```

### Co-location
Keep related files close together:
```
components/ai/
â”œâ”€â”€ AIAssistant.tsx
â”œâ”€â”€ AIAssistant.test.tsx
â”œâ”€â”€ AIAssistant.module.css
â””â”€â”€ hooks/
    â””â”€â”€ useAIAssistant.ts
```

## Testing Structure

### Unit Tests
- Located alongside source files with `.test.ts` suffix
- Use Jest with React Testing Library
- Focus on component behavior and utility functions

### E2E Tests
- Located in `e2e/` directory
- Use Playwright for browser automation
- Test critical user flows and integrations

### Test Utilities
- Shared test utilities in `__tests__/` directory
- Mock data and helper functions for consistent testing

## Configuration Files

### Root Level
- `package.json`: Dependencies and scripts
- `tsconfig.json`: TypeScript configuration
- `tailwind.config.ts`: Tailwind CSS configuration
- `next.config.mjs`: Next.js configuration
- `.eslintrc.json`: ESLint rules
- `.env.example`: Environment variable template

### Build and Deployment
- `Dockerfile`: Container configuration
- `netlify.toml`: Netlify deployment settings
- `scripts/`: Build optimization and utility scripts# OpenSVM Technology Stack

## Core Framework & Runtime
- **Next.js 15.3.5**: React framework with App Router for server-rendered applications
- **React 18.3.1**: UI library with server and client components
- **TypeScript 5.7.3**: Typed JavaScript for better developer experience
- **Node.js 18+**: Runtime environment (Bun recommended for faster builds)

## Blockchain Integration
- **@solana/web3.js 1.98.0**: Official Solana JavaScript SDK
- **@solana/spl-token**: SPL token program integration
- **@coral-xyz/anchor**: Solana program framework
- **@debridge-finance/solana-transaction-parser**: Transaction parsing utilities

## Styling & UI
- **Tailwind CSS 3.4.1**: Utility-first CSS framework
- **Radix UI**: Accessible component primitives
- **Framer Motion**: Animation library
- **next-themes**: Theme switching support
- **Lucide React**: Icon library

## Data Visualization
- **D3.js 7.9.0**: Data visualization library
- **Cytoscape 3.31.1**: Graph visualization
- **Three.js 0.173.0**: 3D graphics library
- **Chart.js 4.4.8**: Chart library
- **Recharts**: React chart components
- **@visactor/vtable**: Virtual table component

## AI & Machine Learning
- **@mlc-ai/web-llm**: Web-based LLM integration
- **Together AI**: LLM API provider
- **@qdrant/js-client-rest**: Vector database client
- **XState 5.19.2**: State machine library for AI workflows

## Development Tools
- **ESLint**: Code linting with TypeScript support
- **Prettier**: Code formatting
- **Jest**: Unit testing framework
- **Playwright**: End-to-end testing
- **@swc/jest**: Fast Jest transformer

## Build & Deployment
- **Webpack**: Module bundler (via Next.js)
- **PostCSS**: CSS processing
- **Sass**: CSS preprocessor support
- **Docker**: Containerization support
- **Netlify**: Deployment platform support

## Common Commands

### Development
```bash
# Start development server
npm run dev
# or (recommended)
bun run dev

# Run with test environment
npm run dev:test
```

### Building
```bash
# Standard build
npm run build

# Optimized build with analysis
npm run build:optimized

# Build with bundle analysis
npm run build:analyze

# Fast build (skip optimizations)
npm run build:fast
```

### Testing
```bash
# Run unit tests
npm test

# Run E2E tests
npm run test:e2e

# Run E2E tests with UI
npm run test:e2e:ui
```

### Installation (when facing dependency issues)
```bash
# Force reinstall with Bun (recommended)
bun install --force

# Legacy peer deps (npm)
npm install --legacy-peer-deps

# Force install (npm)
npm install --force
```

### Linting & Formatting
```bash
# Run ESLint
npm run lint

# Format code with Prettier (typically via IDE)
```

## Environment Configuration
- Copy `.example.env` to `.env.local`
- Required: Solana RPC endpoints
- Optional: AI service API keys, analytics keys
- Environment variables are typed and validated

## Performance Considerations
- Bundle splitting for heavy libraries (Three.js, Solana, charts)
- Server-side rendering for SEO and performance
- Incremental static regeneration for semi-static data
- Extensive caching for blockchain data
- Code splitting and lazy loading for large components# Test & Development Routes Steering

## Routes Covered
- `/test` - General testing interface
- `/test-search` - Search functionality testing
- `/test-vtable` - Virtual table testing
- `/test/components` - Component testing showcase
- `/test/transfers` - Transfer functionality testing
- `/ui-showcase` - UI component showcase

## General Testing Interface (`/test`)

### Purpose
Comprehensive testing interface for developers to test various OpenSVM features and components.

### Key Components Required
- **TestSuite**: Main testing interface
- **FeatureTests**: Individual feature testing modules
- **APITester**: API endpoint testing tools
- **PerformanceTester**: Performance testing utilities
- **MockDataGenerator**: Generate test data
- **TestResults**: Display test results and metrics
- **TestConfiguration**: Configure test parameters

### Testing Categories
```typescript
interface TestSuite {
  name: string;
  description: string;
  tests: Test[];
  configuration: TestConfig;
  results: TestResult[];
}

interface Test {
  id: string;
  name: string;
  description: string;
  category: 'unit' | 'integration' | 'e2e' | 'performance';
  status: 'pending' | 'running' | 'passed' | 'failed';
  duration: number;
  assertions: Assertion[];
}

interface TestConfig {
  environment: 'development' | 'staging' | 'production';
  mockData: boolean;
  timeout: number;
  retries: number;
  parallel: boolean;
}
```

### Implementation Guidelines
- Provide comprehensive test coverage
- Include both automated and manual tests
- Support different test environments
- Generate detailed test reports
- Include performance benchmarking
- Support test data mocking

### Features to Implement
- Automated test execution
- Manual testing workflows
- Performance benchmarking
- API endpoint testing
- Component testing
- Integration testing
- Load testing capabilities

## Search Testing (`/test-search`)

### Purpose
Dedicated testing interface for search functionality including performance, accuracy, and edge cases.

### Key Components Required
- **SearchTester**: Main search testing interface
- **QueryGenerator**: Generate test search queries
- **ResultValidator**: Validate search results
- **PerformanceMetrics**: Search performance tracking
- **AccuracyTester**: Test search accuracy
- **EdgeCaseTester**: Test edge cases and error handling

### Search Test Types
```typescript
interface SearchTest {
  query: string;
  expectedResults: SearchResult[];
  actualResults: SearchResult[];
  accuracy: number;
  responseTime: number;
  relevanceScore: number;
}

interface SearchPerformanceTest {
  queryType: string;
  averageResponseTime: number;
  throughput: number;
  errorRate: number;
  cacheHitRate: number;
}
```

### Testing Scenarios
- Basic keyword searches
- Complex query parsing
- Filter combinations
- Pagination testing
- Real-time search suggestions
- Error handling and edge cases
- Performance under load
- Cache effectiveness

## Virtual Table Testing (`/test-vtable`)

### Purpose
Testing interface for virtual table components with large datasets and performance optimization.

### Key Components Required
- **VTableTester**: Virtual table testing interface
- **DataGenerator**: Generate large test datasets
- **PerformanceMonitor**: Monitor rendering performance
- **ScrollTester**: Test scrolling behavior
- **FilterTester**: Test filtering functionality
- **SortTester**: Test sorting performance

### Virtual Table Test Scenarios
```typescript
interface VTableTest {
  dataSize: number;
  columnCount: number;
  renderTime: number;
  scrollPerformance: ScrollMetrics;
  memoryUsage: number;
  filterPerformance: FilterMetrics;
  sortPerformance: SortMetrics;
}

interface ScrollMetrics {
  smoothness: number;
  frameRate: number;
  lagTime: number;
  jumpiness: number;
}
```

### Performance Metrics
- Initial render time
- Scroll performance
- Memory usage
- Filter response time
- Sort performance
- Column resize performance
- Data update performance

## Component Testing (`/test/components`)

### Purpose
Showcase and testing interface for all UI components with different states and configurations.

### Key Components Required
- **ComponentShowcase**: Display all components
- **StateManager**: Test different component states
- **PropsTester**: Test component props
- **InteractionTester**: Test user interactions
- **AccessibilityTester**: Test accessibility features
- **ResponsiveTester**: Test responsive behavior

### Component Categories
```typescript
interface ComponentTest {
  component: string;
  variants: ComponentVariant[];
  states: ComponentState[];
  props: ComponentProps;
  accessibility: AccessibilityTest;
  responsive: ResponsiveTest;
}

interface ComponentVariant {
  name: string;
  props: any;
  description: string;
  screenshot?: string;
}

interface ComponentState {
  name: string;
  data: any;
  description: string;
}
```

### Testing Features
- Visual regression testing
- Interaction testing
- Accessibility compliance
- Responsive design testing
- Performance testing
- Error state testing
- Loading state testing

## Transfer Testing (`/test/transfers`)

### Purpose
Testing interface for token transfer functionality including validation, processing, and error handling.

### Key Components Required
- **TransferTester**: Main transfer testing interface
- **TransactionSimulator**: Simulate transfer transactions
- **ValidationTester**: Test input validation
- **ErrorHandler**: Test error scenarios
- **PerformanceMonitor**: Monitor transfer performance
- **SecurityTester**: Test security measures

### Transfer Test Scenarios
```typescript
interface TransferTest {
  fromAddress: string;
  toAddress: string;
  amount: number;
  token: string;
  expectedResult: 'success' | 'failure';
  actualResult: string;
  validationErrors: ValidationError[];
  processingTime: number;
}

interface ValidationError {
  field: string;
  error: string;
  severity: 'warning' | 'error';
}
```

### Test Cases
- Valid transfer scenarios
- Invalid address formats
- Insufficient balance handling
- Network error simulation
- Rate limiting testing
- Security validation
- Performance under load

## UI Showcase (`/ui-showcase`)

### Purpose
Comprehensive showcase of all UI components and design system elements.

### Key Components Required
- **DesignSystem**: Design system documentation
- **ComponentLibrary**: All UI components display
- **ColorPalette**: Color system showcase
- **Typography**: Typography system display
- **IconLibrary**: Icon collection showcase
- **LayoutExamples**: Layout pattern examples
- **InteractionPatterns**: Interaction design patterns

### Showcase Categories
```typescript
interface UIShowcase {
  category: string;
  components: ShowcaseComponent[];
  examples: Example[];
  guidelines: Guideline[];
}

interface ShowcaseComponent {
  name: string;
  description: string;
  variants: ComponentVariant[];
  usage: UsageExample[];
  props: PropDefinition[];
}

interface Example {
  title: string;
  description: string;
  code: string;
  preview: React.ComponentType;
}
```

### Design System Elements
- Color palette and usage
- Typography scale and hierarchy
- Spacing and layout system
- Component variants and states
- Icon library and usage
- Animation and transitions
- Responsive breakpoints
- Accessibility guidelines

## API Integration

### Required Endpoints
- `GET /api/test/suite` - Get test suite configuration
- `POST /api/test/run` - Execute test suite
- `GET /api/test/results` - Get test results
- `POST /api/test/mock-data` - Generate mock data
- `GET /api/test/performance` - Get performance metrics

### Testing Data
- Mock blockchain data generation
- Test user accounts
- Sample transactions
- Test token data
- Performance benchmarks

### Test Environment Configuration
```typescript
interface TestEnvironment {
  name: string;
  baseUrl: string;
  apiEndpoints: Record<string, string>;
  mockData: boolean;
  authentication: AuthConfig;
  rateLimit: RateLimitConfig;
}
```

## Implementation Guidelines

### Development Testing
- Provide comprehensive test coverage
- Include performance benchmarking
- Support multiple test environments
- Generate detailed reports
- Include visual regression testing
- Support automated CI/CD integration

### User Testing
- Provide user-friendly testing interfaces
- Include guided testing workflows
- Support feedback collection
- Generate usability reports
- Include accessibility testing
- Support mobile testing

### Performance Testing
- Load testing capabilities
- Stress testing scenarios
- Memory usage monitoring
- Network performance testing
- Database performance testing
- Real-time monitoring

## Security Considerations
- Secure test data handling
- Prevent test data leakage
- Rate limit test executions
- Validate test inputs
- Audit test activities
- Secure test environments

## Accessibility Requirements
- Screen reader compatible testing interfaces
- Keyboard navigation for all test features
- High contrast mode support
- Alternative text for visual elements
- Focus management in test interfaces

## Mobile Optimization
- Responsive test interfaces
- Touch-friendly controls
- Mobile-specific test scenarios
- Performance testing on mobile
- Network condition simulation

## Monitoring and Analytics
- Test execution tracking
- Performance metrics collection
- Error rate monitoring
- User interaction analytics
- Test coverage reporting
- Automated alerting for failures# Token Explorer Routes Steering

## Routes Covered
- `/token/[mint]` - Individual token details
- `/token/[mint]/opengraph-image` - Token social sharing images
- `/tokens` - Token list and market data
- `/tokens/gainers` - Top gaining tokens
- `/tokens/new` - Recently launched tokens

## Token Detail Page (`/token/[mint]`)

### Purpose
Comprehensive token information including metadata, statistics, holder analysis, transfer history, and market data.

### Key Components Required
- **TokenDetails**: Main token information display
- **TokenMarketTable**: Market data and price information
- **TokenAccounts**: Holder distribution and top holders
- **TransfersTable**: Token transfer history
- **TokenStatistics**: Supply, circulation, and metrics
- **PriceChart**: Historical price and volume charts
- **TokenSocialInfo**: Community links and social media

### Data Requirements
```typescript
interface TokenData {
  mint: string;
  metadata: TokenMetadata;
  supply: TokenSupply;
  marketData: TokenMarketData;
  holders: TokenHolder[];
  transfers: TokenTransfer[];
  statistics: TokenStatistics;
  socialLinks: SocialLinks;
}

interface TokenMetadata {
  name: string;
  symbol: string;
  decimals: number;
  description?: string;
  image?: string;
  creator: string;
  verified: boolean;
  tags: string[];
}

interface TokenSupply {
  total: number;
  circulating: number;
  burned: number;
  locked: number;
}

interface TokenMarketData {
  price: number;
  priceChange24h: number;
  volume24h: number;
  marketCap: number;
  fullyDilutedMarketCap: number;
  liquidity: number;
  holders: number;
}

interface TokenHolder {
  address: string;
  balance: number;
  percentage: number;
  rank: number;
  isContract: boolean;
}

interface TokenStatistics {
  transferCount24h: number;
  uniqueHolders: number;
  averageHoldingTime: number;
  concentrationRatio: number;
  liquidityScore: number;
}
```

### Implementation Guidelines
- Use server-side rendering for SEO optimization
- Implement real-time price updates via WebSocket
- Cache token metadata aggressively (rarely changes)
- Show loading states for different data sections
- Implement infinite scroll for transfer history
- Add price alerts and watchlist functionality

### Market Data Integration
- Connect to multiple price data sources
- Implement fallback for price data failures
- Show price in multiple currencies (USD, SOL)
- Display price charts with different timeframes
- Calculate market metrics accurately

### Holder Analysis Features
- Top holders list with percentage ownership
- Holder distribution charts
- Whale movement tracking
- New holder acquisition metrics
- Holder retention analysis

## Token List Page (`/tokens`)

### Purpose
Browse all tokens with market data, filtering, and real-time updates.

### Key Components Required
- **TokenMarketTable**: Main table with market data
- **TokenFilters**: Filtering and search controls
- **MarketOverview**: Overall market statistics
- **TrendingTokens**: Popular tokens section

### Features to Implement
- Real-time price updates every 30 seconds
- Advanced filtering (price range, market cap, volume)
- Search by name, symbol, or mint address
- Sorting by various metrics
- Export functionality for token data
- Watchlist and favorites functionality

### Table Columns
- Token name and symbol with logo
- Current price with 24h change
- Market cap and fully diluted market cap
- 24h volume and volume change
- Circulating supply
- Number of holders
- Price chart sparkline

## Token Gainers Page (`/tokens/gainers`)

### Purpose
Display top performing tokens by price change over different timeframes.

### Key Components Required
- **GainersTable**: Sorted by price performance
- **TimeframeSelector**: 1h, 24h, 7d, 30d options
- **PerformanceCharts**: Visual performance indicators
- **GainerAlerts**: Notification system for big movers

### Features to Implement
- Multiple timeframe analysis
- Percentage and absolute change display
- Volume-weighted performance metrics
- Alert system for significant moves
- Historical gainer tracking

### Data Structure
```typescript
interface TokenGainer {
  mint: string;
  name: string;
  symbol: string;
  image: string;
  priceChange: {
    '1h': number;
    '24h': number;
    '7d': number;
    '30d': number;
  };
  volume24h: number;
  marketCap: number;
  rank: number;
}
```

## New Tokens Page (`/tokens/new`)

### Purpose
Showcase recently launched tokens with launch metrics and early performance data.

### Key Components Required
- **NewTokensTable**: Recently launched tokens
- **LaunchMetrics**: Launch performance indicators
- **TokenLaunchCalendar**: Upcoming token launches
- **RiskIndicators**: Safety and verification status

### Features to Implement
- Launch date and time tracking
- Initial price and current performance
- Liquidity pool creation tracking
- Verification status indicators
- Risk assessment for new tokens
- Launch announcement integration

### Launch Metrics
```typescript
interface TokenLaunch {
  mint: string;
  launchDate: number;
  initialPrice: number;
  currentPrice: number;
  priceChangeFromLaunch: number;
  initialLiquidity: number;
  currentLiquidity: number;
  holderGrowth: number;
  verified: boolean;
  riskScore: number;
}
```

## OpenGraph Images (`/token/[mint]/opengraph-image`)

### Purpose
Generate dynamic social sharing images for token pages.

### Implementation Guidelines
- Include token logo and name prominently
- Show current price and 24h change
- Display market cap and volume
- Use color coding for price changes (green/red)
- Include mini price chart if space allows
- Maintain consistent OpenSVM branding

### Image Content
```typescript
interface TokenOGData {
  name: string;
  symbol: string;
  logo: string;
  price: string;
  priceChange24h: number;
  marketCap: string;
  volume24h: string;
  holders: number;
}
```

## API Integration

### Required Endpoints
- `GET /api/token/[mint]` - Get comprehensive token data
- `GET /api/token-stats/[mint]` - Get token statistics
- `GET /api/tokens` - Get token list with market data
- `GET /api/tokens/gainers` - Get top gaining tokens
- `GET /api/tokens/new` - Get recently launched tokens
- `GET /api/token/[mint]/holders` - Get token holder data
- `GET /api/token/[mint]/transfers` - Get token transfer history
- `GET /api/token/[mint]/chart` - Get price chart data

### Real-time Data
- WebSocket connection for live price updates
- Server-sent events for market data changes
- Push notifications for significant price movements
- Real-time holder count updates

### Caching Strategy
- Token metadata: Cache for 1 hour
- Market data: Cache for 30 seconds
- Holder data: Cache for 5 minutes
- Transfer history: Cache for 1 minute
- Price charts: Cache for 30 seconds

## Testing Requirements

### Unit Tests
- Token data parsing and validation
- Price calculation accuracy
- Market metrics computation
- Holder analysis algorithms
- Chart data generation

### Integration Tests
- Token page loads with valid mint
- Invalid mints show appropriate errors
- Market data updates correctly
- Filtering and search functionality
- Real-time updates work properly

### E2E Tests
- Token search and navigation
- Market data display accuracy
- Price chart interactions
- Holder list functionality
- Transfer history pagination

## Performance Considerations
- Lazy load heavy components (charts, holder lists)
- Implement virtual scrolling for large datasets
- Use React.memo for token list items
- Optimize image loading for token logos
- Bundle split chart libraries

## Security Considerations
- Validate mint addresses before processing
- Sanitize token metadata display
- Rate limit price data requests
- Prevent manipulation of market data
- Secure handling of holder information

## Accessibility Requirements
- Screen reader support for price changes
- Keyboard navigation for tables
- High contrast mode for charts
- Alternative text for token logos
- ARIA labels for interactive elements

## Mobile Optimization
- Responsive table design
- Touch-friendly chart interactions
- Optimized loading for mobile networks
- Simplified view for small screens
- Swipe gestures for navigation

## SEO Optimization
- Dynamic meta titles with token name and price
- Rich meta descriptions with market data
- Structured data for token information
- Canonical URLs for token pages
- Sitemap inclusion for verified tokens

## Monitoring and Analytics
- Track token page views and engagement
- Monitor price data accuracy and latency
- Measure chart rendering performance
- Track user interactions with features
- Monitor error rates and API failures# Transaction Explorer Routes Steering

## Routes Covered
- `/tx` - Transaction search landing page
- `/tx/[signature]` - Individual transaction details
- `/tx/[signature]/graph` - Transaction graph visualization
- `/tx/[signature]/opengraph-image` - Transaction social sharing images

## Transaction Detail Page (`/tx/[signature]`)

### Purpose
Provide comprehensive analysis of individual Solana transactions including instructions, account changes, fees, and AI-powered explanations.

### Key Components Required
- **TransactionDetails**: Main transaction information display
- **InstructionBreakdown**: Detailed instruction parsing and analysis
- **AccountChangesDisplay**: Before/after account state visualization
- **TransactionGraph**: Visual representation of transaction flow
- **AITransactionExplanation**: AI-powered natural language explanation
- **RelatedTransactionsDisplay**: Connected transactions discovery
- **TransactionFailureAnalysis**: Error analysis for failed transactions

### Data Requirements
```typescript
interface TransactionData {
  signature: string;
  slot: number;
  blockTime: number | null;
  fee: number;
  status: 'success' | 'failed';
  instructions: ParsedInstruction[];
  accountChanges: AccountChange[];
  logs: string[];
  meta: TransactionMeta;
  relatedTransactions: string[];
  aiAnalysis?: AIAnalysis;
}

interface ParsedInstruction {
  programId: string;
  programName: string;
  instructionType: string;
  data: any;
  accounts: InstructionAccount[];
  innerInstructions?: ParsedInstruction[];
}

interface AccountChange {
  address: string;
  before: AccountState;
  after: AccountState;
  change: {
    lamports: number;
    data: any;
    owner?: string;
  };
}

interface AIAnalysis {
  summary: string;
  purpose: string;
  riskLevel: 'low' | 'medium' | 'high';
  keyInsights: string[];
  technicalDetails: string;
  recommendations: string[];
}
```

### Implementation Guidelines
- Use Suspense for async data loading
- Implement comprehensive error boundaries
- Show progressive loading states (signature validation â†’ transaction fetch â†’ parsing â†’ AI analysis)
- Cache parsed transaction data aggressively
- Implement retry mechanism for failed requests
- Add copy-to-clipboard functionality for addresses and signatures

### AI Integration
- Trigger AI analysis automatically for complex transactions
- Show AI thinking/loading states
- Allow users to request re-analysis
- Cache AI responses to reduce API costs
- Provide technical and simplified explanation modes

### Performance Considerations
- Lazy load heavy components (graph visualization, AI analysis)
- Use React.memo for instruction list items
- Implement virtual scrolling for transactions with many instructions
- Prefetch related transactions on hover
- Optimize bundle size by code-splitting visualization libraries

## Transaction Graph Page (`/tx/[signature]/graph`)

### Purpose
Interactive graph visualization showing transaction flow, account relationships, and program interactions.

### Key Components Required
- **TransactionGraphClouds**: 3D visualization component
- **TransactionGraphFilters**: Filter controls for graph display
- **TransactionNodeDetails**: Detailed node information panel
- **GraphControls**: Zoom, pan, layout controls

### Visualization Features
- Force-directed graph layout using D3.js/Cytoscape
- Interactive nodes (accounts, programs, instructions)
- Edge weights based on SOL/token amounts
- Color coding by account type and program
- Zoom and pan functionality
- Node clustering for complex transactions
- Export to PNG/SVG functionality

### Graph Data Structure
```typescript
interface GraphData {
  nodes: GraphNode[];
  edges: GraphEdge[];
  metadata: GraphMetadata;
}

interface GraphNode {
  id: string;
  type: 'account' | 'program' | 'instruction';
  label: string;
  data: any;
  position?: { x: number; y: number };
  style: NodeStyle;
}

interface GraphEdge {
  source: string;
  target: string;
  type: 'transfer' | 'instruction' | 'account_change';
  weight: number;
  data: any;
  style: EdgeStyle;
}
```

### Interaction Features
- Click nodes to show details panel
- Hover for quick information tooltips
- Right-click context menu for actions
- Keyboard shortcuts for navigation
- Touch gestures for mobile

## Transaction Search Landing (`/tx`)

### Purpose
Entry point for transaction search with recent transactions and search suggestions.

### Key Components Required
- **SearchBar**: Transaction signature search
- **RecentTransactions**: List of recent network transactions
- **SearchSuggestions**: Auto-complete for partial signatures
- **TransactionStats**: Network transaction statistics

### Features to Implement
- Auto-complete for transaction signatures
- Recent transaction feed with real-time updates
- Transaction type filtering
- Bulk transaction analysis tools
- Export functionality for transaction lists

## OpenGraph Images (`/tx/[signature]/opengraph-image`)

### Purpose
Generate dynamic social sharing images for transaction pages.

### Implementation Guidelines
- Use Next.js ImageResponse API
- Include transaction summary (type, amount, status)
- Show key participants (sender, receiver)
- Display transaction status visually
- Include timestamp and fee information
- Use consistent OpenSVM branding

### Image Content Structure
```typescript
interface TransactionOGData {
  signature: string; // Truncated for display
  type: string; // "Token Transfer", "Program Interaction", etc.
  amount?: string; // "1.5 SOL" or "100 USDC"
  status: 'success' | 'failed';
  timestamp: string;
  fee: string;
  participants: string[]; // Key addresses involved
}
```

## API Integration

### Required Endpoints
- `GET /api/transaction/[signature]` - Get transaction details
- `POST /api/analyze-transaction` - AI analysis of transaction
- `GET /api/transaction/[signature]/related` - Find related transactions
- `GET /api/transaction/[signature]/graph` - Graph data for visualization
- `GET /api/enhanced-transaction/[signature]` - Enhanced transaction data

### Error Handling
- Invalid signatures should return 400 with clear message
- Not found transactions should return 404
- Network timeouts should trigger retry mechanism
- Partial data should be displayed with loading indicators

### Caching Strategy
- Transaction data: Cache for 1 hour (confirmed transactions are immutable)
- AI analysis: Cache for 24 hours
- Graph data: Cache for 30 minutes
- Related transactions: Cache for 15 minutes

## Testing Requirements

### Unit Tests
- Transaction signature validation
- Instruction parsing accuracy
- Account change calculation
- AI analysis integration
- Graph data generation

### Integration Tests
- Transaction page loads with valid signature
- Invalid signatures show appropriate errors
- AI analysis triggers correctly
- Graph visualization renders properly
- Related transactions are discovered

### E2E Tests
- Search for transaction works end-to-end
- Transaction details display correctly
- Graph visualization is interactive
- Social sharing generates correct images
- Mobile experience is functional

## Security Considerations
- Validate transaction signatures before processing
- Sanitize transaction data before display
- Rate limit AI analysis requests
- Prevent XSS in transaction logs display
- Secure handling of sensitive transaction data

## Performance Monitoring
- Track transaction page load times
- Monitor AI analysis response times
- Measure graph rendering performance
- Track user engagement with different features
- Monitor error rates and types

## Accessibility Requirements
- Keyboard navigation for graph visualization
- Screen reader support for transaction details
- High contrast mode for visual elements
- Alternative text for graph nodes
- Focus management in modal dialogs

## Mobile Optimization
- Touch-friendly graph controls
- Responsive transaction details layout
- Optimized loading for mobile networks
- Simplified graph view for small screens
- Swipe gestures for navigation

## SEO and Social Sharing
- Dynamic meta titles with transaction type
- Rich meta descriptions with transaction summary
- Structured data for transaction information
- Twitter Card optimization
- LinkedIn sharing optimization# Utility Routes Steering

## Routes Covered
- `/search` - Universal search interface
- `/chat` - AI chat interface
- `/scan` - QR code and address scanner
- `/share/[shareCode]` - Shared content viewer
- `/docs` - Documentation pages
- `/docs/[slug]` - Individual documentation pages
- `/slots` - Slot explorer
- `/solana` - Solana network information
- `/validator/[address]` - Validator details

## Universal Search (`/search`)

### Purpose
Comprehensive search interface with AI-enhanced results, multi-source search, and intelligent query processing.

### Key Components Required
- **SearchInterface**: Main search input and controls
- **SearchResults**: Categorized search results display
- **AISearchAssistant**: AI-powered search enhancement
- **SearchFilters**: Advanced filtering options
- **SearchSuggestions**: Auto-complete and suggestions
- **RecentSearches**: User search history
- **SearchAnalytics**: Search performance metrics

### Search Categories
```typescript
interface SearchResult {
  type: 'account' | 'transaction' | 'token' | 'block' | 'program' | 'nft';
  id: string;
  title: string;
  description: string;
  metadata: any;
  relevanceScore: number;
  source: string;
}

interface SearchQuery {
  query: string;
  filters: SearchFilter[];
  sort: SortOption;
  limit: number;
  offset: number;
}

interface SearchFilter {
  field: string;
  operator: 'equals' | 'contains' | 'greater' | 'less' | 'range';
  value: any;
}
```

### AI Search Enhancement
- Natural language query processing
- Intent recognition and entity extraction
- Contextual search suggestions
- Query expansion and refinement
- Semantic search capabilities
- Multi-modal search (text, voice, image)

### Implementation Guidelines
- Implement debounced search input
- Use server-side rendering for SEO
- Cache search results appropriately
- Show progressive loading states
- Implement search analytics tracking
- Add export functionality for results

## AI Chat Interface (`/chat`)

### Purpose
Full-screen conversational AI interface for blockchain analysis, education, and assistance.

### Key Components Required
- **ChatInterface**: Main chat conversation display
- **MessageInput**: Text and voice input controls
- **ConversationHistory**: Chat history management
- **AICapabilities**: Available AI tools and functions
- **ContextPanel**: Current context and data display
- **SettingsPanel**: AI configuration and preferences
- **ExportTools**: Conversation export functionality

### Chat Features
```typescript
interface ChatMessage {
  id: string;
  role: 'user' | 'assistant' | 'system';
  content: string;
  timestamp: number;
  context?: PageContext;
  attachments?: Attachment[];
  reactions?: Reaction[];
}

interface ChatSession {
  id: string;
  title: string;
  messages: ChatMessage[];
  context: SessionContext;
  settings: ChatSettings;
  created: number;
  lastActivity: number;
}

interface AICapability {
  name: string;
  description: string;
  category: string;
  enabled: boolean;
  parameters: Parameter[];
}
```

### AI Integration Features
- Streaming responses for better UX
- Context awareness from current page
- Multi-turn conversation support
- Code execution and analysis
- Data visualization generation
- Educational content delivery

## QR Scanner (`/scan`)

### Purpose
QR code and address scanning interface for mobile-friendly blockchain interaction.

### Key Components Required
- **QRScanner**: Camera-based QR code scanner
- **AddressInput**: Manual address input fallback
- **ScanHistory**: Previously scanned addresses
- **ScanResults**: Display scanned content analysis
- **ShareScanner**: Generate QR codes for sharing
- **BulkScanner**: Batch scanning functionality

### Scanner Features
```typescript
interface ScanResult {
  type: 'address' | 'transaction' | 'url' | 'text';
  content: string;
  metadata: any;
  timestamp: number;
  confidence: number;
}

interface QRGenerator {
  generateAddress: (address: string) => string;
  generateTransaction: (signature: string) => string;
  generateCustom: (data: any) => string;
}
```

### Implementation Guidelines
- Use device camera API for scanning
- Implement fallback for devices without camera
- Add manual input option
- Cache scan history locally
- Implement batch scanning for multiple codes
- Add QR code generation functionality

## Shared Content Viewer (`/share/[shareCode]`)

### Purpose
Display shared blockchain content with analytics tracking and social features.

### Key Components Required
- **SharedContentDisplay**: Main content viewer
- **ShareMetadata**: Information about the share
- **ShareAnalytics**: View and engagement tracking
- **RelatedContent**: Suggested related content
- **ShareActions**: Actions available on shared content
- **CommentSystem**: Comments and discussions

### Share Types
```typescript
interface SharedContent {
  shareCode: string;
  type: 'transaction' | 'account' | 'analysis' | 'chart' | 'custom';
  content: any;
  metadata: ShareMetadata;
  analytics: ShareAnalytics;
  permissions: SharePermissions;
}

interface ShareMetadata {
  title: string;
  description: string;
  creator: string;
  created: number;
  expires?: number;
  tags: string[];
}

interface ShareAnalytics {
  views: number;
  uniqueViews: number;
  shares: number;
  comments: number;
  reactions: Reaction[];
}
```

## Documentation (`/docs` and `/docs/[slug]`)

### Purpose
Comprehensive documentation system with search, navigation, and interactive examples.

### Key Components Required
- **DocumentationNav**: Navigation sidebar
- **DocumentContent**: Main documentation display
- **SearchDocs**: Documentation search
- **CodeExamples**: Interactive code samples
- **APIReference**: API documentation
- **TutorialGuide**: Step-by-step tutorials
- **FeedbackSystem**: Documentation feedback

### Documentation Structure
```typescript
interface DocumentationPage {
  slug: string;
  title: string;
  content: string;
  category: string;
  tags: string[];
  lastUpdated: number;
  author: string;
  examples: CodeExample[];
  relatedPages: string[];
}

interface CodeExample {
  language: string;
  code: string;
  description: string;
  runnable: boolean;
  output?: string;
}
```

## Slot Explorer (`/slots`)

### Purpose
Explore Solana slots with navigation and slot-specific information.

### Key Components Required
- **SlotNavigation**: Slot navigation controls
- **SlotInfo**: Current slot information
- **SlotHistory**: Recent slots display
- **SlotSearch**: Search for specific slots
- **SlotMetrics**: Slot performance metrics

## Solana Network Info (`/solana`)

### Purpose
General Solana network information and educational content.

### Key Components Required
- **NetworkOverview**: Solana network basics
- **NetworkStats**: Current network statistics
- **EducationalContent**: Learning materials
- **NetworkHistory**: Historical information
- **CommunityLinks**: Community resources

## Validator Details (`/validator/[address]`)

### Purpose
Detailed validator information including performance, staking, and rewards.

### Key Components Required
- **ValidatorInfo**: Basic validator information
- **ValidatorPerformance**: Performance metrics and history
- **StakingInfo**: Staking details and delegators
- **ValidatorRewards**: Reward distribution
- **ValidatorComparison**: Compare with other validators

### Validator Data
```typescript
interface ValidatorData {
  address: string;
  name?: string;
  website?: string;
  details?: string;
  commission: number;
  activatedStake: number;
  delegators: number;
  performance: ValidatorPerformance;
  rewards: ValidatorRewards;
  history: ValidatorHistory[];
}

interface ValidatorPerformance {
  uptime: number;
  skipRate: number;
  averageSlotTime: number;
  blocksProduced: number;
  rank: number;
  score: number;
}
```

## API Integration

### Required Endpoints
- `GET /api/search` - Universal search
- `GET /api/chat` - AI chat interface
- `GET /api/scan` - QR scanning results
- `GET /api/share/[shareCode]` - Get shared content
- `GET /api/docs` - Documentation index
- `GET /api/docs/[slug]` - Specific documentation
- `GET /api/validator/[address]` - Validator information

### Real-time Features
- Live search suggestions
- Real-time chat responses
- Live validator performance updates
- Real-time share analytics

### Caching Strategy
- Search results: Cache for 5 minutes
- Documentation: Cache for 1 hour
- Validator data: Cache for 5 minutes
- Shared content: Cache for 1 hour
- Chat history: No caching (user-specific)

## Testing Requirements

### Unit Tests
- Search algorithm accuracy
- AI chat functionality
- QR scanning logic
- Share content validation
- Documentation rendering

### Integration Tests
- Search integration works
- Chat AI responses correctly
- QR scanner functions properly
- Shared content displays correctly
- Documentation navigation works

### E2E Tests
- End-to-end search flow
- Complete chat conversations
- QR scanning and results
- Share creation and viewing
- Documentation browsing

## Performance Considerations
- Lazy load heavy components
- Implement search result virtualization
- Use Web Workers for intensive operations
- Optimize chat message rendering
- Bundle split documentation content

## Security Considerations
- Validate search queries
- Sanitize chat inputs and outputs
- Secure QR scanning results
- Validate shared content
- Rate limit API requests

## Accessibility Requirements
- Screen reader support for all interfaces
- Keyboard navigation for all features
- High contrast mode support
- Voice input alternatives
- Focus management in modals

## Mobile Optimization
- Touch-friendly interfaces
- Camera integration for QR scanning
- Responsive design for all components
- Optimized loading for mobile networks
- Gesture support for navigation

## SEO Optimization
- Dynamic meta tags for search results
- Structured data for documentation
- Canonical URLs for all pages
- Social media optimization
- Sitemap inclusion# OpenSVM AI/ML Integration Guide

## ðŸš€ Quick Start

### Basic Integration

```typescript
import { initializeAIML, QuickSetup } from '@/lib/ai/ml';

// Initialize for trading use case
const aiml = QuickSetup.forTrading();

// Perform integrated analysis
const analysis = await aiml.performIntegratedAnalysis({
  analysis_type: 'trading_focus',
  target: {
    type: 'asset',
    identifier: 'SOL'
  },
  scope: {
    time_horizon: '24h',
    depth: 'standard',
    include_predictions: true,
    include_sentiment: true,
    include_risk_analysis: true,
    include_optimization: false
  },
  preferences: {
    confidence_threshold: 0.8,
    risk_tolerance: 'moderate',
    update_frequency: 30000
  }
});

console.log('Analysis Results:', analysis);
```

### Individual Engine Usage

```typescript
import { 
  predictiveAnalyticsEngine,
  sentimentAnalysisEngine,
  portfolioOptimizationEngine,
  automatedResearchEngine
} from '@/lib/ai/ml';

// Price prediction
const prediction = await predictiveAnalyticsEngine.generatePrediction({
  asset: 'SOL',
  prediction_type: 'price',
  time_horizon: '24h',
  confidence_level: 0.95
});

// Sentiment analysis
const sentiment = await sentimentAnalysisEngine.analyzeSentiment({
  asset: 'SOL',
  sources: ['twitter', 'reddit', 'news'],
  time_range: '24h'
});

// Portfolio optimization
const optimization = await portfolioOptimizationEngine.optimizePortfolio({
  current_portfolio: [{
    token: 'SOL',
    symbol: 'SOL',
    amount: 100,
    current_value_usd: 10000
  }],
  optimization_objective: 'maximize_sharpe',
  risk_tolerance: 'moderate',
  time_horizon: '1year',
  constraints: {
    max_position_size: 60,
    min_position_size: 10,
    max_tokens: 5,
    excluded_tokens: [],
    preferred_protocols: ['Jupiter', 'Orca'],
    max_risk_score: 0.8,
    min_liquidity_score: 0.6,
    rebalance_threshold: 5
  }
});
```

## ðŸ—ï¸ System Architecture

### Component Overview

```
OpenSVM AI/ML System
â”œâ”€â”€ AIMLOrchestrator (Central coordinator)
â”œâ”€â”€ Individual Engines
â”‚   â”œâ”€â”€ PredictiveAnalyticsEngine
â”‚   â”œâ”€â”€ SentimentAnalysisEngine
â”‚   â”œâ”€â”€ NLPEngine
â”‚   â”œâ”€â”€ ComputerVisionEngine
â”‚   â”œâ”€â”€ BehavioralModelsEngine
â”‚   â”œâ”€â”€ PortfolioOptimizationEngine
â”‚   â””â”€â”€ AutomatedResearchEngine
â”œâ”€â”€ Core Utilities
â”‚   â”œâ”€â”€ TensorUtils
â”‚   â””â”€â”€ Type Definitions
â””â”€â”€ Testing Suite
    â”œâ”€â”€ Unit Tests
    â”œâ”€â”€ Integration Tests
    â””â”€â”€ Performance Tests
```

### Data Flow

```
User Request â†’ AIMLOrchestrator â†’ Engine Selection â†’ Parallel Processing â†’ 
Cross-Engine Correlation â†’ Result Integration â†’ Response Generation
```

## ðŸ› ï¸ Implementation Patterns

### 1. Real-time Trading Dashboard

```typescript
import { QuickSetup } from '@/lib/ai/ml';

class TradingDashboard {
  private aiml = QuickSetup.forTrading();

  async initializeRealTimeAnalysis(assets: string[]) {
    // Start monitoring system health
    await this.aiml.startMonitoring(30000); // 30 second intervals

    // Set up real-time analysis for each asset
    for (const asset of assets) {
      setInterval(async () => {
        const analysis = await this.aiml.performIntegratedAnalysis({
          analysis_type: 'trading_focus',
          target: { type: 'asset', identifier: asset },
          scope: {
            time_horizon: '1h',
            depth: 'standard',
            include_predictions: true,
            include_sentiment: true,
            include_risk_analysis: true,
            include_optimization: false
          },
          preferences: {
            confidence_threshold: 0.8,
            risk_tolerance: 'moderate',
            update_frequency: 30000
          }
        });

        this.updateDashboard(asset, analysis);
        this.processAlerts(analysis.alerts);
      }, 30000);
    }
  }

  private updateDashboard(asset: string, analysis: any) {
    // Update UI components with new analysis
    console.log(`Updated analysis for ${asset}:`, analysis);
  }

  private processAlerts(alerts: any[]) {
    alerts.forEach(alert => {
      if (alert.severity === 'critical') {
        // Send push notification or email
        this.sendCriticalAlert(alert);
      }
    });
  }
}
```

### 2. Portfolio Management System

```typescript
import { QuickSetup } from '@/lib/ai/ml';

class PortfolioManager {
  private aiml = QuickSetup.forResearch();

  async analyzePortfolio(holdings: any[]) {
    const analysis = await this.aiml.performIntegratedAnalysis({
      analysis_type: 'comprehensive',
      target: {
        type: 'portfolio',
        identifier: 'user_portfolio',
        context: { holdings }
      },
      scope: {
        time_horizon: '1year',
        depth: 'comprehensive',
        include_predictions: true,
        include_sentiment: true,
        include_risk_analysis: true,
        include_optimization: true
      },
      preferences: {
        confidence_threshold: 0.9,
        risk_tolerance: 'moderate',
        update_frequency: 300000 // 5 minutes
      }
    });

    return {
      optimization_suggestions: analysis.results.portfolio,
      risk_assessment: analysis.risk_score,
      recommendations: analysis.recommendations,
      alerts: analysis.alerts.filter(a => a.type === 'risk')
    };
  }

  async generateRebalancingPlan(currentHoldings: any[], targetAllocation: any[]) {
    // Implementation for rebalancing logic
    return this.aiml.performIntegratedAnalysis({
      analysis_type: 'trading_focus',
      target: {
        type: 'portfolio',
        identifier: 'rebalancing_analysis',
        context: { currentHoldings, targetAllocation }
      },
      scope: {
        time_horizon: '7d',
        depth: 'standard',
        include_predictions: true,
        include_sentiment: false,
        include_risk_analysis: true,
        include_optimization: true
      },
      preferences: {
        confidence_threshold: 0.8,
        risk_tolerance: 'moderate',
        update_frequency: 60000
      }
    });
  }
}
```

### 3. Research and Compliance System

```typescript
import { QuickSetup, automatedResearchEngine } from '@/lib/ai/ml';

class ResearchSystem {
  private aiml = QuickSetup.forResearch();

  async conductDueDiligence(protocolName: string) {
    const comprehensive = await automatedResearchEngine.conductResearch({
      target_type: 'protocol',
      target_identifier: protocolName,
      research_depth: 'comprehensive',
      compliance_jurisdiction: 'global',
      risk_tolerance: 'conservative',
      focus_areas: [
        'fundamental_analysis',
        'technical_analysis',
        'team_background',
        'tokenomics',
        'regulatory_compliance'
      ],
      time_horizon: '1year'
    });

    const compliance = await automatedResearchEngine.generateComplianceScore(
      protocolName,
      'protocol',
      'us'
    );

    return {
      research_report: comprehensive,
      compliance_score: compliance,
      investment_recommendation: comprehensive.investment_recommendation,
      key_risks: comprehensive.executive_summary.key_concerns
    };
  }

  async monitorCompliance(protocols: string[]) {
    const results = await automatedResearchEngine.monitorTargets(protocols);
    
    // Process alerts and notifications
    results.forEach(result => {
      result.alerts.forEach(alert => {
        if (alert.severity === 'critical') {
          this.sendComplianceAlert(result.target, alert);
        }
      });
    });

    return results;
  }
}
```

### 4. MEV Detection and Analysis

```typescript
import { behavioralModelsEngine } from '@/lib/ai/ml';

class MEVAnalyzer {
  async detectMEVActivities(transactionData: any[]) {
    const detection = await behavioralModelsEngine.detectMEV({
      analysis_scope: 'transaction_pool',
      transaction_data: transactionData,
      mev_types: ['frontrunning', 'sandwiching', 'arbitrage', 'liquidation'],
      min_profit_threshold: 50
    });

    return {
      detected_activities: detection.mev_activities,
      estimated_profits: detection.mev_activities.reduce(
        (sum, activity) => sum + activity.estimated_profit, 0
      ),
      top_operators: this.identifyTopMEVOperators(detection.mev_activities)
    };
  }

  async analyzeWalletBehavior(walletAddress: string, transactions: any[]) {
    const analysis = await behavioralModelsEngine.analyzeWallet({
      wallet_address: walletAddress,
      analysis_type: 'behavior_classification',
      time_period: '30d',
      transaction_data: transactions
    });

    return {
      behavior_type: analysis.behavior_classification?.primary_behavior,
      risk_score: analysis.risk_assessment?.overall_risk_score,
      confidence: analysis.behavior_classification?.confidence_score,
      risk_factors: analysis.risk_assessment?.risk_factors
    };
  }
}
```

## ðŸš€ Deployment

### Environment Configuration

```bash
# .env.local
AI_ML_DEBUG=false
AI_ML_CACHE_TTL=300000
AI_ML_MAX_BATCH_SIZE=1000
AI_ML_ENABLE_REAL_TIME=true
AI_ML_CONFIDENCE_THRESHOLD=0.7
AI_ML_RISK_THRESHOLD=0.8
```

### Next.js Integration

```typescript
// pages/api/ai-analysis.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { initializeAIML } from '@/lib/ai/ml';

const aiml = initializeAIML({
  enableRealTimeUpdates: true,
  maxConcurrentAnalyses: 5,
  cacheTimeout: 300000,
  confidenceThreshold: 0.8,
  orchestration: {
    enableCrossEngineCorrelation: true,
    enableSmartCaching: true,
    enablePerformanceOptimization: true,
    maxRetries: 3,
    timeoutMs: 30000
  }
});

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    const analysis = await aiml.performIntegratedAnalysis(req.body);
    res.status(200).json(analysis);
  } catch (error) {
    console.error('Analysis failed:', error);
    res.status(500).json({ error: 'Analysis failed' });
  }
}
```

### React Hook Integration

```typescript
// hooks/useAIAnalysis.ts
import { useState, useEffect } from 'react';
import { initializeAIML } from '@/lib/ai/ml';

export function useAIAnalysis(config?: any) {
  const [aiml] = useState(() => initializeAIML(config));
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const performAnalysis = async (request: any) => {
    setLoading(true);
    setError(null);
    
    try {
      const result = await aiml.performIntegratedAnalysis(request);
      return result;
    } catch (err: any) {
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  const getSystemHealth = async () => {
    try {
      return await aiml.getSystemHealth();
    } catch (err: any) {
      setError(err.message);
      throw err;
    }
  };

  return {
    performAnalysis,
    getSystemHealth,
    loading,
    error
  };
}
```

## ðŸ“Š Performance Optimization

### Caching Strategy

```typescript
// Configure intelligent caching
const aiml = initializeAIML({
  orchestration: {
    enableSmartCaching: true,
    enablePerformanceOptimization: true
  },
  cacheTimeout: 300000 // 5 minutes
});

// Manual cache optimization
setInterval(async () => {
  const optimization = await aiml.optimizePerformance();
  console.log('Performance optimization:', optimization);
}, 3600000); // Every hour
```

### Memory Management

```typescript
// Monitor memory usage
const health = await aiml.getSystemHealth();
console.log('Memory usage:', health.performance.total_memory_usage);

// Automatic cleanup
if (health.performance.total_memory_usage > 100) {
  await aiml.optimizePerformance();
}
```

## ðŸ”§ Configuration Options

### Development Configuration

```typescript
const devConfig = {
  enableRealTimeUpdates: false,
  maxConcurrentAnalyses: 3,
  cacheTimeout: 60000,
  confidenceThreshold: 0.5,
  riskThreshold: 0.7,
  updateInterval: 120000,
  orchestration: {
    enableCrossEngineCorrelation: true,
    enableSmartCaching: false,
    enablePerformanceOptimization: false,
    maxRetries: 1,
    timeoutMs: 10000
  }
};
```

### Production Configuration

```typescript
const prodConfig = {
  enableRealTimeUpdates: true,
  maxConcurrentAnalyses: 20,
  cacheTimeout: 300000,
  confidenceThreshold: 0.8,
  riskThreshold: 0.8,
  updateInterval: 30000,
  orchestration: {
    enableCrossEngineCorrelation: true,
    enableSmartCaching: true,
    enablePerformanceOptimization: true,
    maxRetries: 3,
    timeoutMs: 30000
  }
};
```

## ðŸš¨ Error Handling

### Graceful Degradation

```typescript
try {
  const analysis = await aiml.performIntegratedAnalysis(request);
  return analysis;
} catch (error) {
  // Fallback to individual engine analysis
  const fallbackResult = await predictiveAnalyticsEngine.generatePrediction({
    asset: request.target.identifier,
    prediction_type: 'price',
    time_horizon: '24h',
    confidence_level: 0.7
  });
  
  return {
    partial_analysis: true,
    predictive_only: fallbackResult,
    error_message: error.message
  };
}
```

### Health Monitoring

```typescript
// Set up health monitoring
await aiml.startMonitoring(60000); // Check every minute

// Custom health check endpoint
app.get('/health/ai-ml', async (req, res) => {
  const health = await aiml.getSystemHealth();
  
  res.status(health.overall_status === 'healthy' ? 200 : 503).json({
    status: health.overall_status,
    engines: health.engines.map(e => ({
      name: e.name,
      status: e.status,
      responseTime: e.performance.avgResponseTime
    })),
    timestamp: Date.now()
  });
});
```

## ðŸ“ˆ Monitoring and Analytics

### Performance Metrics

```typescript
// Track custom metrics
const startTime = Date.now();
const analysis = await aiml.performIntegratedAnalysis(request);
const processingTime = Date.now() - startTime;

console.log('Analysis completed in:', processingTime, 'ms');
console.log('Engines used:', analysis.metadata.engines_used);
console.log('Cache utilization:', analysis.metadata.cache_usage);
```

### Usage Analytics

```typescript
// Integration with analytics service
const analyticsData = {
  analysis_type: analysis.analysis_type,
  processing_time: analysis.metadata.processing_time,
  engines_used: analysis.metadata.engines_used,
  confidence: analysis.confidence,
  cache_hit_rate: analysis.metadata.cache_usage,
  timestamp: Date.now()
};

// Send to analytics service
analytics.track('ai_ml_analysis_completed', analyticsData);
```

## ðŸ”’ Security Considerations

### Input Validation

```typescript
function validateAnalysisRequest(request: any) {
  if (!request.target?.identifier) {
    throw new Error('Invalid target identifier');
  }
  
  if (request.preferences?.confidence_threshold < 0 || 
      request.preferences?.confidence_threshold > 1) {
    throw new Error('Invalid confidence threshold');
  }
  
  // Additional validation logic
}
```

### Rate Limiting

```typescript
import rateLimit from 'express-rate-limit';

const aimlRateLimit = rateLimit({
  windowMs: 60 * 1000, // 1 minute
  max: 10, // 10 requests per minute
  message: 'AI/ML analysis rate limit exceeded'
});

app.use('/api/ai-analysis', aimlRateLimit);
```

---

This integration guide provides comprehensive examples for implementing the OpenSVM AI/ML system across various use cases and environments. The modular architecture allows for flexible deployment while maintaining high performance and reliability.# OpenSVM AI/ML Engine

## ðŸš€ Overview

The OpenSVM AI/ML Engine is a comprehensive suite of advanced machine learning and artificial intelligence tools specifically designed for blockchain analytics, DeFi protocol analysis, and cryptocurrency market intelligence. Built with TypeScript and optimized for browser environments, this system provides sophisticated analysis capabilities without requiring external ML frameworks.

## ðŸ“‹ Table of Contents

- [Features](#features)
- [Architecture](#architecture)
- [Components](#components)
- [Getting Started](#getting-started)
- [Usage Examples](#usage-examples)
- [API Reference](#api-reference)
- [Testing](#testing)
- [Performance](#performance)
- [Contributing](#contributing)

## âœ¨ Features

### Core AI/ML Capabilities
- **Predictive Analytics**: LSTM-style time-series forecasting for price, volatility, and market movements
- **Sentiment Analysis**: Multi-source sentiment aggregation from social media, news, and on-chain data
- **Natural Language Processing**: Conversational AI for blockchain queries with entity extraction
- **Computer Vision**: Chart pattern recognition and transaction flow visualization
- **Behavioral Analysis**: Wallet behavior classification and MEV detection
- **Portfolio Optimization**: Modern Portfolio Theory implementation with DeFi focus
- **Automated Research**: Comprehensive protocol due diligence and compliance scoring

### Blockchain-Specific Features
- **MEV Detection**: Frontrunning, sandwiching, arbitrage, and liquidation detection
- **Wallet Clustering**: Advanced algorithms to identify related wallet addresses
- **Transaction Pattern Analysis**: Wash trading, Sybil attacks, and money laundering detection
- **DeFi Protocol Analysis**: TVL analysis, yield optimization, and protocol health assessment
- **Real-time Analytics**: Streaming data processing with low-latency alerts
- **Multi-chain Support**: Designed for Solana with extensible architecture

## ðŸ—ï¸ Architecture

### System Design Principles
- **Modular Architecture**: Each engine operates independently while maintaining interoperability
- **Browser-Compatible**: Custom tensor operations and mathematical functions for client-side execution
- **Type Safety**: Comprehensive TypeScript interfaces for all components
- **Performance Optimized**: Efficient algorithms designed for real-time processing
- **Extensible**: Plugin architecture for adding new analysis types

### Core Components

```
lib/ai/ml/
â”œâ”€â”€ core/
â”‚   â””â”€â”€ tensor-utils.ts          # Custom tensor operations and mathematical functions
â”œâ”€â”€ types.ts                     # Comprehensive TypeScript type definitions
â”œâ”€â”€ predictive-analytics.ts      # Time-series forecasting and market prediction
â”œâ”€â”€ sentiment-analysis.ts        # Multi-source sentiment analysis engine
â”œâ”€â”€ nlp-engine.ts               # Conversational AI and entity extraction
â”œâ”€â”€ computer-vision.ts          # Chart analysis and pattern recognition
â”œâ”€â”€ behavioral-models.ts        # Wallet behavior and MEV detection
â”œâ”€â”€ portfolio-optimization.ts   # Portfolio analysis and optimization
â”œâ”€â”€ automated-research.ts       # Protocol research and compliance scoring
â””â”€â”€ index.ts                    # Main exports and engine orchestration
```

## ðŸš€ Getting Started

### Installation

```bash
# Install dependencies (if needed)
npm install
```

### Basic Usage

```typescript
import { 
  predictiveAnalyticsEngine,
  sentimentAnalysisEngine,
  nlpEngine,
  portfolioOptimizationEngine,
  automatedResearchEngine
} from '@/lib/ai/ml';

// Initialize engines
const engines = {
  predictive: predictiveAnalyticsEngine,
  sentiment: sentimentAnalysisEngine,
  nlp: nlpEngine,
  portfolio: portfolioOptimizationEngine,
  research: automatedResearchEngine
};
```

## ðŸ“– Usage Examples

### 1. Price Prediction

```typescript
const prediction = await predictiveAnalyticsEngine.generatePrediction({
  asset: 'SOL',
  prediction_type: 'price',
  time_horizon: '24h',
  confidence_level: 0.95,
  include_scenarios: true
});

console.log(`Predicted SOL price: $${prediction.predictions[0].value}`);
console.log(`Confidence: ${prediction.predictions[0].confidence * 100}%`);
```

### 2. Sentiment Analysis

```typescript
const sentiment = await sentimentAnalysisEngine.analyzeSentiment({
  asset: 'SOL',
  sources: ['twitter', 'reddit', 'news'],
  time_range: '24h',
  include_influencer_analysis: true
});

console.log(`Overall sentiment: ${sentiment.overall_sentiment}`);
console.log(`Confidence: ${sentiment.confidence_score * 100}%`);
```

### 3. Natural Language Processing

```typescript
const response = await nlpEngine.processConversation({
  user_input: "What's my SOL balance and recent transactions?",
  conversation_history: [],
  user_context: {
    wallet_address: '7xKXtg2CW87d97TXJSDpbD5jBkheTqA83TZRuJosgAsU',
    preferred_language: 'en'
  }
});

console.log(response.response_text);
console.log('Suggested actions:', response.suggested_actions);
```

### 4. Portfolio Optimization

```typescript
const optimization = await portfolioOptimizationEngine.optimizePortfolio({
  current_portfolio: [
    {
      token: 'SOL',
      symbol: 'SOL',
      amount: 100,
      current_value_usd: 10000
    },
    {
      token: 'USDC',
      symbol: 'USDC',
      amount: 5000,
      current_value_usd: 5000
    }
  ],
  optimization_objective: 'maximize_sharpe',
  risk_tolerance: 'moderate',
  time_horizon: '1year',
  constraints: {
    max_position_size: 60,
    min_position_size: 10,
    max_tokens: 5,
    excluded_tokens: [],
    preferred_protocols: ['Jupiter', 'Orca'],
    max_risk_score: 0.8,
    min_liquidity_score: 0.6,
    rebalance_threshold: 5
  }
});

console.log('Optimized allocations:', optimization.optimized_portfolio.allocations);
console.log('Expected return:', optimization.optimized_portfolio.expected_return);
```

### 5. Automated Research

```typescript
const research = await automatedResearchEngine.conductResearch({
  target_type: 'protocol',
  target_identifier: 'Jupiter',
  research_depth: 'comprehensive',
  compliance_jurisdiction: 'global',
  risk_tolerance: 'moderate',
  focus_areas: ['fundamental_analysis', 'technical_analysis', 'team_background'],
  time_horizon: '1year'
});

console.log('Overall score:', research.executive_summary.overall_score);
console.log('Investment rating:', research.executive_summary.investment_rating);
console.log('Key strengths:', research.executive_summary.key_strengths);
```

### 6. Wallet Behavior Analysis

```typescript
const analysis = await behavioralModelsEngine.analyzeWallet({
  wallet_address: '7xKXtg2CW87d97TXJSDpbD5jBkheTqA83TZRuJosgAsU',
  analysis_type: 'behavior_classification',
  time_period: '30d',
  transaction_data: transactionHistory
});

console.log('Primary behavior:', analysis.behavior_classification?.primary_behavior);
console.log('Risk score:', analysis.risk_assessment?.overall_risk_score);
```

### 7. MEV Detection

```typescript
const mevResults = await behavioralModelsEngine.detectMEV({
  analysis_scope: 'block_range',
  block_range: { start: 100000, end: 100010 },
  transaction_data: blockTransactions,
  mev_types: ['frontrunning', 'sandwiching', 'arbitrage']
});

console.log('MEV activities detected:', mevResults.mev_activities.length);
mevResults.mev_activities.forEach(activity => {
  console.log(`${activity.mev_type}: $${activity.estimated_profit} profit`);
});
```

## ðŸ“š API Reference

### Core Engines

#### PredictiveAnalyticsEngine
- `generatePrediction(request: PredictionRequest): Promise<PredictionResult>`
- `getModelMetrics(asset: string): Promise<ModelMetrics>`
- `updateModel(asset: string, newData: MarketData[]): Promise<void>`

#### SentimentAnalysisEngine
- `analyzeSentiment(request: SentimentAnalysisRequest): Promise<SentimentAnalysisResult>`
- `getHistoricalSentiment(asset: string, timeRange: string): Promise<SentimentHistory>`
- `subscribeSentimentUpdates(asset: string, callback: Function): void`

#### NLPEngine
- `processConversation(request: ConversationRequest): Promise<ConversationResponse>`
- `extractEntities(text: string): Promise<Entity[]>`
- `classifyIntent(text: string): Promise<IntentClassification>`

#### PortfolioOptimizationEngine
- `optimizePortfolio(request: PortfolioAnalysisRequest): Promise<PortfolioOptimizationResult>`
- `analyzeCurrentPortfolio(holdings: CurrentHolding[]): Promise<PortfolioAnalysis>`
- `generateRebalancingPlan(current: CurrentHolding[], target: OptimizedPortfolio): Promise<RebalancingPlan>`

#### AutomatedResearchEngine
- `conductResearch(request: AutomatedResearchRequest): Promise<ComprehensiveResearchReport>`
- `generateComplianceScore(targetId: string, targetType: string, jurisdiction: string): Promise<ComplianceScore>`
- `monitorTargets(targetIds: string[]): Promise<MonitoringResult[]>`

#### BehavioralModelsEngine
- `analyzeWallet(request: WalletAnalysisRequest): Promise<WalletAnalysisResult>`
- `detectMEV(request: MEVDetectionRequest): Promise<MEVDetectionResult>`
- `performClustering(request: ClusteringRequest): Promise<ClusteringResult>`

### Utility Functions

#### TensorUtils
- `createTensor(data: number[], shape: number[]): TensorData`
- `add(a: TensorData, b: TensorData): TensorData`
- `matmul(a: TensorData, b: TensorData): TensorData`
- `relu(x: number): number`
- `sigmoid(x: number): number`
- `movingAverage(data: number[], window: number): number[]`

## ðŸ§ª Testing

### Running Tests

```bash
# Run all AI/ML tests
npm test lib/ai/ml

# Run specific engine tests
npm test lib/ai/ml/__tests__/predictive-analytics.test.ts
npm test lib/ai/ml/__tests__/sentiment-analysis.test.ts
npm test lib/ai/ml/__tests__/portfolio-optimization.test.ts
npm test lib/ai/ml/__tests__/automated-research.test.ts
npm test lib/ai/ml/__tests__/nlp-engine.test.ts
npm test lib/ai/ml/__tests__/computer-vision.test.ts
npm test lib/ai/ml/__tests__/behavioral-models.test.ts

# Run with coverage
npm test -- --coverage lib/ai/ml
```

### Test Coverage

The test suite covers:
- âœ… **Unit Tests**: Individual function and method testing
- âœ… **Integration Tests**: Cross-engine functionality
- âœ… **Performance Tests**: Latency and memory usage
- âœ… **Error Handling**: Edge cases and invalid inputs
- âœ… **Mock Data**: Realistic test scenarios
- âœ… **Real-time Processing**: Streaming data analysis

### Test Structure

```
__tests__/
â”œâ”€â”€ predictive-analytics.test.ts     # Price prediction and forecasting tests
â”œâ”€â”€ sentiment-analysis.test.ts       # Multi-source sentiment analysis tests
â”œâ”€â”€ portfolio-optimization.test.ts   # Portfolio analysis and optimization tests
â”œâ”€â”€ automated-research.test.ts       # Research and compliance scoring tests
â”œâ”€â”€ nlp-engine.test.ts              # Conversational AI and NLP tests
â”œâ”€â”€ computer-vision.test.ts         # Chart analysis and pattern recognition tests
â””â”€â”€ behavioral-models.test.ts       # Wallet behavior and MEV detection tests
```

## âš¡ Performance

### Benchmarks

| Engine | Operation | Avg Latency | Memory Usage |
|--------|-----------|-------------|--------------|
| Predictive Analytics | Price Prediction | ~200ms | ~10MB |
| Sentiment Analysis | Multi-source Analysis | ~500ms | ~15MB |
| NLP Engine | Conversation Processing | ~300ms | ~8MB |
| Portfolio Optimization | Full Optimization | ~1.5s | ~25MB |
| Automated Research | Comprehensive Report | ~3s | ~20MB |
| Behavioral Models | Wallet Analysis | ~800ms | ~18MB |
| Computer Vision | Chart Analysis | ~600ms | ~12MB |

### Optimization Techniques

- **Lazy Loading**: Engines initialize only when needed
- **Caching**: Intelligent caching of frequently accessed data
- **Batch Processing**: Efficient handling of multiple requests
- **Memory Management**: Automatic cleanup of large datasets
- **Algorithm Optimization**: Custom implementations for browser environments

### Scaling Considerations

- **Horizontal Scaling**: Multiple engine instances for high throughput
- **Data Partitioning**: Efficient data distribution across engines
- **Resource Management**: CPU and memory usage optimization
- **Real-time Processing**: Optimized for streaming data scenarios

## ðŸ”§ Configuration

### Engine Configuration

```typescript
// Configure engines with custom parameters
const config = {
  predictive: {
    defaultConfidence: 0.95,
    maxDataPoints: 10000,
    modelUpdateFrequency: '1h'
  },
  sentiment: {
    sources: ['twitter', 'reddit', 'news'],
    updateInterval: 300000, // 5 minutes
    sentimentThreshold: 0.1
  },
  portfolio: {
    defaultRiskTolerance: 'moderate',
    rebalanceThreshold: 0.05,
    maxPositions: 20
  }
};
```

### Environment Variables

```bash
# Optional configuration
AI_ML_DEBUG=true
AI_ML_CACHE_TTL=3600
AI_ML_MAX_BATCH_SIZE=1000
AI_ML_ENABLE_REAL_TIME=true
```

## ðŸš€ Advanced Features

### Real-time Processing

```typescript
// Enable real-time sentiment monitoring
sentimentAnalysisEngine.subscribeToUpdates('SOL', (sentiment) => {
  if (Math.abs(sentiment.overall_sentiment) > 0.8) {
    console.log('Strong sentiment detected:', sentiment);
  }
});

// Real-time portfolio monitoring
portfolioOptimizationEngine.monitorPortfolio(portfolio, (alerts) => {
  alerts.forEach(alert => {
    if (alert.severity === 'critical') {
      console.log('Portfolio alert:', alert.message);
    }
  });
});
```

### Custom Model Training

```typescript
// Train custom models with historical data
await predictiveAnalyticsEngine.trainCustomModel({
  asset: 'SOL',
  trainingData: historicalPriceData,
  modelType: 'lstm',
  epochs: 100,
  validationSplit: 0.2
});
```

### Multi-Asset Analysis

```typescript
// Analyze correlations across multiple assets
const correlation = await predictiveAnalyticsEngine.analyzeCorrelations([
  'SOL', 'ETH', 'BTC', 'AVAX', 'MATIC'
], '30d');

console.log('Correlation matrix:', correlation.correlationMatrix);
```

## ðŸ¤ Contributing

### Development Setup

```bash
# Clone repository
git clone <repository-url>
cd opensvm

# Install dependencies
npm install

# Run development server
npm run dev

# Run tests
npm test
```

### Code Guidelines

- **TypeScript**: Strict type checking enabled
- **ESLint**: Code quality and consistency
- **Prettier**: Code formatting
- **Jest**: Testing framework
- **Documentation**: Comprehensive JSDoc comments

### Adding New Features

1. **Create Engine**: Implement in separate file with proper TypeScript interfaces
2. **Add Tests**: Comprehensive test coverage required
3. **Update Types**: Add type definitions to `types.ts`
4. **Documentation**: Update README and add JSDoc comments
5. **Integration**: Export from main `index.ts`

## ðŸ“ License

This project is part of the OpenSVM ecosystem. See the main project license for details.

## ðŸ”— Related Documentation

- [OpenSVM Main Documentation](../../README.md)
- [API Documentation](./docs/api.md)
- [Performance Benchmarks](./docs/performance.md)
- [Architecture Deep Dive](./docs/architecture.md)

---

## ðŸŽ¯ Roadmap

### Upcoming Features

- **Deep Learning Models**: More sophisticated neural network architectures
- **Cross-chain Analysis**: Support for Ethereum, Polygon, and other chains
- **Advanced MEV Detection**: More sophisticated MEV strategy detection
- **Regulatory Compliance**: Enhanced compliance scoring and monitoring
- **Social Trading**: Community-driven trading insights
- **Risk Management**: Advanced risk modeling and stress testing

### Performance Improvements

- **WebAssembly Integration**: For computationally intensive operations
- **GPU Acceleration**: Browser-based GPU computing for ML operations
- **Edge Computing**: Distributed processing capabilities
- **Model Compression**: Smaller, faster models for mobile devices

---

*Built with â¤ï¸ for the Solana DeFi ecosystem*# Package Manager Standardization - Test Failure Resolution

## Problem Summary

The project was experiencing 189 failing tests out of 659 total (29% failure rate) due to **package manager conflicts**. Multiple lock files were present:

- `package-lock.json` (NPM) - 31,543 lines
- `yarn.lock` (Yarn) - 15,091 lines  
- `bun.lock` (Bun) - 5,396 lines

These different dependency resolution strategies caused module resolution failures, version conflicts, and Jest environment issues.

## Root Cause Analysis

### Dependency Resolution Conflicts
Different package managers resolve the same dependencies to different versions:
- NPM uses a nested dependency structure
- Yarn uses flat dependency resolution
- Bun uses modern resolution with different optimization strategies

### Test Environment Issues
- Module resolution failures in Jest
- Mocked modules not found due to path differences
- ESM/CommonJS conflicts from different package resolutions
- Canvas and native module loading issues

### Build Script Inconsistencies
Package.json contained mixed commands:
```json
"build:fixed": "bun install --force && next build"
"install:fixed": "bun install --force"
```

## Solution Implemented

### 1. Standardized on NPM
**Why NPM?**
- Most stable for CI/CD environments
- Best compatibility with Node.js ecosystem
- Mature dependency resolution algorithm
- Wide tooling support
- Consistent with most enterprise environments

### 2. Updated Configuration Files

#### package.json Changes
```diff
- "build:fixed": "bun install --force && next build"
+ "build:fixed": "npm install --force && next build"
- "install:fixed": "bun install --force"
+ "install:fixed": "npm install --force"
```

#### jest.config.js Improvements
```javascript
// Removed duplicate testTimeout
// Fixed ts-jest globals (using @swc/jest instead)
// Enhanced transformIgnorePatterns for better module resolution
transformIgnorePatterns: [
  "node_modules/(?!(uuid|@solana/web3.js|@qdrant/js-client-rest|...|@anthropic-ai|@coral-xyz|@debridge-finance|@mlc-ai|@radix-ui|@solana|@swc|@tanstack|@vercel|@visactor)/)"
]
```

### 3. Created Automated Cleanup Script

`fix-package-manager-conflicts.sh` provides:
- Automatic backup of existing lock files
- Clean removal of conflicting dependencies
- Fresh NPM installation
- Test verification
- Error reporting

## Manual Cleanup Steps

If Node.js is available in your environment, run:

```bash
# Make script executable
chmod +x fix-package-manager-conflicts.sh

# Run the cleanup script
./fix-package-manager-conflicts.sh
```

### Manual Alternative (if script fails):

1. **Backup existing files:**
   ```bash
   cp package-lock.json package-lock.json.backup
   cp yarn.lock yarn.lock.backup
   cp bun.lock bun.lock.backup
   ```

2. **Remove conflicting lock files:**
   ```bash
   rm yarn.lock bun.lock
   ```

3. **Clean install with NPM:**
   ```bash
   rm -rf node_modules package-lock.json
   npm cache clean --force
   npm install
   ```

4. **Verify tests:**
   ```bash
   npm test
   ```

## Prevention Measures

### 1. Update .gitignore
Add to `.gitignore`:
```
# Package manager conflicts prevention
yarn.lock
bun.lock
# Keep only package-lock.json for NPM standardization
```

### 2. CI/CD Pipeline Updates
Ensure all CI/CD scripts use NPM only:
```yaml
# Example GitHub Actions
- name: Install dependencies
  run: npm ci

- name: Run tests  
  run: npm test

- name: Build
  run: npm run build
```

### 3. Development Guidelines

**For Team Members:**
- Always use `npm install` or `npm ci` for dependencies
- Never commit `yarn.lock` or `bun.lock` files
- Use `npm run` for all package.json scripts
- Report any package manager mixing immediately

**Pre-commit Hooks (Recommended):**
```bash
#!/bin/sh
# Check for conflicting lock files
if [ -f "yarn.lock" ] || [ -f "bun.lock" ]; then
    echo "âŒ Error: Found conflicting lock files (yarn.lock or bun.lock)"
    echo "This project uses NPM only. Please remove them and use 'npm install'"
    exit 1
fi
```

## Expected Results

After implementing these changes:

### âœ… Before Standardization
- 189 failed tests (29% failure rate)
- Module resolution errors
- Inconsistent dependency versions
- Mixed package manager commands

### âœ… After Standardization  
- Expected: 0 failed tests (target: 100% pass rate)
- Consistent module resolution
- Single source of truth for dependencies
- Unified package management workflow

## Monitoring & Maintenance

### Regular Checks
1. **Weekly:** Verify no conflicting lock files exist
2. **Before releases:** Run full test suite
3. **CI/CD monitoring:** Alert on any yarn/bun usage

### Team Training
- Document NPM-only policy in team guidelines
- Include in onboarding process
- Regular reminders during code reviews

## Troubleshooting

### If Tests Still Fail After Cleanup

1. **Check Node.js version compatibility:**
   ```bash
   node --version  # Should match package.json engines
   npm --version
   ```

2. **Verify Jest configuration:**
   ```bash
   npx jest --debug  # Debug Jest configuration
   ```

3. **Check for phantom dependencies:**
   ```bash
   npm ls  # Look for missing or conflicting versions
   ```

4. **Clear all caches:**
   ```bash
   npm cache clean --force
   rm -rf node_modules/.cache
   rm -rf .next
   ```

### Common Issues & Solutions

**Issue:** "Module not found" errors
**Solution:** Check transformIgnorePatterns in jest.config.js

**Issue:** Canvas module errors  
**Solution:** Verify modulePathIgnorePatterns excludes canvas

**Issue:** ESM/CommonJS conflicts
**Solution:** Check extensionsToTreatAsEsm configuration

## Files Modified

- âœ… `package.json` - Updated scripts to use NPM only
- âœ… `jest.config.js` - Fixed configuration issues  
- âœ… `fix-package-manager-conflicts.sh` - Created cleanup script
- âœ… `PACKAGE_MANAGER_STANDARDIZATION.md` - This documentation

## Next Steps

1. Execute the cleanup script when Node.js is available
2. Run full test suite to verify 100% pass rate
3. Update CI/CD pipelines to use NPM only
4. Add pre-commit hooks to prevent future conflicts
5. Train team on new NPM-only workflow

---

**Created by:** Test Failure Resolution Task  
**Date:** 2025-01-27  
**Status:** Ready for execution when Node.js environment is available# Program Registry and Dynamic Discovery - Implementation Summary

## Task 9: Create program registry and instruction definitions âœ… COMPLETED

This task has been successfully completed with comprehensive implementation of both static program registry and dynamic program discovery capabilities.

## Task 9.1: Build comprehensive program registry âœ… COMPLETED

### Key Achievements:

#### 1. Comprehensive Program Database
- **22 program definitions** covering major Solana ecosystem programs
- **68 instruction definitions** with detailed metadata
- **6 categories**: system, token, defi, nft, governance, utility
- **Complete coverage** of core Solana programs (System, Vote, Stake)
- **Major DeFi protocols**: Jupiter, Raydium, Whirlpool, Serum, Solend, Mercurial
- **NFT ecosystem**: Metaplex Token Metadata, Candy Machine, Auction House, Magic Eden
- **Governance programs**: SPL Governance, Mango DAO
- **Utility programs**: Compute Budget, Address Lookup Table, Memo, Name Service

#### 2. Detailed Instruction Definitions
- **Comprehensive instruction metadata** for each program
- **Risk level assessment** (low, medium, high) for each instruction
- **Account role definitions** with detailed descriptions
- **Parameter specifications** with types and descriptions
- **Documentation links** and website references
- **Category-based organization** for easy navigation

#### 3. Advanced Registry Features
- **Search functionality** across programs and descriptions
- **Category filtering** and program grouping
- **Risk assessment tools** for program analysis
- **Statistics and analytics** on registry contents
- **Program validation** with comprehensive error checking
- **Export capabilities** for external use
- **Similar program discovery** based on categories

#### 4. API Infrastructure
- **RESTful API endpoints** at `/api/program-registry`
- **Individual program lookup** at `/api/program-registry/[programId]`
- **Bulk operations** for multiple program analysis
- **Risk assessment endpoints** for security analysis
- **Instruction lookup** with detailed information
- **Program comparison** functionality

#### 5. Files Created:
- `lib/program-registry.ts` (78,081 characters) - Main registry implementation
- `app/api/program-registry/route.ts` - General API endpoints
- `app/api/program-registry/[programId]/route.ts` - Individual program API
- `__tests__/program-registry.test.ts` - Comprehensive test coverage

## Task 9.2: Add dynamic program discovery âœ… COMPLETED

### Key Achievements:

#### 1. Automatic Program Detection
- **Heuristic-based discovery** using transaction pattern analysis
- **Category classification** for DeFi, NFT, and governance programs
- **Confidence scoring** for discovery accuracy
- **Instruction pattern analysis** with frequency tracking
- **Account role inference** based on usage patterns
- **Risk assessment** for unknown programs

#### 2. Community Contribution System
- **Community program definitions** with validation
- **Voting system** for community contributions (up/down/report)
- **Approval workflow** with automatic status updates
- **Contributor tracking** and attribution
- **Quality control** through community moderation

#### 3. Usage Statistics and Analytics
- **Transaction volume tracking** per program
- **Unique user counting** and growth metrics
- **Popular instruction analysis** with usage frequencies
- **Activity trend calculation** (increasing/stable/decreasing)
- **Trending program rankings** based on multiple factors
- **Daily transaction patterns** over time

#### 4. Advanced Discovery Features
- **Search functionality** across discovered programs
- **Export capabilities** for all discovery data
- **Integration with static registry** for known programs
- **Bulk analysis operations** for multiple programs
- **Real-time statistics updates** from transaction data

#### 5. User Interface Components
- **Community contribution form** with instruction builder
- **Voting interface** for community definitions
- **Discovered programs dashboard** with confidence scores
- **Trending programs display** with analytics
- **Tabbed interface** for different discovery views

#### 6. Files Created:
- `lib/dynamic-program-discovery.ts` (22,578 characters) - Core discovery service
- `app/api/program-discovery/route.ts` - Discovery API endpoints
- `components/CommunityProgramContribution.tsx` - UI component
- `__tests__/dynamic-program-discovery.test.ts` - Test coverage

## Technical Implementation Details

### Architecture
- **Modular design** with clear separation of concerns
- **TypeScript interfaces** for type safety and documentation
- **Singleton pattern** for discovery service instance
- **RESTful API design** following OpenSVM conventions
- **React component architecture** with modern hooks

### Integration Points
- **Instruction Parser Service** integration for transaction analysis
- **Static Program Registry** integration for known programs
- **API endpoint consistency** with existing OpenSVM patterns
- **UI component compatibility** with existing design system

### Performance Considerations
- **Efficient data structures** (Maps for O(1) lookups)
- **Lazy loading** for expensive operations
- **Caching strategies** for frequently accessed data
- **Bulk operations** for processing multiple programs
- **Memory-efficient** pattern analysis algorithms

### Security Features
- **Input validation** for all user contributions
- **Risk assessment** for unknown programs
- **Community moderation** through voting system
- **Rate limiting** considerations in API design
- **Data sanitization** for user-generated content

## Requirements Fulfillment

### Requirement 1.2: Program Identification âœ…
- âœ… Comprehensive database of known Solana programs
- âœ… Automatic program detection and categorization
- âœ… Community-contributed program definitions
- âœ… Program metadata and documentation links

### Requirement 1.3: Instruction Parsing âœ…
- âœ… Detailed instruction definitions for major programs
- âœ… Human-readable instruction descriptions
- âœ… Account role identification and parameter parsing
- âœ… Risk level assessment for instructions

## Testing and Quality Assurance

### Test Coverage
- **Unit tests** for all major functionality
- **Integration tests** for API endpoints
- **Error handling tests** for edge cases
- **Validation tests** for data integrity
- **Performance tests** for large datasets

### Code Quality
- **TypeScript strict mode** for type safety
- **Comprehensive documentation** with JSDoc comments
- **Consistent naming conventions** throughout codebase
- **Error handling** with proper error types and messages
- **Modular architecture** for maintainability

## Future Enhancements

### Potential Improvements
1. **Machine Learning Integration** for better program categorization
2. **Real-time Blockchain Monitoring** for automatic discovery
3. **Advanced Analytics Dashboard** with visualizations
4. **Program Relationship Mapping** based on interaction patterns
5. **API Rate Limiting** and authentication for production use
6. **Database Persistence** for discovered programs and statistics
7. **Notification System** for new program discoveries
8. **Advanced Search** with fuzzy matching and filters

### Scalability Considerations
- **Database integration** for persistent storage
- **Caching layer** for improved performance
- **Background processing** for heavy analysis tasks
- **API versioning** for backward compatibility
- **Monitoring and logging** for production deployment

## Conclusion

The program registry and dynamic discovery implementation provides a comprehensive foundation for transaction analysis in the OpenSVM platform. With 22 static program definitions, 68 instruction definitions, and a complete dynamic discovery system, this implementation significantly enhances the platform's ability to parse and understand Solana transactions.

The combination of static registry for known programs and dynamic discovery for unknown programs creates a robust system that can adapt to the evolving Solana ecosystem while maintaining high accuracy and reliability for transaction analysis.

**Total Implementation**: 
- **4 new files** with comprehensive functionality
- **100,000+ characters** of production-ready code
- **Complete API infrastructure** for program registry access
- **Full UI components** for community interaction
- **Comprehensive test coverage** for reliability
- **Integration-ready** with existing OpenSVM architecture

This implementation fully satisfies the requirements for task 9 and provides a solid foundation for the enhanced transaction explorer capabilities.# Announcing Major Platform Upgrades for $SVMAI Holders!

We're thrilled to announce a massive update to the OpenSVM platform. This release is all about increasing the power and utility of your `$SVMAI` tokens and giving you a world-class explorer experience. Hereâ€™s what it means for you.

## ðŸ”¥ New Exclusive Utilities for Your $SVMAI Tokens

Your `$SVMAI` tokens are now your key to unlocking exclusive features and participating in the new token economy.

*   **Unlock SOL Staking with $SVMAI!**
    *   You can now stake **SOL** directly on the OpenSVM platform, and holding **at least 100,000 $SVMAI** is your key to access this feature.
    *   This provides a powerful new utility for holding `$SVMAI`, giving you access to SOL staking opportunities and their potential rewards.
    *   We've also included a handy calculator in the staking interface to help you estimate your potential SOL returns.

*   **Burn $SVMAI to Boost Validators!**
    *   Introducing a new deflationary burn mechanism! You can now burn your `$SVMAI` tokens to "boost" validators, increasing their visibility in the new "Trending Validators" list.
    *   You can burn **up to 69,000 $SVMAI** for each boost, giving you a powerful way to support validators while also reducing the token's total supply.

## âœ¨ A Smarter, Faster, and More Secure Explorer

We've made a host of under-the-hood improvements to make OpenSVM more powerful, intuitive, and reliable.

*   **AI-Powered Transaction Analysis**: Our explorer is now smarter than ever. We've integrated powerful AI from Anthropic and OpenRouter to provide much clearer, more detailed insights into your on-chain activity. With 27 Solana programs and 68 instruction definitions built-in, the platform can now explain even the most complex transactions in simple terms. The improved Transaction Graph helps you visualize complex transaction flows like never before.
*   **A Secure and Reliable AI Experience**: To power our new AI Assistant, we've built a secure gateway that acts as its front desk and concierge. This system safely checks your `$SVMAI` balance to give you the correct discount, handles all payments securely, and ensures the AI is always fast and available. It's the behind-the-scenes engine that makes your `$SVMAI` tokens powerful and your AI experience seamless.
*   **Full Claude Compatibility for Developers**: Our AI gateway is 100% compatible with Claude's official tools and SDKs. If you're a developer, you can use your favorite Claude tools (Python SDK, JavaScript SDK, or Claude CLI) by simply changing the base URL to `opensvm.com/v1` and using your OpenSVM API key. Your `$SVMAI` tokens automatically handle the payments, making it easy to build AI-powered applications on top of OpenSVM.
*   **Enhanced Validator Discovery**: We've added a new "Trending Validators" carousel and a dedicated Validators page to help you discover and evaluate validators more easily.
*   **A Smoother Experience**: We've shipped numerous UI improvements, including a more detailed account balance display, a better experience on mobile devices, and a more polished look and feel across the site.
*   **Improved Stability and Security**: We have squashed dozens of bugs (including critical ones for staking) and have patched several security vulnerabilities to keep your experience safe and seamless. The entire platform should now feel significantly faster and more responsive.

We are more committed than ever to building the best Solana explorer and bringing more value to the `$SVMAI` community. Thank you for your continued support! 

## How the AI Gateway Works

Here's a visual representation of how your `$SVMAI` tokens power the AI experience:

```mermaid
%%{init: { 'theme':'neutral', 'themeVariables': { 'background':'#f7f7f7', 'primaryColor':'#f7f7f7', 'primaryTextColor':'#333333', 'primaryBorderColor':'#555555', 'lineColor':'#555555' }, 'fontFamily':'Courier New, Courier, monospace' }}%%
sequenceDiagram
    box rgba(220,220,220,0.3) User Environment
    participant User as Your Browser
    end
    box rgba(200,200,200,0.3) OpenSVM Platform
    participant Proxy as AI Gateway
    end
    box rgba(180,180,180,0.3) External Services
    participant Solana as Blockchain
    participant AI as AI Models
    end

    rect rgba(247,247,247,0.8)
    User->>+Proxy: Send AI Request
    Note over User,Proxy: User submits query<br/>to AI Assistant
    
    Proxy->>+Solana: Check $SVMAI Balance
    Solana-->>-Proxy: Return Balance
    Note right of Solana: Real-time balance<br/>verification
    
    Proxy->>Proxy: Calculate Tier & Cost
    Note over Proxy: Applies discount based<br/>on token holdings
    
    par Payment Processing
        Proxy->>+Solana: Process $SVMAI Payment
        Solana-->>-Proxy: Payment Confirmed
    and AI Request
        Proxy->>+AI: Forward Request
        AI-->>Proxy: Stream Response
    end
    
    Proxy-->>-User: Stream AI Response
    Note over User,Proxy: Real-time streaming<br/>response delivery
    end
```

## Token Utility Overview

Here's how your `$SVMAI` tokens unlock different features across the platform:

```mermaid
%%{init: { 'theme':'neutral', 'themeVariables': { 'background':'#f7f7f7', 'primaryColor':'#f7f7f7', 'primaryTextColor':'#333333', 'primaryBorderColor':'#555555', 'lineColor':'#555555' }, 'fontFamily':'Courier New, Courier, monospace' }}%%
graph TD
    A[Your $SVMAI Holdings] --> B{Balance Check}
    
    B -->|100k+ SVMAI| C[SOL Staking Access]
    B -->|100k+ SVMAI| D[Full AI Features]
    B -->|Any Amount| E[Validator Boosting]
    
    
    C --> F[Stake SOL & Earn Rewards]
    D --> G{AI Pricing Tiers}
    E --> H[Burn up to 69k SVMAI]
    
    G -->|1M+ SVMAI| I[Platinum: 1 SVMAI/prompt]
    G -->|100k-999k| J[Gold: 10 SVMAI/prompt]
    G -->|Under 100k| K[Silver: 100 SVMAI/prompt]
    G -->|No Tokens| L[Guest: 200 SVMAI/prompt]
```

## Validator Boost Mechanism

See how the burn-to-boost system works to support your favorite validators:

```mermaid
%%{init: { 'theme':'neutral', 'themeVariables': { 'background':'#f7f7f7', 'primaryColor':'#f7f7f7', 'primaryTextColor':'#333333', 'primaryBorderColor':'#555555', 'lineColor':'#555555' }, 'fontFamily':'Courier New, Courier, monospace' }}%%
sequenceDiagram
    box rgba(220,220,220,0.3) Token Holder
    participant You as $SVMAI Holder
    end
    box rgba(200,200,200,0.3) OpenSVM Platform
    participant Platform as OpenSVM
    end
    box rgba(180,180,180,0.3) Blockchain & Registry
    participant Chain as Solana
    participant List as Trending Validators
    end

    rect rgba(247,247,247,0.8)
    You->>Platform: Select Validator
    Note over You,Platform: Choose from<br/>available validators
    
    Platform->>You: Choose Burn Amount
    Note right of Platform: Maximum 69,000<br/>$SVMAI per boost
    
    You->>Platform: Confirm Burn
    Note over You,Platform: Final confirmation<br/>before burning
    
    critical Token Burn Process
        Platform->>+Chain: Burn Tokens
        Chain-->>-Platform: Burn Confirmed âœ“
    option Burn Failed
        Chain-->>Platform: Transaction Failed
        Platform-->>You: Retry Required
    end
    
    Platform->>List: Boost Ranking
    List-->>You: Validator Boosted! ðŸš€
    
    Note over Chain: Tokens permanently<br/>removed from supply
    Note over List: Higher visibility<br/>for 7 days
    end
```

## AI Assistant Pricing Flow

Understanding how your token holdings determine AI costs:

```mermaid
%%{init: { 'theme':'neutral', 'themeVariables': { 'background':'#f7f7f7', 'primaryColor':'#f7f7f7', 'primaryTextColor':'#333333', 'primaryBorderColor':'#555555', 'lineColor':'#555555' }, 'fontFamily':'Courier New, Courier, monospace' }}%%
flowchart LR
    subgraph "Step 1: Check Wallet"
        W[Your Wallet]
    end
    
    subgraph "Step 2: Determine Tier"
        W --> B1{1M+ SVMAI?}
        B1 -->|Yes| T1[Platinum Tier]
        B1 -->|No| B2{100k+ SVMAI?}
        B2 -->|Yes| T2[Gold Tier]
        B2 -->|No| B3{Any SVMAI?}
        B3 -->|Yes| T3[Silver Tier]
        B3 -->|No| T4[Guest Tier]
    end
    
    subgraph "Step 3: Your Cost"
        T1 --> C1[1 SVMAI per query]
        T2 --> C2[10 SVMAI per query]
        T3 --> C3[100 SVMAI per query]
        T4 --> C4[200 SVMAI per query]
    end
```# Enhanced Multi-SVM Search UX Pull Request

## Overview

This pull request enhances the multi-SVM search UX with smooth animations, AI enhancements, and additional search capabilities across Telegram chats, DuckDuckGo, and X.com for meta information.

## Key Features

- **AI Enhancements**: Integrated OpenRouter API for intelligent analysis of blockchain data
- **Comprehensive Blockchain Data**: Enhanced Moralis API integration to use all available endpoints
- **Data Visualizations**: Interactive visualizations for tokens, NFTs, accounts, and transactions
- **Multi-Platform Search**: Unified search across Solana VM, Telegram, DuckDuckGo, and X.com
- **Smooth Animations**: Implemented Framer Motion animations throughout the search interface
- **Performance Optimizations**: Added caching, batching, and relevance scoring for better performance

## Implementation Details

### AI Enhancements

- Implemented OpenRouter API integration with context-aware model selection
- Created sophisticated prompt engineering system with type-specific instructions
- Added source extraction for better citations with relevant links
- Implemented streaming responses for better user experience

### Blockchain Data Integration

- Enhanced Moralis API integration to use all available endpoints
- Added caching system for API responses to improve performance
- Implemented comprehensive error handling with rate limiting protection
- Added support for token data, NFT metadata, account portfolios, and transaction details

### Data Visualizations

- Created TokenVisualization component for price history, distribution, and statistics
- Implemented NFTVisualization for collection stats, attributes, and rarity distribution
- Added AccountVisualization for portfolio composition and transaction activity
- Developed TransactionVisualization for instructions, account interactions, and token transfers

### Search Interface Improvements

- Enhanced SearchInput component with focus animations and keyboard shortcuts
- Improved SearchSuggestions with staggered animations and hover effects
- Updated SearchButton with motion effects for both idle and loading states
- Created unified search experience across multiple platforms

### Performance Optimizations

- Implemented caching for search results to improve response times
- Added batch processing for large result sets to prevent UI blocking
- Created relevance scoring system for better result ordering
- Implemented result deduplication to remove similar items

## Testing

All components have been tested during development to ensure proper functionality:
- Verified AI responses with various blockchain data types
- Tested search functionality across all platforms
- Confirmed animations and transitions work smoothly
- Validated data visualizations with different data sets

## Documentation

Added comprehensive documentation in `docs/enhanced-search.md` covering:
- Feature overview and usage instructions
- Component documentation with examples
- API integration details
- Performance considerations
- Future enhancement possibilities

## Screenshots

See attached screenshots showing the enhanced search interface with animations and AI responses.

## Next Steps

Potential future enhancements:
- Integration with additional data sources
- Advanced filtering options
- Customizable visualization themes
- Saved search functionality
- Export and sharing capabilities
# OpenSVM - Solana Virtual Machine Explorer

![image](https://github.com/user-attachments/assets/6d829b8f-12b7-429a-a6fc-ef5916d9288b)


OpenSVM is a comprehensive blockchain explorer for the Solana ecosystem, providing detailed insights into transactions, blocks, accounts, programs, and tokens on the Solana blockchain.

## Overview

OpenSVM offers a modern, user-friendly interface for exploring the Solana blockchain with advanced features like transaction visualization, wallet path finding, and AI-powered analysis. The project aims to make blockchain data more accessible and understandable for developers, users, and researchers.

## Key Features

- **Blockchain Data Browsing**: Explore blocks, transactions, accounts, programs, and tokens
- **Transaction Visualization**: Interactive visualizations of transaction flows and relationships
- **Wallet Path Finding**: Discover connections between wallets through token transfers
- **AI Assistant**: Get natural language explanations of blockchain data and transactions
- **Network Statistics**: Monitor Solana network performance and health metrics
- **Token Analytics**: Track token transfers, balances, and activities

## Technology Stack

- **Frontend**: Next.js, React, TypeScript, Tailwind CSS
- **Blockchain Integration**: Solana Web3.js, SPL Token
- **Data Visualization**: D3.js, Cytoscape, Three.js, Chart.js
- **AI Components**: LLM integration via Together AI
- **State Management**: XState for complex workflows
- **Vector Database**: Qdrant for similarity search

## Getting Started

### Prerequisites

- Node.js 18+ or Bun
- Environment variables (see `.example.env`)

### Installation

```bash
# Clone the repository
git clone https://github.com/your-org/opensvm.git
cd opensvm

# Install dependencies
npm install
# or
bun install

# Set up environment variables
cp .example.env .env.local
# Edit .env.local with your configuration

# Start the development server
npm run dev
# or
bun run dev
```

### Building for Production

```bash
npm run build
npm run start
# or
bun run build
bun run start
```

## Documentation

For more detailed documentation, see:

- [Architecture Documentation](./docs/architecture/) - **ðŸ“š Comprehensive architectural documentation**
  - [System Overview](./docs/architecture/system-overview.md) - High-level system architecture
  - [Component Architecture](./docs/architecture/components.md) - Component breakdown and relationships
  - [Architecture Decision Records](./docs/architecture/adr/) - Architectural decisions and rationale
  - [Contributing Guide](./docs/architecture/CONTRIBUTING.md) - How to maintain architecture docs
- [Features](./docs/FEATURES.md) - Detailed feature descriptions
- [API Reference](./docs/API.md) - API endpoints and usage
- [Development Guide](./docs/DEVELOPMENT.md) - Development setup and guidelines

### ðŸ—ï¸ Architecture Overview

OpenSVM is built with a modular, scalable architecture:

```mermaid
graph TB
    subgraph "Frontend Layer"
        UI[Next.js App]
        COMPONENTS[React Components]
        VISUALIZATIONS[D3.js Visualizations]
    end
    
    subgraph "API Layer"
        ROUTES[API Routes]
        MIDDLEWARE[Middleware]
        CACHE[Caching]
    end
    
    subgraph "Data Layer"
        SOLANA[Solana Integration]
        VECTOR[Vector Database]
        AI[AI Services]
    end
    
    UI --> ROUTES
    ROUTES --> SOLANA
    ROUTES --> VECTOR
    ROUTES --> AI
```

**Key Architectural Principles:**
- **Modularity**: Clear separation of concerns with well-defined interfaces
- **Performance**: Optimized for fast response times and efficient resource usage
- **Scalability**: Designed for horizontal scaling and growth
- **Maintainability**: Comprehensive documentation and testing
- **Security**: Security-first design with proper access controls

For detailed architectural information, see our [Architecture Documentation](./docs/architecture/).

## License

[MIT License](LICENSE)
# OpenSVM Performance Monitoring & Developer Experience System

A comprehensive performance monitoring, regression detection, and developer experience system for the OpenSVM Solana blockchain explorer.

## ðŸš€ Features

### Performance Monitoring
- **Real-time Metrics Collection**: FPS, memory usage, API response times
- **Web Vitals Tracking**: LCP, FID, CLS measurements
- **Automated Alerting**: Configurable thresholds with severity levels
- **Historical Data**: Performance trends and analysis

### Regression Detection
- **Automated Detection**: Statistical analysis of performance degradation
- **Baseline Management**: Create and manage performance baselines
- **Smart Alerting**: Multi-rule detection with consecutive failure requirements
- **Historical Comparison**: Track performance changes over time

### Developer Experience
- **Interactive Debug Panel**: Real-time debugging with multiple views
- **Performance Overlays**: Visual performance indicators during development
- **Structured Logging**: Multi-level logging with component tracking
- **Developer Utilities**: Testing tools and performance analyzers

### Error Handling & Crash Reporting
- **Automatic Error Boundaries**: React error boundary system with retry logic
- **Crash Reporting**: Comprehensive crash detection and aggregation
- **Error Categorization**: Severity assessment and error fingerprinting
- **Breadcrumb Tracking**: Context collection for debugging

### User Analytics
- **Privacy-Compliant Tracking**: User interaction monitoring with consent
- **Session Management**: User flow analysis and session tracking
- **Heatmap Data**: Click and interaction pattern collection
- **UX Analytics**: Feature adoption and usage patterns

### API Enhancement
- **OpenAPI Generation**: Automatic API documentation generation
- **Request/Response Logging**: Comprehensive API monitoring
- **Performance Tracking**: API response time monitoring
- **Caching Metrics**: Cache hit/miss tracking

## ðŸ“ System Architecture

```
lib/
â”œâ”€â”€ performance/
â”‚   â”œâ”€â”€ monitor.ts              # Core performance monitoring
â”‚   â”œâ”€â”€ regression-detector.ts  # Automated regression detection
â”‚   â””â”€â”€ types.ts               # TypeScript definitions
â”œâ”€â”€ logging/
â”‚   â””â”€â”€ logger.ts              # Structured logging system
â”œâ”€â”€ error/
â”‚   â””â”€â”€ error-boundary-service.ts # Error handling and reporting
â”œâ”€â”€ analytics/
â”‚   â””â”€â”€ user-interaction-tracker.ts # User analytics
â”œâ”€â”€ crash/
â”‚   â””â”€â”€ crash-reporter.ts      # Crash detection and reporting
â””â”€â”€ api/
    â”œâ”€â”€ openapi-generator.ts   # API documentation generation
    â”œâ”€â”€ middleware.ts          # API monitoring middleware
    â””â”€â”€ request-logger.ts      # Request/response logging

components/
â”œâ”€â”€ debug/
â”‚   â”œâ”€â”€ DebugPanel.tsx         # Main debug interface
â”‚   â”œâ”€â”€ GraphPerformanceOverlay.tsx # Performance overlays
â”‚   â””â”€â”€ DeveloperUtilities.tsx # Testing utilities
â”œâ”€â”€ performance/
â”‚   â””â”€â”€ RegressionAlertPanel.tsx # Regression monitoring UI
â””â”€â”€ error/
    â””â”€â”€ EnhancedErrorBoundary.tsx # React error boundaries

contexts/
â””â”€â”€ PerformanceContext.tsx     # React context provider

hooks/
â””â”€â”€ useRegressionDetection.ts  # Regression detection hooks
```

## ðŸ› ï¸ Installation & Setup

### 1. Basic Setup

Install the required dependencies (if not already included):

```bash
npm install lucide-react
```

### 2. Provider Setup

Wrap your application with the `PerformanceProvider`:

```tsx
// app/layout.tsx or your root component
import { PerformanceProvider } from '@/contexts/PerformanceContext';

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body>
        <PerformanceProvider 
          autoStart={true}
          config={{
            collectionInterval: 1000,
            enableWebVitals: true,
            alertThresholds: {
              fps: { min: 30, critical: 15 },
              memory: { max: 500000000, critical: 1000000000 }
            }
          }}
        >
          {children}
        </PerformanceProvider>
      </body>
    </html>
  );
}
```

### 3. Error Boundary Setup

Add error boundaries to catch and handle errors:

```tsx
// app/page.tsx or component wrapper
import { EnhancedErrorBoundary } from '@/components/error/EnhancedErrorBoundary';

export default function Page() {
  return (
    <EnhancedErrorBoundary
      fallback={<div>Something went wrong. Please refresh the page.</div>}
      enableRetry={true}
      maxRetries={3}
    >
      <YourApplicationContent />
    </EnhancedErrorBoundary>
  );
}
```

### 4. Development Tools Setup

Add the debug panel for development:

```tsx
// components/DevTools.tsx
'use client';

import { useState, useEffect } from 'react';
import { DebugPanel } from '@/components/debug/DebugPanel';

export function DevTools() {
  const [isOpen, setIsOpen] = useState(false);
  const [isDev, setIsDev] = useState(false);

  useEffect(() => {
    setIsDev(process.env.NODE_ENV === 'development');
  }, []);

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // Press Ctrl+Shift+D to open debug panel
      if (e.ctrlKey && e.shiftKey && e.key === 'D') {
        setIsOpen(true);
      }
    };

    if (isDev) {
      window.addEventListener('keydown', handleKeyDown);
      return () => window.removeEventListener('keydown', handleKeyDown);
    }
  }, [isDev]);

  if (!isDev) return null;

  return (
    <>
      {/* Debug button for easy access */}
      <button
        onClick={() => setIsOpen(true)}
        className="fixed bottom-4 right-4 z-50 bg-blue-600 text-white p-2 rounded-full shadow-lg hover:bg-blue-700"
        title="Open Debug Panel (Ctrl+Shift+D)"
      >
        ðŸ›
      </button>
      
      <DebugPanel isOpen={isOpen} onClose={() => setIsOpen(false)} />
    </>
  );
}
```

Then include it in your layout:

```tsx
// app/layout.tsx
import { DevTools } from '@/components/DevTools';

export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        <PerformanceProvider>
          {children}
          <DevTools />
        </PerformanceProvider>
      </body>
    </html>
  );
}
```

## ðŸŽ¯ Quick Start Examples

### Component Performance Tracking

```tsx
import { useComponentPerformance } from '@/contexts/PerformanceContext';

function MyComponent() {
  const { trackEvent, trackCustomMetric } = useComponentPerformance('MyComponent');
  
  const handleClick = () => {
    trackEvent('button-click', { action: 'subscribe' });
  };
  
  useEffect(() => {
    const startTime = performance.now();
    // Simulate data loading
    loadData().then(() => {
      const loadTime = performance.now() - startTime;
      trackCustomMetric('data-load-time', loadTime);
    });
  }, []);
  
  return <button onClick={handleClick}>Subscribe</button>;
}
```

### API Performance Monitoring

```tsx
import { useApiPerformance } from '@/contexts/PerformanceContext';

function useUserData() {
  const { trackApiCall } = useApiPerformance();
  
  const fetchUser = async (id: string) => {
    return trackApiCall(
      () => fetch(`/api/users/${id}`).then(r => r.json()),
      'fetch-user',
      { userId: id, cached: false }
    );
  };
  
  return { fetchUser };
}
```

### Regression Detection

```tsx
import { useRegressionDetection } from '@/hooks/useRegressionDetection';

function PerformanceDashboard() {
  const { 
    detections, 
    createBaseline, 
    startDetection,
    getDetectionStats 
  } = useRegressionDetection();
  
  const stats = getDetectionStats();
  
  useEffect(() => {
    startDetection(); // Start monitoring for regressions
  }, []);
  
  return (
    <div>
      <h2>Performance Status</h2>
      <p>Recent Issues: {stats.recentDetections}</p>
      <p>Critical Issues: {stats.criticalDetections}</p>
      
      <button onClick={() => createBaseline('production')}>
        Create Production Baseline
      </button>
    </div>
  );
}
```

## ðŸ”§ Configuration

### Performance Monitoring Config

```tsx
const performanceConfig = {
  // Collection settings
  collectionInterval: 1000,        // How often to collect metrics (ms)
  maxDataPoints: 1000,            // Max stored data points
  
  // Feature toggles
  enableWebVitals: true,          // Enable Web Vitals collection
  enableMemoryMonitoring: true,   // Enable memory monitoring
  enableUserInteractions: false,  // Disable in production for privacy
  
  // Alert thresholds
  alertThresholds: {
    fps: { min: 30, critical: 15 },
    memory: { max: 500000000, critical: 1000000000 },
    apiResponseTime: { max: 2000, critical: 5000 }
  },
  
  // Sampling (for production)
  samplingRate: 1.0,              // Sample 100% in dev, reduce in prod
};
```

### Regression Detection Config

```tsx
regressionDetector.updateConfig({
  baselineRetentionDays: 30,      // Keep baselines for 30 days
  minSampleSizeForBaseline: 100,  // Minimum samples before creating baseline
  detectionIntervalMs: 60000,     // Check for regressions every minute
  autoCreateBaselines: true,      // Automatically create baselines
  
  rules: [
    {
      metric: 'fps',
      threshold: 15,              // 15% FPS drop triggers alert
      consecutiveFailures: 3,     // Must fail 3 times in a row
      severity: 'high',
      enabled: true
    },
    {
      metric: 'memory',
      threshold: 25,              // 25% memory increase
      consecutiveFailures: 2,
      severity: 'critical',
      enabled: true
    }
  ]
});
```

## ðŸ§ª Testing

Run the integration tests:

```bash
npm test tests/integration/performance-monitoring.test.ts
```

The test suite covers:
- âœ… Core performance monitoring functionality
- âœ… Regression detection and alerting
- âœ… Error handling and crash reporting
- âœ… User interaction tracking
- âœ… API monitoring integration
- âœ… Component lifecycle management
- âœ… Data persistence and recovery
- âœ… Performance under load
- âœ… Configuration validation

## ðŸ“Š Monitoring in Production

### Key Metrics Dashboard

Set up monitoring for these critical metrics:

```javascript
// Example monitoring setup
const criticalMetrics = {
  // Performance thresholds
  averageFPS: { min: 30, alert: 'performance-degradation' },
  memoryUsage: { max: '1GB', alert: 'memory-leak' },
  apiResponseTime: { p95: '2s', alert: 'api-slowdown' },
  
  // Error thresholds  
  errorRate: { max: '1%', alert: 'high-error-rate' },
  crashRate: { max: '0.1%', alert: 'stability-issue' },
  
  // User experience
  webVitalsLCP: { max: '2.5s', alert: 'ux-degradation' },
  webVitalsFID: { max: '100ms', alert: 'interactivity-issue' }
};
```

### Production Alerts

Configure alerts in your monitoring system:

```yaml
# Example alert configuration
alerts:
  - name: "Performance Regression Detected"
    condition: "regression_detection_count > 0"
    severity: "warning"
    notification: ["#dev-alerts", "performance-team@company.com"]
    
  - name: "Critical Performance Issue"
    condition: "fps_avg < 15 OR memory_usage > 1GB"
    severity: "critical"
    notification: ["#incident-response", "on-call@company.com"]
    
  - name: "High Error Rate"
    condition: "error_rate > 0.05"
    severity: "error"
    notification: ["#dev-alerts", "backend-team@company.com"]
```

## ðŸ› Troubleshooting

### Common Issues

**High Memory Usage**
```javascript
// Check for memory leaks
console.log('Memory usage:', performance.memory);
logger.getLogs().filter(log => log.component === 'PerformanceMonitor');

// Reduce collection frequency
regressionDetector.updateConfig({ 
  detectionIntervalMs: 120000 // 2 minutes instead of 1
});
```

**Missing Metrics**
```javascript
// Verify provider is set up correctly
const monitor = PerformanceMonitor.getInstance();
console.log('Monitor config:', monitor.getConfig());
console.log('Monitor status:', monitor.isRunning());
```

**Excessive Logging**
```javascript
// Adjust log levels
logger.setLevel('info'); // Reduce from 'debug'
logger.setMaxEntries(1000); // Reduce retention

// Disable specific log types in production
logger.setConfig({
  enableUserInteractionLogs: false,
  enablePerformanceLogs: true,
  enableApiLogs: true
});
```

### Debug Console Commands

Access debugging tools in browser console:

```javascript
// Performance monitoring
window.__OPENSVM_MONITOR__.getMetrics();
window.__OPENSVM_MONITOR__.getAlerts();
window.__OPENSVM_MONITOR__.exportData();

// Regression detection
window.__OPENSVM_REGRESSION__.getBaselines();
window.__OPENSVM_REGRESSION__.getDetections();
window.__OPENSVM_REGRESSION__.createBaseline('debug');

// Logging
window.__OPENSVM_LOGGER__.getLogs();
window.__OPENSVM_LOGGER__.exportLogs('json');
window.__OPENSVM_LOGGER__.setLevel('debug');

// Crash reporting
window.__OPENSVM_CRASH__.getReports();
window.__OPENSVM_CRASH__.clearReports();
```

## ðŸ“ˆ Performance Impact

The monitoring system is designed to have minimal performance impact:

- **CPU Usage**: < 1% additional CPU usage
- **Memory Overhead**: ~5-10MB for typical usage
- **Network Impact**: Minimal (local storage + occasional API calls)
- **Bundle Size**: ~50KB gzipped additional code

### Production Optimizations

```typescript
// Production configuration for minimal impact
const productionConfig = {
  collectionInterval: 5000,    // Collect less frequently
  samplingRate: 0.1,          // Sample only 10% of users
  maxDataPoints: 100,         // Store fewer data points
  enableWebVitals: true,      // Keep essential metrics
  enableMemoryMonitoring: false, // Disable heavy monitoring
  enableUserInteractions: false  // Disable for privacy
};
```

## ðŸ¤ Contributing

To contribute to the performance monitoring system:

1. **Add new metrics**: Extend the `PerformanceMetrics` interface in `types.ts`
2. **Add detection rules**: Configure new regression rules in `regression-detector.ts`
3. **Add monitoring components**: Create new debug panels or overlays
4. **Improve visualizations**: Enhance the debug panel with new charts/views
5. **Add integrations**: Connect to external monitoring services

## ðŸ“š API Reference

For detailed API documentation, see:
- [Performance Monitoring Guide](./docs/PERFORMANCE_MONITORING.md)
- [Integration Tests](./tests/integration/performance-monitoring.test.ts)
- Component-specific documentation in each module

## ðŸ” Security & Privacy

The system is designed with privacy and security in mind:

- **No PII Collection**: User interactions are tracked without personal information
- **Configurable Privacy**: Easy to disable user tracking in production
- **Secure Storage**: All data stored locally or encrypted in transit
- **GDPR Compliant**: Respects user privacy preferences

## ðŸ“„ License

This performance monitoring system is part of the OpenSVM project and follows the same licensing terms.

---

**Need Help?** Check the [troubleshooting section](#ðŸ›-troubleshooting) or open an issue in the repository.# OpenSVM QA Report
Date: February 11, 2024
Time: 05:30 AM (UTC+3)

## Test Environment
- Next.js Application
- Development Environment
- Node.js with Next.js 15.1.6
- Local server: http://localhost:3000

## Test Status: PARTIALLY WORKING âš ï¸

## Working Features
1. Network Statistics
   - Blocks Processed: âœ“ (360,247,108)
   - Active Validators: âœ“ (65)
   - TPS: âœ“ (69)
   - Network Load: âœ“ (90.53%)
   - Current Epoch: âœ“ (833)
   - Block Height: âœ“ (360,247,108)

2. UI Components
   - Navigation Menu: âœ“
   - Search Interface: âœ“
   - Layout Structure: âœ“
   - Network Stats Display: âœ“

## Remaining Issues

### 1. Wallet Integration (CRITICAL)
- **Issue**: Cannot read properties of undefined (reading 'getBalance')
- **Impact**: 
  - Wallet connection not working
  - Balance display failing
  - Transaction features blocked
- **Error Messages**:
  ```
  [Page Error] TypeError: Cannot read properties of undefined (reading 'getBalance')
  ```

### 2. Plugin Configuration (MEDIUM)
- **Issue**: Missing Filler plugin
- **Error**:
  ```
  [warn] Tried to use the 'fill' option without the 'Filler' plugin enabled
  ```

### 3. Server Version Check (LOW)
- **Warning**: Failed to obtain server version
- **Message**: "Unable to check client-server compatibility"

## Technical Analysis

### RPC Configuration
- Successfully switched to public RPC endpoints
- Network stats now loading correctly
- Basic blockchain queries working

### Current RPC Endpoints
```typescript
- api.devnet.solana.com
- api.testnet.solana.com
- api.metaplex.solana.com
- free.rpcpool.com
- solana.public-rpc.com
- solana.api.rpcpool.com
- solana-mainnet.g.alchemy.com/v2/demo
- solana-api.tt-prod.net
```

## Next Steps

### 1. Fix Wallet Integration
- Debug wallet connection logic
- Add proper error handling for unconnected state
- Implement wallet connection status checks

### 2. Plugin Configuration
- Enable Filler plugin
- Update plugin dependencies
- Fix visualization components
