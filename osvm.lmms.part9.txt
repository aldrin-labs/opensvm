4. **Technical Architecture Review**: Ensure scalability and performance
5. **Begin Phase 1 Implementation**: Start with Wallet Path Finding

This roadmap provides a clear path forward for implementing all missing features while maintaining focus on user value and technical excellence.# Network Monitoring Enhancements - Design Document

## Overview

The enhanced Network Monitoring system provides comprehensive real-time and historical analysis of Solana network activity with advanced anomaly detection, customizable alerting, and detailed performance analytics. The system combines machine learning-based anomaly detection with rule-based monitoring to provide comprehensive network oversight.

## Architecture

### System Components

```mermaid
graph TB
    Events[Event Stream] --> Processor[Event Processor]
    Processor --> Detector[Anomaly Detector]
    Processor --> Rules[Rule Engine]
    Processor --> Storage[Event Storage]
    
    Detector --> ML[ML Models]
    Detector --> Alerts[Alert Manager]
    Rules --> Alerts
    
    Alerts --> Notifications[Notification Service]
    Storage --> Analytics[Analytics Engine]
    Analytics --> Dashboard[Dashboard UI]
    
    Dashboard --> API[Monitoring API]
    API --> Cache[Redis Cache]
```

### Data Flow

1. **Event Ingestion**: Real-time blockchain events from Solana RPC
2. **Event Processing**: Parse, enrich, and categorize events
3. **Anomaly Detection**: ML-based and rule-based anomaly identification
4. **Alert Generation**: Create alerts based on detected anomalies
5. **Notification Dispatch**: Send alerts via configured channels
6. **Historical Storage**: Store events for analysis and reporting
7. **Analytics Processing**: Generate trends and insights
8. **Dashboard Updates**: Real-time dashboard updates via WebSocket

## Components and Interfaces

### Frontend Components

#### `EnhancedMonitoringDashboard`
```typescript
interface EnhancedMonitoringDashboardProps {
  timeRange: TimeRange;
  onTimeRangeChange: (range: TimeRange) => void;
  customLayout?: DashboardLayout;
}

interface DashboardLayout {
  widgets: DashboardWidget[];
  layout: GridLayout;
  refreshInterval: number;
}

interface DashboardWidget {
  id: string;
  type: 'metric' | 'chart' | 'alert' | 'table' | 'map';
  title: string;
  config: WidgetConfig;
  position: GridPosition;
}
```

#### `AnomalyDetectionPanel`
```typescript
interface AnomalyDetectionPanelProps {
  anomalies: DetectedAnomaly[];
  onAnomalyClick: (anomaly: DetectedAnomaly) => void;
  filters: AnomalyFilters;
  onFiltersChange: (filters: AnomalyFilters) => void;
}

interface DetectedAnomaly {
  id: string;
  type: AnomalyType;
  severity: 'low' | 'medium' | 'high' | 'critical';
  confidence: number;
  timestamp: Date;
  description: string;
  affectedEntities: string[];
  evidence: AnomalyEvidence[];
  status: 'active' | 'investigating' | 'resolved' | 'false_positive';
}

type AnomalyType = 
  | 'volume_spike'
  | 'wash_trading'
  | 'large_transfer'
  | 'unusual_program_usage'
  | 'validator_anomaly'
  | 'fee_anomaly';
```

#### `AlertManagementPanel`
```typescript
interface AlertManagementPanelProps {
  alerts: AlertRule[];
  onCreateAlert: (rule: AlertRule) => void;
  onUpdateAlert: (id: string, rule: AlertRule) => void;
  onDeleteAlert: (id: string) => void;
}

interface AlertRule {
  id: string;
  name: string;
  description: string;
  conditions: AlertCondition[];
  actions: AlertAction[];
  enabled: boolean;
  severity: AlertSeverity;
  cooldownPeriod: number;
  tags: string[];
}

interface AlertCondition {
  metric: string;
  operator: 'gt' | 'lt' | 'eq' | 'ne' | 'contains';
  value: number | string;
  timeWindow: number;
  aggregation?: 'sum' | 'avg' | 'max' | 'min' | 'count';
}

interface AlertAction {
  type: 'email' | 'webhook' | 'sms' | 'slack';
  config: ActionConfig;
  enabled: boolean;
}
```

#### `HistoricalAnalysisPanel`
```typescript
interface HistoricalAnalysisPanelProps {
  timeRange: TimeRange;
  metrics: HistoricalMetric[];
  onMetricSelect: (metric: string) => void;
  onExport: (format: 'csv' | 'json') => void;
}

interface HistoricalMetric {
  name: string;
  data: TimeSeriesData[];
  trend: TrendAnalysis;
  anomalies: HistoricalAnomaly[];
}

interface TimeSeriesData {
  timestamp: Date;
  value: number;
  metadata?: Record<string, any>;
}

interface TrendAnalysis {
  direction: 'up' | 'down' | 'stable';
  strength: number;
  forecast: ForecastData[];
  seasonality?: SeasonalityPattern;
}
```

#### `CustomRulesPanel`
```typescript
interface CustomRulesPanelProps {
  rules: MonitoringRule[];
  onCreateRule: (rule: MonitoringRule) => void;
  onUpdateRule: (id: string, rule: MonitoringRule) => void;
  onDeleteRule: (id: string) => void;
}

interface MonitoringRule {
  id: string;
  name: string;
  description: string;
  targets: RuleTarget[];
  conditions: RuleCondition[];
  actions: RuleAction[];
  enabled: boolean;
  priority: number;
  tags: string[];
}

interface RuleTarget {
  type: 'address' | 'program' | 'token' | 'validator';
  value: string;
  label?: string;
}

interface RuleCondition {
  field: string;
  operator: ComparisonOperator;
  value: any;
  logicalOperator?: 'AND' | 'OR';
}
```

### Backend Services

#### `AnomalyDetectionService`
```typescript
class AnomalyDetectionService {
  async detectAnomalies(
    events: NetworkEvent[],
    timeWindow: number
  ): Promise<DetectedAnomaly[]>;
  
  async trainModel(
    historicalData: HistoricalData,
    modelType: ModelType
  ): Promise<MLModel>;
  
  async updateAnomalyStatus(
    anomalyId: string,
    status: AnomalyStatus,
    feedback?: string
  ): Promise<void>;
}
```

#### `AlertManagerService`
```typescript
class AlertManagerService {
  async createAlert(rule: AlertRule): Promise<string>;
  async updateAlert(id: string, rule: AlertRule): Promise<void>;
  async deleteAlert(id: string): Promise<void>;
  async evaluateAlerts(events: NetworkEvent[]): Promise<TriggeredAlert[]>;
  async sendNotification(alert: TriggeredAlert): Promise<void>;
}
```

#### `HistoricalAnalyticsService`
```typescript
class HistoricalAnalyticsService {
  async getHistoricalMetrics(
    metric: string,
    timeRange: TimeRange,
    granularity: Granularity
  ): Promise<TimeSeriesData[]>;
  
  async analyzeTrends(
    data: TimeSeriesData[]
  ): Promise<TrendAnalysis>;
  
  async generateForecast(
    data: TimeSeriesData[],
    periods: number
  ): Promise<ForecastData[]>;
  
  async exportData(
    query: AnalyticsQuery,
    format: ExportFormat
  ): Promise<ExportResult>;
}
```

#### `CustomRulesEngine`
```typescript
class CustomRulesEngine {
  async createRule(rule: MonitoringRule): Promise<string>;
  async updateRule(id: string, rule: MonitoringRule): Promise<void>;
  async deleteRule(id: string): Promise<void>;
  async evaluateRules(event: NetworkEvent): Promise<RuleMatch[]>;
  async optimizeRules(): Promise<OptimizationReport>;
}
```

## Data Models

### Event and Anomaly Models

```typescript
interface NetworkEvent {
  id: string;
  timestamp: Date;
  type: EventType;
  source: string;
  data: EventData;
  metadata: EventMetadata;
  processed: boolean;
}

interface AnomalyEvidence {
  type: 'statistical' | 'pattern' | 'rule';
  description: string;
  confidence: number;
  data: any;
}

interface TriggeredAlert {
  id: string;
  ruleId: string;
  ruleName: string;
  severity: AlertSeverity;
  timestamp: Date;
  message: string;
  context: AlertContext;
  actions: AlertAction[];
}
```

### Analytics Models

```typescript
interface PerformanceMetrics {
  tps: number;
  avgConfirmationTime: number;
  avgFee: number;
  validatorUptime: number;
  networkLatency: number;
  errorRate: number;
}

interface ForecastData {
  timestamp: Date;
  predicted: number;
  confidence: number;
  upperBound: number;
  lowerBound: number;
}

interface SeasonalityPattern {
  period: 'hourly' | 'daily' | 'weekly';
  strength: number;
  peaks: Date[];
  troughs: Date[];
}
```

## Error Handling

### Data Processing Errors
- Event stream interruptions
- Malformed event data
- Processing pipeline failures
- Storage system unavailability

### Detection Errors
- ML model failures
- Rule evaluation errors
- False positive management
- Confidence threshold adjustments

### Notification Errors
- Delivery failures
- Rate limiting issues
- Channel configuration errors
- Retry mechanism failures

## Testing Strategy

### Unit Tests
- Anomaly detection algorithms
- Alert rule evaluation
- Trend analysis calculations
- Custom rule engine logic
- Notification delivery systems

### Integration Tests
- End-to-end monitoring workflow
- Real-time event processing
- Historical data analysis
- Dashboard real-time updates
- Alert notification delivery

### Performance Tests
- High-volume event processing
- Real-time anomaly detection
- Dashboard rendering performance
- Historical query performance
- Concurrent user handling

### Security Tests
- Input validation and sanitization
- Access control for sensitive data
- Alert configuration security
- Data export permissions
- API endpoint security# Network Monitoring Enhancements - Requirements Document

## Introduction

The Network Monitoring system currently provides basic live event monitoring but lacks comprehensive anomaly detection, alert management, historical analysis, and custom monitoring rules. These enhancements will create a robust monitoring platform for Solana network security and performance analysis.

## Requirements

### Requirement 1: Comprehensive Anomaly Detection

**User Story:** As a security analyst, I want automated anomaly detection across multiple metrics, so that I can identify potential threats and unusual network behavior quickly.

#### Acceptance Criteria

1. WHEN monitoring network activity THEN the system SHALL detect unusual transaction volume spikes
2. WHEN analyzing transaction patterns THEN the system SHALL identify potential wash trading activities
3. WHEN monitoring token transfers THEN the system SHALL detect suspicious large transfers
4. WHEN analyzing program interactions THEN the system SHALL identify unusual program usage patterns
5. WHEN detecting anomalies THEN the system SHALL calculate confidence scores and severity levels

### Requirement 2: Alert Configuration and Management

**User Story:** As a network administrator, I want to configure custom alerts for specific conditions, so that I can be notified of events relevant to my monitoring needs.

#### Acceptance Criteria

1. WHEN configuring alerts THEN the system SHALL allow setting thresholds for various metrics
2. WHEN creating alerts THEN the system SHALL support multiple notification channels (email, webhook, SMS)
3. WHEN alerts trigger THEN the system SHALL provide detailed context and recommended actions
4. WHEN managing alerts THEN the system SHALL allow enabling/disabling and modification of existing alerts
5. WHEN alerts are frequent THEN the system SHALL implement rate limiting and alert grouping

### Requirement 3: Historical Event Analysis

**User Story:** As a researcher, I want to analyze historical network events and trends, so that I can understand long-term patterns and investigate past incidents.

#### Acceptance Criteria

1. WHEN accessing historical data THEN the system SHALL provide events from the past 30 days minimum
2. WHEN analyzing trends THEN the system SHALL show time-series charts for key metrics
3. WHEN investigating incidents THEN the system SHALL allow filtering events by time, type, and severity
4. WHEN comparing periods THEN the system SHALL provide period-over-period analysis tools
5. WHEN exporting data THEN the system SHALL support CSV and JSON export formats

### Requirement 4: Performance Trend Analysis

**User Story:** As a network operator, I want to track network performance trends over time, so that I can identify degradation patterns and plan capacity improvements.

#### Acceptance Criteria

1. WHEN monitoring performance THEN the system SHALL track TPS trends over multiple time periods
2. WHEN analyzing network health THEN the system SHALL monitor validator performance and uptime
3. WHEN tracking efficiency THEN the system SHALL measure average transaction fees and confirmation times
4. WHEN identifying bottlenecks THEN the system SHALL highlight performance degradation patterns
5. WHEN forecasting THEN the system SHALL provide trend projections based on historical data

### Requirement 5: Custom Monitoring Rules

**User Story:** As a compliance officer, I want to create custom monitoring rules for specific addresses or programs, so that I can track entities of interest automatically.

#### Acceptance Criteria

1. WHEN creating rules THEN the system SHALL allow monitoring specific wallet addresses
2. WHEN creating rules THEN the system SHALL allow monitoring specific program interactions
3. WHEN creating rules THEN the system SHALL support complex conditions with AND/OR logic
4. WHEN rules trigger THEN the system SHALL log events with full context and evidence
5. WHEN managing rules THEN the system SHALL provide rule performance metrics and optimization suggestions

### Requirement 6: Real-time Dashboard and Visualization

**User Story:** As a monitoring operator, I want a comprehensive real-time dashboard, so that I can monitor network health and respond to issues quickly.

#### Acceptance Criteria

1. WHEN viewing the dashboard THEN the system SHALL display key network metrics in real-time
2. WHEN monitoring alerts THEN the system SHALL show active alerts with severity indicators
3. WHEN analyzing trends THEN the system SHALL provide interactive charts with drill-down capabilities
4. WHEN customizing views THEN the system SHALL allow dashboard layout personalization
5. WHEN sharing insights THEN the system SHALL support dashboard sharing and embedding# Network Monitoring Enhancements - Implementation Plan

## Task Overview

This implementation plan enhances the existing basic monitoring system with comprehensive anomaly detection, alert management, historical analysis, and custom monitoring capabilities.

## Implementation Tasks

- [ ] 1. Enhance event processing and storage infrastructure
  - [ ] 1.1 Upgrade event ingestion system
    - Enhance existing LiveEventMonitor to capture more event types
    - Implement event enrichment with additional metadata
    - Add event categorization and tagging system
    - _Requirements: 1.1, 4.1_

  - [ ] 1.2 Build event storage and indexing
    - Implement time-series database for historical event storage
    - Create efficient indexing for fast event queries
    - Add data retention policies and archiving
    - _Requirements: 3.1, 3.3_

- [ ] 2. Implement anomaly detection engine
  - [ ] 2.1 Build statistical anomaly detection
    - Create baseline calculation for normal network behavior
    - Implement statistical outlier detection algorithms
    - Add confidence scoring for detected anomalies
    - _Requirements: 1.1, 1.5_

  - [ ] 2.2 Develop pattern-based anomaly detection
    - Implement wash trading detection algorithms
    - Create suspicious transfer pattern recognition
    - Add unusual program usage pattern detection
    - _Requirements: 1.2, 1.3, 1.4_

  - [ ] 2.3 Build machine learning anomaly models
    - Train ML models on historical network data
    - Implement real-time model inference
    - Add model retraining and performance monitoring
    - _Requirements: 1.1, 1.5_

- [ ] 3. Create comprehensive alert management system
  - [ ] 3.1 Build alert rule configuration interface
    - Create UI for defining custom alert conditions
    - Implement threshold setting with multiple metrics
    - Add alert rule testing and validation
    - _Requirements: 2.1, 2.4_

  - [ ] 3.2 Implement notification channels
    - Add email notification system with templates
    - Implement webhook notifications for external systems
    - Create SMS notification integration
    - _Requirements: 2.2_

  - [ ] 3.3 Build alert management and tracking
    - Create alert dashboard with status tracking
    - Implement alert acknowledgment and resolution workflow
    - Add alert grouping and rate limiting
    - _Requirements: 2.3, 2.5_

- [ ] 4. Develop historical analysis and reporting
  - [ ] 4.1 Build historical data query system
    - Create efficient time-series data queries
    - Implement data aggregation and summarization
    - Add filtering and search capabilities
    - _Requirements: 3.1, 3.3_

  - [ ] 4.2 Create trend analysis engine
    - Implement time-series trend calculation
    - Add seasonality detection and analysis
    - Create period-over-period comparison tools
    - _Requirements: 3.2, 3.4, 4.2_

  - [ ] 4.3 Build data export functionality
    - Implement CSV export for historical data
    - Add JSON export with metadata
    - Create scheduled report generation
    - _Requirements: 3.5_

- [ ] 5. Implement performance monitoring and analytics
  - [ ] 5.1 Build network performance tracking
    - Create TPS monitoring with trend analysis
    - Implement validator performance tracking
    - Add network latency and health metrics
    - _Requirements: 4.1, 4.2_

  - [ ] 5.2 Develop efficiency metrics analysis
    - Track average transaction fees over time
    - Monitor confirmation time trends
    - Create network efficiency scoring
    - _Requirements: 4.3_

  - [ ] 5.3 Add performance forecasting
    - Implement trend-based performance forecasting
    - Create capacity planning recommendations
    - Add performance degradation early warning
    - _Requirements: 4.4, 4.5_

- [ ] 6. Create custom monitoring rules engine
  - [ ] 6.1 Build rule definition system
    - Create interface for defining custom monitoring rules
    - Implement complex condition logic (AND/OR)
    - Add rule targeting for specific addresses/programs
    - _Requirements: 5.1, 5.2, 5.3_

  - [ ] 6.2 Implement rule evaluation engine
    - Create real-time rule evaluation system
    - Add rule performance monitoring and optimization
    - Implement rule conflict detection and resolution
    - _Requirements: 5.4, 5.5_

  - [ ] 6.3 Build rule management interface
    - Create UI for rule creation and editing
    - Add rule testing and simulation capabilities
    - Implement rule performance analytics
    - _Requirements: 5.5_

- [ ] 7. Enhance monitoring dashboard
  - [ ] 7.1 Build real-time metrics dashboard
    - Create customizable widget system for key metrics
    - Implement real-time data updates via WebSocket
    - Add interactive charts with drill-down capabilities
    - _Requirements: 6.1, 6.3_

  - [ ] 7.2 Create alert visualization panel
    - Build active alerts display with severity indicators
    - Implement alert timeline and history visualization
    - Add alert correlation and grouping display
    - _Requirements: 6.2_

  - [ ] 7.3 Add dashboard customization features
    - Implement drag-and-drop dashboard layout
    - Create dashboard templates and presets
    - Add dashboard sharing and collaboration features
    - _Requirements: 6.4, 6.5_

- [ ] 8. Build anomaly investigation tools
  - [ ] 8.1 Create anomaly detail views
    - Build detailed anomaly information panels
    - Implement evidence presentation and analysis
    - Add anomaly correlation and relationship mapping
    - _Requirements: 1.5_

  - [ ] 8.2 Add anomaly feedback system
    - Create false positive reporting mechanism
    - Implement anomaly status tracking (investigating, resolved)
    - Add feedback loop for model improvement
    - _Requirements: 1.5_

- [ ] 9. Implement API endpoints for monitoring features
  - [ ] 9.1 Create anomaly detection APIs
    - Add `/api/monitoring/anomalies` endpoint
    - Implement `/api/monitoring/alerts` endpoint
    - Create `/api/monitoring/rules` endpoint
    - _Requirements: All_

  - [ ] 9.2 Build historical analytics APIs
    - Add `/api/monitoring/historical` endpoint
    - Implement `/api/monitoring/trends` endpoint
    - Create `/api/monitoring/export` endpoint
    - _Requirements: 3.1, 3.2, 3.5_

- [ ] 10. Add real-time communication infrastructure
  - [ ] 10.1 Implement WebSocket for real-time updates
    - Create WebSocket server for dashboard updates
    - Add real-time alert notifications
    - Implement event streaming for live monitoring
    - _Requirements: 6.1, 6.2_

  - [ ] 10.2 Build notification delivery system
    - Create reliable notification queue system
    - Implement delivery confirmation and retry logic
    - Add notification rate limiting and throttling
    - _Requirements: 2.2, 2.5_

- [ ] 11. Enhance existing monitoring page
  - [ ] 11.1 Integrate new components into monitoring page
    - Replace basic LiveEventMonitor with enhanced dashboard
    - Add tabbed interface for different monitoring views
    - Implement responsive layout for all new features
    - _Requirements: All_

  - [ ] 11.2 Add navigation and user experience improvements
    - Create intuitive navigation between monitoring features
    - Add contextual help and tooltips
    - Implement keyboard shortcuts for power users
    - _Requirements: All_

- [ ] 12. Implement caching and performance optimization
  - [ ] 12.1 Add intelligent caching for analytics
    - Implement Redis caching for frequently accessed metrics
    - Add cache invalidation strategies for real-time data
    - Create cache warming for dashboard performance
    - _Requirements: All_

  - [ ] 12.2 Optimize for high-volume event processing
    - Implement event batching and bulk processing
    - Add horizontal scaling capabilities
    - Create performance monitoring and alerting
    - _Requirements: 1.1, 4.1_

- [ ] 13. Build comprehensive testing suite
  - [ ] 13.1 Create unit tests for monitoring services
    - Test anomaly detection algorithm accuracy
    - Test alert rule evaluation correctness
    - Test trend analysis and forecasting accuracy
    - _Requirements: All_

  - [ ] 13.2 Add integration and performance tests
    - Test end-to-end monitoring workflow
    - Test real-time dashboard updates
    - Test high-volume event processing performance
    - _Requirements: All_

- [ ] 14. Implement security and access control
  - [ ] 14.1 Add role-based access control
    - Implement user roles for monitoring features
    - Add permission system for alert management
    - Create audit logging for sensitive operations
    - _Requirements: All_

  - [ ] 14.2 Secure sensitive monitoring data
    - Implement data encryption for stored events
    - Add secure API authentication
    - Create data retention and privacy controls
    - _Requirements: All_

- [ ] 15. Create documentation and user training
  - [ ] 15.1 Build user documentation
    - Create user guide for monitoring features
    - Add troubleshooting documentation
    - Build API documentation for developers
    - _Requirements: All_

  - [ ] 15.2 Add contextual help and onboarding
    - Create interactive tutorials for new users
    - Add contextual help throughout the interface
    - Implement feature discovery and tips
    - _Requirements: All_

## Implementation Notes

### Development Approach
- Build on existing LiveEventMonitor component
- Implement anomaly detection incrementally with different algorithms
- Use event-driven architecture for real-time processing
- Prioritize performance and scalability from the start

### Technology Choices
- **Time-series Database**: InfluxDB or TimescaleDB for event storage
- **Real-time Processing**: Apache Kafka or Redis Streams
- **Machine Learning**: TensorFlow.js or Python microservices
- **Caching**: Redis for performance optimization
- **WebSocket**: Socket.io for real-time dashboard updates

### Performance Considerations
- Implement event sampling for high-volume periods
- Use database partitioning for historical data
- Cache frequently accessed analytics queries
- Implement circuit breakers for external dependencies

### Security Considerations
- Validate all user inputs for alert rules and custom rules
- Implement rate limiting for API endpoints
- Secure notification channels with proper authentication
- Audit all configuration changes and sensitive operations# Program Explorer Enhancements Design

## Overview

The Program Explorer Enhancements design provides a comprehensive solution for analyzing Solana programs with advanced code analysis, security assessment, performance monitoring, and developer tools. The system transforms the basic program explorer into a full-featured platform for developers, auditors, and researchers to understand program functionality, assess security, and optimize performance.

## Architecture

### High-Level Architecture

```mermaid
graph TB
    subgraph "Client Layer"
        A[Program Detail Page] --> B[Program List Page]
        A --> C[Code Analyzer]
        A --> D[Security Analyzer]
        B --> E[Program Discovery]
        C --> F[Disassembly Viewer]
    end
    
    subgraph "API Layer"
        G[Program API] --> H[Code Analysis Engine]
        G --> I[Security Engine]
        H --> J[Disassembly Service]
        I --> K[Vulnerability Scanner]
        L[Analytics API] --> M[Usage Analytics]
        N[Performance API] --> O[Metrics Collector]
    end
    
    subgraph "Data Layer"
        P[Qdrant Vector DB] --> Q[Program Patterns]
        P --> R[Security Signatures]
        P --> S[Performance Patterns]
        T[PostgreSQL] --> U[Program Metadata]
        T --> V[Usage Statistics]
        W[Redis Cache] --> X[Analysis Results]
    end
    
    A --> G
    C --> H
    D --> I
    E --> L
    F --> J
    G --> P
    H --> P
    I --> P
    M --> P
```

### Component Architecture

The program explorer follows a modular architecture with specialized analysis engines:

- **Presentation Layer**: React components with code visualization and analysis tools
- **Analysis Layer**: Specialized engines for code analysis, security assessment, and performance monitoring
- **Data Access Layer**: Multi-database approach with Qdrant for vectors, PostgreSQL for metadata
- **Integration Layer**: External APIs for program data, security databases, and performance metrics

## Layout Design Scheme

### Program Detail Page Layout (`/program/[address]`)

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                                    Header                                           │
│  ┌─────────────────┐  ┌──────────────────────────────────────────────────────────┐ │
│  │   Program Icon  │  │  Program Name • Verified Badge • Category               │ │
│  │   & Address     │  │  Deploy Date • Last Updated • Version                   │ │
│  │   (Copy Button) │  │  Author • Repository Link • Documentation               │ │
│  └─────────────────┘  └──────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────────────┐
│                              Quick Stats Bar                                        │
│  Transactions: 1.2M  │  Users: 45K  │  Success Rate: 98.5%  │  Security: 85/100   │
│  Compute Units: 2.1M │  Rank: #23   │  Performance: 92/100  │  Last Activity: 2m  │
└─────────────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────────────┐
│                                  Tab Navigation                                     │
│  [ Overview ] [ Code Analysis ] [ Security ] [ Performance ] [ Dependencies ]      │
└─────────────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────────────┐
│                                 Main Content Area                                   │
│                                                                                     │
│  ┌─────────────────────────────────────┐  ┌─────────────────────────────────────┐  │
│  │                                     │  │                                     │  │
│  │           Primary Panel             │  │           Secondary Panel           │  │
│  │                                     │  │                                     │  │
│  │  (Content changes based on         │  │  • Similar Programs                 │  │
│  │   selected tab)                    │  │  • Dependencies                     │  │
│  │                                     │  │  • Recent Activity                  │  │
│  │                                     │  │  • Quick Actions                    │  │
│  │                                     │  │  • Export Options                   │  │
│  │                                     │  │                                     │  │
│  └─────────────────────────────────────┘  └─────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

### Overview Tab Layout

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                              Program Overview                                       │
│                                                                                     │
│  ┌─────────────────────────────────────┐  ┌─────────────────────────────────────┐  │
│  │         Program Metadata            │  │        Activity Metrics             │  │
│  │  • Description                      │  │  • Transaction Volume Chart         │  │
│  │  • Category & Tags                  │  │  • User Growth Chart                │  │
│  │  • Deployment Info                  │  │  • Success Rate Trend               │  │
│  │  • Upgrade Authority                │  │  • Compute Unit Usage               │  │
│  └─────────────────────────────────────┘  └─────────────────────────────────────┘  │
│                                                                                     │
│  ┌─────────────────────────────────────┐  ┌─────────────────────────────────────┐  │
│  │      Instruction Analytics          │  │       Account Ownership             │  │
│  │  • Top Instructions Table           │  │  • Owned Accounts List              │  │
│  │  • Usage Statistics                 │  │  • Account Types Distribution       │  │
│  │  • Performance Metrics              │  │  • Data Size & Activity             │  │
│  │  • Caller Distribution              │  │  • Relationship Graph               │  │
│  └─────────────────────────────────────┘  └─────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

### Code Analysis Tab Layout

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                              Code Analysis Tools                                    │
│                                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐ │
│  │                          Code Viewer Controls                                   │ │
│  │  [Hex Dump] [Disassembly] [Control Flow] | Search: [_______] | Jump: [_____]   │ │
│  └─────────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                     │
│  ┌─────────────────────────────────────┐  ┌─────────────────────────────────────┐  │
│  │                                     │  │                                     │  │
│  │         Code Viewer                 │  │       Analysis Results             │  │
│  │                                     │  │                                     │  │
│  │  Address  | Bytes    | Assembly     │  │  • Code Patterns Detected          │  │
│  │  0x1000   | 48 89 e5 | mov %rsp,%rbp│  │  • Optimization Opportunities      │  │
│  │  0x1003   | 48 83 ec | sub $0x20,%rsp│  │  • Complexity Metrics             │  │
│  │  0x1007   | 20       |              │  │  • Function Analysis               │  │
│  │  ...      | ...      | ...          │  │  • Jump Targets & References       │  │
│  │                                     │  │  • Export Options                   │  │
│  │  [Line numbers and highlighting]    │  │                                     │  │
│  │                                     │  │                                     │  │
│  └─────────────────────────────────────┘  └─────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

### Security Tab Layout

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                              Security Assessment                                    │
│                                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐ │
│  │                          Security Score Dashboard                               │ │
│  │  Overall Score: 85/100 [████████▒▒] | Risk Level: MEDIUM | Last Scan: 2h ago   │ │
│  └─────────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                     │
│  ┌─────────────────────────────────────┐  ┌─────────────────────────────────────┐  │
│  │        Vulnerabilities              │  │         Audit Reports               │  │
│  │                                     │  │                                     │  │
│  │  🔴 Critical (0)                    │  │  • Trail of Bits - PASS            │  │
│  │  🟠 High (1)                        │  │    Date: 2024-01-15                │  │
│  │    • Buffer Overflow Risk           │  │    Findings: 3 Low, 1 Medium       │  │
│  │      Location: 0x1234               │  │                                     │  │
│  │  🟡 Medium (3)                      │  │  • Neodyme - CONDITIONAL           │  │
│  │  🟢 Low (2)                         │  │    Date: 2024-02-01                │  │
│  │                                     │  │    Findings: 2 Medium              │  │
│  │  [View Details] [Export Report]     │  │                                     │  │
│  └─────────────────────────────────────┘  └─────────────────────────────────────┘  │
│                                                                                     │
│  ┌─────────────────────────────────────┐  ┌─────────────────────────────────────┐  │
│  │       Code Quality Metrics          │  │      Upgrade & Permissions         │  │
│  │                                     │  │                                     │  │
│  │  Complexity: 7.2/10                 │  │  Upgradeable: Yes                   │  │
│  │  Maintainability: 85/100            │  │  Authority: 0x5678...               │  │
│  │  Test Coverage: 78/100              │  │  Governance: Multisig               │  │
│  │  Documentation: 92/100              │  │  Risk Level: Medium                 │  │
│  │  Best Practices: 88/100             │  │                                     │  │
│  └─────────────────────────────────────┘  └─────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

### Performance Tab Layout

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                             Performance Analytics                                   │
│                                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐ │
│  │                        Performance Metrics Overview                             │ │
│  │  Avg Compute: 1,250 CU | P95: 2,100 CU | Success: 98.5% | Throughput: 45 TPS  │ │
│  └─────────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                     │
│  ┌─────────────────────────────────────┐  ┌─────────────────────────────────────┐  │
│  │        Performance Charts           │  │      Optimization Suggestions       │  │
│  │                                     │  │                                     │  │
│  │  [Compute Units Over Time Chart]    │  │  🚀 High Impact                     │  │
│  │  [Success Rate Trend Chart]         │  │    • Optimize loop at 0x1234       │  │
│  │  [Execution Time Distribution]      │  │      Potential savings: 200 CU     │  │
│  │  [Resource Usage Breakdown]         │  │                                     │  │
│  │                                     │  │  ⚡ Medium Impact                   │  │
│  │  Time Range: [Last 7 days ▼]       │  │    • Cache computation result       │  │
│  │                                     │  │      Potential savings: 50 CU      │  │
│  └─────────────────────────────────────┘  └─────────────────────────────────────┘  │
│                                                                                     │
│  ┌─────────────────────────────────────┐  ┌─────────────────────────────────────┐  │
│  │      Instruction Performance        │  │        Resource Usage              │  │
│  │                                     │  │                                     │  │
│  │  Instruction | Avg CU | Calls | %   │  │  Memory: 2.1 MB (85% of limit)     │  │
│  │  transfer    | 1,200  | 45K   | 35% │  │  Storage: 512 KB                   │  │
│  │  swap        | 2,100  | 23K   | 28% │  │  Network: 1.2 MB/day               │  │
│  │  mint        | 800    | 12K   | 15% │  │  CPU: 12% avg utilization          │  │
│  │  burn        | 600    | 8K    | 10% │  │                                     │  │
│  └─────────────────────────────────────┘  └─────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

### Program List Page Layout (`/programs`)

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                                Programs Explorer                                    │
│                                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐ │
│  │                          Search & Filter Controls                               │ │
│  │  Search: [________________] | Category: [All ▼] | Activity: [All ▼] | Sort: [▼] │ │
│  │  Verified: ☑ | Security Score: [0────●────100] | Performance: [0────●────100]   │ │
│  └─────────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                     │
│  ┌─────────────────────────────────────┐  ┌─────────────────────────────────────┐  │
│  │                                     │  │                                     │  │
│  │         Programs Table              │  │        Category Overview           │  │
│  │                                     │  │                                     │  │
│  │ Name/Address | Category | Activity  │  │  📊 DeFi: 1,234 programs           │  │
│  │ Jupiter      | DEX      | ████████  │  │  🎮 Gaming: 567 programs           │  │
│  │ Serum        | DEX      | ███████▒  │  │  🖼️ NFT: 890 programs              │  │
│  │ Raydium      | AMM      | ██████▒▒  │  │  🏗️ Infrastructure: 234 programs   │  │
│  │ ...          | ...      | ...       │  │  📱 Social: 123 programs           │  │
│  │                                     │  │                                     │  │
│  │ [Load More] [Export List]           │  │  [View All Categories]             │  │
│  │                                     │  │                                     │  │
│  └─────────────────────────────────────┘  └─────────────────────────────────────┘  │
│                                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐ │
│  │                            Network Program Statistics                           │ │
│  │  Total Programs: 3,456 | Active (24h): 1,234 | New (7d): 45 | Avg Score: 82   │ │
│  └─────────────────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

### Global Program Similarity Browser Page Layout (`/programs/similarity-browser`)

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                        Global Program Similarity Browser                            │
│                                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐ │
│  │                          Similarity Search Controls                             │ │
│  │  Search Mode: [Browse All ▼] | Similarity Type: [Bytecode ▼] [Semantic ▼]      │ │
│  │  Min Similarity: [0.7] | Category Filter: [All ▼] | Sort: [Similarity ▼]       │ │
│  │  [🔍 Search Similar Programs] [📊 View Clusters] [📤 Export Results]            │ │
│  └─────────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐ │
│  │                            Similarity Type Tabs                                │ │
│  │  [Bytecode Similarity] [Semantic Similarity] [Transaction Patterns] [Mixed]    │ │
│  └─────────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                     │
│  ┌─────────────────────────────────────────┐  ┌─────────────────────────────────────┐  │
│  │                                     │  │                                     │  │
│  │      Similar Programs Table         │  │      Similarity Network View       │  │
│  │                                     │  │                                     │  │
│  │ Program A | Program B | Similarity  │  │  ┌─────────────────────────────────┐ │  │
│  │ Jupiter   | Raydium   | 94.2%      │  │  │                                 │ │  │
│  │ Serum     | Openbook  | 89.7%      │  │  │     Interactive Network        │ │  │
│  │ Orca      | Whirlpool | 87.3%      │  │  │                                 │ │  │
│  │ Marinade  | Lido      | 82.1%      │  │  │  ● Program Nodes (Size=Activity)│ │  │
│  │ ...       | ...       | ...        │  │  │  ─ Similarity Edges (Thickness) │ │  │
│  │                                     │  │  │  🎨 Color by Category          │ │  │
│  │ [Load More] [Compare Selected]      │  │  │  🔍 Zoom & Pan Controls        │ │  │
│  │                                     │  │  │                                 │ │  │
│  └─────────────────────────────────────┘  │  └─────────────────────────────────┘ │  │
│                                          └─────────────────────────────────────┘  │
│                                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐ │
│  │                           Similarity Insights Panel                             │ │
│  │                                                                                 │ │
│  │  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────┐ │ │
│  │  │  Top Clusters   │  │ Common Patterns │  │ Similarity Dist │  │ Categories  │ │ │
│  │  │                 │  │                 │  │                 │  │             │ │ │
│  │  │  DEX Cluster    │  │  Token Swap     │  │  90-100%: 45    │  │  DeFi: 67%  │ │ │
│  │  │  23 programs    │  │  156 programs   │  │  80-90%:  123   │  │  Gaming: 12%│ │ │
│  │  │  Avg: 91.2%     │  │                 │  │  70-80%:  234   │  │  NFT: 15%   │ │ │
│  │  │                 │  │  Liquidity Pool │  │  60-70%:  89    │  │  Other: 6%  │ │ │
│  │  │  AMM Cluster    │  │  89 programs    │  │  <60%:    12    │  │             │ │ │
│  │  │  15 programs    │  │                 │  │                 │  │             │ │ │
│  │  │  Avg: 86.7%     │  │  Staking        │  │  [View Chart]   │  │ [Details]   │ │ │
│  │  │                 │  │  67 programs    │  │                 │  │             │ │ │
│  │  └─────────────────┘  └─────────────────┘  └─────────────────┘  └─────────────┘ │ │
│  └─────────────────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

### Program Similarity Matrix Page Layout (`/programs/similarity-matrix`)

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                          Program Similarity Matrix View                             │
│                                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐ │
│  │                            Matrix Configuration                                 │ │
│  │  Programs: [Top 50 ▼] | Similarity: [Bytecode ▼] | Threshold: [0.6]           │ │
│  │  Display: [Heatmap ▼] | Sort: [Similarity ▼] | [🔄 Refresh] [📤 Export]        │ │
│  └─────────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐ │
│  │                          Similarity Heatmap Matrix                              │ │
│  │                                                                                 │ │
│  │        │Jupiter│Raydium│Serum │Orca  │Marinade│...                              │ │
│  │  ──────┼───────┼───────┼──────┼──────┼────────┼───                              │ │
│  │ Jupiter│ 100%  │ 94.2% │ 78.1%│ 65.3%│  45.2% │...                              │ │
│  │ Raydium│ 94.2% │ 100%  │ 82.7%│ 89.1%│  52.8% │...                              │ │
│  │ Serum  │ 78.1% │ 82.7% │ 100% │ 71.4%│  38.9% │...                              │ │
│  │ Orca   │ 65.3% │ 89.1% │ 71.4%│ 100% │  67.2% │...                              │ │
│  │Marinade│ 45.2% │ 52.8% │ 38.9%│ 67.2%│  100%  │...                              │ │
│  │  ...   │  ...  │  ...  │ ...  │ ...  │   ...  │...                              │ │
│  │                                                                                 │ │
│  │  🟥 90-100%  🟧 80-90%  🟨 70-80%  🟩 60-70%  🟦 50-60%  ⬜ <50%                │ │
│  │                                                                                 │ │
│  └─────────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                     │
│  ┌─────────────────────────────────────┐  ┌─────────────────────────────────────┐  │
│  │        Matrix Statistics            │  │       Selected Pair Analysis        │  │
│  │                                     │  │                                     │  │
│  │  Total Comparisons: 2,500           │  │  Jupiter ↔ Raydium                  │  │
│  │  High Similarity (>90%): 45         │  │  Similarity: 94.2%                  │  │
│  │  Medium Similarity (70-90%): 234    │  │  Type: Fork/Library                 │  │
│  │  Low Similarity (50-70%): 456       │  │                                     │  │
│  │  No Similarity (<50%): 1,765        │  │  Common Features:                   │  │
│  │                                     │  │  • Token swap logic                 │  │
│  │  Average Similarity: 67.3%          │  │  • AMM calculations                 │  │
│  │  Highest Pair: Jupiter-Raydium      │  │  • Fee collection                   │  │
│  │  Most Connected: Jupiter (23 links) │  │                                     │  │
│  │                                     │  │  [View Detailed Comparison]         │  │
│  └─────────────────────────────────────┘  └─────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

### Mobile Layout Adaptations

```
Mobile Program Detail (< 768px):
┌─────────────────────────────┐
│        Program Header       │
│  Icon | Name & Address      │
│       | Category & Status   │
└─────────────────────────────┘
┌─────────────────────────────┐
│      Collapsible Stats      │
│  [Tap to expand metrics]    │
└─────────────────────────────┘
┌─────────────────────────────┐
│      Tab Navigation         │
│ [Overview][Code][Security]  │
│    [Performance][More]      │
└─────────────────────────────┘
┌─────────────────────────────┐
│                             │
│      Stacked Content        │
│   (Single column layout)    │
│                             │
│  • Primary content first    │
│  • Secondary content below  │
│  • Collapsible sections     │
│                             │
└─────────────────────────────┘
```

## Components and Interfaces

### Core Program Components

#### ProgramDetailsPage Component
```typescript
interface ProgramDetailsPageProps {
  address: string;
  initialData?: ProgramData;
}

interface ProgramData {
  address: string;
  metadata: ProgramMetadata;
  code: ProgramCode;
  instructions: InstructionData[];
  accounts: OwnedAccount[];
  interactions: ProgramInteraction[];
  security: SecurityAnalysis;
  metrics: ProgramMetrics;
  dependencies: ProgramDependency[];
  performance: PerformanceMetrics;
  documentation: ProgramDocumentation;
}

interface ProgramMetadata {
  name?: string;
  description?: string;
  version?: string;
  author?: string;
  repository?: string;
  documentation?: string;
  verified: boolean;
  deployedAt: number;
  lastUpdated: number;
  upgradeAuthority?: string;
  category: string;
  tags: string[];
}

interface ProgramCode {
  size: number;
  hash: string;
  disassembly: DisassemblyInstruction[];
  hexDump: string;
  entryPoints: EntryPoint[];
  dependencies: string[];
  controlFlowGraph: ControlFlowNode[];
  codePatterns: CodePattern[];
}
```

#### ProgramListPage Component
```typescript
interface ProgramListPageProps {
  initialPrograms?: ProgramListItem[];
  filters?: ProgramFilters;
  sortBy?: ProgramSortOption;
}

interface ProgramListItem {
  address: string;
  name?: string;
  category: string;
  verified: boolean;
  deployedAt: number;
  lastActivity: number;
  transactionCount: number;
  uniqueUsers: number;
  computeUnitsConsumed: number;
  successRate: number;
  securityScore: number;
  performanceScore: number;
}

interface ProgramFilters {
  categories: string[];
  verified: boolean;
  activityLevel: 'low' | 'medium' | 'high';
  deploymentDateRange: [number, number];
  securityScoreRange: [number, number];
  performanceScoreRange: [number, number];
}
```

### Code Analysis Components

#### CodeAnalyzer Component
```typescript
interface CodeAnalyzerProps {
  programAddress: string;
  codeData: ProgramCode;
  onPatternDetected: (pattern: CodePattern) => void;
}

interface DisassemblyInstruction {
  address: string;
  opcode: string;
  operands: string[];
  bytes: number[];
  comment?: string;
  jumpTarget?: string;
  references: Reference[];
}

interface ControlFlowNode {
  id: string;
  address: string;
  instructions: DisassemblyInstruction[];
  successors: string[];
  predecessors: string[];
  type: 'basic_block' | 'function_entry' | 'function_exit' | 'branch' | 'loop';
}

interface CodePattern {
  type: 'vulnerability' | 'optimization' | 'best_practice' | 'anti_pattern';
  name: string;
  description: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  locations: CodeLocation[];
  recommendation: string;
}
```

#### DisassemblyViewer Component
```typescript
interface DisassemblyViewerProps {
  disassembly: DisassemblyInstruction[];
  hexDump: string;
  controlFlowGraph: ControlFlowNode[];
  onNavigate: (address: string) => void;
}

interface DisassemblyViewerState {
  currentAddress: string;
  highlightedInstructions: string[];
  showHexDump: boolean;
  showControlFlow: boolean;
  searchQuery: string;
  bookmarks: string[];
}

interface NavigationFeatures {
  jumpToAddress: (address: string) => void;
  searchInCode: (query: string) => SearchResult[];
  highlightInstruction: (address: string) => void;
  addBookmark: (address: string, label: string) => void;
  findReferences: (address: string) => Reference[];
}
```

### Security Analysis Components

#### SecurityAnalyzer Component
```typescript
interface SecurityAnalyzerProps {
  programData: ProgramData;
  securityAnalysis: SecurityAnalysis;
  onVulnerabilityFound: (vulnerability: Vulnerability) => void;
}

interface SecurityAnalysis {
  riskScore: number; // 0-100
  riskLevel: 'low' | 'medium' | 'high' | 'critical';
  vulnerabilities: Vulnerability[];
  auditReports: AuditReport[];
  upgradeability: UpgradeabilityInfo;
  permissions: Permission[];
  codeQuality: CodeQualityMetrics;
}

interface Vulnerability {
  id: string;
  type: 'buffer_overflow' | 'integer_overflow' | 'reentrancy' | 'access_control' | 'logic_error';
  severity: 'low' | 'medium' | 'high' | 'critical';
  location: CodeLocation;
  description: string;
  impact: string;
  recommendation: string;
  cwe?: string; // Common Weakness Enumeration
  cvss?: number; // Common Vulnerability Scoring System
}

interface AuditReport {
  auditor: string;
  date: number;
  version: string;
  findings: AuditFinding[];
  overallRating: 'pass' | 'conditional_pass' | 'fail';
  reportUrl?: string;
}
```

### Performance Analysis Components

#### PerformanceAnalyzer Component
```typescript
interface PerformanceAnalyzerProps {
  programAddress: string;
  performanceMetrics: PerformanceMetrics;
  onOptimizationFound: (optimization: OptimizationSuggestion) => void;
}

interface PerformanceMetrics {
  computeUnitsAverage: number;
  computeUnitsMedian: number;
  computeUnitsP95: number;
  executionTimeAverage: number;
  successRate: number;
  errorRate: number;
  throughput: number;
  resourceUsage: ResourceUsage;
  trends: PerformanceTrend[];
}

interface ResourceUsage {
  memoryUsage: number;
  storageUsage: number;
  networkActivity: number;
  cpuUtilization: number;
}

interface OptimizationSuggestion {
  type: 'compute_optimization' | 'memory_optimization' | 'storage_optimization' | 'algorithm_improvement';
  description: string;
  potentialSavings: number; // Estimated compute unit savings
  difficulty: 'easy' | 'medium' | 'hard';
  codeLocation?: CodeLocation;
  example?: string;
}
```

### Analytics Components

#### InstructionAnalytics Component
```typescript
interface InstructionAnalyticsProps {
  programAddress: string;
  instructionData: InstructionData[];
  usageMetrics: InstructionUsageMetrics;
}

interface InstructionData {
  discriminator: string;
  name: string;
  usage: InstructionUsage;
  parameters: InstructionParameter[];
  accounts: AccountRequirement[];
  computeUnits: ComputeUnitMetrics;
}

interface InstructionUsage {
  totalCalls: number;
  uniqueCallers: number;
  averageComputeUnits: number;
  successRate: number;
  last24h: number;
  trend: 'increasing' | 'decreasing' | 'stable';
  callerDistribution: CallerStats[];
}

interface ComputeUnitMetrics {
  average: number;
  median: number;
  p95: number;
  min: number;
  max: number;
  trend: number[]; // Historical data points
}
```

#### AccountOwnershipAnalyzer Component
```typescript
interface AccountOwnershipAnalyzerProps {
  programAddress: string;
  ownedAccounts: OwnedAccount[];
  accountRelationships: AccountRelationship[];
}

interface OwnedAccount {
  address: string;
  type: 'data' | 'executable' | 'system';
  size: number;
  lamports: number;
  lastModified: number;
  dataHash?: string;
  dataStructure?: DataStructure;
  accessPattern: AccessPattern;
}

interface AccountRelationship {
  fromAccount: string;
  toAccount: string;
  relationshipType: 'references' | 'owns' | 'delegates' | 'inherits';
  strength: number; // 0-100
  lastInteraction: number;
}

interface DataStructure {
  fields: DataField[];
  size: number;
  alignment: number;
  version?: number;
}
```

## Data Models

### Program Analysis Data Models
```typescript
interface ProgramInteraction {
  signature: string;
  caller: string;
  instruction: string;
  timestamp: number;
  computeUnits: number;
  success: boolean;
  accounts: string[];
  data: any;
}

interface ProgramDependency {
  address: string;
  name?: string;
  type: 'library' | 'program' | 'system';
  version?: string;
  relationship: 'imports' | 'calls' | 'inherits';
  critical: boolean;
}

interface ProgramMetrics {
  totalTransactions: number;
  uniqueUsers: number;
  totalComputeUnits: number;
  averageComputePerTx: number;
  successRate: number;
  growthRate: number;
  activityLevel: 'inactive' | 'low' | 'moderate' | 'high';
  rank: number;
}
```

### Security Data Models
```typescript
interface CodeQualityMetrics {
  complexity: number; // Cyclomatic complexity
  maintainability: number; // 0-100
  testCoverage: number; // 0-100
  documentation: number; // 0-100
  bestPractices: number; // 0-100
  codeSmells: CodeSmell[];
}

interface CodeSmell {
  type: string;
  severity: 'minor' | 'major' | 'critical';
  location: CodeLocation;
  description: string;
  suggestion: string;
}

interface UpgradeabilityInfo {
  upgradeable: boolean;
  upgradeAuthority?: string;
  upgradeHistory: UpgradeEvent[];
  governanceModel?: string;
  riskLevel: 'low' | 'medium' | 'high';
}
```

## Qdrant Integration Design

### Vector Collections Structure

```typescript
interface ProgramVectorCollections {
  programs: 'program_vectors';
  code_patterns: 'code_pattern_vectors';
  security_signatures: 'security_vectors';
  performance_patterns: 'performance_vectors';
  instruction_patterns: 'instruction_vectors';
}

interface ProgramVector {
  id: string; // program address
  vector: number[]; // 512-dimensional embedding
  payload: {
    address: string;
    category: string;
    codeSize: number;
    instructionCount: number;
    complexityScore: number;
    securityScore: number;
    performanceScore: number;
    activityLevel: number;
    deployedAt: number;
    lastUpdated: number;
    dependencies: string[];
    features: string[];
  };
}

interface CodePatternVector {
  id: string; // unique pattern id
  vector: number[]; // Code pattern embedding
  payload: {
    patternType: 'vulnerability' | 'optimization' | 'best_practice';
    severity: number;
    programAddress: string;
    location: CodeLocation;
    description: string;
    confidence: number;
    detectedAt: number;
  };
}
```

### Vector Search Operations

```typescript
class ProgramVectorService {
  async findSimilarPrograms(programAddress: string, limit: number = 10): Promise<SimilarProgram[]> {
    const programVector = await this.getProgramVector(programAddress);
    
    const searchResult = await this.qdrantClient.search('program_vectors', {
      vector: programVector.vector,
      limit,
      filter: {
        must_not: [{ key: 'address', match: { value: programAddress } }]
      }
    });
    
    return searchResult.map(result => ({
      address: result.payload.address,
      similarity: result.score,
      reason: this.calculateSimilarityReason(programVector.payload, result.payload)
    }));
  }

  async detectCodePatterns(programAddress: string): Promise<CodePattern[]> {
    const codeData = await this.getProgramCode(programAddress);
    const codeVector = await this.generateCodeVector(codeData);
    
    const searchResult = await this.qdrantClient.search('code_pattern_vectors', {
      vector: codeVector,
      limit: 100,
      score_threshold: 0.8
    });
    
    return searchResult.map(result => ({
      type: result.payload.patternType,
      confidence: result.score,
      location: result.payload.location,
      description: result.payload.description,
      severity: result.payload.severity
    }));
  }
}
```

## Error Handling

### Error Types and Recovery

```typescript
enum ProgramExplorerErrorType {
  INVALID_ADDRESS = 'INVALID_ADDRESS',
  PROGRAM_NOT_FOUND = 'PROGRAM_NOT_FOUND',
  CODE_ANALYSIS_ERROR = 'CODE_ANALYSIS_ERROR',
  SECURITY_ANALYSIS_ERROR = 'SECURITY_ANALYSIS_ERROR',
  PERFORMANCE_ERROR = 'PERFORMANCE_ERROR',
  DISASSEMBLY_ERROR = 'DISASSEMBLY_ERROR',
  QDRANT_ERROR = 'QDRANT_ERROR'
}

class ProgramErrorHandler {
  static handleAddressError(address: string): ProgramExplorerError {
    if (!this.isValidProgramAddress(address)) {
      return {
        type: ProgramExplorerErrorType.INVALID_ADDRESS,
        message: `Invalid program address: ${address}`,
        retryable: false,
        suggestions: ['Check the address format', 'Search by program name instead']
      };
    }
  }

  static handleCodeAnalysisError(error: any): ProgramExplorerError {
    return {
      type: ProgramExplorerErrorType.CODE_ANALYSIS_ERROR,
      message: 'Code analysis temporarily unavailable',
      retryable: true,
      retryAfter: 30000,
      fallback: 'basic_program_info'
    };
  }
}
```

## Testing Strategy

### Unit Testing Approach

```typescript
describe('ProgramAnalyzer', () => {
  describe('analyzeProgram', () => {
    it('should analyze program code correctly', async () => {
      const mockProgramData = createMockProgramData();
      const result = await ProgramAnalyzer.analyzeProgram(mockProgramData);
      
      expect(result.securityScore).toBeGreaterThan(0);
      expect(result.performanceScore).toBeGreaterThan(0);
      expect(result.codePatterns).toBeInstanceOf(Array);
    });

    it('should detect security vulnerabilities', async () => {
      const mockVulnerableProgram = createMockVulnerableProgram();
      const result = await ProgramAnalyzer.analyzeProgram(mockVulnerableProgram);
      
      expect(result.vulnerabilities.length).toBeGreaterThan(0);
      expect(result.riskLevel).toBe('high');
    });
  });

  describe('disassembleProgram', () => {
    it('should generate disassembly correctly', async () => {
      const mockBytecode = createMockBytecode();
      const result = await ProgramAnalyzer.disassembleProgram(mockBytecode);
      
      expect(result.instructions).toBeInstanceOf(Array);
      expect(result.controlFlowGraph).toBeDefined();
    });
  });
});
```

### Integration Testing Strategy

1. **API Integration Tests**: Test all program-related endpoints
2. **Qdrant Integration Tests**: Test vector search and storage
3. **Code Analysis Tests**: Test disassembly and pattern detection
4. **Security Analysis Tests**: Test vulnerability detection
5. **Performance Analysis Tests**: Test metrics calculation

## Performance Optimization

### Caching Strategy

```typescript
interface ProgramCacheConfig {
  programMetadata: {
    ttl: 3600000; // 1 hour
    strategy: 'background-refresh';
  };
  codeAnalysis: {
    ttl: 7200000; // 2 hours
    strategy: 'lazy-refresh';
  };
  securityAnalysis: {
    ttl: 1800000; // 30 minutes
    strategy: 'background-refresh';
  };
  performanceMetrics: {
    ttl: 300000; // 5 minutes
    strategy: 'real-time-update';
  };
  disassembly: {
    ttl: 86400000; // 24 hours
    strategy: 'immutable';
  };
}

class ProgramCacheManager {
  async getProgramData(address: string): Promise<ProgramData> {
    const cacheKey = `program:${address}`;
    const cached = await this.redis.get(cacheKey);
    
    if (cached) {
      this.backgroundRefresh(address);
      return JSON.parse(cached);
    }
    
    const data = await this.fetchProgramData(address);
    await this.redis.setex(cacheKey, 3600, JSON.stringify(data));
    
    return data;
  }
}
```

## Security Considerations

### Code Analysis Security

1. **Sandboxed Analysis**: Run code analysis in isolated environments
2. **Input Validation**: Validate all program addresses and parameters
3. **Resource Limits**: Implement timeouts and memory limits for analysis
4. **Audit Trails**: Log all analysis operations and results

### Data Protection

```typescript
class ProgramSecurityManager {
  static validateAnalysisInput(input: any): boolean {
    return this.sanitizeInput(input) && this.checkInputLimits(input);
  }
  
  static sanitizeDisassembly(disassembly: any): any {
    // Remove potentially sensitive information
    return this.filterSensitiveData(disassembly);
  }
  
  static auditAnalysisOperation(operation: string, user: string, program: string): void {
    this.logSecurityEvent({
      type: 'program_analysis',
      operation,
      user,
      program,
      timestamp: Date.now()
    });
  }
}
```

## Additional Features and Enhancements

### Program Comparison and Benchmarking

```typescript
interface ProgramComparison {
  programs: string[]; // Up to 5 programs
  metrics: ComparisonMetric[];
  benchmarks: BenchmarkResult[];
  recommendations: ComparisonInsight[];
}

interface ComparisonMetric {
  name: string;
  values: number[];
  unit: string;
  trend: 'higher_better' | 'lower_better';
}

interface BenchmarkResult {
  category: string;
  leader: string;
  scores: { [programAddress: string]: number };
  insights: string[];
}
```

### Program Version History and Change Tracking

```typescript
interface ProgramVersionHistory {
  versions: ProgramVersion[];
  changeLog: ChangeLogEntry[];
  migrationGuide?: MigrationGuide;
  deprecationNotices: DeprecationNotice[];
}

interface ProgramVersion {
  version: string;
  deployedAt: number;
  codeHash: string;
  changes: CodeChange[];
  breakingChanges: boolean;
  securityImpact: 'none' | 'low' | 'medium' | 'high';
}

interface CodeChange {
  type: 'addition' | 'modification' | 'deletion';
  location: CodeLocation;
  description: string;
  impact: string;
}
```

### Developer Tools and IDE Integration

```typescript
interface DeveloperTools {
  codeExport: CodeExportOptions;
  ideIntegration: IDEPlugin[];
  testingTools: TestingFramework[];
  debuggingTools: DebuggerInterface;
}

interface CodeExportOptions {
  formats: ('rust' | 'c' | 'assembly' | 'json')[];
  includeComments: boolean;
  includeMetadata: boolean;
  optimizationLevel: 'none' | 'basic' | 'aggressive';
}

interface TestingFramework {
  name: string;
  testCases: TestCase[];
  coverage: CoverageReport;
  fuzzingResults: FuzzingResult[];
}
```

### Community Features and Social Integration

```typescript
interface ProgramCommunity {
  discussions: Discussion[];
  reviews: ProgramReview[];
  contributions: CommunityContribution[];
  expertAnalysis: ExpertAnalysis[];
}

interface ProgramReview {
  reviewer: string;
  rating: number; // 1-5 stars
  aspects: {
    security: number;
    performance: number;
    codeQuality: number;
    documentation: number;
  };
  review: string;
  timestamp: number;
  helpful: number; // Helpful votes
}

interface ExpertAnalysis {
  expert: string;
  credentials: string[];
  analysis: string;
  recommendations: string[];
  riskAssessment: string;
  timestamp: number;
}
```

### Advanced Analytics and Machine Learning

```typescript
interface MLAnalytics {
  anomalyDetection: AnomalyReport[];
  predictiveAnalysis: PredictiveInsight[];
  patternRecognition: PatternAnalysis[];
  riskPrediction: RiskPrediction;
}

interface AnomalyReport {
  type: 'performance' | 'security' | 'usage' | 'behavior';
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  detectedAt: number;
  confidence: number;
  recommendation: string;
}

interface PredictiveInsight {
  metric: string;
  prediction: number;
  timeframe: string;
  confidence: number;
  factors: PredictionFactor[];
}
```

### Program Ecosystem Mapping

```typescript
interface EcosystemMap {
  programClusters: ProgramCluster[];
  interactionNetwork: InteractionEdge[];
  ecosystemHealth: EcosystemMetrics;
  influenceMap: InfluenceNode[];
}

interface ProgramCluster {
  id: string;
  programs: string[];
  category: string;
  centralProgram: string;
  cohesionScore: number;
  description: string;
}

interface InteractionEdge {
  from: string;
  to: string;
  interactionType: 'calls' | 'inherits' | 'composes' | 'depends';
  frequency: number;
  strength: number;
}
```

### Real-time Monitoring and Alerting

```typescript
interface RealTimeMonitoring {
  liveMetrics: LiveMetric[];
  alerts: ProgramAlert[];
  healthStatus: HealthStatus;
  performanceStream: PerformanceEvent[];
}

interface ProgramAlert {
  id: string;
  type: 'performance_degradation' | 'security_issue' | 'unusual_activity' | 'error_spike';
  severity: 'info' | 'warning' | 'error' | 'critical';
  message: string;
  timestamp: number;
  acknowledged: boolean;
  actions: AlertAction[];
}

interface HealthStatus {
  overall: 'healthy' | 'warning' | 'critical';
  components: {
    performance: HealthComponent;
    security: HealthComponent;
    availability: HealthComponent;
    usage: HealthComponent;
  };
  lastUpdated: number;
}
```

## Monitoring and Analytics

### Performance Monitoring

1. **Analysis Performance**: Track code analysis and disassembly times
2. **API Response Times**: Monitor all program-related endpoints
3. **Qdrant Performance**: Track vector search response times
4. **Security Scan Performance**: Monitor vulnerability detection times
5. **User Engagement**: Track feature usage and user interactions
6. **Real-time Metrics**: Monitor program health and performance in real-time
7. **Predictive Analytics**: Use ML to predict performance issues and optimization opportunities

### Business Analytics

1. **Program Discovery**: Track which programs are most viewed
2. **Analysis Usage**: Monitor which analysis features are most used
3. **Security Insights**: Track security issues discovered
4. **Performance Trends**: Monitor program performance over time
5. **Community Engagement**: Track reviews, discussions, and expert analysis
6. **Ecosystem Evolution**: Monitor program ecosystem changes and trends

### Advanced Features Integration

1. **Program Comparison Dashboard**: Side-by-side program analysis and benchmarking
2. **Version Control Integration**: Track program changes and provide migration guides
3. **Developer Toolchain**: Export tools, IDE plugins, and testing frameworks
4. **Community Platform**: Reviews, discussions, and expert analysis
5. **ML-Powered Insights**: Anomaly detection, predictive analysis, and pattern recognition
6. **Ecosystem Visualization**: Program relationship mapping and influence analysis
7. **Real-time Monitoring**: Live metrics, alerts, and health status tracking

This comprehensive design provides a robust foundation for implementing the program explorer enhancements with advanced code analysis, security assessment, performance monitoring, community features, and cutting-edge analytics capabilities.# Program Explorer Enhancements Requirements

## Introduction

This specification defines the requirements for enhancing the program explorer functionality in OpenSVM, covering individual program details, code analysis, instruction usage analytics, account ownership analysis, and security assessment. The program explorer is essential for developers, auditors, and researchers to understand Solana programs, analyze their behavior, and assess their security and performance.

## Requirements

### Requirement 1: Individual Program Detail Page

**User Story:** As a Solana developer, I want to view comprehensive information about a specific program, so that I can understand its functionality, analyze its code, and assess its security.

#### Acceptance Criteria

1. WHEN a user navigates to `/program/[address]` with a valid program address THEN the system SHALL display comprehensive program information including metadata, code analysis, instruction usage, account ownership, and security assessment
2. WHEN a user provides an invalid program address THEN the system SHALL display a 404 error page with suggestions for valid program searches
3. WHEN program data is loading THEN the system SHALL show progressive loading states for different sections (metadata, code, instructions, accounts)
4. WHEN program metadata is unavailable THEN the system SHALL show fallback information using on-chain data and code analysis
5. WHEN a user views program details THEN the system SHALL provide links to related programs and dependencies
6. WHEN code analysis is displayed THEN the system SHALL show disassembly, hex dump, and control flow visualization
7. WHEN instruction usage is shown THEN the system SHALL display usage statistics and performance metrics
8. WHEN account ownership is displayed THEN the system SHALL show owned accounts and their relationships

### Requirement 2: Program Code Analysis and Visualization

**User Story:** As a security auditor, I want to analyze program code with disassembly and visualization tools, so that I can understand program logic and identify potential security issues.

#### Acceptance Criteria

1. WHEN viewing program code THEN the system SHALL display hex dump with address offsets and byte highlighting
2. WHEN disassembly is shown THEN the system SHALL provide assembly code with instruction highlighting and jump target identification
3. WHEN control flow is analyzed THEN the system SHALL generate control flow graphs showing program execution paths
4. WHEN code navigation is used THEN the system SHALL support jump-to-address, search within code, and instruction highlighting
5. WHEN code patterns are detected THEN the system SHALL identify common patterns and potential vulnerabilities
6. WHEN code is exported THEN the system SHALL provide export functionality for disassembly and analysis results
7. WHEN code analysis fails THEN the system SHALL show appropriate error messages and retry options
8. WHEN large programs are analyzed THEN the system SHALL implement pagination and virtual scrolling for performance

### Requirement 3: Instruction Usage Analytics

**User Story:** As a program analyst, I want to see detailed instruction usage statistics and performance metrics, so that I can understand program behavior and optimize performance.

#### Acceptance Criteria

1. WHEN instruction analytics are displayed THEN the system SHALL show usage statistics for each instruction type
2. WHEN performance metrics are calculated THEN the system SHALL display average compute units, success rates, and execution times
3. WHEN usage trends are analyzed THEN the system SHALL show instruction usage over time with trend indicators
4. WHEN caller analysis is performed THEN the system SHALL identify unique callers and usage patterns
5. WHEN instruction comparison is done THEN the system SHALL compare instruction performance across different programs
6. WHEN usage alerts are configured THEN the system SHALL notify users of significant usage changes
7. WHEN analytics are exported THEN the system SHALL provide detailed analytics reports in multiple formats
8. WHEN real-time usage is tracked THEN the system SHALL update instruction statistics with live data

### Requirement 4: Account Ownership Analysis

**User Story:** As a blockchain researcher, I want to analyze accounts owned by programs and their relationships, so that I can understand program ecosystem and data structures.

#### Acceptance Criteria

1. WHEN account ownership is analyzed THEN the system SHALL display all accounts owned by the program
2. WHEN account types are classified THEN the system SHALL categorize accounts by type (data, executable, system)
3. WHEN account relationships are mapped THEN the system SHALL show relationships between owned accounts
4. WHEN account activity is tracked THEN the system SHALL display account modification history and patterns
5. WHEN account data is analyzed THEN the system SHALL parse and display account data structures where possible
6. WHEN account search is used THEN the system SHALL support filtering and searching within owned accounts
7. WHEN account export is performed THEN the system SHALL provide account data export functionality
8. WHEN account monitoring is enabled THEN the system SHALL track changes to owned accounts in real-time

### Requirement 5: Program Interaction History and Patterns

**User Story:** As a DeFi analyst, I want to analyze program interaction history and identify usage patterns, so that I can understand program adoption and ecosystem integration.

#### Acceptance Criteria

1. WHEN interaction history is displayed THEN the system SHALL show recent program interactions with transaction details
2. WHEN usage patterns are analyzed THEN the system SHALL identify common interaction patterns and sequences
3. WHEN caller analysis is performed THEN the system SHALL show top callers and their interaction frequency
4. WHEN integration mapping is done THEN the system SHALL identify programs that interact with this program
5. WHEN usage metrics are calculated THEN the system SHALL show transaction volume, unique users, and growth metrics
6. WHEN seasonal patterns are detected THEN the system SHALL identify usage patterns over different time periods
7. WHEN interaction export is provided THEN the system SHALL export interaction data for further analysis
8. WHEN real-time monitoring is enabled THEN the system SHALL track new interactions and usage changes

### Requirement 6: Program Security Analysis and Audit Information

**User Story:** As a security researcher, I want to see security analysis and audit information for programs, so that I can assess program safety and identify potential risks.

#### Acceptance Criteria

1. WHEN security analysis is performed THEN the system SHALL check for common vulnerability patterns and security issues
2. WHEN audit information is available THEN the system SHALL display security audit results and findings
3. WHEN risk assessment is calculated THEN the system SHALL provide comprehensive risk scores and explanations
4. WHEN vulnerability detection is run THEN the system SHALL identify potential buffer overflows, integer overflows, and access control issues
5. WHEN upgrade analysis is performed THEN the system SHALL analyze program upgradeability and governance mechanisms
6. WHEN permission analysis is done THEN the system SHALL identify program permissions and potential privilege escalation risks
7. WHEN security alerts are configured THEN the system SHALL notify users of security issues and updates
8. WHEN security reports are generated THEN the system SHALL provide detailed security assessment reports

### Requirement 7: Program List and Discovery

**User Story:** As a developer, I want to browse and discover programs with activity metrics and filtering options, so that I can find relevant programs and analyze ecosystem trends.

#### Acceptance Criteria

1. WHEN visiting `/programs` THEN the system SHALL display a comprehensive list of programs with activity metrics
2. WHEN program list is sorted THEN the system SHALL support sorting by activity, transactions, users, and deployment date
3. WHEN programs are filtered THEN the system SHALL provide filters for program type, activity level, and verification status
4. WHEN program search is used THEN the system SHALL support search by address, name, and functionality
5. WHEN program categories are shown THEN the system SHALL group programs by type (DeFi, gaming, NFT, infrastructure)
6. WHEN activity metrics are displayed THEN the system SHALL show transaction counts, user counts, and growth trends
7. WHEN new programs are highlighted THEN the system SHALL show recently deployed programs with deployment metrics
8. WHEN program list is exported THEN the system SHALL provide export functionality with current activity data

### Requirement 8: Program Performance Metrics and Optimization

**User Story:** As a performance engineer, I want to see detailed performance metrics and optimization suggestions for programs, so that I can improve program efficiency and reduce costs.

#### Acceptance Criteria

1. WHEN performance metrics are displayed THEN the system SHALL show compute unit consumption, execution times, and efficiency scores
2. WHEN optimization suggestions are provided THEN the system SHALL identify potential performance improvements and cost reductions
3. WHEN performance trends are analyzed THEN the system SHALL show performance changes over time and identify degradation
4. WHEN benchmarking is performed THEN the system SHALL compare program performance against similar programs
5. WHEN resource usage is tracked THEN the system SHALL monitor memory usage, storage consumption, and network activity
6. WHEN performance alerts are configured THEN the system SHALL notify users of performance issues and anomalies
7. WHEN optimization reports are generated THEN the system SHALL provide detailed performance analysis and recommendations
8. WHEN performance monitoring is enabled THEN the system SHALL track performance metrics in real-time

### Requirement 9: Program Dependencies and Integration Analysis

**User Story:** As a system architect, I want to analyze program dependencies and integrations, so that I can understand program relationships and ecosystem architecture.

#### Acceptance Criteria

1. WHEN dependency analysis is performed THEN the system SHALL identify programs and libraries that this program depends on
2. WHEN integration mapping is done THEN the system SHALL show programs that integrate with or call this program
3. WHEN dependency graphs are generated THEN the system SHALL visualize program dependency relationships
4. WHEN version tracking is enabled THEN the system SHALL track program versions and upgrade dependencies
5. WHEN impact analysis is performed THEN the system SHALL assess the impact of program changes on dependent systems
6. WHEN ecosystem mapping is done THEN the system SHALL show the program's role in the broader Solana ecosystem
7. WHEN dependency alerts are configured THEN the system SHALL notify users of dependency changes and updates
8. WHEN integration export is provided THEN the system SHALL export dependency and integration data for analysis

### Requirement 10: Program Development and Deployment Analytics

**User Story:** As a project manager, I want to track program development activity and deployment patterns, so that I can understand development trends and project health.

#### Acceptance Criteria

1. WHEN development activity is tracked THEN the system SHALL monitor program updates, deployments, and code changes
2. WHEN deployment analytics are shown THEN the system SHALL display deployment frequency, success rates, and rollback patterns
3. WHEN developer activity is analyzed THEN the system SHALL identify development teams and contribution patterns
4. WHEN version history is displayed THEN the system SHALL show program version history and change logs
5. WHEN development metrics are calculated THEN the system SHALL show development velocity, bug fix rates, and feature additions
6. WHEN project health is assessed THEN the system SHALL provide project health scores based on development activity
7. WHEN development alerts are configured THEN the system SHALL notify users of development milestones and issues
8. WHEN development reports are generated THEN the system SHALL provide comprehensive development analytics reports

### Requirement 11: Program Documentation and Educational Resources

**User Story:** As a developer learning Solana, I want to access program documentation and educational resources, so that I can understand how programs work and learn from examples.

#### Acceptance Criteria

1. WHEN documentation is available THEN the system SHALL display program documentation, README files, and API references
2. WHEN educational content is provided THEN the system SHALL offer tutorials, examples, and best practices
3. WHEN code examples are shown THEN the system SHALL provide interactive code examples and usage patterns
4. WHEN learning paths are available THEN the system SHALL suggest learning resources based on program complexity
5. WHEN community content is integrated THEN the system SHALL show community-contributed documentation and guides
6. WHEN documentation search is used THEN the system SHALL support searching within documentation and resources
7. WHEN documentation export is provided THEN the system SHALL allow downloading documentation for offline use
8. WHEN documentation updates are tracked THEN the system SHALL notify users of documentation changes and additions

### Requirement 12: Program Testing and Validation Tools

**User Story:** As a QA engineer, I want to test and validate program functionality, so that I can ensure program correctness and identify potential issues.

#### Acceptance Criteria

1. WHEN testing tools are provided THEN the system SHALL offer program testing interfaces and validation tools
2. WHEN test cases are generated THEN the system SHALL create automated test cases based on program analysis
3. WHEN validation is performed THEN the system SHALL validate program inputs, outputs, and state changes
4. WHEN fuzzing is enabled THEN the system SHALL provide fuzzing tools to test program robustness
5. WHEN test results are displayed THEN the system SHALL show test execution results and coverage metrics
6. WHEN regression testing is performed THEN the system SHALL compare program behavior across different versions
7. WHEN test reports are generated THEN the system SHALL provide comprehensive testing and validation reports
8. WHEN continuous testing is enabled THEN the system SHALL monitor program behavior and detect regressions

### Requirement 13: Data Storage and Vector Search Integration

**User Story:** As a system architect, I want all processed program analytics data to be stored in Qdrant for efficient vector search and similarity analysis, so that the system can provide fast recommendations and complex queries.

#### Acceptance Criteria

1. WHEN program analytics are processed THEN the system SHALL store all processed data (code analysis, instruction usage, security assessment, performance metrics) in Qdrant collections
2. WHEN program similarity is calculated THEN the system SHALL use Qdrant vector embeddings to find similar programs based on functionality and characteristics
3. WHEN security analysis is performed THEN the system SHALL store security patterns and vulnerability signatures as vectors in Qdrant
4. WHEN performance analysis is completed THEN the system SHALL store performance patterns and optimization opportunities in Qdrant for fast lookup
5. WHEN program recommendations are generated THEN the system SHALL use Qdrant similarity search to find related programs and dependencies
6. WHEN code patterns are analyzed THEN the system SHALL store code patterns and architectural patterns as searchable vectors
7. WHEN data is queried THEN the system SHALL use Qdrant's filtering and search capabilities for complex analytics queries
8. WHEN data is updated THEN the system SHALL maintain data consistency between Qdrant and other storage systems

### Requirement 14: Performance Optimization and Caching

**User Story:** As a system administrator, I want the program explorer to perform efficiently under high load, so that users experience fast response times and reliable service.

#### Acceptance Criteria

1. WHEN program data is cached THEN the system SHALL implement appropriate caching strategies for different data types
2. WHEN real-time updates are provided THEN the system SHALL optimize for minimal latency and resource usage
3. WHEN large datasets are handled THEN the system SHALL implement pagination and virtual scrolling
4. WHEN API responses are optimized THEN the system SHALL minimize response sizes and implement compression
5. WHEN database queries are executed THEN the system SHALL use efficient indexing and query optimization
6. WHEN CDN is utilized THEN the system SHALL cache static assets and optimize global delivery
7. WHEN performance monitoring is implemented THEN the system SHALL track response times and system health
8. WHEN scaling is required THEN the system SHALL support horizontal scaling and load balancing

### Requirement 15: Mobile Optimization and Accessibility

**User Story:** As a mobile user with accessibility needs, I want the program explorer to work seamlessly on mobile devices and with assistive technologies, so that I can access program information anywhere.

#### Acceptance Criteria

1. WHEN using mobile devices THEN the system SHALL provide responsive design optimized for touch interaction
2. WHEN accessibility features are used THEN the system SHALL support screen readers and keyboard navigation
3. WHEN mobile performance is optimized THEN the system SHALL minimize data usage and loading times
4. WHEN touch gestures are implemented THEN the system SHALL support swipe navigation and touch-friendly controls
5. WHEN offline functionality is provided THEN the system SHALL cache essential data for offline viewing
6. WHEN mobile-specific features are used THEN the system SHALL integrate with device capabilities (notifications, sharing)
7. WHEN accessibility standards are met THEN the system SHALL comply with WCAG 2.1 AA guidelines
8. WHEN mobile testing is performed THEN the system SHALL work across different devices and browsers# Program Explorer Enhancements Implementation Plan

- [ ] 1. Set up core program data infrastructure and Qdrant integration
  - Create program data types and interfaces for comprehensive program information
  - Implement Qdrant collections for program vectors, code patterns, and similarity analysis
  - Set up API endpoints for program fetching, analysis, and real-time updates
  - Configure caching layer with appropriate TTL strategies for different data types
  - _Requirements: 1.1, 13.1, 13.2, 14.1, 14.2_

- [ ] 1.1 Create program data models and TypeScript interfaces
  - Create `lib/types/program.types.ts` with comprehensive ProgramData interface including address, metadata, code, instructions[], accounts[], interactions[], security, metrics, dependencies[], performance, documentation
  - Define ProgramMetadata interface with name, description, version, author, repository, documentation, verified, deployedAt, lastUpdated, upgradeAuthority, category, tags[]
  - Create ProgramCode interface with size, hash, disassembly[], hexDump, entryPoints[], dependencies[], controlFlowGraph[], codePatterns[]
  - Implement SecurityAnalysis interface with riskScore, riskLevel, vulnerabilities[], auditReports[], upgradeability, permissions[], codeQuality
  - Define PerformanceMetrics interface with computeUnitsAverage, computeUnitsMedian, computeUnitsP95, executionTimeAverage, successRate, errorRate, throughput, resourceUsage, trends[]
  - Create InstructionData interface with discriminator, name, usage, parameters[], accounts[], computeUnits
  - Add OwnedAccount interface with address, type, size, lamports, lastModified, dataHash, dataStructure, accessPattern
  - Implement SimilarityAnalysis interfaces with SimilarProgram, BytecodeOverlap, FunctionMatch, InstructionSimilarity, SemanticSimilarity
  - Create ProgramCluster interface with id, programs[], centralProgram, averageSimilarity, clusterType, commonFeatures[], description, cohesionScore, separationScore
  - _Requirements: 1.1, 2.1, 3.1, 4.1, 5.1, 6.1, 8.1, 9.1_

- [ ] 1.2 Set up Qdrant vector database integration for program analysis
  - Create `lib/qdrant/program-vectors.ts` with QdrantProgramService class implementing createCollections(), storeProgramVector(), searchSimilarPrograms(), storeCodePattern(), searchCodePatterns(), storeSimilarityVector() methods
  - Configure Qdrant collections: program_vectors (512-dim embeddings with payload: address, category, codeSize, instructionCount, complexityScore, securityScore, performanceScore, activityLevel, deployedAt, lastUpdated, dependencies[], features[]), code_pattern_vectors (code pattern embeddings with patternType, severity, programAddress, location, description, confidence, detectedAt), bytecode_similarity (bytecode embeddings for similarity search), semantic_similarity (semantic behavior embeddings), transaction_patterns (transaction pattern vectors)
  - Implement vector generation using OpenAI embeddings API for program characteristics, code patterns, bytecode similarity, and semantic behavior
  - Create vector search operations with filtering capabilities for similar program discovery, code pattern matching, and cluster analysis
  - Add vector upsert operations for real-time updates when program data changes
  - Implement similarity scoring algorithms for bytecode overlap, semantic similarity, and functional equivalence
  - _Requirements: 13.1, 13.2, 13.3, 13.4, 13.5, 13.6, 13.7, 13.8_- [ 
] 1.3 Implement core program API endpoints
  - Create `app/api/program/[address]/route.ts` with GET handler that validates program address using base58 validation and length checking, fetches program account data from Solana RPC using getAccountInfo() and getProgramAccounts(), processes program metadata and code using program analysis services, implements error handling for invalid addresses (return 404) and network errors (return 500 with retry headers)
  - Implement `app/api/programs/route.ts` with GET handler supporting query parameters: limit (default 50, max 100), offset (for pagination), sortBy (activity, transactions, users, deployedAt), filterBy (category, verified, activityLevel), search (name/address search), return ProgramListItem[] with address, name, category, verified, deployedAt, lastActivity, transactionCount, uniqueUsers, computeUnitsConsumed, successRate, securityScore, performanceScore
  - Add `app/api/programs/similarity/route.ts` with POST handler accepting targetProgram, similarityType, threshold, maxResults parameters, use Qdrant similarity search to find similar programs, return SimilarityAnalysisResult with similarPrograms[], analysisMetadata, clusters[], visualizationData
  - Create `app/api/programs/clusters/route.ts` with POST handler supporting clusteringAlgorithm, similarityThreshold, maxClusters parameters, perform program clustering using machine learning algorithms, return ClusterAnalysisResult with clusters[], outliers[], clusteringMetrics, visualizationData
  - Implement input validation using Zod schemas for all query parameters and path parameters
  - Add rate limiting using lib/rate-limiter.ts with different limits per endpoint (program detail: 200/min, program list: 500/min, similarity: 50/min, clustering: 10/min)
  - _Requirements: 1.1, 7.1, 7.2, 7.3, 7.4, 7.5, 7.6, 7.7, 7.8_

- [ ] 1.4 Set up program data caching system
  - Create `lib/cache/program-cache.ts` with ProgramCacheManager class implementing get/set/invalidate methods for different data types, use Redis for production with Map<string, CacheEntry> fallback for development
  - Configure cache TTL strategies: program metadata = 1 hour (rarely changes), code analysis = 2 hours (computationally expensive), security analysis = 30 minutes (important for safety), performance metrics = 5 minutes (real-time updates), disassembly = 24 hours (immutable unless upgraded), similarity analysis = 1 hour (expensive computation)
  - Implement cache key patterns: "program:{address}", "program:code:{address}", "program:security:{address}", "program:performance:{address}", "program:similarity:{address}:{type}", "programs:list:{params_hash}", "programs:clusters:{algorithm}:{threshold}"
  - Add cache warming for popular programs: pre-fetch and cache top 100 programs by activity on startup, implement background refresh job every 10 minutes for active programs
  - Create cache metrics tracking: hit/miss rates, memory usage, eviction counts, expose via /api/cache/metrics endpoint for monitoring
  - Implement cache invalidation triggers: invalidate program cache when new deployments detected, invalidate analysis cache when program upgrades occur, invalidate similarity cache when new similar programs are discovered
  - _Requirements: 14.1, 14.2, 14.3, 14.4, 14.5, 14.6, 14.7, 14.8_

- [ ] 2. Build program detail page with comprehensive information display
  - Create ProgramDetailsPage component with metadata, code analysis, security assessment, and performance monitoring
  - Implement progressive loading states and error handling for different data sections
  - Add tabbed interface for different analysis views and real-time updates
  - _Requirements: 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8_

- [ ] 2.1 Create ProgramDetailsPage main component
  - Create `app/program/[address]/page.tsx` as server component with generateMetadata() function for dynamic SEO, implement getProgramData() server function using fetch to /api/program/[address], handle loading states with Suspense wrapper
  - Build responsive layout using CSS Grid: header section (program info + quick stats), tab navigation (Overview | Code Analysis | Security | Performance | Dependencies), main content area with primary and secondary panels, sidebar with similar programs and quick actions
  - Implement tabbed navigation component in `components/ProgramTabs.tsx` with URL synchronization, lazy loading of tab content, keyboard navigation support, tab state management
  - Add error boundary wrapper using `components/ProgramErrorBoundary.tsx` to catch and display program not found (404) or network errors, implement retry button that refetches data
  - Create loading skeleton components matching final layout structure, use React Suspense with fallback showing skeleton for each section
  - Implement URL parameter validation: parse address from params, validate as base58 string with correct length, redirect invalid addresses to /programs with error message
  - _Requirements: 1.1, 1.2, 1.3_

- [ ] 2.2 Implement program metadata and quick stats display
  - Create `components/ProgramHeader.tsx` component displaying program icon/logo, name, verified badge, category, address (with copy button), deployment date, last updated, version, author, repository link, documentation link
  - Build `components/ProgramQuickStats.tsx` component showing key metrics: total transactions, unique users, success rate, security score, performance score, last activity, rank, with real-time updates and color coding
  - Create `components/ProgramMetadata.tsx` displaying detailed metadata: description, category and tags, deployment information, upgrade authority, governance model, with expandable sections for detailed information
  - Implement real-time updates using WebSocket connection for live metrics, show last update timestamp, implement update animations and notifications
  - Add copy-to-clipboard functionality for program address, upgrade authority, and other identifiers using navigator.clipboard API with fallback
  - Create sharing functionality: generate shareable program analysis links, social media integration, bookmark functionality
  - _Requirements: 1.1, 1.2, 1.3, 1.4, 1.5_

- [ ] 2.3 Build program overview tab with activity metrics and analytics
  - Create `components/ProgramOverview.tsx` with four-quadrant layout: program metadata panel, activity metrics panel, instruction analytics panel, account ownership panel
  - Implement `components/ActivityMetricsChart.tsx` using recharts library showing transaction volume over time, user growth chart, success rate trends, compute unit usage patterns, with multiple timeframe options (24h, 7d, 30d, 1y)
  - Add `components/InstructionAnalyticsTable.tsx` using @tanstack/react-table displaying top instructions with columns: instruction name, total calls, unique callers, average compute units, success rate, trend indicator, usage percentage
  - Create `components/AccountOwnershipDisplay.tsx` showing owned accounts list with account address, type (data/executable/system), size, lamports, last modified, with filtering and search capabilities
  - Implement real-time data updates for all metrics, show loading states during data fetching, handle empty states when no data available
  - Add export functionality for all analytics data: CSV export for instruction analytics, account ownership data, activity metrics with timestamps
  - _Requirements: 1.1, 3.1, 3.2, 3.3, 3.4, 3.5, 3.6, 3.7, 3.8, 4.1, 4.2, 4.3, 4.4, 4.5, 4.6, 4.7, 4.8, 5.1, 5.2, 5.3, 5.4, 5.5, 5.6, 5.7, 5.8_

- [ ] 3. Implement comprehensive code analysis and visualization system
  - Create code analysis engine with disassembly, hex dump, and control flow analysis
  - Build interactive code viewer with navigation, search, and pattern detection
  - Implement code pattern recognition and vulnerability detection
  - _Requirements: 2.1, 2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8_

- [ ] 3.1 Build code analysis engine
  - Create `lib/analyzers/code-analyzer.ts` with CodeAnalyzer class containing analyzeProgram(programAddress: string) method, fetch program bytecode using Solana RPC, implement disassembly using capstone.js or similar disassembler, generate hex dump with address offsets and byte highlighting
  - Implement control flow analysis: identify basic blocks and function boundaries, detect jump targets and branch instructions, generate control flow graph using graph algorithms, identify loops, conditionals, and function calls
  - Add code pattern detection: identify common vulnerability patterns (buffer overflows, integer overflows, reentrancy), detect optimization opportunities, recognize coding patterns and best practices, flag potential security issues
  - Create instruction analysis: parse assembly instructions and operands, identify instruction types and categories, calculate instruction frequency and usage patterns, detect unusual or suspicious instruction sequences
  - Implement function analysis: identify function entry and exit points, analyze function parameters and return values, calculate function complexity metrics, detect recursive functions and call chains
  - Store analysis results in Qdrant: create code pattern vectors for similar pattern detection, enable fast lookup of known code issues, implement pattern matching for new programs
  - _Requirements: 2.1, 2.2, 2.3, 2.4, 2.5_

- [ ] 3.2 Create interactive disassembly viewer
  - Create `components/DisassemblyViewer.tsx` with code viewer interface supporting hex dump view, disassembly view, control flow graph view, with toggle buttons and view synchronization
  - Implement `components/CodeNavigation.tsx` with search functionality (search within code, jump to address, find references), navigation controls (previous/next function, jump to target), bookmarking system (save important addresses, add notes)
  - Add `components/HexDumpDisplay.tsx` showing hex bytes with address offsets, byte highlighting on hover, ASCII representation, clickable bytes for detailed information
  - Build `components/AssemblyDisplay.tsx` with syntax highlighting for assembly instructions, operand highlighting, jump target identification, instruction tooltips with detailed information
  - Create `components/ControlFlowGraph.tsx` using D3.js or Cytoscape for graph visualization, interactive nodes and edges, zoom and pan functionality, node highlighting and selection
  - Implement code export functionality: export disassembly to text files, save control flow graphs as images, export analysis results as JSON, provide API for programmatic access
  - _Requirements: 2.1, 2.2, 2.3, 2.4, 2.6, 2.8_

- [ ] 3.3 Implement code pattern recognition and analysis
  - Create `lib/analyzers/pattern-detector.ts` with PatternDetector class implementing detectPatterns(disassembly: DisassemblyInstruction[]) method, use pattern matching algorithms to identify known code patterns, detect security vulnerabilities and optimization opportunities
  - Build vulnerability detection system: identify buffer overflow patterns, detect integer overflow conditions, recognize reentrancy vulnerabilities, flag access control issues, detect logic errors and edge cases
  - Add optimization detection: identify inefficient code patterns, detect redundant computations, recognize optimization opportunities, suggest performance improvements, calculate potential savings
  - Create code quality analysis: measure cyclomatic complexity, assess maintainability metrics, evaluate coding standards compliance, identify code smells and anti-patterns
  - Implement pattern visualization: highlight detected patterns in code viewer, provide pattern explanations and recommendations, show pattern severity and confidence levels, link to educational resources
  - Store pattern analysis in Qdrant: create pattern signature vectors for similar pattern detection, enable pattern-based program similarity, implement pattern clustering and analysis
  - _Requirements: 2.5, 2.6, 2.7, 2.8_-
 [ ] 4. Build comprehensive security analysis and assessment system
  - Create security analysis engine with vulnerability detection and risk scoring
  - Implement audit report integration and security metrics calculation
  - Build security visualization and reporting tools
  - _Requirements: 6.1, 6.2, 6.3, 6.4, 6.5, 6.6, 6.7, 6.8_

- [ ] 4.1 Build security analysis engine
  - Create `lib/analyzers/security-analyzer.ts` with SecurityAnalyzer class containing analyzeProgramSecurity(programData: ProgramData) method, implement comprehensive security assessment including vulnerability detection, risk scoring, and audit analysis
  - Implement vulnerability detection algorithms: buffer overflow detection using stack analysis, integer overflow detection in arithmetic operations, reentrancy detection in cross-program invocations, access control analysis for privilege escalation, logic error detection in conditional statements
  - Add risk scoring system: calculate overall risk score (0-100) based on multiple factors, weight vulnerabilities by severity and exploitability, consider program complexity and attack surface, factor in audit results and community feedback
  - Create audit report integration: fetch audit reports from major security firms, parse audit findings and recommendations, correlate audit results with automated analysis, track audit coverage and completeness
  - Implement upgradeability analysis: analyze upgrade authority and governance mechanisms, assess upgrade risks and centralization concerns, track upgrade history and patterns, evaluate governance token distribution
  - Store security analysis in Qdrant: create security pattern vectors for vulnerability detection, enable security-based program similarity, implement threat intelligence sharing
  - _Requirements: 6.1, 6.2, 6.3, 6.4, 6.5, 6.6, 6.7, 6.8_

- [ ] 4.2 Create security visualization and reporting components
  - Create `components/SecurityDashboard.tsx` with security score display (0-100 with color coding), risk level indicator (low/medium/high/critical), vulnerability summary with counts by severity, audit status and coverage metrics
  - Build `components/VulnerabilityList.tsx` using @tanstack/react-table displaying vulnerabilities with columns: type, severity, location, description, impact, recommendation, CWE/CVE references, with filtering and sorting capabilities
  - Implement `components/AuditReportsDisplay.tsx` showing audit reports from security firms, audit findings and recommendations, audit dates and versions, overall audit ratings, with links to full reports
  - Add `components/SecurityTrends.tsx` using recharts to show security score trends over time, vulnerability discovery and resolution rates, audit frequency and coverage, security improvement metrics
  - Create `components/UpgradeabilityAnalysis.tsx` displaying upgrade authority information, governance model analysis, upgrade history and patterns, centralization risk assessment
  - Implement security report generation: comprehensive security assessment reports, vulnerability details and remediation guidance, audit summary and recommendations, exportable PDF reports
  - _Requirements: 6.1, 6.2, 6.3, 6.4, 6.5, 6.6, 6.7, 6.8_

- [ ] 5. Implement performance analysis and optimization system
  - Create performance monitoring engine with metrics collection and analysis
  - Build performance visualization and optimization recommendation system
  - Implement performance benchmarking and comparison tools
  - _Requirements: 8.1, 8.2, 8.3, 8.4, 8.5, 8.6, 8.7, 8.8_

- [ ] 5.1 Build performance analysis engine
  - Create `lib/analyzers/performance-analyzer.ts` with PerformanceAnalyzer class implementing analyzePerformance(programAddress: string) method, collect performance metrics from transaction history, calculate compute unit statistics, analyze execution times and success rates
  - Implement metrics calculation: average, median, and P95 compute unit consumption, execution time distribution and trends, success rate and error analysis, throughput and transaction volume metrics, resource usage patterns
  - Add performance trend analysis: identify performance degradation over time, detect performance anomalies and spikes, analyze seasonal patterns and usage cycles, correlate performance with network conditions
  - Create optimization detection: identify performance bottlenecks in code, detect inefficient algorithms and data structures, recognize optimization opportunities, estimate potential performance improvements
  - Implement benchmarking system: compare performance against similar programs, establish performance baselines and targets, track performance improvements over time, generate performance rankings
  - Store performance data in Qdrant: create performance pattern vectors for similar performance analysis, enable performance-based program recommendations, implement performance clustering
  - _Requirements: 8.1, 8.2, 8.3, 8.4, 8.5, 8.6, 8.7, 8.8_

- [ ] 5.2 Create performance visualization and optimization components
  - Create `components/PerformanceOverview.tsx` with performance metrics dashboard showing average compute units, P95 compute units, success rate, throughput, with real-time updates and trend indicators
  - Build `components/PerformanceCharts.tsx` using recharts library displaying compute units over time, success rate trends, execution time distribution, resource usage breakdown, with multiple timeframe options
  - Implement `components/OptimizationSuggestions.tsx` showing optimization opportunities ranked by impact, potential compute unit savings, implementation difficulty, code locations, with detailed explanations and examples
  - Add `components/InstructionPerformance.tsx` using @tanstack/react-table displaying instruction-level performance metrics: instruction type, average compute units, call frequency, performance percentage, with sorting and filtering
  - Create `components/ResourceUsageDisplay.tsx` showing memory usage, storage consumption, network activity, CPU utilization, with usage limits and optimization recommendations
  - Implement performance report generation: detailed performance analysis reports, optimization recommendations and implementation guides, benchmarking results and comparisons, exportable performance data
  - _Requirements: 8.1, 8.2, 8.3, 8.4, 8.5, 8.6, 8.7, 8.8_

- [ ] 6. Build program similarity analysis and clustering system
  - Create similarity analysis engine with bytecode and semantic comparison
  - Implement program clustering algorithms and visualization
  - Build similarity search interface and results display
  - _Requirements: Custom requirement for similarity analysis based on user request_

- [ ] 6.1 Build program similarity analysis engine
  - Create `lib/analyzers/similarity-analyzer.ts` with SimilarityAnalyzer class implementing analyzeSimilarity(targetProgram: string, similarityType: SimilarityType) method, support multiple similarity types (bytecode, semantic, functional, behavioral, structural)
  - Implement bytecode similarity analysis: compare raw bytecode using sequence alignment algorithms, calculate bytecode overlap percentages, identify identical code sequences, detect code modifications and variations, use fuzzy hashing for approximate matching
  - Add semantic similarity analysis: analyze transaction patterns and behavior, compare program functionality and use cases, evaluate API compatibility and interface similarity, assess functional equivalence using symbolic execution
  - Create function-level similarity: identify identical functions using hash comparison, detect similar functions with minor modifications, analyze function call graphs and dependencies, compare function complexity and structure
  - Implement instruction pattern matching: compare instruction sequences and patterns, detect similar algorithmic approaches, identify common code libraries and templates, analyze control flow similarities
  - Store similarity vectors in Qdrant: create bytecode embeddings for fast similarity search, generate semantic behavior vectors, implement similarity indexing for efficient queries, enable real-time similarity updates
  - _Requirements: Custom requirement for bytecode and semantic similarity analysis_

- [ ] 6.2 Implement program clustering algorithms
  - Create `lib/clustering/program-clusterer.ts` with ProgramClusterer class implementing clusterPrograms(programs: string[], algorithm: ClusteringAlgorithm) method, support multiple clustering algorithms (K-means, hierarchical, DBSCAN, spectral clustering)
  - Implement K-means clustering: determine optimal number of clusters using elbow method, initialize cluster centroids using K-means++, iterate until convergence with configurable tolerance, handle outliers and noise
  - Add hierarchical clustering: build dendrogram using linkage criteria (single, complete, average), support agglomerative and divisive approaches, enable cluster cutting at different similarity thresholds, visualize cluster hierarchy
  - Create DBSCAN clustering: identify dense regions and outliers, configure epsilon and minimum points parameters, handle varying cluster densities, detect arbitrary cluster shapes
  - Implement cluster validation: calculate silhouette scores for cluster quality, compute Davies-Bouldin index for cluster separation, measure Calinski-Harabasz index for cluster cohesion, assess cluster stability
  - Add cluster analysis: identify cluster characteristics and common features, determine central programs for each cluster, calculate intra-cluster and inter-cluster similarities, generate cluster descriptions
  - Store clustering results in Qdrant: create cluster vectors for cluster-based search, enable cluster membership queries, implement cluster evolution tracking
  - _Requirements: Custom requirement for program clustering and analysis_

- [ ] 6.3 Create similarity search and clustering interfaces
  - Create `app/programs/similarity/page.tsx` with similarity search interface, target program input with validation, similarity type selection (bytecode/semantic/functional), threshold slider, max results configuration
  - Build `components/SimilaritySearchForm.tsx` with program address input with autocomplete, similarity type radio buttons, threshold range slider (0.1-1.0), advanced options (max results, filter criteria), search button with loading states
  - Implement `components/SimilarityResults.tsx` using @tanstack/react-table displaying similar programs with columns: program address, similarity score, relationship type, match details, last analyzed, with sorting and filtering
  - Add `components/SimilarityVisualization.tsx` using D3.js or Cytoscape for network graph visualization, nodes representing programs, edges showing similarity relationships, interactive zoom and pan, node clustering and highlighting
  - Create `app/programs/clusters/page.tsx` with clustering interface, algorithm selection, parameter configuration, cluster visualization, cluster analysis results
  - Build `components/ClusterVisualization.tsx` with 2D scatter plot using recharts, cluster coloring and labeling, outlier identification, interactive cluster selection, cluster statistics display
  - _Requirements: Custom requirement for similarity search and clustering interfaces_

- [ ] 6.4 Implement detailed similarity analysis components
  - Create `components/SimilarityDetails.tsx` with detailed match analysis, bytecode overlap visualization, function matching results, instruction similarity breakdown, semantic similarity metrics
  - Build `components/BytecodeComparison.tsx` showing side-by-side bytecode comparison, highlighted common sequences, unique sections identification, overlap percentage calculation, sequence alignment visualization
  - Implement `components/FunctionMatching.tsx` displaying function-level comparisons, identical function pairs, similar function analysis, function signature comparison, call graph similarities
  - Add `components/InstructionSimilarity.tsx` with instruction pattern analysis, common instruction sequences, unique instruction identification, control flow comparison, algorithmic similarity assessment
  - Create `components/SemanticAnalysis.tsx` showing transaction pattern similarities, behavioral equivalence analysis, API compatibility assessment, use case comparison, functional similarity metrics
  - Implement export functionality: similarity analysis reports, comparison matrices, cluster analysis results, visualization exports (PNG, SVG), data exports (CSV, JSON)
  - _Requirements: Custom requirement for detailed similarity analysis and comparison_

- [ ] 7. Build global program similarity browser and matrix views
  - Create global similarity browser page for exploring all program similarities
  - Implement similarity matrix view with heatmap visualization
  - Build advanced filtering and export capabilities for similarity data
  - _Requirements: Custom requirement for global similarity browser based on user request_

- [ ] 7.1 Create global program similarity browser page
  - Create `app/programs/similarity-browser/page.tsx` with comprehensive similarity exploration interface, search mode selection (Browse All, Target-based), similarity type tabs (Bytecode, Semantic, Transaction Patterns, Mixed), advanced filtering controls
  - Build `components/GlobalSimilarityBrowser.tsx` with similarity search controls, min similarity threshold slider, category filters, sort options (similarity, activity, category), search and export buttons
  - Implement `components/SimilarityNetworkView.tsx` using D3.js or Cytoscape for interactive network visualization, program nodes sized by activity, similarity edges with thickness based on score, color coding by category, zoom and pan controls
  - Add `components/SimilarityInsightsPanel.tsx` with four-quadrant layout: top clusters (DEX, AMM, NFT clusters with average similarity), common patterns (token swap, liquidity pool, staking patterns), similarity distribution chart, category breakdown
  - Create `components/SimilarProgramsTable.tsx` using @tanstack/react-table displaying program pairs with columns: Program A, Program B, Similarity %, Relationship Type, Common Features, with load more functionality and comparison selection
  - Implement real-time similarity updates: WebSocket connection for new similarity discoveries, notification system for interesting matches, background similarity computation for new programs
  - _Requirements: Custom requirement for global similarity browser interface_

- [ ] 7.2 Build program similarity matrix view
  - Create `app/programs/similarity-matrix/page.tsx` with similarity matrix interface, matrix configuration controls (program selection, similarity type, threshold, display options), heatmap visualization, matrix statistics
  - Build `components/SimilarityMatrix.tsx` with interactive heatmap using D3.js or recharts, color-coded similarity scores (red=high, white=low), clickable cells for detailed analysis, row/column sorting, zoom and pan functionality
  - Implement `components/MatrixConfiguration.tsx` with program selection dropdown (Top 50, Top 100, Custom list), similarity type selection, threshold slider, display options (heatmap, network, table), refresh and export buttons
  - Add `components/MatrixStatistics.tsx` showing total comparisons, similarity distribution (90-100%, 80-90%, etc.), highest similarity pairs, most connected programs, average similarity score
  - Create `components/SelectedPairAnalysis.tsx` displaying detailed analysis when matrix cell is clicked, similarity breakdown, common features, relationship type, detailed comparison link
  - Implement matrix export functionality: export similarity matrix as CSV, save heatmap as PNG/SVG, generate similarity reports, provide API endpoints for programmatic access
  - _Requirements: Custom requirement for similarity matrix visualization_

- [ ] 7.3 Implement advanced similarity filtering and analytics
  - Create `components/SimilarityFilters.tsx` with advanced filtering options: similarity score ranges, program categories, deployment date ranges, activity levels, verification status, custom program lists
  - Build `components/SimilarityAnalytics.tsx` with similarity trend analysis, cluster evolution tracking, similarity pattern detection, ecosystem health metrics based on program relationships
  - Implement `components/SimilarityExport.tsx` with multiple export formats: CSV for data analysis, JSON for API integration, PNG/SVG for visualizations, PDF reports for documentation
  - Add `components/SimilaritySearch.tsx` with advanced search capabilities: search by program name/address, similarity pattern search, cluster-based search, semantic search using natural language
  - Create similarity recommendation system: suggest interesting program comparisons, recommend programs for analysis, identify trending similarity patterns, provide personalized similarity feeds
  - Implement similarity caching and optimization: cache similarity computations, implement incremental similarity updates, optimize matrix calculations, use Web Workers for heavy computations
  - _Requirements: Custom requirement for advanced similarity features_- [ ] 8. 
Build program list and discovery system
  - Create program list page with filtering, sorting, and search capabilities
  - Implement program discovery and categorization system
  - Build program statistics and analytics dashboard
  - _Requirements: 7.1, 7.2, 7.3, 7.4, 7.5, 7.6, 7.7, 7.8_

- [ ] 8.1 Create program list page and discovery interface
  - Create `app/programs/page.tsx` with comprehensive program listing, search and filter controls, category overview, network statistics, with server-side rendering for SEO optimization
  - Build `components/ProgramSearchFilters.tsx` with search input supporting program name and address search, category filter dropdown (DeFi, Gaming, NFT, Infrastructure, Social), activity level filter (inactive, low, moderate, high), verification status checkbox, security score range slider, performance score range slider
  - Implement `components/ProgramTable.tsx` using @tanstack/react-table with virtual scrolling for large datasets, columns: program name/address, category, verification status, deployment date, last activity, transaction count, unique users, success rate, security score, performance score, with sorting and filtering capabilities
  - Add `components/CategoryOverview.tsx` displaying program categories with counts, category-specific statistics, trending categories, category growth metrics, with clickable category filters
  - Create `components/NetworkProgramStats.tsx` showing total programs, active programs (24h), new programs (7d), average security score, top categories, network health indicators, with similarity analysis and clustering buttons
  - Implement infinite scroll or pagination for large program lists, loading states during data fetching, empty states when no programs match filters, export functionality for filtered results
  - _Requirements: 7.1, 7.2, 7.3, 7.4, 7.5, 7.6, 7.7, 7.8_

- [ ] 8.2 Build program discovery and recommendation system
  - Create `lib/discovery/program-discovery.ts` with ProgramDiscovery class implementing discoverPrograms(criteria: DiscoveryCriteria) method, use machine learning algorithms for program recommendation, analyze user behavior and preferences for personalized suggestions
  - Implement trending program detection: identify programs with increasing activity, detect viral programs and rapid adoption, analyze social media mentions and community engagement, track developer activity and updates
  - Add new program monitoring: detect newly deployed programs, analyze program quality and legitimacy, identify promising new projects, track early adoption patterns, provide early access notifications
  - Create similar program recommendations: use Qdrant similarity search for program suggestions, recommend programs based on user viewing history, suggest complementary programs and integrations, provide category-based recommendations
  - Implement program scoring and ranking: calculate program quality scores, rank programs by activity and adoption, assess program maturity and stability, evaluate community support and documentation
  - Store discovery data in Qdrant: create user preference vectors for personalized recommendations, generate program trend vectors, implement recommendation indexing for fast queries
  - _Requirements: 7.1, 7.2, 7.3, 7.4, 7.5, 7.6, 7.7, 7.8_

- [ ] 9. Implement program dependencies and integration analysis
  - Create dependency analysis engine with program relationship mapping
  - Build integration visualization and impact assessment tools
  - Implement ecosystem mapping and influence analysis
  - _Requirements: 9.1, 9.2, 9.3, 9.4, 9.5, 9.6, 9.7, 9.8_

- [ ] 9.1 Build dependency analysis engine
  - Create `lib/analyzers/dependency-analyzer.ts` with DependencyAnalyzer class implementing analyzeDependencies(programAddress: string) method, identify program dependencies through code analysis, detect library usage and imports, analyze cross-program invocations
  - Implement dependency detection: parse program bytecode for external program calls, identify library dependencies and shared code, detect program composition and inheritance patterns, analyze upgrade dependencies and version compatibility
  - Add integration mapping: identify programs that call this program, detect bidirectional dependencies and circular references, analyze integration patterns and usage frequency, map ecosystem relationships and connections
  - Create impact analysis: assess impact of program changes on dependent systems, identify critical dependencies and single points of failure, analyze upgrade cascades and breaking changes, evaluate ecosystem stability and resilience
  - Implement dependency visualization: generate dependency graphs using graph algorithms, create hierarchical dependency trees, visualize integration networks and ecosystems, highlight critical paths and bottlenecks
  - Store dependency data in Qdrant: create dependency pattern vectors for similar dependency analysis, enable dependency-based program recommendations, implement ecosystem clustering and analysis
  - _Requirements: 9.1, 9.2, 9.3, 9.4, 9.5, 9.6, 9.7, 9.8_

- [ ] 9.2 Create dependency visualization and analysis components
  - Create `components/DependencyGraph.tsx` using D3.js or Cytoscape for interactive dependency visualization, nodes representing programs, edges showing dependencies, hierarchical layout with zoom and pan, dependency type color coding
  - Build `components/DependencyTable.tsx` using @tanstack/react-table displaying program dependencies with columns: dependency address, dependency type, relationship strength, last interaction, version compatibility, with filtering and sorting
  - Implement `components/IntegrationMap.tsx` showing programs that integrate with current program, integration frequency and patterns, bidirectional relationship visualization, integration health metrics
  - Add `components/ImpactAnalysis.tsx` displaying potential impact of program changes, affected programs and systems, risk assessment and mitigation strategies, upgrade planning and coordination
  - Create `components/EcosystemOverview.tsx` with ecosystem health metrics, program influence scores, network centrality measures, ecosystem evolution trends, community and adoption metrics
  - Implement dependency export functionality: dependency reports and documentation, integration guides and best practices, ecosystem analysis and insights, visualization exports and sharing
  - _Requirements: 9.1, 9.2, 9.3, 9.4, 9.5, 9.6, 9.7, 9.8_

- [ ] 10. Build advanced analytics and machine learning features
  - Create anomaly detection system for unusual program behavior
  - Implement predictive analytics for program performance and security
  - Build recommendation engine for program discovery and analysis
  - _Requirements: 10.1, 10.2, 10.3, 10.4, 10.5, 10.6, 10.7, 10.8_

- [ ] 10.1 Implement anomaly detection for program behavior
  - Create `lib/ml/anomaly-detector.ts` with AnomalyDetector class implementing detectAnomalies(programData: ProgramData) method, use machine learning algorithms to identify unusual patterns, detect security threats and performance issues
  - Build behavioral analysis: establish baseline behavior patterns for programs, detect deviations from normal operation, identify suspicious transaction patterns, flag unusual resource consumption
  - Add security anomaly detection: detect potential exploits and attacks, identify unusual access patterns, flag suspicious code modifications, monitor for known attack signatures
  - Create performance anomaly detection: identify performance degradation patterns, detect resource usage spikes, flag efficiency regressions, monitor for optimization opportunities
  - Implement real-time anomaly monitoring: stream program activity data, apply anomaly detection algorithms in real-time, generate alerts for critical anomalies, provide anomaly severity scoring
  - Store anomaly patterns in Qdrant: create anomaly signature vectors, enable similar anomaly detection, implement anomaly clustering and analysis, track anomaly evolution over time
  - _Requirements: 10.1, 10.2, 10.3, 10.4, 10.5, 10.6, 10.7, 10.8_

- [ ] 10.2 Build predictive analytics and forecasting system
  - Create `lib/ml/predictor.ts` with ProgramPredictor class implementing predictPerformance(programAddress: string) and predictSecurity(programAddress: string) methods, use time series analysis and machine learning for forecasting
  - Implement performance prediction: forecast compute unit usage trends, predict throughput and scalability limits, estimate resource requirements, project performance under different load conditions
  - Add security risk prediction: predict vulnerability discovery likelihood, forecast security score trends, estimate attack probability, project security improvement timelines
  - Create adoption forecasting: predict program usage growth, forecast community adoption patterns, estimate market penetration, project ecosystem integration trends
  - Build trend analysis: identify long-term patterns in program behavior, detect cyclical patterns and seasonality, forecast technology adoption curves, predict ecosystem evolution
  - Implement prediction accuracy tracking: measure prediction accuracy over time, adjust models based on actual outcomes, provide confidence intervals for predictions, track model performance metrics
  - _Requirements: 10.1, 10.2, 10.3, 10.4, 10.5, 10.6, 10.7, 10.8_

- [ ] 11. Implement comprehensive testing and quality assurance
  - Create unit tests for all analysis engines and components
  - Build integration tests for API endpoints and data flows
  - Implement end-to-end tests for user workflows and features
  - _Requirements: 11.1, 11.2, 11.3, 11.4, 11.5, 11.6, 11.7, 11.8_

- [ ] 11.1 Create comprehensive unit test suite
  - Create `__tests__/analyzers/code-analyzer.test.ts` testing CodeAnalyzer class methods, mock Solana RPC responses, test disassembly generation, validate control flow analysis, verify pattern detection accuracy
  - Build `__tests__/analyzers/security-analyzer.test.ts` testing SecurityAnalyzer vulnerability detection, mock audit report data, test risk scoring algorithms, validate security pattern recognition
  - Implement `__tests__/analyzers/performance-analyzer.test.ts` testing PerformanceAnalyzer metrics calculation, mock transaction history data, test optimization detection, validate benchmarking algorithms
  - Add `__tests__/analyzers/similarity-analyzer.test.ts` testing SimilarityAnalyzer bytecode and semantic comparison, mock Qdrant responses, test clustering algorithms, validate similarity scoring
  - Create `__tests__/components/` directory with tests for all React components, test component rendering, validate prop handling, test user interactions, verify accessibility compliance
  - Implement test utilities in `__tests__/utils/` for mock data generation, test helpers, and common testing patterns, create realistic program data mocks, Qdrant response mocks, Solana RPC mocks
  - _Requirements: 11.1, 11.2, 11.3, 11.4, 11.5, 11.6, 11.7, 11.8_

- [ ] 11.2 Build integration test suite
  - Create `__tests__/integration/api-endpoints.test.ts` testing all API endpoints with real database connections, test program data fetching, validate similarity search, test clustering operations
  - Build `__tests__/integration/qdrant-integration.test.ts` testing Qdrant vector operations, test vector storage and retrieval, validate similarity search accuracy, test collection management
  - Implement `__tests__/integration/cache-integration.test.ts` testing cache operations, validate cache hit/miss behavior, test cache invalidation, verify cache warming functionality
  - Add `__tests__/integration/data-flow.test.ts` testing end-to-end data processing, validate program analysis pipeline, test real-time updates, verify data consistency
  - Create performance integration tests measuring API response times, database query performance, vector search latency, cache performance metrics
  - Implement error handling integration tests for network failures, database errors, invalid inputs, rate limiting scenarios
  - _Requirements: 11.1, 11.2, 11.3, 11.4, 11.5, 11.6, 11.7, 11.8_

- [ ] 11.3 Implement end-to-end testing with Playwright
  - Create `e2e/program-explorer.spec.ts` testing complete user workflows, program detail page navigation, code analysis interactions, security assessment viewing, performance metrics exploration
  - Build `e2e/similarity-analysis.spec.ts` testing similarity search workflows, program comparison features, clustering visualization, matrix view interactions
  - Implement `e2e/program-discovery.spec.ts` testing program list browsing, filtering and search functionality, category navigation, program recommendation features
  - Add `e2e/mobile-responsive.spec.ts` testing mobile user experience, responsive design validation, touch interactions, mobile-specific features
  - Create visual regression tests using Playwright screenshots, test component visual consistency, validate chart rendering, verify layout responsiveness
  - Implement accessibility testing using axe-playwright, test keyboard navigation, validate ARIA labels, verify screen reader compatibility, test color contrast compliance
  - _Requirements: 11.1, 11.2, 11.3, 11.4, 11.5, 11.6, 11.7, 11.8_

- [ ] 12. Implement production deployment and monitoring
  - Set up production infrastructure with proper scaling and monitoring
  - Implement comprehensive logging and error tracking
  - Build performance monitoring and alerting systems
  - _Requirements: 12.1, 12.2, 12.3, 12.4, 12.5, 12.6, 12.7, 12.8_

- [ ] 12.1 Set up production infrastructure and deployment
  - Configure production deployment pipeline using Docker containers, set up Kubernetes cluster for scalability, implement blue-green deployment strategy, configure load balancing and auto-scaling
  - Set up production databases: configure PostgreSQL cluster for metadata storage, deploy Qdrant cluster for vector operations, set up Redis cluster for caching, implement database backup and recovery
  - Configure monitoring infrastructure: deploy Prometheus for metrics collection, set up Grafana for visualization, implement Jaeger for distributed tracing, configure log aggregation with ELK stack
  - Implement security measures: configure SSL/TLS certificates, set up WAF and DDoS protection, implement API rate limiting, configure security headers and CORS policies
  - Set up CI/CD pipeline: automated testing on pull requests, security scanning and vulnerability assessment, performance testing and benchmarking, automated deployment to staging and production
  - Configure environment management: separate configurations for development, staging, and production, secure secret management, environment variable validation, configuration drift detection
  - _Requirements: 12.1, 12.2, 12.3, 12.4, 12.5, 12.6, 12.7, 12.8_

- [ ] 12.2 Implement comprehensive monitoring and alerting
  - Create `lib/monitoring/metrics.ts` with custom metrics collection, track API response times, monitor database query performance, measure vector search latency, collect user interaction metrics
  - Build `lib/monitoring/alerts.ts` with intelligent alerting system, configure alerts for API errors, database connection issues, high response times, unusual traffic patterns, security incidents
  - Implement health check endpoints: `/api/health` for basic health status, `/api/health/detailed` for comprehensive system status, `/api/health/dependencies` for external service status
  - Add performance monitoring: track Core Web Vitals, monitor JavaScript bundle sizes, measure page load times, analyze user experience metrics, identify performance bottlenecks
  - Create error tracking and reporting: integrate with Sentry for error monitoring, implement custom error categorization, track error trends and patterns, provide error resolution workflows
  - Build operational dashboards: real-time system status, performance metrics visualization, error rate tracking, user activity monitoring, resource utilization graphs
  - _Requirements: 12.1, 12.2, 12.3, 12.4, 12.5, 12.6, 12.7, 12.8_# Token Explorer Enhancements Design

## Overview

The Token Explorer Enhancements design provides a comprehensive solution for token analysis, community engagement, and trading on Solana. The system transforms the basic token explorer into a full-featured platform with advanced analytics, security assessment, community features, portfolio tracking, AI insights, and integrated trading capabilities. The design emphasizes user engagement through gamification, social features, and cutting-edge analysis tools.

## Architecture

### High-Level Architecture

```mermaid
graph TB
    subgraph "Client Layer"
        A[Token Detail Page] --> B[Token List Pages]
        A --> C[Portfolio Tracker]
        A --> D[Trading Interface]
        B --> E[Launch Pad]
        C --> F[AI Insights]
    end
    
    subgraph "API Layer"
        G[Token API] --> H[Analytics Engine]
        G --> I[Security Engine]
        H --> J[AI Prediction Engine]
        I --> K[Rug Pull Detector]
        L[Trading API] --> M[DEX Aggregator]
        N[Community API] --> O[Trollbox Service]
    end
    
    subgraph "Data Layer"
        P[Qdrant Vector DB] --> Q[Token Analytics]
        P --> R[Security Patterns]
        P --> S[User Behavior]
        T[PostgreSQL] --> U[User Data]
        T --> V[Community Data]
        W[Redis Cache] --> X[Real-time Data]
    end
    
    A --> G
    C --> G
    D --> L
    E --> G
    F --> J
    O --> N
    G --> P
    H --> P
    I --> P
    J --> P
```

### Component Architecture

The token explorer follows a modular microservices architecture with clear separation of concerns:

- **Presentation Layer**: React components with real-time updates
- **Business Logic Layer**: Specialized engines for analytics, security, and AI
- **Data Access Layer**: Multi-database approach with Qdrant for vectors, PostgreSQL for relational data
- **Integration Layer**: External APIs for market data, DEX aggregation, and social media

## Components and Interfaces

### Core Token Components

#### TokenDetailsPage Component
```typescript
interface TokenDetailsPageProps {
  mint: string;
  initialData?: TokenData;
}

interface TokenData {
  mint: string;
  metadata: TokenMetadata;
  supply: TokenSupply;
  marketData: TokenMarketData;
  holders: TokenHolder[];
  transfers: TokenTransfer[];
  statistics: TokenStatistics;
  socialLinks: SocialLinks;
  securityAnalysis: SecurityAnalysis;
  creatorAnalysis: CreatorAnalysis;
  bundlingAnalysis: BundlingAnalysis;
  similarTokens: SimilarToken[];
  communityRating: CommunityRating;
  aiInsights: AIInsights;
}

interface TokenMetadata {
  name: string;
  symbol: string;
  decimals: number;
  description?: string;
  image?: string;
  creator: string;
  verified: boolean;
  tags: string[];
  createdAt: number;
  website?: string;
  twitter?: string;
  discord?: string;
  telegram?: string;
}

interface TokenMarketData {
  price: number;
  priceChange24h: number;
  volume24h: number;
  marketCap: number;
  fullyDilutedMarketCap: number;
  liquidity: number;
  holders: number;
  priceHistory: PricePoint[];
  volumeHistory: VolumePoint[];
}
```

#### TokenListPage Component
```typescript
interface TokenListPageProps {
  initialTokens?: TokenListItem[];
  filters?: TokenFilters;
  sortBy?: TokenSortOption;
}

interface TokenListItem {
  mint: string;
  name: string;
  symbol: string;
  image: string;
  price: number;
  priceChange24h: number;
  marketCap: number;
  volume24h: number;
  holders: number;
  verified: boolean;
  riskScore: number;
  communityRating: number;
  launchDate?: number;
}

interface TokenFilters {
  marketCapRange: [number, number];
  volumeRange: [number, number];
  priceRange: [number, number];
  categories: string[];
  verified: boolean;
  riskLevel: 'low' | 'medium' | 'high';
  launchDateRange?: [number, number];
}
```

### Security Analysis Components

#### SecurityAnalysisDisplay Component
```typescript
interface SecurityAnalysisDisplayProps {
  securityAnalysis: SecurityAnalysis;
  creatorAnalysis: CreatorAnalysis;
  bundlingAnalysis: BundlingAnalysis;
  onRiskClick: (riskType: string) => void;
}

interface SecurityAnalysis {
  riskScore: number; // 0-100
  riskLevel: 'low' | 'medium' | 'high' | 'critical';
  riskFactors: RiskFactor[];
  liquidityAnalysis: LiquidityAnalysis;
  contractVerification: ContractVerification;
  auditReports: AuditReport[];
}

interface CreatorAnalysis {
  creatorAddress: string;
  creatorRiskScore: number;
  previousTokens: PreviousToken[];
  rugPullConnections: RugPullConnection[];
  walletSeedAnalysis: WalletSeedAnalysis;
  reputationScore: number;
}

interface BundlingAnalysis {
  bundlingDetected: boolean;
  bundlingScore: number; // 0-100
  coordinatedWallets: CoordinatedWallet[];
  fundingPatterns: FundingPattern[];
  manipulationIndicators: ManipulationIndicator[];
}

interface WalletSeedAnalysis {
  seedingChain: SeedingStep[];
  finalSource: 'exchange' | 'validator' | 'unknown' | 'suspicious';
  riskLevel: 'low' | 'medium' | 'high';
  confidence: number;
}
```

### Community Features Components

#### TokenTrollbox Component
```typescript
interface TokenTrollboxProps {
  tokenMint: string;
  userWallet?: string;
  userHoldings?: number;
  totalSupply: number;
}

interface TrollboxMessage {
  id: string;
  content: string;
  timestamp: number;
  ownershipPercentage: number;
  messageType: 'message' | 'rating';
  sentiment?: 'positive' | 'negative' | 'neutral';
}

interface CommunityRating {
  totalRatings: number;
  positiveRatings: number;
  negativeRatings: number;
  weightedScore: number; // Weighted by ownership
  sentimentTrend: SentimentPoint[];
  topHolderSentiment: number;
}
```

#### CommunityRatingSystem Component
```typescript
interface CommunityRatingSystemProps {
  tokenMint: string;
  userHoldings: number;
  totalSupply: number;
  currentRating: CommunityRating;
  onRatingSubmit: (rating: 'like' | 'dislike') => void;
}

interface RatingWeight {
  userId: string;
  ownershipPercentage: number;
  rating: 'like' | 'dislike';
  timestamp: number;
  weight: number; // Calculated based on ownership
}
```

### Portfolio and Trading Components

#### PortfolioTracker Component
```typescript
interface PortfolioTrackerProps {
  walletAddress: string;
  tokens: PortfolioToken[];
  totalValue: number;
  totalPnL: number;
}

interface PortfolioToken {
  mint: string;
  symbol: string;
  name: string;
  balance: number;
  currentPrice: number;
  averageCostBasis: number;
  unrealizedPnL: number;
  realizedPnL: number;
  allocation: number; // Percentage of portfolio
  priceChange24h: number;
  transactions: PortfolioTransaction[];
}

interface PortfolioTransaction {
  signature: string;
  type: 'buy' | 'sell' | 'transfer_in' | 'transfer_out';
  amount: number;
  price: number;
  timestamp: number;
  fees: number;
}
```

#### TradingInterface Component
```typescript
interface TradingInterfaceProps {
  tokenMint: string;
  tokenData: TokenData;
  userWallet?: string;
  onTradeExecute: (trade: TradeOrder) => void;
}

interface TradeOrder {
  type: 'market' | 'limit' | 'stop_loss' | 'dca';
  side: 'buy' | 'sell';
  amount: number;
  price?: number; // For limit orders
  stopPrice?: number; // For stop loss
  slippage: number;
  dexRoute: DexRoute;
}

interface DexRoute {
  dex: string;
  route: RouteStep[];
  priceImpact: number;
  estimatedOutput: number;
  fees: number;
  executionTime: number;
}
```

### AI and Analytics Components

#### AIInsightsPanel Component
```typescript
interface AIInsightsPanelProps {
  tokenMint: string;
  insights: AIInsights;
  onPredictionRequest: () => void;
}

interface AIInsights {
  pricePrediction: PricePrediction;
  sentimentAnalysis: SentimentAnalysis;
  technicalAnalysis: TechnicalAnalysis;
  riskAssessment: AIRiskAssessment;
  tradingSignals: TradingSignal[];
  marketPatterns: MarketPattern[];
}

interface PricePrediction {
  timeframes: {
    '1h': PredictionPoint;
    '24h': PredictionPoint;
    '7d': PredictionPoint;
    '30d': PredictionPoint;
  };
  confidence: number;
  factors: PredictionFactor[];
  historicalAccuracy: number;
}

interface TradingSignal {
  type: 'buy' | 'sell' | 'hold';
  strength: number; // 0-100
  confidence: number; // 0-100
  reasoning: string;
  targetPrice?: number;
  stopLoss?: number;
  timeframe: string;
}
```

### Gamification Components

#### UserProgressPanel Component
```typescript
interface UserProgressPanelProps {
  userStats: UserStats;
  achievements: Achievement[];
  leaderboard: LeaderboardEntry[];
}

interface UserStats {
  level: number;
  points: number;
  pointsToNextLevel: number;
  rank: number;
  badges: Badge[];
  streaks: Streak[];
  contributions: Contribution[];
}

interface Achievement {
  id: string;
  name: string;
  description: string;
  icon: string;
  points: number;
  unlocked: boolean;
  unlockedAt?: number;
  progress: number; // 0-100
  requirements: AchievementRequirement[];
}

interface LeaderboardEntry {
  rank: number;
  userId: string;
  displayName: string;
  points: number;
  level: number;
  badges: Badge[];
  specialization: string; // 'analyst', 'trader', 'community'
}
```

## Data Models

### Token Data Models
```typescript
interface TokenSupply {
  total: number;
  circulating: number;
  burned: number;
  locked: number;
  inflation: number;
  deflation: number;
}

interface TokenStatistics {
  transferCount24h: number;
  uniqueHolders: number;
  averageHoldingTime: number;
  concentrationRatio: number;
  liquidityScore: number;
  velocityScore: number;
  utilityScore: number;
  ageInDays: number;
  volatility: VolatilityMetrics;
}

interface VolatilityMetrics {
  daily: number;
  weekly: number;
  monthly: number;
  annualized: number;
  beta: number; // vs SOL or market index
}
```

### Security Data Models
```typescript
interface RiskFactor {
  type: 'liquidity' | 'concentration' | 'creator' | 'bundling' | 'contract';
  severity: 'low' | 'medium' | 'high' | 'critical';
  score: number; // 0-100
  description: string;
  evidence: Evidence[];
  mitigation?: string;
}

interface RugPullConnection {
  connectedToken: string;
  connectionType: 'same_creator' | 'funding_source' | 'wallet_cluster';
  confidence: number;
  rugPullDate: number;
  lossAmount: number;
  evidence: string[];
}

interface CoordinatedWallet {
  address: string;
  fundingSource: string;
  purchaseAmount: number;
  purchaseTime: number;
  clusterScore: number; // How closely related to other wallets
  suspiciousPatterns: string[];
}
```

### Community Data Models
```typescript
interface CommunityData {
  trollboxMessages: TrollboxMessage[];
  ratings: CommunityRating;
  socialMetrics: SocialMetrics;
  communityHealth: CommunityHealth;
}

interface SocialMetrics {
  twitterFollowers: number;
  discordMembers: number;
  telegramMembers: number;
  socialGrowth24h: number;
  mentionCount: number;
  sentimentScore: number;
  influencerMentions: InfluencerMention[];
}

interface CommunityHealth {
  activityLevel: 'low' | 'medium' | 'high';
  engagementRate: number;
  toxicityScore: number;
  moderationNeeded: boolean;
  communitySize: 'small' | 'medium' | 'large';
  growthTrend: 'declining' | 'stable' | 'growing';
}
```

## Qdrant Integration Design

### Vector Collections Structure

```typescript
interface QdrantCollections {
  tokens: 'token_vectors';
  security_patterns: 'security_vectors';
  user_behavior: 'user_vectors';
  market_patterns: 'market_vectors';
  community_sentiment: 'sentiment_vectors';
}

interface TokenVector {
  id: string; // token mint
  vector: number[]; // 512-dimensional embedding
  payload: {
    mint: string;
    symbol: string;
    marketCap: number;
    volume24h: number;
    holderCount: number;
    riskScore: number;
    category: string;
    launchDate: number;
    creatorRisk: number;
    bundlingScore: number;
    communityRating: number;
    liquidityScore: number;
    volatility: number;
    utilityScore: number;
  };
}

interface SecurityVector {
  id: string; // unique security pattern id
  vector: number[]; // Security pattern embedding
  payload: {
    patternType: 'rug_pull' | 'bundling' | 'wash_trading' | 'pump_dump';
    severity: number;
    tokenMint: string;
    creatorAddress: string;
    evidence: string[];
    confidence: number;
    detectedAt: number;
  };
}
```

### Vector Search Operations

```typescript
class TokenVectorService {
  async findSimilarTokens(tokenMint: string, limit: number = 10): Promise<SimilarToken[]> {
    const tokenVector = await this.getTokenVector(tokenMint);
    
    const searchResult = await this.qdrantClient.search('token_vectors', {
      vector: tokenVector.vector,
      limit,
      filter: {
        must_not: [{ key: 'mint', match: { value: tokenMint } }]
      }
    });
    
    return searchResult.map(result => ({
      mint: result.payload.mint,
      similarity: result.score,
      reason: this.calculateSimilarityReason(tokenVector.payload, result.payload)
    }));
  }

  async detectSecurityPatterns(tokenMint: string): Promise<SecurityPattern[]> {
    const tokenData = await this.getTokenAnalytics(tokenMint);
    const securityVector = await this.generateSecurityVector(tokenData);
    
    const searchResult = await this.qdrantClient.search('security_vectors', {
      vector: securityVector,
      limit: 50,
      score_threshold: 0.8
    });
    
    return searchResult.map(result => ({
      patternType: result.payload.patternType,
      confidence: result.score,
      evidence: result.payload.evidence,
      severity: result.payload.severity
    }));
  }
}
```

## Error Handling

### Error Types and Recovery

```typescript
enum TokenExplorerErrorType {
  INVALID_MINT = 'INVALID_MINT',
  TOKEN_NOT_FOUND = 'TOKEN_NOT_FOUND',
  MARKET_DATA_ERROR = 'MARKET_DATA_ERROR',
  SECURITY_ANALYSIS_ERROR = 'SECURITY_ANALYSIS_ERROR',
  COMMUNITY_ERROR = 'COMMUNITY_ERROR',
  TRADING_ERROR = 'TRADING_ERROR',
  AI_SERVICE_ERROR = 'AI_SERVICE_ERROR',
  QDRANT_ERROR = 'QDRANT_ERROR'
}

class TokenErrorHandler {
  static handleMintError(mint: string): TokenExplorerError {
    if (!this.isValidMint(mint)) {
      return {
        type: TokenExplorerErrorType.INVALID_MINT,
        message: `Invalid token mint address: ${mint}`,
        retryable: false,
        suggestions: ['Check the mint address format', 'Search by token symbol instead']
      };
    }
  }

  static handleSecurityAnalysisError(error: any): TokenExplorerError {
    return {
      type: TokenExplorerErrorType.SECURITY_ANALYSIS_ERROR,
      message: 'Security analysis temporarily unavailable',
      retryable: true,
      retryAfter: 30000,
      fallback: 'basic_security_info'
    };
  }
}
```

## Testing Strategy

### Unit Testing Approach

```typescript
describe('TokenAnalyzer', () => {
  describe('analyzeTokenSecurity', () => {
    it('should detect rug pull patterns correctly', async () => {
      const mockTokenData = createMockTokenWithRugPullPatterns();
      const result = await TokenAnalyzer.analyzeTokenSecurity(mockTokenData);
      
      expect(result.riskLevel).toBe('high');
      expect(result.riskFactors).toContainEqual(
        expect.objectContaining({ type: 'creator', severity: 'high' })
      );
    });

    it('should identify bundling patterns', async () => {
      const mockTokenData = createMockTokenWithBundling();
      const result = await TokenAnalyzer.analyzeTokenSecurity(mockTokenData);
      
      expect(result.bundlingAnalysis.bundlingDetected).toBe(true);
      expect(result.bundlingAnalysis.bundlingScore).toBeGreaterThan(70);
    });
  });

  describe('findSimilarTokens', () => {
    it('should find tokens with similar characteristics', async () => {
      const mockToken = createMockToken();
      const result = await TokenAnalyzer.findSimilarTokens(mockToken.mint);
      
      expect(result).toHaveLength(10);
      expect(result[0].similarity).toBeGreaterThan(0.8);
    });
  });
});
```

### Integration Testing Strategy

1. **API Integration Tests**: Test all token-related endpoints
2. **Qdrant Integration Tests**: Test vector search and storage
3. **Security Analysis Tests**: Test rug pull and bundling detection
4. **Community Feature Tests**: Test trollbox and rating system
5. **Trading Integration Tests**: Test DEX aggregation and execution
6. **AI Service Tests**: Test prediction and insight generation

## Performance Optimization

### Caching Strategy

```typescript
interface TokenCacheConfig {
  tokenMetadata: {
    ttl: 3600000; // 1 hour
    strategy: 'background-refresh';
  };
  marketData: {
    ttl: 30000; // 30 seconds
    strategy: 'real-time-update';
  };
  securityAnalysis: {
    ttl: 1800000; // 30 minutes
    strategy: 'lazy-refresh';
  };
  communityData: {
    ttl: 60000; // 1 minute
    strategy: 'real-time-update';
  };
  aiInsights: {
    ttl: 900000; // 15 minutes
    strategy: 'background-refresh';
  };
}

class TokenCacheManager {
  async getTokenData(mint: string): Promise<TokenData> {
    const cacheKey = `token:${mint}`;
    const cached = await this.redis.get(cacheKey);
    
    if (cached) {
      // Trigger background refresh if needed
      this.backgroundRefresh(mint);
      return JSON.parse(cached);
    }
    
    const data = await this.fetchTokenData(mint);
    await this.redis.setex(cacheKey, 3600, JSON.stringify(data));
    
    return data;
  }
}
```

### Real-time Updates

```typescript
class TokenRealtimeManager {
  private wsConnections = new Map<string, WebSocket[]>();
  
  subscribeToToken(tokenMint: string, ws: WebSocket) {
    if (!this.wsConnections.has(tokenMint)) {
      this.wsConnections.set(tokenMint, []);
    }
    this.wsConnections.get(tokenMint)!.push(ws);
    
    // Start real-time data stream for this token
    this.startTokenStream(tokenMint);
  }
  
  broadcastTokenUpdate(tokenMint: string, update: TokenUpdate) {
    const connections = this.wsConnections.get(tokenMint) || [];
    
    connections.forEach(ws => {
      if (ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
          type: 'token_update',
          mint: tokenMint,
          data: update
        }));
      }
    });
  }
}
```

## Security Considerations

### Data Privacy and Protection

1. **User Privacy**: Hash wallet addresses in community features
2. **Trading Security**: Secure wallet connections and transaction signing
3. **API Security**: Rate limiting and authentication for sensitive endpoints
4. **Data Encryption**: Encrypt sensitive user data and preferences
5. **Audit Trails**: Log all security-related operations

### AI Model Security

```typescript
class AISecurityManager {
  static validatePredictionInput(input: any): boolean {
    // Validate input to prevent prompt injection
    return this.sanitizeInput(input) && this.checkInputLimits(input);
  }
  
  static filterPredictionOutput(output: any): any {
    // Filter AI output to prevent harmful content
    return this.sanitizeOutput(output);
  }
  
  static trackModelPerformance(predictions: Prediction[]): void {
    // Track accuracy and detect model drift
    this.updateModelMetrics(predictions);
  }
}
```

## Monitoring and Analytics

### Performance Monitoring

1. **Page Load Times**: Track token page performance
2. **API Response Times**: Monitor all token-related endpoints
3. **Qdrant Performance**: Track vector search response times
4. **AI Service Performance**: Monitor prediction generation times
5. **Trading Execution**: Track trade execution success rates

### User Analytics

1. **Feature Usage**: Track which features are most used
2. **User Journey**: Analyze how users navigate token pages
3. **Engagement Metrics**: Measure time spent and interactions
4. **Conversion Tracking**: Track portfolio additions and trades
5. **Community Participation**: Monitor trollbox and rating activity

This comprehensive design provides a robust foundation for implementing the token explorer enhancements with advanced security analysis, community features, AI insights, and integrated trading capabilities.# Token Explorer Enhancements Requirements

## Introduction

This specification defines the requirements for enhancing the token explorer functionality in OpenSVM, covering individual token details, token market data, holder analysis, and trading insights. The token explorer is essential for users to understand token ecosystems, track market movements, and analyze token distribution patterns on Solana.

## Requirements

### Requirement 1: Individual Token Detail Page

**User Story:** As a token investor, I want to view comprehensive information about a specific token, so that I can make informed investment decisions and understand token fundamentals.

#### Acceptance Criteria

1. WHEN a user navigates to `/token/[mint]` with a valid mint address THEN the system SHALL display comprehensive token information including metadata, supply data, market metrics, holder analysis, and transfer history
2. WHEN a user provides an invalid mint address THEN the system SHALL display a 404 error page with suggestions for valid token searches
3. WHEN token data is loading THEN the system SHALL show progressive loading states for different sections (metadata, market data, holders, transfers)
4. WHEN token metadata is unavailable THEN the system SHALL show fallback information using mint address and on-chain data
5. WHEN a user views token details THEN the system SHALL provide links to related tokens and trading pairs
6. WHEN market data is displayed THEN the system SHALL show real-time price updates and historical charts
7. WHEN holder information is shown THEN the system SHALL display top holders and distribution analysis
8. WHEN transfer history is displayed THEN the system SHALL provide filtering and search capabilities

### Requirement 2: Token Market Data Integration

**User Story:** As a trader, I want to see real-time market data and price charts for tokens, so that I can track price movements and make trading decisions.

#### Acceptance Criteria

1. WHEN viewing a token page THEN the system SHALL display current price, 24h change, market cap, volume, and liquidity metrics
2. WHEN market data updates THEN the system SHALL refresh prices in real-time without page reload
3. WHEN price charts are displayed THEN the system SHALL support multiple timeframes (1h, 24h, 7d, 30d, 1y)
4. WHEN volume data is shown THEN the system SHALL display trading volume trends and patterns
5. WHEN market cap is calculated THEN the system SHALL use accurate circulating supply data
6. WHEN liquidity metrics are displayed THEN the system SHALL show DEX liquidity and trading pair information
7. WHEN price alerts are configured THEN the system SHALL notify users of significant price movements
8. WHEN market data is unavailable THEN the system SHALL show appropriate fallback messages and retry options

### Requirement 3: Token Holder Analysis

**User Story:** As a token analyst, I want to analyze token holder distribution and whale activity, so that I can understand token concentration and market dynamics.

#### Acceptance Criteria

1. WHEN viewing token holders THEN the system SHALL display top 100 holders with addresses, balances, and ownership percentages
2. WHEN holder distribution is analyzed THEN the system SHALL show concentration metrics and Gini coefficient
3. WHEN whale activity is tracked THEN the system SHALL identify large holders and their recent transactions
4. WHEN new holders are detected THEN the system SHALL show holder growth metrics and acquisition patterns
5. WHEN holder retention is analyzed THEN the system SHALL calculate average holding time and turnover rates
6. WHEN holder addresses are clicked THEN the system SHALL navigate to account detail pages
7. WHEN holder data is exported THEN the system SHALL provide CSV/JSON export functionality
8. WHEN holder privacy is considered THEN the system SHALL respect user privacy preferences and anonymization requests

### Requirement 4: Token Transfer History and Analysis

**User Story:** As a compliance officer, I want to track token transfers and analyze transaction patterns, so that I can monitor for suspicious activity and ensure regulatory compliance.

#### Acceptance Criteria

1. WHEN viewing transfer history THEN the system SHALL display recent transfers with sender, receiver, amount, and timestamp
2. WHEN transfers are filtered THEN the system SHALL support filtering by amount range, date range, and address
3. WHEN large transfers are detected THEN the system SHALL highlight significant movements and whale activity
4. WHEN transfer patterns are analyzed THEN the system SHALL identify unusual activity and potential wash trading
5. WHEN transfer data is searched THEN the system SHALL support search by transaction signature and addresses
6. WHEN transfers are exported THEN the system SHALL provide detailed export with all transaction metadata
7. WHEN real-time transfers occur THEN the system SHALL update the transfer list with live data
8. WHEN transfer analysis is performed THEN the system SHALL calculate velocity metrics and circulation patterns

### Requirement 5: Token Statistics and Metrics

**User Story:** As a DeFi researcher, I want to see comprehensive token statistics and derived metrics, so that I can analyze token health and ecosystem participation.

#### Acceptance Criteria

1. WHEN token statistics are displayed THEN the system SHALL show supply metrics (total, circulating, burned, locked)
2. WHEN circulation metrics are calculated THEN the system SHALL display velocity, turnover rate, and active addresses
3. WHEN token utility is analyzed THEN the system SHALL show program interactions and use cases
4. WHEN token age is considered THEN the system SHALL display creation date, age, and lifecycle metrics
5. WHEN token performance is measured THEN the system SHALL calculate price performance over multiple timeframes
6. WHEN token correlation is analyzed THEN the system SHALL show correlation with other tokens and market indices
7. WHEN token risk is assessed THEN the system SHALL provide risk scores and volatility metrics
8. WHEN token fundamentals are evaluated THEN the system SHALL show developer activity and community metrics

### Requirement 6: Token List and Market Overview

**User Story:** As a market observer, I want to browse all tokens with market data and filtering options, so that I can discover new tokens and track market trends.

#### Acceptance Criteria

1. WHEN visiting `/tokens` THEN the system SHALL display a comprehensive list of tokens with market data
2. WHEN token list is sorted THEN the system SHALL support sorting by market cap, volume, price change, and holders
3. WHEN tokens are filtered THEN the system SHALL provide filters for market cap range, volume, and token categories
4. WHEN token search is used THEN the system SHALL support search by name, symbol, and mint address
5. WHEN market overview is displayed THEN the system SHALL show total market statistics and trends
6. WHEN token categories are shown THEN the system SHALL group tokens by type (DeFi, gaming, NFT, etc.)
7. WHEN new tokens are highlighted THEN the system SHALL show recently launched tokens with launch metrics
8. WHEN token list is exported THEN the system SHALL provide export functionality with current market data

### Requirement 7: Token Gainers and Losers Tracking

**User Story:** As a momentum trader, I want to see top gaining and losing tokens across different timeframes, so that I can identify trading opportunities and market trends.

#### Acceptance Criteria

1. WHEN visiting `/tokens/gainers` THEN the system SHALL display top performing tokens by price change
2. WHEN timeframes are selected THEN the system SHALL support 1h, 24h, 7d, and 30d performance analysis
3. WHEN gainers are ranked THEN the system SHALL sort by percentage change with volume weighting
4. WHEN losers are displayed THEN the system SHALL show worst performing tokens with context
5. WHEN performance metrics are calculated THEN the system SHALL include volume-adjusted returns
6. WHEN alerts are configured THEN the system SHALL notify users of significant movers
7. WHEN historical gainers are tracked THEN the system SHALL show past performance leaders
8. WHEN gainer analysis is performed THEN the system SHALL identify patterns and catalysts for price movements

### Requirement 8: New Token Discovery and Launch Tracking

**User Story:** As an early investor, I want to discover newly launched tokens and track their early performance, so that I can identify investment opportunities and assess launch success.

#### Acceptance Criteria

1. WHEN visiting `/tokens/new` THEN the system SHALL display recently launched tokens with launch metrics
2. WHEN launch performance is tracked THEN the system SHALL show price change from launch and initial metrics
3. WHEN launch quality is assessed THEN the system SHALL provide verification status and risk indicators
4. WHEN liquidity is analyzed THEN the system SHALL show initial and current liquidity levels
5. WHEN early adoption is measured THEN the system SHALL track holder growth and distribution
6. WHEN launch calendar is displayed THEN the system SHALL show upcoming token launches and schedules
7. WHEN launch alerts are configured THEN the system SHALL notify users of new token launches
8. WHEN launch analysis is performed THEN the system SHALL identify successful launch patterns and red flags

### Requirement 9: Token Social Media and Community Integration

**User Story:** As a community member, I want to see token social media activity and community metrics, so that I can gauge community sentiment and engagement.

#### Acceptance Criteria

1. WHEN token social links are displayed THEN the system SHALL show official website, Twitter, Discord, and Telegram links
2. WHEN social metrics are tracked THEN the system SHALL display follower counts and engagement rates
3. WHEN community activity is measured THEN the system SHALL show discussion volume and sentiment analysis
4. WHEN social sentiment is analyzed THEN the system SHALL provide sentiment scores and trend indicators
5. WHEN community growth is tracked THEN the system SHALL show follower growth and engagement trends
6. WHEN social alerts are configured THEN the system SHALL notify users of significant social activity
7. WHEN community health is assessed THEN the system SHALL provide community health scores and metrics
8. WHEN social data is integrated THEN the system SHALL correlate social activity with price movements

### Requirement 10: Token Holder Trollbox and Community Rating

**User Story:** As a token holder, I want to participate in anonymous community discussions and rate the token with other holders, so that I can share insights and gauge community sentiment without revealing my wallet address.

#### Acceptance Criteria

1. WHEN accessing the trollbox THEN the system SHALL verify user holds the token before allowing message posting and rating
2. WHEN messages are displayed THEN the system SHALL show the user's ownership percentage (~X% of total supply) instead of wallet address
3. WHEN ownership percentage is calculated THEN the system SHALL update in real-time based on current token holdings
4. WHEN messages are posted THEN the system SHALL implement rate limiting based on ownership percentage (higher holders get more frequent posting)
5. WHEN community rating is performed THEN the system SHALL allow token holders to like/dislike the token with voting weight based on ownership percentage
6. WHEN rating results are displayed THEN the system SHALL show aggregated sentiment scores and holder sentiment distribution
7. WHEN rating history is tracked THEN the system SHALL maintain historical sentiment trends and correlate with price movements
8. WHEN message moderation is applied THEN the system SHALL implement community-based moderation and spam filtering
9. WHEN message history is maintained THEN the system SHALL store messages with timestamps and ownership snapshots
10. WHEN trollbox privacy is protected THEN the system SHALL ensure wallet addresses are never revealed in the chat interface
11. WHEN ownership verification is performed THEN the system SHALL re-verify token holdings periodically to maintain access rights
12. WHEN rating manipulation is prevented THEN the system SHALL detect and prevent coordinated rating attacks and bot activity

### Requirement 11: Token Price Alerts and Watchlists

**User Story:** As an active trader, I want to set price alerts and maintain watchlists for tokens, so that I can monitor my investments and react to market opportunities.

#### Acceptance Criteria

1. WHEN price alerts are created THEN the system SHALL support alerts for price thresholds, percentage changes, and volume spikes
2. WHEN watchlists are managed THEN the system SHALL allow users to add/remove tokens and organize by categories
3. WHEN alerts are triggered THEN the system SHALL send notifications via email, browser notifications, or webhooks
4. WHEN watchlist performance is tracked THEN the system SHALL show portfolio-style performance metrics
5. WHEN alert history is maintained THEN the system SHALL provide logs of triggered alerts and user actions
6. WHEN alert conditions are configured THEN the system SHALL support complex conditions and combinations
7. WHEN watchlist sharing is enabled THEN the system SHALL allow users to share watchlists with others
8. WHEN alert management is provided THEN the system SHALL offer bulk operations and alert templates

### Requirement 12: Token Comparison and Analysis Tools

**User Story:** As a token analyst, I want to compare multiple tokens side-by-side and analyze their relative performance, so that I can make informed investment decisions.

#### Acceptance Criteria

1. WHEN tokens are compared THEN the system SHALL display side-by-side metrics for up to 5 tokens
2. WHEN comparison metrics are shown THEN the system SHALL include market data, holder metrics, and performance data
3. WHEN relative performance is analyzed THEN the system SHALL show correlation analysis and beta calculations
4. WHEN comparison charts are displayed THEN the system SHALL overlay price charts and volume data
5. WHEN fundamental comparison is performed THEN the system SHALL compare supply metrics and tokenomics
6. WHEN comparison results are exported THEN the system SHALL provide detailed comparison reports
7. WHEN comparison templates are used THEN the system SHALL offer pre-configured comparison sets
8. WHEN comparison insights are generated THEN the system SHALL highlight key differences and similarities

### Requirement 12: Token API and Data Export

**User Story:** As a developer, I want to access token data programmatically and export data for analysis, so that I can build applications and perform custom analysis.

#### Acceptance Criteria

1. WHEN API endpoints are accessed THEN the system SHALL provide RESTful APIs for all token data
2. WHEN data is exported THEN the system SHALL support CSV, JSON, and Excel formats
3. WHEN API authentication is required THEN the system SHALL provide API key management
4. WHEN rate limiting is applied THEN the system SHALL implement fair usage policies
5. WHEN real-time data is accessed THEN the system SHALL provide WebSocket APIs for live updates
6. WHEN historical data is requested THEN the system SHALL support time-series data export
7. WHEN API documentation is provided THEN the system SHALL offer comprehensive API documentation
8. WHEN API monitoring is implemented THEN the system SHALL track usage and provide analytics

### Requirement 13: Token Security and Risk Assessment

**User Story:** As a security-conscious investor, I want to see security assessments and risk indicators for tokens, so that I can avoid scams and make safer investment decisions.

#### Acceptance Criteria

1. WHEN security analysis is performed THEN the system SHALL check for common scam patterns and red flags
2. WHEN contract verification is checked THEN the system SHALL verify token contract authenticity
3. WHEN liquidity risks are assessed THEN the system SHALL analyze liquidity depth and concentration
4. WHEN holder risks are evaluated THEN the system SHALL identify potential rug pull indicators
5. WHEN audit information is available THEN the system SHALL display security audit results
6. WHEN risk scores are calculated THEN the system SHALL provide comprehensive risk ratings
7. WHEN security alerts are configured THEN the system SHALL notify users of security concerns
8. WHEN risk education is provided THEN the system SHALL offer educational content about token risks

### Requirement 14: Token Creator Analysis and Rug Pull Detection

**User Story:** As a security researcher, I want to analyze token creators and their wallet history to identify potential rug pull risks, so that I can warn users about dangerous tokens.

#### Acceptance Criteria

1. WHEN token creator is analyzed THEN the system SHALL identify the wallet that created/minted the token
2. WHEN creator wallet history is traced THEN the system SHALL analyze the creator's transaction history and previous token creations
3. WHEN rug pull connections are checked THEN the system SHALL identify if the creator wallet is connected to previous rug pulls or scam tokens
4. WHEN wallet seeder analysis is performed THEN the system SHALL trace funding sources back through the chain until reaching exchanges or validators
5. WHEN creator risk assessment is calculated THEN the system SHALL provide risk scores based on creator's history and connections
6. WHEN previous token performance is analyzed THEN the system SHALL show performance of other tokens created by the same entity
7. WHEN creator reputation is displayed THEN the system SHALL show creator's track record and community feedback
8. WHEN creator alerts are configured THEN the system SHALL notify users when tokens are created by flagged addresses

### Requirement 15: Token Bundling and Manipulation Detection

**User Story:** As a market analyst, I want to detect token bundling and coordinated buying patterns, so that I can identify artificially inflated tokens and market manipulation.

#### Acceptance Criteria

1. WHEN bundling analysis is performed THEN the system SHALL identify wallets that purchased tokens from the same funding source
2. WHEN coordinated buying is detected THEN the system SHALL identify purchases made in the same time period by related wallets
3. WHEN wallet clustering is analyzed THEN the system SHALL group wallets based on funding patterns and transaction timing
4. WHEN manipulation patterns are identified THEN the system SHALL detect wash trading and artificial volume inflation
5. WHEN bundle risk scores are calculated THEN the system SHALL provide manipulation risk ratings based on detected patterns
6. WHEN natural vs artificial demand is assessed THEN the system SHALL distinguish between organic growth and coordinated activity
7. WHEN bundling alerts are configured THEN the system SHALL notify users of detected manipulation patterns
8. WHEN bundling evidence is displayed THEN the system SHALL show visual representations of wallet connections and funding flows

### Requirement 16: Similar Tokens and Recommendation System

**User Story:** As a token explorer, I want to discover similar tokens and receive recommendations based on my interests, so that I can find related investment opportunities.

#### Acceptance Criteria

1. WHEN similar tokens are displayed THEN the system SHALL show tokens with similar characteristics (market cap, sector, performance)
2. WHEN token similarity is calculated THEN the system SHALL use multiple factors including price correlation, holder overlap, and use case similarity
3. WHEN recommendations are provided THEN the system SHALL suggest tokens based on user viewing history and preferences
4. WHEN token categories are analyzed THEN the system SHALL group tokens by sector, use case, and ecosystem participation
5. WHEN correlation analysis is performed THEN the system SHALL show price and volume correlations with other tokens
6. WHEN ecosystem connections are mapped THEN the system SHALL identify tokens used in similar protocols or applications
7. WHEN recommendation quality is measured THEN the system SHALL track user engagement with recommended tokens
8. WHEN personalized suggestions are offered THEN the system SHALL adapt recommendations based on user behavior and preferences

### Requirement 17: Data Storage and Vector Search Integration

**User Story:** As a system architect, I want all processed token analytics data to be stored in Qdrant for efficient vector search and similarity analysis, so that the system can provide fast recommendations and complex queries.

#### Acceptance Criteria

1. WHEN token analytics are processed THEN the system SHALL store all processed data (holder analysis, transfer patterns, security scores, creator analysis) in Qdrant collections
2. WHEN token similarity is calculated THEN the system SHALL use Qdrant vector embeddings to find similar tokens based on multiple characteristics
3. WHEN bundling detection is performed THEN the system SHALL store wallet clustering data and funding patterns as vectors in Qdrant
4. WHEN creator risk analysis is completed THEN the system SHALL store creator profiles and risk indicators in Qdrant for fast lookup
5. WHEN token recommendations are generated THEN the system SHALL use Qdrant similarity search to find related tokens
6. WHEN security analysis is performed THEN the system SHALL store risk patterns and scam indicators as searchable vectors
7. WHEN data is queried THEN the system SHALL use Qdrant's filtering and search capabilities for complex analytics queries
8. WHEN data is updated THEN the system SHALL maintain data consistency between Qdrant and other storage systems

### Requirement 18: Performance Optimization and Caching

**User Story:** As a system administrator, I want the token explorer to perform efficiently under high load, so that users experience fast response times and reliable service.

#### Acceptance Criteria

1. WHEN token data is cached THEN the system SHALL implement appropriate caching strategies for different data types
2. WHEN real-time updates are provided THEN the system SHALL optimize for minimal latency and resource usage
3. WHEN large datasets are handled THEN the system SHALL implement pagination and virtual scrolling
4. WHEN API responses are optimized THEN the system SHALL minimize response sizes and implement compression
5. WHEN database queries are executed THEN the system SHALL use efficient indexing and query optimization
6. WHEN CDN is utilized THEN the system SHALL cache static assets and optimize global delivery
7. WHEN performance monitoring is implemented THEN the system SHALL track response times and system health
8. WHEN scaling is required THEN the system SHALL support horizontal scaling and load balancing

### Requirement 19: Token Portfolio Tracking and PnL Analysis

**User Story:** As an investor, I want to track my token portfolio performance and see detailed PnL analysis, so that I can monitor my investments and make informed decisions.

#### Acceptance Criteria

1. WHEN connecting wallet THEN the system SHALL automatically detect and track all token holdings
2. WHEN portfolio is displayed THEN the system SHALL show current value, cost basis, unrealized PnL, and percentage allocation
3. WHEN PnL is calculated THEN the system SHALL track realized gains/losses from all transactions
4. WHEN portfolio performance is analyzed THEN the system SHALL show performance vs market benchmarks and indices
5. WHEN tax reporting is needed THEN the system SHALL generate tax reports with detailed transaction history
6. WHEN portfolio alerts are configured THEN the system SHALL notify users of significant portfolio changes
7. WHEN portfolio sharing is enabled THEN the system SHALL allow users to share portfolio performance (with privacy controls)
8. WHEN portfolio analytics are provided THEN the system SHALL show diversification metrics and risk analysis

### Requirement 20: Token Prediction and AI Insights

**User Story:** As a trader, I want to see AI-powered predictions and insights about token performance, so that I can make more informed trading decisions.

#### Acceptance Criteria

1. WHEN AI analysis is performed THEN the system SHALL provide price prediction models based on historical data and market indicators
2. WHEN sentiment analysis is conducted THEN the system SHALL analyze social media, news, and community sentiment for price impact
3. WHEN technical analysis is provided THEN the system SHALL show AI-generated support/resistance levels and trend analysis
4. WHEN market patterns are identified THEN the system SHALL detect and alert users to similar historical patterns
5. WHEN risk assessment is calculated THEN the system SHALL provide AI-powered risk scores and volatility predictions
6. WHEN trading signals are generated THEN the system SHALL provide buy/sell signals with confidence levels
7. WHEN AI insights are displayed THEN the system SHALL explain the reasoning behind predictions and recommendations
8. WHEN prediction accuracy is tracked THEN the system SHALL maintain performance metrics for AI models and improve over time

### Requirement 21: Gamification and User Engagement

**User Story:** As a platform user, I want to earn rewards and achievements for using the platform, so that I feel engaged and motivated to continue exploring tokens.

#### Acceptance Criteria

1. WHEN users interact with the platform THEN the system SHALL award points for various activities (viewing tokens, sharing insights, accurate predictions)
2. WHEN achievements are unlocked THEN the system SHALL provide badges for milestones (first token analysis, portfolio tracking, community participation)
3. WHEN leaderboards are displayed THEN the system SHALL show top users by points, prediction accuracy, and community contributions
4. WHEN rewards are distributed THEN the system SHALL offer token airdrops, premium features, or exclusive access as rewards
5. WHEN user levels are calculated THEN the system SHALL provide progression system with increasing benefits
6. WHEN challenges are created THEN the system SHALL offer weekly/monthly challenges for token discovery and analysis
7. WHEN social features are gamified THEN the system SHALL reward quality contributions to trollbox and community ratings
8. WHEN referral program is implemented THEN the system SHALL reward users for bringing new users to the platform

### Requirement 22: Token Launch Pad and Early Access Features

**User Story:** As an early investor, I want to discover and get early access to promising token launches before they hit major exchanges, so that I can maximize my investment opportunities.

#### Acceptance Criteria

1. WHEN token launches are tracked THEN the system SHALL monitor and list upcoming token launches with detailed project information
2. WHEN early access is provided THEN the system SHALL offer whitelist spots and early purchase opportunities for verified projects
3. WHEN launch quality is assessed THEN the system SHALL provide due diligence reports and risk assessments for upcoming launches
4. WHEN launch notifications are configured THEN the system SHALL alert users about launches matching their criteria and interests
5. WHEN launch performance is tracked THEN the system SHALL show post-launch performance metrics and early investor returns
6. WHEN launch calendar is displayed THEN the system SHALL provide comprehensive calendar with launch schedules and key dates
7. WHEN launch community is built THEN the system SHALL create dedicated spaces for discussing upcoming launches
8. WHEN launch analytics are provided THEN the system SHALL analyze successful launch patterns and provide insights

### Requirement 23: Advanced Trading Integration and DEX Aggregation

**User Story:** As a trader, I want to execute trades directly from the token explorer with best price discovery, so that I can act quickly on insights without leaving the platform.

#### Acceptance Criteria

1. WHEN trading is initiated THEN the system SHALL integrate with major DEX aggregators (Jupiter, Pumpfun, Bonkfun, Raydium) for best price execution
2. WHEN price comparison is shown THEN the system SHALL display prices across multiple DEXs and recommend optimal routes
3. WHEN trading interface is used THEN the system SHALL provide advanced order types (limit, stop-loss, DCA)
4. WHEN slippage is calculated THEN the system SHALL show real-time slippage estimates and price impact
5. WHEN trading history is tracked THEN the system SHALL maintain detailed trading logs and performance analytics
6. WHEN trading signals are integrated THEN the system SHALL allow one-click trading based on AI recommendations
7. WHEN MEV protection is provided THEN the system SHALL offer MEV-protected trading options
8. WHEN trading fees are optimized THEN the system SHALL find routes with lowest fees and best execution

### Requirement 24: Mobile Optimization and Accessibility

**User Story:** As a mobile user with accessibility needs, I want the token explorer to work seamlessly on mobile devices and with assistive technologies, so that I can access token information anywhere.

#### Acceptance Criteria

1. WHEN using mobile devices THEN the system SHALL provide responsive design optimized for touch interaction
2. WHEN accessibility features are used THEN the system SHALL support screen readers and keyboard navigation
3. WHEN mobile performance is optimized THEN the system SHALL minimize data usage and loading times
4. WHEN touch gestures are implemented THEN the system SHALL support swipe navigation and touch-friendly controls
5. WHEN offline functionality is provided THEN the system SHALL cache essential data for offline viewing
6. WHEN mobile-specific features are used THEN the system SHALL integrate with device capabilities (notifications, sharing)
7. WHEN accessibility standards are met THEN the system SHALL comply with WCAG 2.1 AA guidelines
8. WHEN mobile testing is performed THEN the system SHALL work across different devices and browsers# Token Explorer Enhancements Implementation Plan

- [ ] 1. Set up core token data infrastructure and Qdrant integration
  - Create token data types and interfaces for comprehensive token information
  - Implement Qdrant collections for token vectors, security patterns, and user behavior
  - Set up API endpoints for token fetching, analytics, and real-time updates
  - Configure caching layer with appropriate TTL strategies for different data types
  - _Requirements: 1.1, 17.1, 17.2, 18.1, 18.2_

- [ ] 1.1 Create token data models and TypeScript interfaces
  - Create `lib/types/token.types.ts` with comprehensive TokenData interface including mint, metadata, supply, marketData, holders[], transfers[], statistics, socialLinks, securityAnalysis, creatorAnalysis, bundlingAnalysis, similarTokens[], communityRating, aiInsights
  - Define TokenMetadata interface with name, symbol, decimals, description, image, creator, verified, tags[], createdAt, website, twitter, discord, telegram
  - Create TokenMarketData interface with price, priceChange24h, volume24h, marketCap, fullyDilutedMarketCap, liquidity, holders, priceHistory[], volumeHistory[]
  - Implement TokenSupply interface with total, circulating, burned, locked, inflation, deflation
  - Define TokenStatistics interface with transferCount24h, uniqueHolders, averageHoldingTime, concentrationRatio, liquidityScore, velocityScore, utilityScore, ageInDays, volatility metrics
  - Create SecurityAnalysis interface with riskScore, riskLevel, riskFactors[], liquidityAnalysis, contractVerification, auditReports[]
  - Implement CreatorAnalysis interface with creatorAddress, creatorRiskScore, previousTokens[], rugPullConnections[], walletSeedAnalysis, reputationScore
  - Add BundlingAnalysis interface with bundlingDetected, bundlingScore, coordinatedWallets[], fundingPatterns[], manipulationIndicators[]
  - Create CommunityRating interface with totalRatings, positiveRatings, negativeRatings, weightedScore, sentimentTrend[], topHolderSentiment
  - Define AIInsights interface with pricePrediction, sentimentAnalysis, technicalAnalysis, riskAssessment, tradingSignals[], marketPatterns[]
  - _Requirements: 1.1, 2.1, 3.1, 4.1, 5.1, 10.1, 13.1, 14.1, 15.1, 16.1, 19.1, 20.1_

- [ ] 1.2 Set up Qdrant vector database integration
  - Create `lib/qdrant/token-vectors.ts` with QdrantTokenService class implementing createCollections(), storeTokenVector(), searchSimilarTokens(), storeSecurityPattern(), searchSecurityPatterns() methods
  - Configure Qdrant collections: token_vectors (512-dim embeddings with payload: mint, symbol, marketCap, volume24h, holderCount, riskScore, category, launchDate, creatorRisk, bundlingScore, communityRating, liquidityScore, volatility, utilityScore), security_vectors (security pattern embeddings with patternType, severity, tokenMint, creatorAddress, evidence[], confidence, detectedAt), user_vectors (user behavior patterns), market_vectors (market pattern analysis), sentiment_vectors (community sentiment analysis)
  - Implement vector generation using OpenAI embeddings API for token characteristics, security patterns, and user behavior
  - Create vector search operations with filtering capabilities for similar token discovery, security pattern matching, and recommendation generation
  - Add vector upsert operations for real-time updates when token data changes
  - Implement vector similarity scoring and ranking algorithms for accurate recommendations
  - _Requirements: 17.1, 17.2, 17.3, 17.4, 17.5, 17.6, 17.7, 17.8_- [ ] 1.
3 Implement core token API endpoints
  - Create `app/api/token/[mint]/route.ts` with GET handler that validates mint parameter using base58 validation and length checking, fetches token metadata from Solana RPC using getAccountInfo() and getParsedAccountInfo(), processes token supply data using getTokenSupply(), implements error handling for invalid mints (return 404) and network errors (return 500 with retry headers)
  - Implement `app/api/tokens/route.ts` with GET handler supporting query parameters: limit (default 50, max 100), offset (for pagination), sortBy (marketCap, volume, priceChange, holders), filterBy (category, verified, riskLevel), search (name/symbol search), return TokenListItem[] with mint, name, symbol, image, price, priceChange24h, marketCap, volume24h, holders, verified, riskScore, communityRating, launchDate
  - Add `app/api/tokens/gainers/route.ts` supporting timeframe parameter (1h, 24h, 7d, 30d), return top gaining tokens sorted by percentage change with volume weighting
  - Create `app/api/tokens/new/route.ts` returning recently launched tokens (last 30 days) with launch metrics and performance data
  - Implement input validation using Zod schemas for all query parameters and path parameters
  - Add rate limiting using lib/rate-limiter.ts with different limits per endpoint (token detail: 200/min, token list: 500/min, gainers: 100/min)
  - _Requirements: 1.1, 6.1, 7.1, 8.1_

- [ ] 1.4 Set up token data caching system
  - Create `lib/cache/token-cache.ts` with TokenCacheManager class implementing get/set/invalidate methods for different data types, use Redis for production with Map<string, CacheEntry> fallback for development
  - Configure cache TTL strategies: token metadata = 1 hour (rarely changes), market data = 30 seconds (real-time updates), security analysis = 30 minutes (computationally expensive), community data = 1 minute (active discussions), AI insights = 15 minutes (model inference costs)
  - Implement cache key patterns: "token:{mint}", "token:market:{mint}", "token:security:{mint}", "token:community:{mint}", "token:ai:{mint}", "tokens:list:{params_hash}", "tokens:gainers:{timeframe}"
  - Add cache warming for popular tokens: pre-fetch and cache top 100 tokens by market cap on startup, implement background refresh job every 5 minutes for top tokens
  - Create cache metrics tracking: hit/miss rates, memory usage, eviction counts, expose via /api/cache/metrics endpoint for monitoring
  - Implement cache invalidation triggers: invalidate token cache when new transactions detected, invalidate market data on price updates, invalidate security analysis when new risk patterns detected
  - _Requirements: 18.1, 18.2, 18.3, 18.4_

- [ ] 2. Build token detail page with comprehensive information display
  - Create TokenDetailsPage component with metadata, market data, holder analysis, and security assessment
  - Implement progressive loading states and error handling for different data sections
  - Add real-time price updates and market data streaming
  - _Requirements: 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8_

- [ ] 2.1 Create TokenDetailsPage main component
  - Create `app/token/[mint]/page.tsx` as server component with generateMetadata() function for dynamic SEO, implement getTokenData() server function using fetch to /api/token/[mint], handle loading states with Suspense wrapper
  - Build responsive layout using CSS Grid: header section (token info + price), main content area with tabbed interface (Overview | Holders | Transfers | Security | Community | Trading), sidebar with similar tokens and AI insights
  - Implement tabbed navigation component in `components/TokenTabs.tsx` with URL synchronization, lazy loading of tab content, keyboard navigation support
  - Add error boundary wrapper using `components/TokenErrorBoundary.tsx` to catch and display token not found (404) or network errors, implement retry button that refetches data
  - Create loading skeleton components matching final layout structure, use React Suspense with fallback showing skeleton for each section
  - Implement URL parameter validation: parse mint from params, validate as base58 string with correct length, redirect invalid mints to /tokens with error message
  - _Requirements: 1.1, 1.2, 1.3_- 
[ ] 2.2 Implement token metadata and market data display
  - Create `components/TokenHeader.tsx` component displaying token logo, name, symbol, verified badge, price (with real-time updates), 24h change (with color coding), market cap, volume, and quick action buttons (trade, add to watchlist, share)
  - Build `components/TokenMarketData.tsx` component showing detailed market metrics: current price, 24h high/low, market cap (circulating and fully diluted), 24h volume, liquidity, holder count, price charts with multiple timeframes (1h, 24h, 7d, 30d, 1y)
  - Create `components/TokenSupplyInfo.tsx` displaying supply metrics: total supply, circulating supply, burned tokens, locked tokens, inflation/deflation rates with visual progress bars
  - Implement `components/TokenPriceChart.tsx` using recharts library with candlestick/line chart options, volume overlay, zoom/pan functionality, technical indicators (MA, RSI, MACD), export chart functionality
  - Add real-time price updates using WebSocket connection to price feed, implement price change animations and notifications, show last update timestamp
  - Create copy-to-clipboard functionality for mint address, contract address, and other identifiers using navigator.clipboard API with fallback
  - _Requirements: 1.1, 2.1, 2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8_

- [ ] 2.3 Build token holder analysis and distribution display
  - Create `components/TokenHolders.tsx` using @tanstack/react-table for virtual scrolling, implement columns: rank, address (truncated with copy button), balance (formatted with decimals), percentage of total supply, account type (wallet/program), last activity timestamp
  - Implement holder distribution visualization with `components/HolderDistributionChart.tsx` using recharts: pie chart showing top 10 holders vs others, concentration metrics (Gini coefficient, top 10/50/100 holder percentages), whale activity indicators
  - Add holder analysis metrics: unique holder count, average holding time, holder growth rate, turnover rate, new holders in last 24h/7d, holder retention analysis
  - Create `components/WhaleActivityTracker.tsx` showing large holder movements: recent large transfers, whale accumulation/distribution patterns, whale wallet labels and tracking
  - Implement holder search and filtering: filter by balance range, account type, activity level, sort by balance/percentage/activity, search by address
  - Add holder export functionality: CSV export with holder addresses, balances, percentages, timestamps, include privacy options for data export
  - _Requirements: 3.1, 3.2, 3.3, 3.4, 3.5, 3.6, 3.7, 3.8_

- [ ] 2.4 Build token transfer history and analysis display
  - Create `components/TokenTransfers.tsx` using virtual scrolling for large transfer lists, implement columns: timestamp (relative + absolute), from address (truncated), to address (truncated), amount (formatted), USD value (when available), transaction signature (clickable), transfer type (normal/program interaction)
  - Implement transfer filtering with `components/TransferFilters.tsx`: filter by amount range (min/max), date range picker, address search (sender/receiver), transfer type, sort by amount/time/USD value
  - Add large transfer detection and highlighting: identify transfers above certain thresholds (1%, 5%, 10% of daily volume), highlight whale movements with special styling, show transfer impact on price
  - Create transfer pattern analysis: detect unusual activity patterns, identify potential wash trading, calculate transfer velocity and circulation metrics, show transfer frequency charts
  - Implement real-time transfer updates: WebSocket connection for live transfer feed, show new transfers with animation, maintain scroll position during updates
  - Add transfer export functionality: CSV/JSON export with full transfer details, include transaction signatures and metadata, support date range filtering for exports
  - _Requirements: 4.1, 4.2, 4.3, 4.4, 4.5, 4.6, 4.7, 4.8_

- [ ] 3. Implement comprehensive security analysis and risk assessment
  - Create security analysis engine for rug pull detection and risk scoring
  - Build creator analysis system with wallet history tracking
  - Implement bundling detection and manipulation pattern recognition
  - _Requirements: 13.1, 13.2, 13.3, 13.4, 13.5, 13.6, 13.7, 13.8, 14.1, 14.2, 14.3, 14.4, 14.5, 14.6, 14.7, 14.8, 15.1, 15.2, 15.3, 15.4, 15.5, 15.6, 15.7, 15.8_- 
[ ] 3.1 Build security analysis engine
  - Create `lib/analyzers/security-analyzer.ts` with SecurityAnalyzer class containing analyzeTokenSecurity(tokenData: TokenData) method, implement risk scoring algorithm (0-100) based on multiple factors: liquidity depth, holder concentration, creator history, contract verification, audit status
  - Implement liquidity analysis: calculate liquidity depth across DEXs, identify liquidity concentration risks, detect potential liquidity rug pulls, analyze liquidity provider behavior and token unlock schedules
  - Add contract verification system: verify token contract authenticity against known standards, check for malicious code patterns, validate token metadata consistency, identify proxy contracts and upgrade mechanisms
  - Create audit report integration: fetch and display security audit results from major audit firms, parse audit findings and risk levels, show audit coverage and recommendations
  - Implement risk factor detection: identify common scam patterns (honeypot, high tax, ownership concentration), detect unusual token mechanics, analyze token utility and use cases
  - Store security analysis results in Qdrant: create security pattern vectors for similar risk detection, enable fast lookup of known security issues, implement pattern matching for new tokens
  - _Requirements: 13.1, 13.2, 13.3, 13.4, 13.5, 13.6, 13.7, 13.8_

- [ ] 3.2 Implement creator analysis and rug pull detection
  - Create `lib/analyzers/creator-analyzer.ts` with CreatorAnalyzer class implementing analyzeTokenCreator(creatorAddress: string) method, trace creator wallet history and previous token creations, identify connections to known rug pulls and scam tokens
  - Implement wallet seed analysis: trace funding sources back through transaction chain, identify ultimate funding source (exchange, validator, or suspicious wallet), calculate confidence score for funding legitimacy, detect circular funding patterns
  - Add previous token performance tracking: analyze all tokens created by same wallet, calculate success/failure rate of previous projects, identify patterns in token launches and abandonment, track creator reputation over time
  - Create rug pull connection detection: cross-reference creator with known rug pull database, identify wallet clusters and associated addresses, detect shared funding sources with known scammers, analyze timing patterns of suspicious activity
  - Implement creator reputation scoring: weight factors including previous token performance, community feedback, time since first activity, transaction patterns, social media presence and verification
  - Store creator analysis in Qdrant: create creator risk vectors for pattern matching, enable fast lookup of creator history, implement similarity search for related creators
  - _Requirements: 14.1, 14.2, 14.3, 14.4, 14.5, 14.6, 14.7, 14.8_

- [ ] 3.3 Build bundling detection and manipulation analysis
  - Create `lib/analyzers/bundling-analyzer.ts` with BundlingAnalyzer class implementing detectTokenBundling(tokenMint: string) method, analyze wallet funding patterns and purchase timing, identify coordinated buying activity and artificial demand
  - Implement coordinated wallet detection: identify wallets funded from same source within short time periods, detect similar transaction patterns and amounts, analyze wallet creation timing and funding sequences, cluster related wallets using graph analysis
  - Add manipulation pattern recognition: detect wash trading between related wallets, identify artificial volume inflation, analyze price manipulation attempts, detect coordinated pump and dump schemes
  - Create funding pattern analysis: trace funding sources for token purchasers, identify common funding wallets and exchanges, detect unusual funding patterns and timing, analyze funding amount distributions
  - Implement bundling risk scoring: calculate manipulation probability (0-100), weight factors including wallet clustering, timing patterns, funding sources, transaction similarities, provide evidence and confidence levels
  - Store bundling analysis in Qdrant: create manipulation pattern vectors, enable detection of similar bundling schemes, implement pattern matching for new token launches
  - _Requirements: 15.1, 15.2, 15.3, 15.4, 15.5, 15.6, 15.7, 15.8_

- [ ] 3.4 Create security analysis display components
  - Create `components/SecurityAnalysisPanel.tsx` with risk score display (0-100 with color coding), risk level indicator (low/medium/high/critical), detailed risk factors list with explanations, expandable sections for each risk category
  - Build `components/CreatorAnalysisDisplay.tsx` showing creator wallet address, reputation score, previous token history table, rug pull connections (if any), wallet seed analysis results with funding chain visualization
  - Implement `components/BundlingDetectionDisplay.tsx` with bundling risk score, coordinated wallet clusters visualization, funding pattern charts, manipulation evidence list, timeline of suspicious activity
  - Add `components/SecurityRecommendations.tsx` providing actionable security advice based on analysis results, risk mitigation strategies, red flags to watch for, educational content about token security
  - Create security alert system: show prominent warnings for high-risk tokens, implement progressive disclosure for risk details, provide clear action recommendations, include links to educational resources
  - Implement security data export: generate security reports in PDF format, include all analysis results and evidence, provide shareable security assessments
  - _Requirements: 13.1, 13.2, 13.3, 13.4, 13.5, 13.6, 13.7, 13.8, 14.1, 14.2, 14.3, 14.4, 14.5, 14.6, 14.7, 14.8, 15.1, 15.2, 15.3, 15.4, 15.5, 15.6, 15.7, 15.8_- 
[ ] 4. Build community features with trollbox and rating system
  - Create token holder verification system for community access
  - Implement anonymous trollbox with ownership percentage display
  - Build community rating system weighted by token holdings
  - _Requirements: 10.1, 10.2, 10.3, 10.4, 10.5, 10.6, 10.7, 10.8, 10.9, 10.10, 10.11, 10.12_

- [ ] 4.1 Implement token holder verification system
  - Create `lib/auth/token-holder-auth.ts` with TokenHolderAuth class implementing verifyTokenHoldings(walletAddress: string, tokenMint: string) method, use Solana RPC to check token account balance, calculate ownership percentage of total supply
  - Build holder verification middleware for API endpoints: verify wallet signature, check token holdings in real-time, implement caching for verified holders (5 minute TTL), handle edge cases (zero balance, account not found)
  - Add periodic re-verification system: background job to re-check holder status every 15 minutes, handle balance changes and access revocation, maintain holder status cache with automatic expiration
  - Create holder tier system based on ownership percentage: whale (>1%), large holder (0.1-1%), medium holder (0.01-0.1%), small holder (<0.01%), implement different privileges and rate limits per tier
  - Implement wallet connection integration: support multiple wallet adapters (Phantom, Solflare, Backpack), handle wallet switching and disconnection, maintain session state and re-authentication
  - Add holder verification UI components: wallet connection button, holder status indicator, ownership percentage display, verification progress and error states
  - _Requirements: 10.1, 10.3, 10.8, 10.11_

- [ ] 4.2 Build token trollbox system
  - Create `components/TokenTrollbox.tsx` with real-time chat interface, message input with character limit (280 chars), message display with timestamp and ownership percentage, auto-scroll to latest messages
  - Implement `lib/trollbox/trollbox-service.ts` with TrollboxService class managing message posting, retrieval, and real-time updates, use WebSocket for live message streaming, implement message persistence in database
  - Add rate limiting based on ownership percentage: whales (>1%) can post every 30 seconds, large holders (0.1-1%) every 60 seconds, medium holders (0.01-0.1%) every 120 seconds, small holders (<0.01%) every 300 seconds
  - Create message moderation system: automatic spam detection using content analysis, community-based reporting and moderation, admin moderation tools, message deletion and user timeout capabilities
  - Implement message formatting: support for basic text formatting, emoji support, automatic link detection, mention system for other holders, message threading for replies
  - Add trollbox privacy features: never display wallet addresses, show only ownership percentage (~X.XX%), implement message encryption for sensitive discussions, provide anonymous posting options
  - _Requirements: 10.1, 10.2, 10.4, 10.8, 10.9, 10.10_

- [ ] 4.3 Implement community rating system
  - Create `components/CommunityRatingSystem.tsx` with like/dislike buttons, rating display with weighted scores, sentiment visualization (positive/negative distribution), historical rating trends chart
  - Build `lib/rating/rating-service.ts` with RatingService class implementing submitRating(walletAddress: string, tokenMint: string, rating: 'like' | 'dislike') method, calculate weighted scores based on ownership percentage, prevent duplicate ratings from same wallet
  - Add rating weight calculation: weight votes by ownership percentage (whale vote = 100x small holder), implement quadratic voting to prevent manipulation, cap maximum vote weight to prevent single-holder dominance
  - Create rating analytics: track rating trends over time, correlate ratings with price movements, identify rating manipulation attempts, generate sentiment reports and insights
  - Implement rating display components: overall sentiment score (0-100), positive/negative percentage breakdown, top holder sentiment vs general sentiment, rating history charts with price overlay
  - Add rating manipulation detection: identify coordinated rating attacks, detect bot activity and fake accounts, implement cooldown periods and verification requirements, flag suspicious rating patterns
  - _Requirements: 10.5, 10.6, 10.7, 10.12_

- [ ] 5. Implement AI insights and prediction system
  - Create AI prediction engine for price forecasting and market analysis
  - Build sentiment analysis system for social media and community data
  - Implement trading signal generation and technical analysis
  - _Requirements: 20.1, 20.2, 20.3, 20.4, 20.5, 20.6, 20.7, 20.8_- 
[ ] 5.1 Build AI prediction engine
  - Create `lib/ai/prediction-engine.ts` with PredictionEngine class implementing generatePricePrediction(tokenMint: string, timeframes: string[]) method, use machine learning models for price forecasting, integrate multiple data sources (price history, volume, social sentiment, market indicators)
  - Implement prediction models: LSTM neural networks for time series forecasting, ensemble methods combining multiple models, technical analysis indicators (RSI, MACD, Bollinger Bands), sentiment-based price impact models
  - Add prediction confidence scoring: calculate confidence levels (0-100) for each prediction, factor in data quality and model accuracy, provide uncertainty ranges and risk assessments, track historical prediction accuracy
  - Create market pattern recognition: identify recurring price patterns and cycles, detect support and resistance levels, recognize trend reversals and breakout patterns, analyze correlation with broader market movements
  - Implement prediction caching and optimization: cache predictions for 15 minutes to reduce API costs, implement background model updates, optimize inference speed for real-time predictions, handle model versioning and updates
  - Store prediction results in Qdrant: create prediction pattern vectors for similar market conditions, enable fast lookup of historical predictions, implement pattern matching for market analysis
  - _Requirements: 20.1, 20.4, 20.8_

- [ ] 5.2 Implement sentiment analysis system
  - Create `lib/ai/sentiment-analyzer.ts` with SentimentAnalyzer class implementing analyzeSentiment(tokenMint: string) method, integrate social media APIs (Twitter, Reddit, Discord), analyze community trollbox messages and ratings
  - Build multi-source sentiment aggregation: Twitter mentions and engagement, Reddit discussions and upvotes, Discord community activity, Telegram group sentiment, news article analysis, influencer mentions and opinions
  - Add sentiment scoring algorithms: natural language processing for text analysis, emotion detection and classification, sentiment trend analysis over time, weighted sentiment based on source credibility and reach
  - Create sentiment-price correlation analysis: identify relationships between sentiment changes and price movements, calculate sentiment impact scores, detect sentiment-driven price events, provide sentiment-based trading insights
  - Implement real-time sentiment monitoring: continuous monitoring of social media feeds, real-time sentiment score updates, sentiment alert system for significant changes, sentiment trend visualization and reporting
  - Store sentiment data in Qdrant: create sentiment pattern vectors for similar market conditions, enable sentiment-based token recommendations, implement sentiment clustering and analysis
  - _Requirements: 20.2, 20.7_

- [ ] 5.3 Build trading signal generation system
  - Create `lib/ai/signal-generator.ts` with SignalGenerator class implementing generateTradingSignals(tokenMint: string) method, combine technical analysis, sentiment data, and market patterns, generate buy/sell/hold recommendations with confidence levels
  - Implement technical analysis signals: moving average crossovers, RSI overbought/oversold conditions, MACD divergences, Bollinger Band squeezes, volume analysis and breakout detection
  - Add fundamental analysis signals: holder concentration changes, liquidity depth analysis, whale movement detection, token utility and adoption metrics, competitive analysis and market positioning
  - Create signal confidence scoring: weight signals by historical accuracy, combine multiple signal types for stronger recommendations, provide risk-adjusted signal strength, include stop-loss and take-profit levels
  - Implement signal backtesting and validation: test signals against historical data, calculate win rates and risk-adjusted returns, optimize signal parameters for better performance, track signal performance over time
  - Add signal delivery system: real-time signal notifications, customizable signal filters and preferences, signal history and performance tracking, integration with trading interface for one-click execution
  - _Requirements: 20.3, 20.5, 20.6, 20.7_

- [ ] 5.4 Create AI insights display components
  - Create `components/AIInsightsPanel.tsx` with prediction display (price targets for different timeframes), confidence indicators and uncertainty ranges, prediction reasoning and key factors, historical accuracy metrics
  - Build `components/SentimentAnalysisDisplay.tsx` showing overall sentiment score, sentiment breakdown by source, sentiment trend charts, correlation with price movements, sentiment alerts and notifications
  - Implement `components/TradingSignalsDisplay.tsx` with current signals (buy/sell/hold), signal strength and confidence, recommended entry/exit points, stop-loss and take-profit levels, signal history and performance
  - Add `components/MarketPatternAnalysis.tsx` displaying identified patterns, pattern completion probability, similar historical patterns, pattern-based predictions and insights
  - Create AI insights export functionality: generate AI analysis reports, include predictions and reasoning, provide downloadable insights summary, share insights with community (with privacy controls)
  - Implement AI model transparency: explain AI decision-making process, show data sources and weights, provide model performance metrics, include disclaimers and risk warnings
  - _Requirements: 20.1, 20.2, 20.3, 20.4, 20.5, 20.6, 20.7, 20.8_

- [ ] 6. Build portfolio tracking and PnL analysis system
  - Create portfolio tracking system with automatic wallet detection
  - Implement comprehensive PnL calculation with cost basis tracking
  - Build portfolio analytics and performance comparison tools
  - _Requirements: 19.1, 19.2, 19.3, 19.4, 19.5, 19.6, 19.7, 19.8_-
 [ ] 6.1 Implement portfolio tracking system
  - Create `lib/portfolio/portfolio-tracker.ts` with PortfolioTracker class implementing trackWalletPortfolio(walletAddress: string) method, automatically detect all token holdings using Solana RPC getTokenAccountsByOwner(), calculate current values using real-time price data
  - Build transaction history analysis: fetch all token transactions for wallet, categorize transactions (buy, sell, transfer in/out, swap), calculate cost basis using FIFO/LIFO methods, track realized and unrealized gains/losses
  - Add portfolio performance metrics: total portfolio value, 24h/7d/30d performance, best/worst performing tokens, allocation percentages, diversification metrics, risk-adjusted returns (Sharpe ratio)
  - Create portfolio comparison tools: compare performance vs market benchmarks (SOL, market indices), peer portfolio comparison, sector allocation analysis, performance attribution analysis
  - Implement portfolio alerts: significant portfolio value changes, individual token performance alerts, rebalancing recommendations, risk threshold notifications
  - Store portfolio data in database: user portfolio snapshots, historical performance data, transaction records with cost basis, portfolio preferences and settings
  - _Requirements: 19.1, 19.2, 19.3, 19.4, 19.6_

- [ ] 6.2 Build PnL calculation engine
  - Create `lib/portfolio/pnl-calculator.ts` with PnLCalculator class implementing calculatePnL(transactions: Transaction[], currentPrices: PriceData[]) method, support multiple cost basis methods (FIFO, LIFO, average cost), handle complex scenarios (swaps, liquidity provision, staking rewards)
  - Implement realized PnL tracking: calculate gains/losses from completed transactions, handle partial sales and cost basis adjustments, track wash sale rules and tax implications, generate detailed transaction reports
  - Add unrealized PnL calculation: current market value vs cost basis, mark-to-market valuation, unrealized gain/loss percentages, portfolio-level unrealized PnL aggregation
  - Create tax reporting functionality: generate tax reports with realized gains/losses, support different tax jurisdictions and rules, export tax data in standard formats (CSV, TurboTax), include transaction details and cost basis information
  - Implement PnL analytics: PnL trends over time, token-specific PnL analysis, trading performance metrics, win/loss ratios, average holding periods, return on investment calculations
  - Add PnL visualization components: PnL charts and graphs, profit/loss distribution, performance heatmaps, comparative PnL analysis across time periods
  - _Requirements: 19.2, 19.3, 19.5_

- [ ] 6.3 Create portfolio display components
  - Create `components/PortfolioOverview.tsx` with total portfolio value display, 24h change with color coding, allocation pie chart, top holdings table, performance metrics dashboard
  - Build `components/PortfolioTokenList.tsx` using @tanstack/react-table with columns: token name/symbol, balance, current price, cost basis, unrealized PnL ($ and %), allocation %, 24h change, actions (trade, remove from watchlist)
  - Implement `components/PortfolioPerformanceChart.tsx` using recharts with portfolio value over time, comparison with benchmarks, performance attribution, drawdown analysis, return distribution
  - Add `components/PortfolioAnalytics.tsx` showing diversification metrics, risk analysis, correlation matrix, sector allocation, performance statistics (total return, annualized return, volatility, Sharpe ratio)
  - Create portfolio sharing functionality: generate shareable portfolio performance reports, privacy controls for shared data, social media integration for portfolio updates
  - Implement portfolio export features: CSV/Excel export with detailed holdings and performance, PDF portfolio reports, tax reporting exports, historical data downloads
  - _Requirements: 19.1, 19.2, 19.3, 19.4, 19.7, 19.8_

- [ ] 7. Implement gamification and user engagement system
  - Create user points and achievement system
  - Build leaderboards and competitive features
  - Implement reward system and user progression
  - _Requirements: 21.1, 21.2, 21.3, 21.4, 21.5, 21.6, 21.7, 21.8_

- [ ] 7.1 Build user points and achievement system
  - Create `lib/gamification/points-system.ts` with PointsSystem class implementing awardPoints(userId: string, activity: string, points: number) method, track user activities (token views, portfolio updates, community participation, accurate predictions), implement point multipliers for premium users
  - Define point-earning activities: view token details (1 point), add token to watchlist (5 points), share token analysis (10 points), accurate price prediction (50 points), community contribution (25 points), referral signup (100 points)
  - Build achievement system: create achievement definitions with requirements and rewards, track progress towards achievements, unlock badges and special privileges, implement rare achievements for exceptional contributions
  - Add user level progression: calculate user levels based on total points, unlock new features and privileges at higher levels, provide level-based benefits (higher rate limits, exclusive features, priority support)
  - Create achievement categories: analyst achievements (accurate predictions, detailed analysis), community achievements (helpful contributions, positive ratings), explorer achievements (discovering new tokens, early adoption), trader achievements (successful trades, portfolio performance)
  - Store gamification data in database: user points and levels, achievement progress and unlocks, activity history and streaks, leaderboard rankings and statistics
  - _Requirements: 21.1, 21.2, 21.5_- [
 ] 7.2 Implement leaderboards and competitive features
  - Create `components/Leaderboards.tsx` with multiple leaderboard categories: top analysts (prediction accuracy), top contributors (community points), top traders (portfolio performance), top discoverers (early token finds), overall points leaders
  - Build `lib/gamification/leaderboard-service.ts` with LeaderboardService class managing leaderboard calculations, rankings, and updates, implement real-time leaderboard updates, handle ties and ranking algorithms
  - Add competitive challenges: weekly prediction contests, monthly portfolio challenges, community contribution competitions, token discovery races, collaborative challenges for teams
  - Create challenge system: define challenge rules and rewards, track participant progress, announce winners and distribute rewards, create seasonal and special event challenges
  - Implement social features for competition: challenge friends and followers, create private leaderboards for groups, share achievements and rankings, celebrate milestones and victories
  - Add leaderboard rewards: exclusive badges and titles, premium feature access, token airdrops and prizes, recognition in community, special privileges and early access
  - _Requirements: 21.3, 21.6_

- [ ] 7.3 Build reward system and user progression
  - Create `lib/gamification/reward-system.ts` with RewardSystem class implementing distributeRewards(userId: string, rewardType: string, amount: number) method, manage token airdrops, premium feature access, exclusive content unlocks
  - Implement reward types: token airdrops for top performers, premium subscription credits, exclusive feature access, early access to new features, special badges and titles, merchandise and physical rewards
  - Add referral program: reward users for bringing new users, track referral success and engagement, provide tiered referral bonuses, create referral leaderboards and competitions
  - Create user progression paths: analyst track (focus on predictions and analysis), trader track (portfolio performance and trading), community track (social contributions and moderation), explorer track (token discovery and research)
  - Implement streak systems: daily login streaks, prediction streaks, community participation streaks, provide streak bonuses and multipliers, celebrate milestone streaks
  - Add seasonal events and special rewards: holiday-themed challenges, anniversary celebrations, market milestone rewards, community achievement celebrations
  - _Requirements: 21.4, 21.5, 21.7, 21.8_

- [ ] 7.4 Create gamification display components
  - Create `components/UserProgressDashboard.tsx` with current level and points, progress to next level, recent achievements, active challenges, leaderboard position, streak counters
  - Build `components/AchievementGallery.tsx` showing unlocked achievements with descriptions, progress on locked achievements, achievement categories and filters, sharing functionality for achievements
  - Implement `components/LeaderboardDisplay.tsx` with tabbed interface for different leaderboard types, user ranking and position, top performers showcase, filtering and search functionality
  - Add `components/ChallengeCenter.tsx` displaying active challenges, challenge progress tracking, challenge history and results, challenge creation for community moderators
  - Create gamification notifications: achievement unlock notifications, level up celebrations, challenge completion alerts, leaderboard position changes, reward distribution notifications
  - Implement gamification analytics: user engagement metrics, feature usage tracking, reward effectiveness analysis, challenge participation rates, progression funnel analysis
  - _Requirements: 21.1, 21.2, 21.3, 21.4, 21.5, 21.6, 21.7, 21.8_

- [ ] 8. Build token launch pad and early access system
  - Create token launch tracking and discovery system
  - Implement early access and whitelist management
  - Build launch quality assessment and due diligence tools
  - _Requirements: 22.1, 22.2, 22.3, 22.4, 22.5, 22.6, 22.7, 22.8_

- [ ] 8.1 Implement token launch tracking system
  - Create `lib/launchpad/launch-tracker.ts` with LaunchTracker class implementing trackUpcomingLaunches() method, monitor new token creations on Solana, identify legitimate projects vs spam tokens, collect launch metadata and project information
  - Build launch data collection: project descriptions and whitepapers, team information and social links, tokenomics and distribution plans, roadmap and development milestones, community size and engagement metrics
  - Add launch calendar functionality: upcoming launch schedules, launch countdown timers, timezone support for global users, calendar integration and reminders, launch notification system
  - Create launch performance tracking: post-launch price performance, initial vs current market cap, holder growth and distribution, liquidity development, trading volume trends
  - Implement launch quality scoring: project legitimacy assessment, team credibility analysis, tokenomics evaluation, community engagement metrics, technical implementation quality
  - Store launch data in Qdrant: create launch pattern vectors for similar project discovery, enable launch success prediction, implement pattern matching for quality assessment
  - _Requirements: 22.1, 22.5, 22.6, 22.8_- [ 
] 8.2 Build early access and whitelist system
  - Create `lib/launchpad/whitelist-manager.ts` with WhitelistManager class implementing manageWhitelist(projectId: string, userAddress: string) method, handle whitelist applications and approvals, manage allocation limits and purchase windows
  - Implement early access criteria: user level and points requirements, portfolio size and activity thresholds, community contribution scores, referral program participation, premium subscription status
  - Add whitelist application process: application forms with user verification, project-specific requirements and questions, application review and approval workflow, waitlist management for oversubscribed launches
  - Create allocation management: fair distribution algorithms, anti-sybil measures, allocation limits per user, purchase window management, refund handling for failed launches
  - Implement launch participation tracking: user participation history, success rates and returns, allocation utilization rates, feedback and rating system for completed launches
  - Add early access benefits: discounted token prices, larger allocation limits, priority access to popular launches, exclusive project information, direct communication with project teams
  - _Requirements: 22.2, 22.4, 22.7_

- [ ] 8.3 Implement launch quality assessment system
  - Create `lib/launchpad/due-diligence.ts` with DueDiligenceAnalyzer class implementing assessLaunchQuality(projectData: ProjectData) method, analyze project fundamentals, team credibility, technical implementation, market opportunity
  - Build team verification system: verify team member identities and backgrounds, check previous project history and success rates, analyze team social media presence and credibility, identify red flags and warning signs
  - Add technical assessment: code quality and security analysis, smart contract audits and verification, tokenomics analysis and sustainability, technical roadmap feasibility assessment
  - Create market analysis: competitive landscape analysis, market size and opportunity assessment, token utility and value proposition evaluation, adoption potential and use case validation
  - Implement risk assessment: identify potential risks and red flags, calculate overall risk score, provide risk mitigation recommendations, generate comprehensive due diligence reports
  - Add community assessment: community size and engagement analysis, social media presence and growth, influencer endorsements and partnerships, community sentiment and feedback analysis
  - _Requirements: 22.3, 22.8_

- [ ] 8.4 Create launch pad display components
  - Create `components/LaunchPadDashboard.tsx` with upcoming launches grid, featured projects showcase, launch calendar view, user allocation status, participation history
  - Build `components/LaunchProjectCard.tsx` showing project logo and name, launch date and countdown, allocation details, quality score and risk assessment, whitelist status and application button
  - Implement `components/LaunchDetails.tsx` with comprehensive project information, team details and verification status, tokenomics and distribution, roadmap and milestones, due diligence report
  - Add `components/LaunchCalendar.tsx` with calendar view of upcoming launches, filtering by date and category, launch reminders and notifications, timezone support and customization
  - Create launch participation interface: whitelist application forms, allocation management, purchase interface, transaction status tracking, refund and support system
  - Implement launch analytics: launch success metrics, user participation statistics, return on investment tracking, launch performance comparisons, market impact analysis
  - _Requirements: 22.1, 22.2, 22.3, 22.4, 22.5, 22.6, 22.7, 22.8_

- [ ] 9. Implement advanced trading integration
  - Create DEX aggregation and price discovery system
  - Build advanced trading interface with multiple order types
  - Implement MEV protection and optimal execution
  - _Requirements: 23.1, 23.2, 23.3, 23.4, 23.5, 23.6, 23.7, 23.8_

- [ ] 9.1 Build DEX aggregation system
  - Create `lib/trading/dex-aggregator.ts` with DexAggregator class implementing findBestRoute(inputToken: string, outputToken: string, amount: number) method, integrate with Jupiter, 1inch, and other aggregators, compare prices and execution routes across multiple DEXs
  - Implement route optimization: find routes with best price execution, minimize slippage and price impact, optimize for lowest fees and fastest execution, handle complex multi-hop routes
  - Add liquidity analysis: analyze liquidity depth across DEXs, identify potential slippage and price impact, monitor liquidity changes in real-time, provide liquidity warnings and recommendations
  - Create price comparison interface: show prices across different DEXs, highlight best execution venues, display price differences and arbitrage opportunities, provide historical price comparison data
  - Implement route caching and optimization: cache popular routes for faster execution, pre-calculate routes for trending tokens, optimize route calculation performance, handle route expiration and updates
  - Add execution monitoring: track trade execution status, monitor for failed transactions, provide execution analytics and performance metrics, handle partial fills and order management
  - _Requirements: 23.1, 23.2, 23.4, 23.8_- [ 
] 9.2 Implement advanced trading interface
  - Create `components/TradingInterface.tsx` with order entry form, market/limit/stop order types, slippage controls, trade size calculator, execution preview with fees and impact
  - Build `lib/trading/order-manager.ts` with OrderManager class implementing submitOrder(orderData: OrderData) method, handle different order types (market, limit, stop-loss, DCA), manage order lifecycle and status updates
  - Add advanced order types: dollar-cost averaging (DCA) orders, trailing stop orders, conditional orders based on technical indicators, portfolio rebalancing orders, time-weighted average price (TWAP) orders
  - Create trading analytics: trade history and performance tracking, profit/loss analysis per trade, trading statistics and metrics, win/loss ratios and average returns, trading pattern analysis
  - Implement risk management: position sizing recommendations, stop-loss and take-profit suggestions, portfolio risk analysis, maximum drawdown protection, risk-adjusted return calculations
  - Add one-click trading from AI signals: integrate with AI signal system, execute trades based on AI recommendations, automatic order placement with predefined parameters, signal-based portfolio management
  - _Requirements: 23.3, 23.5, 23.6_

- [ ] 9.3 Build MEV protection and execution optimization
  - Create `lib/trading/mev-protection.ts` with MEVProtection class implementing protectTrade(tradeData: TradeData) method, integrate with MEV protection services (Flashbots, Eden Network), implement private mempool submission
  - Add execution optimization: optimize transaction timing and routing, minimize MEV extraction and sandwich attacks, use private mempools for sensitive trades, implement batch trading for better execution
  - Create execution analytics: track MEV extraction and protection effectiveness, analyze execution quality and slippage, monitor front-running and sandwich attacks, provide execution improvement recommendations
  - Implement fee optimization: find routes with lowest total fees, optimize gas usage and transaction costs, provide fee estimation and optimization, handle fee market volatility and spikes
  - Add execution monitoring: real-time trade execution tracking, transaction status updates and confirmations, execution quality metrics and reporting, failed transaction handling and retry logic
  - Create execution reporting: detailed execution reports with costs and performance, execution quality benchmarking, MEV protection effectiveness analysis, trading cost analysis and optimization suggestions
  - _Requirements: 23.7, 23.8_

- [ ] 9.4 Create trading display components
  - Create `components/TradingDashboard.tsx` with trading interface, order book display, recent trades, portfolio impact preview, execution status and history
  - Build `components/OrderEntry.tsx` with token selection, order type selection, amount input with validation, slippage controls, execution preview with fees and impact, submit and cancel buttons
  - Implement `components/TradeHistory.tsx` using @tanstack/react-table with columns: timestamp, token pair, order type, amount, price, fees, status, PnL, actions (view details, repeat trade)
  - Add `components/TradingAnalytics.tsx` showing trading performance metrics, profit/loss charts, win/loss ratios, trading frequency analysis, risk metrics and recommendations
  - Create trading notifications: order execution alerts, price target notifications, stop-loss triggers, trading opportunity alerts, execution quality warnings
  - Implement trading export features: trade history export in CSV/Excel, tax reporting integration, trading performance reports, execution quality analysis reports
  - _Requirements: 23.1, 23.2, 23.3, 23.4, 23.5, 23.6, 23.7, 23.8_

- [ ] 10. Build token comparison and recommendation system
  - Create similar token discovery using Qdrant vector search
  - Implement token comparison tools and analysis
  - Build personalized recommendation engine
  - _Requirements: 16.1, 16.2, 16.3, 16.4, 16.5, 16.6, 16.7, 16.8_

- [ ] 10.1 Implement similar token discovery system
  - Create `lib/recommendations/similarity-engine.ts` with SimilarityEngine class implementing findSimilarTokens(tokenMint: string, criteria: SimilarityType[]) method, use Qdrant vector search for token similarity, support multiple similarity criteria (market cap, sector, performance, holder patterns)
  - Build token embedding generation: create multi-dimensional embeddings from token characteristics (price history, volume patterns, holder distribution, social metrics, technical indicators), update embeddings regularly with new data
  - Add similarity scoring algorithms: calculate similarity scores based on multiple factors, weight different similarity criteria, provide similarity explanations and reasoning, handle edge cases and outliers
  - Create similarity categories: price correlation similarity, market cap and volume similarity, holder pattern similarity, sector and use case similarity, social sentiment similarity, technical indicator similarity
  - Implement similarity caching: cache similarity calculations for popular tokens, update similarity scores when token data changes, optimize similarity search performance, handle similarity score expiration
  - Store similarity data in Qdrant: maintain updated token vectors, enable fast similarity search, implement similarity clustering and analysis, support complex similarity queries
  - _Requirements: 16.1, 16.2, 16.5_- [ ] 
10.2 Build token comparison tools
  - Create `components/TokenComparison.tsx` with side-by-side comparison interface supporting up to 5 tokens, comparison metrics selection, visual comparison charts, export comparison results
  - Build `lib/analysis/comparison-engine.ts` with ComparisonEngine class implementing compareTokens(tokenMints: string[]) method, calculate relative metrics and performance, identify key differences and similarities, generate comparison insights
  - Add comparison categories: market metrics (price, market cap, volume, liquidity), fundamental metrics (supply, holder distribution, age), performance metrics (price changes, volatility, returns), social metrics (community size, sentiment, activity)
  - Create comparison visualizations: side-by-side metric tables, comparison charts and graphs, relative performance analysis, correlation analysis, competitive positioning maps
  - Implement comparison templates: pre-configured comparison sets for common analysis (DeFi tokens, gaming tokens, meme coins), user-created comparison templates, popular comparison combinations
  - Add comparison sharing: shareable comparison reports, social media integration, comparison bookmarking, collaborative comparison analysis, comparison discussion threads
  - _Requirements: 16.3, 16.4, 16.6, 16.8_

- [ ] 10.3 Implement personalized recommendation engine
  - Create `lib/recommendations/recommendation-engine.ts` with RecommendationEngine class implementing generateRecommendations(userId: string) method, analyze user behavior and preferences, provide personalized token recommendations, adapt recommendations based on user feedback
  - Build user behavior analysis: track token views and interactions, analyze portfolio composition and changes, monitor trading patterns and preferences, identify user interests and investment style
  - Add recommendation algorithms: collaborative filtering based on similar users, content-based filtering using token characteristics, hybrid approaches combining multiple methods, machine learning models for preference prediction
  - Create recommendation categories: tokens similar to user's portfolio, trending tokens in user's interest areas, undervalued tokens based on user criteria, new launches matching user preferences, tokens with strong fundamentals
  - Implement recommendation feedback: user rating system for recommendations, recommendation effectiveness tracking, continuous learning from user actions, recommendation quality improvement over time
  - Add recommendation personalization: customize recommendations based on user level and experience, adjust for risk tolerance and investment goals, consider user's geographic location and regulations, provide explanation for each recommendation
  - _Requirements: 16.7, 16.8_

- [ ] 10.4 Create recommendation display components
  - Create `components/SimilarTokens.tsx` with similar token cards, similarity scores and explanations, quick comparison buttons, similarity criteria filters
  - Build `components/TokenRecommendations.tsx` showing personalized recommendations, recommendation reasons, user feedback options, recommendation categories and filters
  - Implement `components/ComparisonDashboard.tsx` with comparison interface, metric selection, visualization options, export and sharing functionality
  - Add `components/RecommendationFeed.tsx` with personalized token feed, recommendation updates, trending recommendations, social recommendations from followed users
  - Create recommendation notifications: new recommendation alerts, recommendation performance updates, similar token discoveries, trending token notifications
  - Implement recommendation analytics: recommendation click-through rates, user engagement with recommendations, recommendation effectiveness metrics, user satisfaction tracking
  - _Requirements: 16.1, 16.2, 16.3, 16.4, 16.5, 16.6, 16.7, 16.8_

- [ ] 11. Implement comprehensive testing and quality assurance
  - Write unit tests for all analytics engines and components
  - Create integration tests for API endpoints and real-time features
  - Implement end-to-end tests for complete user workflows
  - Add performance testing for large datasets and concurrent users
  - _Requirements: All requirements need comprehensive testing coverage_

- [ ] 11.1 Write comprehensive unit tests
  - Create `__tests__/analyzers/security-analyzer.test.ts` testing SecurityAnalyzer.analyzeTokenSecurity() with mock token data, test risk scoring algorithms with various risk scenarios, verify rug pull detection accuracy, test bundling detection with coordinated wallet patterns
  - Build `__tests__/analyzers/creator-analyzer.test.ts` testing CreatorAnalyzer.analyzeTokenCreator() with different creator scenarios, test wallet seed analysis with various funding patterns, verify rug pull connection detection, test creator reputation scoring
  - Create `__tests__/community/trollbox-service.test.ts` testing TrollboxService message posting and retrieval, test holder verification and rate limiting, verify message moderation and spam detection, test real-time message streaming
  - Add `__tests__/ai/prediction-engine.test.ts` testing PredictionEngine.generatePricePrediction() with historical data, test prediction accuracy and confidence scoring, verify model performance and optimization, test prediction caching and updates
  - Implement `__tests__/portfolio/portfolio-tracker.test.ts` testing PortfolioTracker.trackWalletPortfolio() with various wallet scenarios, test PnL calculations with different transaction types, verify portfolio performance metrics, test tax reporting functionality
  - Create `__tests__/trading/dex-aggregator.test.ts` testing DexAggregator.findBestRoute() with different token pairs, test route optimization and price comparison, verify execution monitoring and analytics, test MEV protection effectiveness
  - _Requirements: All requirements need unit test coverage_- [ ]
 11.2 Create integration and end-to-end tests
  - Create `__tests__/integration/token-api-integration.test.ts` testing all token-related API endpoints with real Solana data, test API response times and data accuracy, verify caching behavior and cache invalidation, test rate limiting and error handling
  - Build `__tests__/integration/qdrant-integration.test.ts` testing Qdrant vector operations with token data, test similarity search accuracy and performance, verify vector storage and retrieval, test vector updates and consistency
  - Create `__tests__/integration/realtime-integration.test.ts` testing WebSocket connections for real-time updates, verify price updates and market data streaming, test trollbox real-time messaging, test notification delivery and user experience
  - Add `e2e/token-explorer.spec.ts` using Playwright testing complete user workflows: token discovery and analysis, portfolio tracking and management, community participation and rating, trading execution and monitoring
  - Implement `e2e/security-analysis.spec.ts` testing security analysis workflows: rug pull detection, creator analysis, bundling detection, risk assessment and reporting
  - Create `e2e/ai-insights.spec.ts` testing AI features: price predictions, sentiment analysis, trading signals, recommendation system
  - _Requirements: All requirements need integration and E2E test coverage_

- [ ] 11.3 Implement performance and load testing
  - Create `__tests__/performance/token-analysis-performance.test.ts` testing analytics processing performance with large datasets, measure security analysis speed with complex patterns, test AI prediction generation times, verify Qdrant search performance
  - Build load testing scenarios using Artillery or similar tools: simulate concurrent users accessing token pages, test API endpoint performance under load, verify real-time feature scalability, test database and cache performance
  - Add memory usage and resource monitoring: track memory consumption during analytics processing, monitor CPU usage for AI operations, test garbage collection and memory leaks, verify resource cleanup
  - Create performance benchmarks: establish baseline performance metrics, track performance regression over time, optimize slow operations and bottlenecks, implement performance monitoring and alerting
  - _Requirements: 18.1, 18.2, 18.3, 18.4, 18.5, 18.6, 18.7, 18.8_

- [ ] 12. Implement mobile optimization and accessibility
  - Create responsive design for all token explorer components
  - Add accessibility features including ARIA labels and keyboard navigation
  - Optimize touch interactions and mobile performance
  - _Requirements: 24.1, 24.2, 24.3, 24.4, 24.5, 24.6, 24.7, 24.8_

- [ ] 12.1 Implement responsive design and mobile optimization
  - Create mobile-first responsive layouts using CSS Grid and Flexbox: implement breakpoints at 320px (mobile), 768px (tablet), 1024px (desktop), 1440px (wide), optimize token detail pages for mobile viewing with collapsible sections
  - Optimize complex components for mobile: redesign token comparison interface for mobile screens, create mobile-friendly trading interface with simplified controls, implement swipe navigation for token browsing
  - Add touch-friendly interactions: increase touch target sizes to minimum 44px, implement swipe gestures for token navigation, add haptic feedback for important actions, optimize scrolling performance for long lists
  - Create mobile-specific components: `components/mobile/MobileTokenCard.tsx` for condensed token display, `components/mobile/MobileTrollbox.tsx` with optimized chat interface, implement mobile portfolio dashboard
  - Implement progressive enhancement: ensure core functionality works without JavaScript, add mobile-specific enhancements progressively, optimize images and assets for mobile networks, implement service worker for offline functionality
  - Add mobile performance optimizations: implement virtual scrolling for token lists, use intersection observer for lazy loading, minimize bundle size for mobile, implement efficient caching strategies
  - _Requirements: 24.1, 24.3, 24.4, 24.5_

- [ ] 12.2 Add comprehensive accessibility features
  - Implement proper ARIA labels and semantic HTML structure: use semantic HTML5 elements throughout token explorer, add ARIA labels for all interactive elements, implement proper heading hierarchy, use role attributes for complex components
  - Add keyboard navigation support: implement focus management with proper tab order, add keyboard shortcuts for common actions, create skip links for main content areas, implement focus trapping in modals and dropdowns
  - Create high contrast mode support: implement CSS custom properties for colors, add high contrast theme toggle, ensure minimum contrast ratios, test with Windows High Contrast mode
  - Add screen reader compatibility: provide descriptive alt text for charts and visualizations, implement live regions for dynamic content updates, add screen reader only text for context, use proper form labels and fieldsets
  - Implement accessibility testing: integrate @axe-core/react for automated testing, add manual testing checklist, implement keyboard-only navigation testing, test with screen readers (NVDA, JAWS, VoiceOver)
  - Create accessibility documentation: document keyboard shortcuts and navigation, provide accessibility statement, implement user feedback mechanism for accessibility issues
  - _Requirements: 24.2, 24.7_

- [ ] 13. Deploy and monitor production system
  - Set up production deployment with proper scaling and monitoring
  - Configure performance monitoring and alerting
  - Implement gradual rollout and feature flags
  - Create documentation and user guides
  - _Requirements: All requirements need production deployment and monitoring_

- [ ] 13.1 Configure production deployment and scaling
  - Set up production environment with Kubernetes or similar orchestration, configure auto-scaling for API services based on load, implement load balancing for high availability, set up database clustering and replication
  - Configure monitoring and logging: implement structured logging with correlation IDs, set up error tracking with Sentry, configure performance monitoring with DataDog/New Relic, implement health check endpoints
  - Add security measures: implement API rate limiting and DDoS protection, configure SSL/TLS certificates and security headers, set up WAF and security scanning, implement secrets management and rotation
  - Create deployment pipeline: configure CI/CD with automated testing, implement blue-green deployment strategy, set up feature flags for gradual rollout, configure rollback procedures and disaster recovery
  - _Requirements: All requirements need production deployment_

- [ ] 13.2 Set up comprehensive monitoring and alerting
  - Configure application monitoring: track API response times and error rates, monitor database performance and query times, track Qdrant vector search performance, monitor AI service response times and accuracy
  - Set up business metrics monitoring: track user engagement and feature usage, monitor token analysis accuracy and performance, track community participation and sentiment, measure trading execution success rates
  - Implement alerting system: configure alerts for system performance degradation, set up business metric alerts for anomalies, implement escalation procedures for critical issues, create status page for user communication
  - Create monitoring dashboards: build executive dashboard with key metrics, create operational dashboard for system health, implement user analytics dashboard, set up real-time monitoring displays
  - _Requirements: All requirements need comprehensive monitoring_# Transaction Explorer Enhancements - Design Document

## Overview

The enhanced Transaction Explorer provides comprehensive transaction analysis through detailed instruction parsing, account change visualization, AI-powered explanations, and related transaction discovery. The system transforms raw blockchain data into understandable insights for users of all technical levels.

## Architecture

### System Components

```mermaid
graph TB
    UI[Transaction UI] --> Parser[Instruction Parser]
    UI --> Changes[Account Changes Analyzer]
    UI --> AI[AI Explanation Engine]
    UI --> Related[Related Tx Finder]
    UI --> Graph[Transaction Graph]
    
    Parser --> Programs[Program Registry]
    Changes --> Diff[State Diff Engine]
    AI --> LLM[Language Model]
    Related --> Cache[Transaction Cache]
    Graph --> Viz[Graph Visualizer]
```

### Enhanced Transaction Flow

1. **Transaction Loading**: Fetch transaction data with full account states
2. **Instruction Parsing**: Parse and categorize all instructions
3. **Account Analysis**: Calculate before/after state changes
4. **AI Analysis**: Generate natural language explanation
5. **Related Discovery**: Find connected transactions
6. **Visualization**: Render interactive transaction graph
7. **Metrics Calculation**: Compute performance and cost metrics

## Components and Interfaces

### Frontend Components

#### `EnhancedTransactionView`
```typescript
interface EnhancedTransactionViewProps {
  signature: string;
  transaction?: ParsedTransaction;
  onRelatedTransactionClick?: (signature: string) => void;
}

interface ParsedTransaction {
  signature: string;
  slot: number;
  blockTime: number;
  instructions: ParsedInstruction[];
  accountChanges: AccountChange[];
  aiExplanation?: AIExplanation;
  relatedTransactions: RelatedTransaction[];
  metrics: TransactionMetrics;
}
```

#### `InstructionBreakdown`
```typescript
interface InstructionBreakdownProps {
  instructions: ParsedInstruction[];
  onInstructionClick?: (instruction: ParsedInstruction) => void;
}

interface ParsedInstruction {
  programId: string;
  programName?: string;
  instructionType: string;
  description: string;
  accounts: InstructionAccount[];
  data: InstructionData;
  innerInstructions?: ParsedInstruction[];
  computeUnits: number;
}

interface InstructionAccount {
  pubkey: string;
  isSigner: boolean;
  isWritable: boolean;
  role: 'payer' | 'recipient' | 'authority' | 'program' | 'system';
}
```

#### `AccountChangesPanel`
```typescript
interface AccountChangesPanelProps {
  changes: AccountChange[];
  onAccountClick?: (address: string) => void;
}

interface AccountChange {
  address: string;
  before: AccountState;
  after: AccountState;
  lamportsDiff: number;
  tokenChanges: TokenChange[];
  dataChanges?: DataChange;
}

interface AccountState {
  lamports: number;
  owner: string;
  executable: boolean;
  rentEpoch: number;
  data?: string;
}

interface TokenChange {
  mint: string;
  symbol?: string;
  beforeAmount: number;
  afterAmount: number;
  difference: number;
}
```

#### `AIExplanationPanel`
```typescript
interface AIExplanationPanelProps {
  explanation: AIExplanation;
  isLoading: boolean;
  onRegenerateExplanation?: () => void;
}

interface AIExplanation {
  summary: string;
  mainAction: string;
  secondaryEffects: string[];
  riskAssessment: RiskAssessment;
  technicalDetails: TechnicalDetail[];
  confidence: number;
}

interface RiskAssessment {
  level: 'low' | 'medium' | 'high';
  factors: string[];
  recommendations: string[];
}
```

#### `RelatedTransactionsPanel`
```typescript
interface RelatedTransactionsPanelProps {
  relatedTransactions: RelatedTransaction[];
  onTransactionClick: (signature: string) => void;
  isLoading: boolean;
}

interface RelatedTransaction {
  signature: string;
  relationship: RelationshipType;
  strength: number;
  description: string;
  timestamp: number;
  accounts: string[];
}

type RelationshipType = 
  | 'same_accounts'
  | 'same_program'
  | 'temporal_proximity'
  | 'token_flow'
  | 'authority_chain';
```

#### `TransactionGraph`
```typescript
interface TransactionGraphProps {
  transaction: ParsedTransaction;
  showRelated?: boolean;
  onNodeClick?: (address: string) => void;
  onEdgeClick?: (transfer: Transfer) => void;
}

interface GraphNode {
  id: string;
  type: 'account' | 'program' | 'token';
  label: string;
  balance?: number;
  isWritable: boolean;
  isSigner: boolean;
}

interface GraphEdge {
  source: string;
  target: string;
  type: 'transfer' | 'instruction' | 'authority';
  amount?: number;
  label: string;
}
```

### Backend Services

#### `InstructionParserService`
```typescript
class InstructionParserService {
  async parseInstructions(
    transaction: Transaction
  ): Promise<ParsedInstruction[]>;
  
  async getInstructionDescription(
    programId: string,
    instructionData: Buffer
  ): Promise<string>;
  
  async identifyInstructionType(
    programId: string,
    data: Buffer
  ): Promise<string>;
}
```

#### `AccountChangesAnalyzer`
```typescript
class AccountChangesAnalyzer {
  async analyzeAccountChanges(
    transaction: Transaction,
    preBalances: number[],
    postBalances: number[]
  ): Promise<AccountChange[]>;
  
  async getTokenChanges(
    address: string,
    beforeSlot: number,
    afterSlot: number
  ): Promise<TokenChange[]>;
  
  async analyzeDataChanges(
    address: string,
    beforeData: Buffer,
    afterData: Buffer
  ): Promise<DataChange>;
}
```

#### `AITransactionAnalyzer`
```typescript
class AITransactionAnalyzer {
  async generateExplanation(
    transaction: ParsedTransaction
  ): Promise<AIExplanation>;
  
  async assessRisk(
    transaction: ParsedTransaction
  ): Promise<RiskAssessment>;
  
  async identifyMainAction(
    instructions: ParsedInstruction[]
  ): Promise<string>;
}
```

#### `RelatedTransactionFinder`
```typescript
class RelatedTransactionFinder {
  async findRelatedTransactions(
    signature: string,
    options: RelatedTxOptions
  ): Promise<RelatedTransaction[]>;
  
  async findByAccountInteractions(
    accounts: string[],
    timeWindow: number
  ): Promise<RelatedTransaction[]>;
  
  async findByProgramUsage(
    programId: string,
    timeWindow: number
  ): Promise<RelatedTransaction[]>;
}
```

## Data Models

### Enhanced Transaction Data

```typescript
interface TransactionMetrics {
  totalFee: number;
  computeUnitsUsed: number;
  computeUnitsRequested: number;
  efficiency: number;
  size: number;
  accountsModified: number;
  instructionCount: number;
  innerInstructionCount: number;
  priorityFee?: number;
  baseFee: number;
  feePerComputeUnit: number;
}

interface DataChange {
  type: 'account_data' | 'token_account' | 'program_data';
  beforeHash: string;
  afterHash: string;
  sizeChange: number;
  significantChanges: string[];
  fieldChanges?: FieldChange[];
}

interface FieldChange {
  field: string;
  beforeValue: any;
  afterValue: any;
  significance: 'high' | 'medium' | 'low';
}

interface TechnicalDetail {
  category: 'instruction' | 'account' | 'program' | 'token';
  title: string;
  description: string;
  importance: 'high' | 'medium' | 'low';
  data?: any;
}

interface InstructionData {
  raw: Buffer;
  parsed?: any;
  discriminator?: string;
  args?: Record<string, any>;
}
```

### Program Registry

```typescript
interface ProgramInfo {
  programId: string;
  name: string;
  description: string;
  category: string;
  instructions: InstructionDefinition[];
  website?: string;
  documentation?: string;
}

interface InstructionDefinition {
  discriminator: string;
  name: string;
  description: string;
  accounts: AccountDefinition[];
  args: ArgumentDefinition[];
}
```

## Error Handling

### Transaction Loading Errors
- Transaction not found or invalid signature
- RPC timeout or connection issues
- Incomplete transaction data
- Historical transaction limitations

### Parsing Errors
- Unknown program instructions
- Malformed instruction data
- Missing account information
- Incomplete state data

### AI Analysis Errors
- LLM service unavailability
- Context too large for analysis
- Analysis timeout
- Confidence threshold not met

## Testing Strategy

### Unit Tests
- Instruction parsing accuracy
- Account change calculations
- AI explanation generation
- Related transaction discovery
- Graph construction algorithms

### Integration Tests
- End-to-end transaction analysis
- AI service integration
- RPC data fetching and parsing
- Graph visualization rendering
- Related transaction accuracy

### Performance Tests
- Large transaction parsing
- Complex instruction analysis
- AI explanation generation time
- Graph rendering performance
- Related transaction search speed

### User Experience Tests
- Transaction explanation clarity
- Graph interaction usability
- Mobile responsiveness
- Accessibility compliance
- Error state handling# Transaction Explorer Enhancements - Requirements Document

## Introduction

The Transaction Explorer currently provides basic transaction display but lacks detailed instruction parsing, account change visualization, AI-powered explanations, and related transaction discovery. These enhancements will transform it into a comprehensive transaction analysis tool that helps users understand complex Solana transactions.

## Requirements

### Requirement 1: Detailed Instruction Parsing and Display

**User Story:** As a developer, I want to see parsed transaction instructions with human-readable descriptions, so that I can understand what each instruction does.

#### Acceptance Criteria

1. WHEN a transaction loads THEN the system SHALL parse all instructions and display them in a structured format
2. WHEN displaying instructions THEN the system SHALL show program names, instruction types, and parameters
3. WHEN an instruction involves known programs THEN the system SHALL provide human-readable descriptions
4. WHEN displaying complex instructions THEN the system SHALL group related instructions together
5. WHEN instructions have nested calls THEN the system SHALL show the call hierarchy clearly

### Requirement 2: Account Changes Visualization

**User Story:** As a user, I want to see how account balances and data changed during a transaction, so that I can understand the transaction's impact.

#### Acceptance Criteria

1. WHEN a transaction loads THEN the system SHALL display before/after states for all affected accounts
2. WHEN showing account changes THEN the system SHALL highlight balance changes with clear visual indicators
3. WHEN accounts have token balances THEN the system SHALL show token balance changes separately
4. WHEN account data changes THEN the system SHALL display data diffs in a readable format
5. WHEN changes are significant THEN the system SHALL highlight them with appropriate visual emphasis

### Requirement 3: AI-Powered Transaction Explanation

**User Story:** As a non-technical user, I want AI to explain what a transaction does in plain English, so that I can understand complex blockchain operations.

#### Acceptance Criteria

1. WHEN a transaction loads THEN the system SHALL generate an AI explanation of the transaction's purpose
2. WHEN the AI analyzes a transaction THEN it SHALL identify the main action and secondary effects
3. WHEN explaining complex transactions THEN the AI SHALL break down the explanation into digestible parts
4. WHEN transactions involve DeFi protocols THEN the AI SHALL explain the financial implications
5. WHEN transactions are potentially suspicious THEN the AI SHALL highlight risk factors

### Requirement 4: Related Transaction Discovery

**User Story:** As an analyst, I want to find transactions related to the current one, so that I can trace transaction flows and understand broader patterns.

#### Acceptance Criteria

1. WHEN viewing a transaction THEN the system SHALL identify and display related transactions
2. WHEN finding related transactions THEN the system SHALL show relationships by account interactions
3. WHEN finding related transactions THEN the system SHALL show relationships by program usage
4. WHEN finding related transactions THEN the system SHALL show relationships by time proximity
5. WHEN displaying related transactions THEN the system SHALL rank them by relevance strength

### Requirement 5: Transaction Graph Visualization

**User Story:** As a user, I want to see a visual representation of transaction flows, so that I can understand complex multi-step operations.

#### Acceptance Criteria

1. WHEN viewing a transaction THEN the system SHALL provide an option to view it as a graph
2. WHEN displaying the transaction graph THEN accounts SHALL be shown as nodes
3. WHEN displaying the transaction graph THEN transfers SHALL be shown as directed edges
4. WHEN the graph is complex THEN the system SHALL provide zoom and pan controls
5. WHEN nodes are clicked THEN the system SHALL show detailed account information

### Requirement 6: Advanced Transaction Metrics

**User Story:** As a researcher, I want detailed metrics about transaction performance and costs, so that I can analyze transaction efficiency.

#### Acceptance Criteria

1. WHEN displaying a transaction THEN the system SHALL show detailed fee breakdown
2. WHEN displaying a transaction THEN the system SHALL show compute unit usage
3. WHEN displaying a transaction THEN the system SHALL show transaction size and efficiency metrics
4. WHEN comparing similar transactions THEN the system SHALL provide comparative analysis
5. WHEN transactions fail THEN the system SHALL provide detailed error analysis and suggestions# Transaction Explorer Enhancements - Implementation Plan

## Task Overview

This implementation plan enhances the existing Transaction Explorer with detailed instruction parsing, account change visualization, AI explanations, and related transaction discovery.

## Implementation Tasks

- [ ] 1. Enhance transaction data fetching and parsing
  - [x] 1.1 Upgrade transaction data collection
    - Modify existing transaction fetching to include pre/post account states
    - Add comprehensive instruction data collection
    - Implement transaction metadata enrichment
    - _Requirements: 1.1, 2.1_

  - [x] 1.2 Create instruction parsing service
    - Build instruction parser for common Solana programs
    - Create program registry with instruction definitions
    - Implement instruction categorization and description generation
    - _Requirements: 1.1, 1.2, 1.3_

- [ ] 2. Build detailed instruction display components
  - [x] 2.1 Create instruction breakdown component
    - Design hierarchical instruction display with nested calls
    - Implement program name resolution and instruction type identification
    - Add expandable/collapsible instruction details
    - _Requirements: 1.1, 1.4, 1.5_

  - [x] 2.2 Add instruction interaction features
    - Implement instruction hover tooltips with additional context
    - Add click-to-expand functionality for complex instructions
    - Create instruction filtering and search capabilities
    - _Requirements: 1.2, 1.3_

- [ ] 3. Implement account changes analysis and visualization
  - [x] 3.1 Build account changes analyzer
    - Create service to calculate before/after account states
    - Implement balance change detection and calculation
    - Add token balance change analysis
    - _Requirements: 2.1, 2.2, 2.3_

  - [x] 3.2 Create account changes display component
    - Design visual diff display for account changes
    - Implement balance change highlighting with color coding
    - Add token balance changes with metadata resolution
    - _Requirements: 2.2, 2.3, 2.5_

  - [x] 3.3 Add account data change visualization
    - Implement data diff visualization for account data changes
    - Create readable format for complex data structures
    - Add significance highlighting for major changes
    - _Requirements: 2.4, 2.5_

- [ ] 4. Integrate AI-powered transaction explanation
  - [x] 4.1 Build AI transaction analyzer service
    - Create service to generate natural language transaction explanations
    - Implement main action identification and secondary effects analysis
    - Add risk assessment and security analysis
    - _Requirements: 3.1, 3.2, 3.5_

  - [x] 4.2 Create AI explanation display component
    - Design explanation panel with summary and detailed breakdown
    - Implement progressive disclosure for technical details
    - Add regeneration and feedback functionality
    - _Requirements: 3.3, 3.4_

  - [x] 4.3 Add specialized DeFi transaction analysis
    - Implement DeFi protocol recognition and analysis
    - Add financial impact calculation and explanation
    - Create yield farming and liquidity analysis
    - _Requirements: 3.4_

- [ ] 5. Develop related transaction discovery
  - [x] 5.1 Build related transaction finder service
    - Implement account-based relationship discovery
    - Add program usage pattern analysis
    - Create temporal proximity detection
    - _Requirements: 4.1, 4.2, 4.3_

  - [x] 5.2 Create relationship strength scoring
    - Implement scoring algorithm for transaction relationships
    - Add relationship type classification
    - Create relevance ranking system
    - _Requirements: 4.4, 4.5_

  - [x] 5.3 Build related transactions display
    - Create related transactions panel with categorization
    - Implement relationship visualization and explanation
    - Add click-to-navigate functionality
    - _Requirements: 4.5_

- [ ] 6. Implement transaction graph visualization
  - [x] 6.1 Create transaction graph builder
    - Build graph data structure from transaction data
    - Implement node and edge creation for accounts and transfers
    - Add graph layout calculation and optimization
    - _Requirements: 5.1, 5.2, 5.3_

  - [x] 6.2 Build interactive graph component
    - Integrate D3.js or Cytoscape for graph rendering
    - Implement zoom, pan, and node interaction controls
    - Add node and edge click handlers with detailed information
    - _Requirements: 5.4, 5.5_

  - [x] 6.3 Add graph filtering and customization
    - Implement graph filtering by account types and amounts
    - Add layout options and visual customization
    - Create graph export functionality
    - _Requirements: 5.4_

- [ ] 7. Build advanced transaction metrics
  - [x] 7.1 Create transaction metrics calculator
    - Implement detailed fee breakdown analysis
    - Add compute unit usage tracking and analysis
    - Create transaction efficiency scoring
    - _Requirements: 6.1, 6.2, 6.3_

  - [x] 7.2 Build metrics display component
    - Design comprehensive metrics dashboard
    - Implement comparative analysis with similar transactions
    - Add performance benchmarking and recommendations
    - _Requirements: 6.4_

  - [x] 7.3 Add transaction failure analysis
    - Implement detailed error analysis for failed transactions
    - Create failure reason explanation and suggestions
    - Add retry and optimization recommendations
    - _Requirements: 6.5_

- [ ] 8. Enhance existing transaction content component
  - [x] 8.1 Integrate new components into TransactionContent
    - Modify existing TransactionContent to use enhanced components
    - Add tabbed interface for different analysis views
    - Implement responsive layout for all new features
    - _Requirements: All_

  - [x] 8.2 Add loading states and error handling
    - Implement progressive loading for different analysis phases
    - Add error boundaries and fallback states
    - Create retry mechanisms for failed analyses
    - _Requirements: All_

- [x] 9. Create program registry and instruction definitions
  - [x] 9.1 Build comprehensive program registry
    - Create database of known Solana programs
    - Add instruction definitions for major programs (SPL Token, System, etc.)
    - Implement program metadata and documentation links
    - _Requirements: 1.2, 1.3_

  - [x] 9.2 Add dynamic program discovery
    - Implement automatic program detection and categorization
    - Add community-contributed program definitions
    - Create program usage statistics and popularity tracking
    - _Requirements: 1.2_

- [x] 10. Implement caching and performance optimization
  - [x] 10.1 Add transaction analysis caching
    - Implement caching for parsed instructions and account changes
    - Add AI explanation caching to reduce API costs
    - Create related transaction caching with TTL
    - _Requirements: All_

  - [x] 10.2 Optimize for large transactions
    - Implement pagination for transactions with many instructions
    - Add lazy loading for related transactions
    - Create performance monitoring and optimization
    - _Requirements: 1.4, 4.5_

- [x] 11. Build API endpoints for enhanced features
  - [x] 11.1 Create transaction analysis endpoints
    - Add `/api/transaction/[signature]/analysis` endpoint
    - Implement `/api/transaction/[signature]/related` endpoint
    - Create `/api/transaction/[signature]/explain` endpoint
    - _Requirements: All_

  - [x] 11.2 Add supporting API services
    - Create program registry API endpoints
    - Add instruction definition lookup endpoints
    - Implement transaction metrics calculation endpoints
    - _Requirements: 1.2, 6.1_

- [x] 12. Add comprehensive testing
  - [x] 12.1 Write unit tests for analysis services
    - Test instruction parsing accuracy across different programs
    - Test account change calculation correctness
    - Test AI explanation generation and quality
    - _Requirements: All_

  - [x] 12.2 Create integration tests
    - Test end-to-end transaction analysis workflow
    - Test graph visualization rendering and interactions
    - Test related transaction discovery accuracy
    - _Requirements: All_

- [x] 13. Implement accessibility and mobile support
  - [x] 13.1 Add accessibility features
    - Implement keyboard navigation for all interactive elements
    - Add screen reader support for complex visualizations
    - Create high contrast mode for graph visualizations
    - _Requirements: All_

  - [x] 13.2 Optimize for mobile devices
    - Create responsive layouts for all new components
    - Implement touch-friendly graph interactions
    - Add mobile-optimized instruction display
    - _Requirements: All_

- [x] 14. Create user documentation and help
  - [x] 14.1 Add contextual help and tooltips
    - Create help text for all new features
    - Add tooltips explaining technical concepts
    - Implement guided tour for new users
    - _Requirements: All_

  - [x] 14.2 Build comprehensive documentation
    - Write user guide for enhanced transaction analysis
    - Create developer documentation for API endpoints
    - Add troubleshooting guide for common issues
    - _Requirements: All_

## Implementation Notes

### Development Approach
- Enhance existing components incrementally rather than replacing
- Implement caching early to support development and testing
- Use progressive enhancement to maintain backward compatibility
- Prioritize core parsing and analysis before advanced visualizations

### Technology Integration
- **Instruction Parsing**: Custom parsers for major programs, extensible architecture
- **AI Analysis**: Integration with existing AI infrastructure
- **Graph Visualization**: Reuse existing graph components where possible
- **Caching**: Leverage existing caching infrastructure

### Performance Considerations
- Implement lazy loading for expensive analysis operations
- Cache AI explanations to reduce API costs and improve response times
- Use Web Workers for intensive parsing operations
- Optimize graph rendering for transactions with many accounts

### Testing Strategy
- Use real transaction data for testing parsing accuracy
- Mock AI services for consistent testing
- Performance testing with complex transactions
- Cross-browser testing for graph visualizations# User Profile Enhancements Design

## Overview

The User Profile Enhancements design provides a comprehensive social platform for Solana users with profile management, social interactions, activity feeds, community features, and reputation systems. The system transforms wallet addresses into social identities, enabling users to connect, share insights, and build communities around their blockchain activities.

## Architecture

### High-Level Architecture

```mermaid
graph TB
    subgraph "Client Layer"
        A[User Profile Page] --> B[Activity Feed]
        A --> C[Social Features]
        A --> D[Community Groups]
        B --> E[Content Creation]
        C --> F[Messaging System]
    end
    
    subgraph "API Layer"
        G[User API] --> H[Profile Service]
        G --> I[Social Service]
        H --> J[Authentication Service]
        I --> K[Activity Service]
        L[Community API] --> M[Group Service]
        N[Messaging API] --> O[Chat Service]
    end
    
    subgraph "Data Layer"
        P[PostgreSQL] --> Q[User Profiles]
        P --> R[Social Graph]
        P --> S[Activity Feed]
        T[Redis Cache] --> U[Session Cache]
        T --> V[Feed Cache]
        W[File Storage] --> X[Profile Images]
        W --> Y[Content Media]
    end
    
    A --> G
    B --> K
    C --> I
    D --> L
    E --> K
    F --> N
    G --> P
    I --> P
    L --> P
    N --> P
```

### Component Architecture

The user profile system follows a social media architecture pattern:

- **Presentation Layer**: React components with real-time updates and social interactions
- **Service Layer**: User management, social graph, activity feeds, and community features
- **Data Access Layer**: PostgreSQL for structured social data and Redis for caching
- **Integration Layer**: External social platforms, wallet providers, and blockchain services

## Layout Design Scheme

### User Profile Page Layout (`/user/[walletAddress]`)

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                                User Profile                                         │
│                                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐ │
│  │                            Profile Header                                       │ │
│  │  ┌─────────────────┐  ┌──────────────────────────────────────────────────────┐ │ │
│  │  │                 │  │  @username • Verified ✓                             │ │ │
│  │  │   Profile       │  │  Display Name                                        │ │ │
│  │  │   Avatar        │  │  Bio: DeFi enthusiast and NFT collector...          │ │ │
│  │  │                 │  │  📍 Location • 🔗 website.com • 🐦 @twitter         │ │ │
│  │  │   [Edit]        │  │  Joined: Jan 2024 • Wallet: 0x1234...abcd           │ │ │
│  │  └─────────────────┘  └──────────────────────────────────────────────────────┘ │ │
│  └─────────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐ │
│  │                            Profile Stats                                        │ │
│  │  Following: 234 | Followers: 1,456 | Posts: 89 | Reputation: 8.7/10           │ │
│  │  Portfolio: $45,230 | Transactions: 2,345 | Programs: 23 | NFTs: 67           │ │
│  └─────────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐ │
│  │                              Action Buttons                                     │ │
│  │  [Follow] [Message] [Share Profile] [Add to List] [Report] [Block]             │ │
│  └─────────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐ │
│  │                              Tab Navigation                                     │ │
│  │  [ Posts ] [ Portfolio ] [ Activity ] [ NFTs ] [ Groups ] [ Achievements ]     │ │
│  └─────────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                     │
│  ┌─────────────────────────────────────────┐  ┌─────────────────────────────────────┐  │
│  │                                     │  │                                     │  │
│  │           Main Content              │  │            Sidebar                  │  │
│  │                                     │  │                                     │  │
│  │  (Content changes based on         │  │  • Achievements & Badges            │  │
│  │   selected tab)                    │  │    - Early Adopter                  │  │
│  │                                     │  │    - DeFi Expert                    │  │
│  │                                     │  │    - NFT Collector                  │  │
│  │                                     │  │                                     │  │
│  │                                     │  │  • Recent Activity                  │  │
│  │                                     │  │    - Swapped 100 USDC              │  │
│  │                                     │  │    - Joined DeFi Group             │  │
│  │                                     │  │    - Posted Analysis               │  │
│  │                                     │  │                                     │  │
│  │                                     │  │  • Mutual Connections              │  │
│  │                                     │  │    - @alice (DeFi Trader)          │  │
│  │                                     │  │    - @bob (NFT Artist)             │  │
│  │                                     │  │                                     │  │
│  └─────────────────────────────────────┘  └─────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────────────┘
```### Po
sts Tab Layout

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                                User Posts                                           │
│                                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐ │
│  │                          Create Post Section                                    │ │
│  │  ┌─────────────────────────────────────────────────────────────────────────────┐ │ │
│  │  │ What's happening in your blockchain journey?                                │ │ │
│  │  │ [Text Area for Post Content]                                                │ │ │
│  │  │                                                                             │ │ │
│  │  │ [📷 Image] [📊 Share Transaction] [💰 Share Portfolio] [🎯 Tag Users]       │ │ │
│  │  │                                              [Cancel] [Post] │ │ │
│  │  └─────────────────────────────────────────────────────────────────────────────┘ │ │
│  └─────────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐ │
│  │                              Posts Feed                                         │ │
│  │                                                                                 │ │
│  │  ┌─────────────────────────────────────────────────────────────────────────────┐ │ │
│  │  │ @username • 2h ago                                                          │ │ │
│  │  │                                                                             │ │ │
│  │  │ Just made a huge profit on my $BONK trade! 🚀                               │ │ │
│  │  │ Bought at $0.000012 and sold at $0.000018 (+50%)                           │ │ │
│  │  │                                                                             │ │ │
│  │  │ [Transaction Card: Swap 1000 SOL → 83.3M BONK]                             │ │ │
│  │  │                                                                             │ │ │
│  │  │ 💬 12 Comments  🔄 5 Reshares  ❤️ 23 Likes  📊 View Analysis               │ │ │
│  │  └─────────────────────────────────────────────────────────────────────────────┘ │ │
│  │                                                                                 │ │
│  │  ┌─────────────────────────────────────────────────────────────────────────────┐ │ │
│  │  │ @username • 5h ago                                                          │ │ │
│  │  │                                                                             │ │ │
│  │  │ New analysis on Solana DeFi trends 📈                                       │ │ │
│  │  │ TVL has grown 300% this quarter across major protocols...                  │ │ │
│  │  │                                                                             │ │ │
│  │  │ [Article Preview with thumbnail and excerpt]                               │ │ │
│  │  │                                                                             │ │ │
│  │  │ 💬 8 Comments  🔄 12 Reshares  ❤️ 45 Likes  📖 Read More                   │ │ │
│  │  └─────────────────────────────────────────────────────────────────────────────┘ │ │
│  │                                                                                 │ │
│  │  ┌─────────────────────────────────────────────────────────────────────────────┐ │ │
│  │  │ @username • 1d ago                                                          │ │ │
│  │  │                                                                             │ │ │
│  │  │ Minted my first NFT on Magic Eden! 🎨                                       │ │ │
│  │  │ Really excited about this new collection...                                 │ │ │
│  │  │                                                                             │ │ │
│  │  │ [NFT Image with metadata]                                                   │ │ │
│  │  │                                                                             │ │ │
│  │  │ 💬 15 Comments  🔄 3 Reshares  ❤️ 67 Likes  🖼️ View NFT                    │ │ │
│  │  └─────────────────────────────────────────────────────────────────────────────┘ │ │
│  │                                                                                 │ │
│  │ [Load More Posts]                                                               │ │
│  └─────────────────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

### Activity Feed Layout (`/feed`)

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                               Activity Feed                                         │
│                                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐ │
│  │                            Feed Controls                                        │ │
│  │  [🏠 Home] [🔥 Trending] [👥 Following] [🎯 For You] | [⚙️ Settings]            │ │
│  └─────────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                     │
│  ┌─────────────────────────────────────────┐  ┌─────────────────────────────────────┐  │
│  │                                     │  │                                     │  │
│  │           Main Feed                 │  │         Trending Sidebar            │  │
│  │                                     │  │                                     │  │
│  │  ┌─────────────────────────────────┐ │  │  • Trending Topics                  │  │
│  │  │ @alice • 1h ago                 │ │  │    #DeFiSummer                      │  │
│  │  │                                 │ │  │    #SolanaNFTs                      │  │
│  │  │ Amazing returns on my Jupiter   │ │  │    #MemeCoinMadness                 │  │
│  │  │ strategy this week! 📈           │ │  │                                     │  │
│  │  │                                 │ │  │  • Suggested Users                  │  │
│  │  │ [Portfolio Performance Chart]   │ │  │    @defi_expert (Follow)            │  │
│  │  │                                 │ │  │    @nft_collector (Follow)          │  │
│  │  │ 💬 5  🔄 2  ❤️ 12               │ │  │    @solana_dev (Follow)             │  │
│  │  └─────────────────────────────────┘ │  │                                     │  │
│  │                                     │  │  • Active Groups                     │  │
│  │  ┌─────────────────────────────────┐ │  │    DeFi Strategies (234 members)    │  │
│  │  │ @bob • 2h ago                   │ │  │    NFT Alpha (567 members)          │  │
│  │  │                                 │ │  │    Solana Developers (890 members)  │  │
│  │  │ Just discovered this hidden gem │ │  │                                     │  │
│  │  │ NFT collection 💎               │ │  │  • Recent Achievements              │  │
│  │  │                                 │ │  │    @charlie earned "DeFi Master"    │  │
│  │  │ [NFT Collection Preview]        │ │  │    @diana reached 1000 followers    │  │
│  │  │                                 │ │  │    @eve joined "Whale Club"         │  │
│  │  │ 💬 8  🔄 4  ❤️ 23               │ │  │                                     │  │
│  │  └─────────────────────────────────┘ │  │                                     │  │
│  │                                     │  │                                     │  │
│  │  ┌─────────────────────────────────┐ │  │                                     │  │
│  │  │ @charlie • 3h ago               │ │  │                                     │  │
│  │  │                                 │ │  │                                     │  │
│  │  │ Market analysis: SOL looking    │ │  │                                     │  │
│  │  │ bullish for next week 🚀        │ │  │                                     │  │
│  │  │                                 │ │  │                                     │  │
│  │  │ [Technical Analysis Chart]      │ │  │                                     │  │
│  │  │                                 │ │  │                                     │  │
│  │  │ 💬 15  🔄 7  ❤️ 34              │ │  │                                     │  │
│  │  └─────────────────────────────────┘ │  │                                     │  │
│  │                                     │  │                                     │  │
│  │ [Load More Posts]                   │  │                                     │  │
│  └─────────────────────────────────────┘  └─────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

### Groups/Communities Layout (`/groups`)

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                                Communities                                          │
│                                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐ │
│  │                           Community Controls                                    │ │
│  │  [🔍 Search Groups] [➕ Create Group] | Filter: [All ▼] Sort: [Popular ▼]       │ │
│  └─────────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐ │
│  │                            Featured Groups                                      │ │
│  │                                                                                 │ │
│  │  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────┐ │ │
│  │  │                 │  │                 │  │                 │  │             │ │ │
│  │  │   DeFi Alpha    │  │  NFT Collectors │  │ Solana Devs     │  │ Meme Coins  │ │ │
│  │  │                 │  │                 │  │                 │  │             │ │ │
│  │  │ 1,234 members   │  │ 2,567 members   │  │ 890 members     │  │ 3,456 mem.  │ │ │
│  │  │ 45 posts/day    │  │ 23 posts/day    │  │ 67 posts/day    │  │ 89 posts/d  │ │ │
│  │  │                 │  │                 │  │                 │  │             │ │ │
│  │  │ [Join Group]    │  │ [Join Group]    │  │ [Join Group]    │  │ [Join Group]│ │ │
│  │  └─────────────────┘  └─────────────────┘  └─────────────────┘  └─────────────┘ │ │
│  └─────────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐ │
│  │                             Your Groups                                         │ │
│  │                                                                                 │ │
│  │ Group Name        | Members | Activity | Role      | Last Visit | Actions      │ │
│  │ ───────────────── | ─────── | ──────── | ───────── | ────────── | ──────────── │ │
│  │ DeFi Strategies   | 1,234   | High     | Admin     | 2h ago     | [Manage]     │ │
│  │ NFT Alpha         | 567     | Medium   | Member    | 1d ago     | [View]       │ │
│  │ Solana News       | 2,890   | High     | Moderator | 4h ago     | [Moderate]   │ │
│  │ Trading Tips      | 445     | Low      | Member    | 3d ago     | [View]       │ │
│  │                                                                                 │ │
│  └─────────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐ │
│  │                           Discover Groups                                       │ │
│  │                                                                                 │ │
│  │  Categories: [DeFi] [NFT] [Gaming] [Development] [Trading] [General]           │ │
│  │                                                                                 │ │
│  │  ┌─────────────────────────────────────────────────────────────────────────────┐ │ │
│  │  │ 🏛️ Jupiter Trading Strategies                                               │ │ │
│  │  │ Advanced trading strategies and market analysis for Jupiter DEX             │ │ │
│  │  │ 2,345 members • 156 posts this week • Very Active                          │ │ │
│  │  │ Tags: #DeFi #Trading #Jupiter #Strategies                                   │ │ │
│  │  │                                                        [Join Group]        │ │ │
│  │  └─────────────────────────────────────────────────────────────────────────────┘ │ │
│  │                                                                                 │ │
│  │  ┌─────────────────────────────────────────────────────────────────────────────┐ │ │
│  │  │ 🎨 Solana NFT Artists                                                       │ │ │
│  │  │ Community for NFT artists and creators on Solana                           │ │ │
│  │  │ 1,567 members • 89 posts this week • Active                                │ │ │
│  │  │ Tags: #NFT #Art #Creators #Community                                        │ │ │
│  │  │                                                        [Join Group]        │ │ │
│  │  └─────────────────────────────────────────────────────────────────────────────┘ │ │
│  │                                                                                 │ │
│  │ [Load More Groups]                                                              │ │
│  └─────────────────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

### Messaging Interface Layout (`/messages`)

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                                Messages                                             │
│                                                                                     │
│  ┌─────────────────────────────────────┐  ┌─────────────────────────────────────┐  │
│  │                                     │  │                                     │  │
│  │        Conversations List           │  │          Chat Window                │  │
│  │                                     │  │                                     │  │
│  │  [🔍 Search conversations]          │  │  @alice • Online                    │  │
│  │                                     │  │  ┌─────────────────────────────────┐ │  │
│  │  ┌─────────────────────────────────┐ │  │  │                                 │ │  │
│  │  │ @alice • 2m ago                 │ │  │  │        Chat Messages            │ │  │
│  │  │ Hey, saw your Jupiter analysis  │ │  │  │                                 │ │  │
│  │  │ 💬 2 unread                     │ │  │  │  alice: Hey, saw your Jupiter   │ │  │
│  │  └─────────────────────────────────┘ │  │  │         analysis! Great work    │ │  │
│  │                                     │  │  │                            2m   │ │  │
│  │  ┌─────────────────────────────────┐ │  │  │                                 │ │  │
│  │  │ @bob • 1h ago                   │ │  │  │  you: Thanks! I spent a lot of  │ │  │
│  │  │ Thanks for the NFT tip!         │ │  │  │       time researching it       │ │  │
│  │  │                                 │ │  │  │                            1m   │ │  │
│  │  └─────────────────────────────────┘ │  │  │                                 │ │  │
│  │                                     │  │  │  alice: Would love to discuss    │ │  │
│  │  ┌─────────────────────────────────┐ │  │  │         more strategies         │ │  │
│  │  │ @charlie • 3h ago               │ │  │  │                           30s   │ │  │
│  │  │ Group: DeFi Alpha               │ │  │  │                                 │ │  │
│  │  │ New market update posted        │ │  │  └─────────────────────────────────┘ │  │
│  │  └─────────────────────────────────┘ │  │                                     │  │
│  │                                     │  │  ┌─────────────────────────────────┐ │  │
│  │  ┌─────────────────────────────────┐ │  │  │ Type a message...               │ │  │
│  │  │ @diana • 1d ago                 │ │  │  │                                 │ │  │
│  │  │ Portfolio review session?       │ │  │  │ [📎] [😊] [💰] [📊]      [Send] │ │  │
│  │  │                                 │ │  │  └─────────────────────────────────┘ │  │
│  │  └─────────────────────────────────┘ │  │                                     │  │
│  │                                     │  │                                     │  │
│  │ [New Message]                       │  │                                     │  │
│  └─────────────────────────────────────┘  └─────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────────────┘
```# User Profile Enhancements Requirements

## Introduction

The User Profile Enhancements provide social features and user-centric functionality for Solana wallet addresses, including user profiles, social interactions, activity feeds, following systems, and community features. This system transforms basic wallet viewing into a social platform for blockchain users to connect, share insights, and build communities around their on-chain activities.

## Requirements

### Requirement 1: User Profile Creation and Management

**User Story:** As a blockchain user, I want to create and customize a profile for my wallet address with personal information and preferences, so that I can establish my identity and connect with other users in the ecosystem.

#### Acceptance Criteria

1. WHEN a user connects their wallet THEN the system SHALL create a basic profile with wallet address as identifier
2. WHEN profile customization is accessed THEN the system SHALL allow setting display name, bio, avatar image, and social links
3. WHEN profile verification is requested THEN the system SHALL provide wallet signature verification for profile ownership
4. WHEN profile privacy is configured THEN the system SHALL allow users to set visibility levels for different profile elements
5. WHEN profile badges are earned THEN the system SHALL display achievement badges, verification status, and community roles
6. WHEN profile is updated THEN the system SHALL validate changes and update profile information in real-time
7. WHEN profile deletion is requested THEN the system SHALL provide secure profile deletion with data retention policies
8. WHEN profile recovery is needed THEN the system SHALL allow profile recovery through wallet signature verification

### Requirement 2: Social Following and Connection System

**User Story:** As a community member, I want to follow other users and build a network of connections, so that I can stay updated on their activities and discover interesting blockchain interactions.

#### Acceptance Criteria

1. WHEN following another user THEN the system SHALL create a following relationship and update follower counts
2. WHEN unfollowing a user THEN the system SHALL remove the following relationship and update counts accordingly
3. WHEN viewing followers THEN the system SHALL display list of users following the current profile with pagination
4. WHEN viewing following THEN the system SHALL display list of users the current profile follows with management options
5. WHEN mutual connections exist THEN the system SHALL highlight mutual followers and suggest connections
6. WHEN follow notifications are enabled THEN the system SHALL notify users of new followers and follow-backs
7. WHEN privacy settings are applied THEN the system SHALL respect user preferences for follower visibility
8. WHEN blocking users THEN the system SHALL provide blocking functionality to prevent unwanted interactions

### Requirement 3: Activity Feed and Social Sharing

**User Story:** As an active user, I want to share my blockchain activities and see updates from users I follow, so that I can engage with the community and discover interesting transactions and insights.

#### Acceptance Criteria

1. WHEN sharing activities THEN the system SHALL allow users to share transactions, achievements, and insights with commentary
2. WHEN activity feed is viewed THEN the system SHALL display chronological feed of activities from followed users
3. WHEN interacting with posts THEN the system SHALL support likes, comments, and reshares for shared content
4. WHEN content is moderated THEN the system SHALL provide reporting and moderation tools for inappropriate content
5. WHEN privacy controls are used THEN the system SHALL allow users to control who can see their shared activities
6. WHEN feed is personalized THEN the system SHALL use algorithms to show relevant and engaging content
7. WHEN notifications are configured THEN the system SHALL notify users of interactions on their shared content
8. WHEN content is searched THEN the system SHALL provide search functionality across shared activities and comments

### Requirement 4: Community Features and Groups

**User Story:** As a community organizer, I want to create and manage groups around specific interests or projects, so that users can collaborate and share knowledge within focused communities.

#### Acceptance Criteria

1. WHEN creating groups THEN the system SHALL allow users to create communities around specific topics or projects
2. WHEN joining groups THEN the system SHALL provide group discovery and joining mechanisms with approval processes
3. WHEN managing groups THEN the system SHALL provide moderation tools, member management, and group settings
4. WHEN group activities occur THEN the system SHALL track group discussions, shared content, and member interactions
5. WHEN group events are created THEN the system SHALL support event creation, RSVP tracking, and event notifications
6. WHEN group analytics are viewed THEN the system SHALL provide insights on group growth, engagement, and activity
7. WHEN group privacy is configured THEN the system SHALL support public, private, and invite-only group types
8. WHEN group content is moderated THEN the system SHALL provide community guidelines enforcement and content moderation

### Requirement 5: Reputation and Achievement System

**User Story:** As a platform user, I want to build reputation and earn achievements based on my blockchain activities and community participation, so that I can demonstrate my expertise and contributions.

#### Acceptance Criteria

1. WHEN activities are tracked THEN the system SHALL calculate reputation scores based on transaction history, community participation, and contributions
2. WHEN achievements are earned THEN the system SHALL award badges for milestones, special activities, and community contributions
3. WHEN reputation is displayed THEN the system SHALL show reputation scores, levels, and progress indicators on profiles
4. WHEN leaderboards are viewed THEN the system SHALL provide rankings based on different reputation metrics and achievements
5. WHEN reputation factors are calculated THEN the system SHALL consider transaction volume, DeFi participation, NFT activities, and social engagement
6. WHEN achievement verification occurs THEN the system SHALL verify achievements through on-chain data and community validation
7. WHEN reputation decay is applied THEN the system SHALL implement time-based reputation decay to maintain active participation
8. WHEN reputation abuse is detected THEN the system SHALL prevent gaming and manipulation of reputation systems

### Requirement 6: User Discovery and Recommendations

**User Story:** As a new user, I want to discover interesting users and receive recommendations for people to follow, so that I can quickly build a relevant network and find valuable content.

#### Acceptance Criteria

1. WHEN user discovery is accessed THEN the system SHALL provide user search with filters for interests, activity level, and reputation
2. WHEN recommendations are generated THEN the system SHALL suggest users based on similar activities, mutual connections, and interests
3. WHEN trending users are displayed THEN the system SHALL highlight users with high activity, engagement, or recent achievements
4. WHEN user categories are browsed THEN the system SHALL organize users by categories like DeFi experts, NFT collectors, developers, traders
5. WHEN discovery algorithms run THEN the system SHALL use machine learning to improve recommendation accuracy over time
6. WHEN onboarding occurs THEN the system SHALL provide guided user discovery during initial platform setup
7. WHEN discovery preferences are set THEN the system SHALL allow users to customize discovery criteria and recommendation types
8. WHEN privacy is maintained THEN the system SHALL respect user privacy preferences in discovery and recommendations

### Requirement 7: Messaging and Communication System

**User Story:** As a community member, I want to communicate directly with other users through messaging and comments, so that I can build relationships and collaborate on blockchain activities.

#### Acceptance Criteria

1. WHEN direct messaging is used THEN the system SHALL provide private messaging between users with encryption
2. WHEN message threads are managed THEN the system SHALL organize conversations, support message history, and provide search functionality
3. WHEN group messaging occurs THEN the system SHALL support group chats and community discussions
4. WHEN message notifications are sent THEN the system SHALL provide real-time notifications for new messages and mentions
5. WHEN message moderation is applied THEN the system SHALL provide spam filtering, blocking, and reporting mechanisms
6. WHEN message privacy is configured THEN the system SHALL allow users to control who can message them and message visibility
7. WHEN message encryption is used THEN the system SHALL implement end-to-end encryption for sensitive communications
8. WHEN message retention is managed THEN the system SHALL provide message retention policies and deletion options

### Requirement 8: Portfolio Sharing and Analysis

**User Story:** As a trader or investor, I want to share my portfolio performance and analysis with the community, so that I can showcase my strategies and learn from others.

#### Acceptance Criteria

1. WHEN portfolios are shared THEN the system SHALL allow users to share portfolio snapshots, performance metrics, and analysis
2. WHEN portfolio privacy is controlled THEN the system SHALL provide granular privacy controls for different portfolio elements
3. WHEN portfolio comparisons are made THEN the system SHALL enable portfolio comparison tools and benchmarking
4. WHEN portfolio insights are generated THEN the system SHALL provide AI-powered insights and recommendations for shared portfolios
5. WHEN portfolio discussions occur THEN the system SHALL support comments and discussions on shared portfolio content
6. WHEN portfolio tracking is enabled THEN the system SHALL allow users to track and follow other users' portfolio performance
7. WHEN portfolio analytics are provided THEN the system SHALL offer detailed analytics and performance attribution for shared portfolios
8. WHEN portfolio education is delivered THEN the system SHALL provide educational content and strategy explanations

### Requirement 9: Event and Activity Coordination

**User Story:** As an event organizer, I want to create and manage blockchain-related events and activities, so that I can bring the community together for learning and networking.

#### Acceptance Criteria

1. WHEN events are created THEN the system SHALL allow users to create events with details, location, time, and requirements
2. WHEN event discovery occurs THEN the system SHALL provide event browsing, filtering, and search functionality
3. WHEN event participation is managed THEN the system SHALL handle RSVP tracking, attendee management, and capacity limits
4. WHEN event notifications are sent THEN the system SHALL provide event reminders, updates, and communication tools
5. WHEN event verification is performed THEN the system SHALL verify event attendance through various mechanisms
6. WHEN event feedback is collected THEN the system SHALL gather feedback, ratings, and reviews for events
7. WHEN event analytics are provided THEN the system SHALL offer insights on event success, attendance, and engagement
8. WHEN event integration occurs THEN the system SHALL integrate with external calendar and event management systems

### Requirement 10: Content Creation and Curation

**User Story:** As a content creator, I want to create and curate blockchain-related content for the community, so that I can share knowledge and build my reputation as a thought leader.

#### Acceptance Criteria

1. WHEN content is created THEN the system SHALL support various content types including articles, tutorials, analysis, and multimedia
2. WHEN content is published THEN the system SHALL provide publishing tools, formatting options, and media embedding
3. WHEN content is curated THEN the system SHALL allow users to curate and organize content collections around specific topics
4. WHEN content is discovered THEN the system SHALL provide content discovery through search, categories, and recommendations
5. WHEN content is engaged with THEN the system SHALL track views, likes, shares, and comments for content analytics
6. WHEN content is monetized THEN the system SHALL provide options for content monetization and creator rewards
7. WHEN content quality is maintained THEN the system SHALL implement content moderation and quality control mechanisms
8. WHEN content is attributed THEN the system SHALL ensure proper attribution and prevent plagiarism

### Requirement 11: Privacy and Security Controls

**User Story:** As a privacy-conscious user, I want comprehensive privacy and security controls for my profile and activities, so that I can participate in the community while protecting my sensitive information.

#### Acceptance Criteria

1. WHEN privacy settings are configured THEN the system SHALL provide granular privacy controls for all profile elements and activities
2. WHEN data encryption is applied THEN the system SHALL encrypt sensitive user data and communications
3. WHEN access controls are implemented THEN the system SHALL provide role-based access controls and permission management
4. WHEN audit trails are maintained THEN the system SHALL log all access and modifications to user data for security monitoring
5. WHEN data portability is requested THEN the system SHALL allow users to export their data in standard formats
6. WHEN account security is managed THEN the system SHALL provide two-factor authentication and security monitoring
7. WHEN privacy compliance is maintained THEN the system SHALL comply with relevant privacy regulations and standards
8. WHEN data deletion is requested THEN the system SHALL provide secure data deletion with verification of removal

### Requirement 12: Integration with External Platforms

**User Story:** As a multi-platform user, I want to integrate my profile with external social platforms and blockchain services, so that I can maintain a unified online presence and leverage existing networks.

#### Acceptance Criteria

1. WHEN social integration is configured THEN the system SHALL integrate with Twitter, Discord, Telegram, and other social platforms
2. WHEN cross-platform sharing occurs THEN the system SHALL enable sharing of activities and achievements to external platforms
3. WHEN identity verification is performed THEN the system SHALL verify social media accounts and external identities
4. WHEN data synchronization happens THEN the system SHALL sync relevant data from connected platforms while respecting privacy
5. WHEN external notifications are managed THEN the system SHALL provide notification management across integrated platforms
6. WHEN platform APIs are used THEN the system SHALL integrate with blockchain service APIs for enhanced functionality
7. WHEN single sign-on is implemented THEN the system SHALL support SSO with major platforms and wallet providers
8. WHEN integration security is maintained THEN the system SHALL secure all external integrations and API communications

### Requirement 13: Mobile Application and Responsive Design

**User Story:** As a mobile user, I want full social functionality on mobile devices with native app features, so that I can stay connected and engaged with the community while on-the-go.

#### Acceptance Criteria

1. WHEN mobile interface is used THEN the system SHALL provide responsive design optimized for mobile screens and touch interactions
2. WHEN mobile app features are utilized THEN the system SHALL support push notifications, offline functionality, and device integration
3. WHEN mobile performance is optimized THEN the system SHALL load quickly and efficiently on mobile networks with data optimization
4. WHEN mobile-specific features are implemented THEN the system SHALL utilize device capabilities like camera, GPS, and biometric authentication
5. WHEN cross-device synchronization occurs THEN the system SHALL sync user data and preferences across all devices
6. WHEN mobile accessibility is provided THEN the system SHALL comply with mobile accessibility standards and guidelines
7. WHEN mobile security is maintained THEN the system SHALL implement mobile-specific security measures and secure storage
8. WHEN mobile user experience is optimized THEN the system SHALL provide intuitive navigation and mobile-first design patterns

### Requirement 14: Analytics and Insights for Users

**User Story:** As a data-driven user, I want detailed analytics and insights about my social activities and community engagement, so that I can optimize my participation and measure my impact.

#### Acceptance Criteria

1. WHEN user analytics are generated THEN the system SHALL provide comprehensive analytics on profile views, engagement, and growth
2. WHEN social metrics are calculated THEN the system SHALL track follower growth, content performance, and interaction rates
3. WHEN community impact is measured THEN the system SHALL assess user influence, contribution quality, and community value
4. WHEN trend analysis is performed THEN the system SHALL identify trends in user behavior, content performance, and community engagement
5. WHEN comparative analytics are provided THEN the system SHALL benchmark user performance against peers and community averages
6. WHEN predictive insights are generated THEN the system SHALL provide recommendations for improving engagement and community impact
7. WHEN analytics visualization is displayed THEN the system SHALL present analytics through interactive charts, graphs, and dashboards
8. WHEN analytics export is enabled THEN the system SHALL allow users to export their analytics data for external analysis# User Profile Enhancements Implementation Plan

- [ ] 1. Set up core user profile infrastructure and authentication system
  - Create user profile data models and interfaces for social features
  - Implement wallet-based authentication and profile creation system
  - Set up API endpoints for user management, profiles, and social interactions
  - Configure database schema for users, social graph, and activity feeds
  - _Requirements: 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8_

- [ ] 1.1 Create user profile data models and TypeScript interfaces
  - Create `lib/types/user.types.ts` with comprehensive UserProfile interface including walletAddress, displayName, bio, avatar, socialLinks[], verified, joinDate, privacy settings
  - Define SocialGraph interface with following[], followers[], mutualConnections[], relationshipStrength, connectionDate
  - Create ActivityFeed interface with posts[], interactions[], sharedContent[], visibility, timestamp, engagement metrics
  - Implement UserSettings interface with privacy controls, notification preferences, theme settings, language preferences
  - Define CommunityGroup interface with groupId, name, description, members[], moderators[], privacy, rules[], activity metrics
  - Create ReputationSystem interface with score, level, badges[], achievements[], contributionMetrics, trustScore
  - Add MessagingSystem interface with conversations[], messages[], participants[], encryption, messageStatus
  - Implement ContentCreation interface with posts[], articles[], media[], tags[], engagement, monetization
  - _Requirements: 1.1, 1.2, 1.3, 1.4_

- [ ] 1.2 Implement wallet-based authentication and profile creation
  - Create `lib/auth/wallet-auth.ts` with WalletAuthService class implementing connectWallet(), verifySignature(), createProfile(), updateProfile() methods
  - Implement wallet signature verification for profile ownership and authentication, support multiple wallet providers (Phantom, Solflare, Backpack)
  - Add profile creation flow: automatic profile generation on first wallet connection, guided profile setup with display name and bio, avatar upload and social links
  - Create profile verification system: verify wallet ownership through signature, verify social media accounts through OAuth, implement verification badges and trust scores
  - Implement session management: JWT token generation and validation, session persistence across devices, secure logout and session cleanup
  - Add profile recovery mechanisms: recover profile through wallet signature, handle wallet changes and profile migration, backup and restore profile data
  - _Requirements: 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8_

- [ ] 1.3 Set up core user API endpoints and database schema
  - Create `app/api/user/[walletAddress]/route.ts` with GET/PUT handlers for user profile management, profile data retrieval, privacy controls, profile updates
  - Implement `app/api/user/[walletAddress]/social/route.ts` with endpoints for following/unfollowing users, retrieving followers/following lists, managing social connections
  - Add `app/api/user/[walletAddress]/feed/route.ts` with GET/POST handlers for activity feed management, post creation, feed retrieval with pagination
  - Create `app/api/auth/wallet/route.ts` with POST handler for wallet authentication, signature verification, session creation, profile linking
  - Implement database schema in PostgreSQL: users table, social_connections table, activity_feed table, user_settings table, groups table, messages table
  - Add database indexes for performance: wallet_address, user_id, follower/following relationships, activity feed queries, message threads
  - _Requirements: 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8_

- [ ] 2. Build user profile page with social features and customization
  - Create UserProfilePage component with profile header, stats, and tabbed interface
  - Implement profile customization with avatar upload, bio editing, and social links
  - Add social interaction features like following, messaging, and profile sharing
  - _Requirements: 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8_

- [ ] 2.1 Create UserProfilePage main component and layout
  - Create `app/user/[walletAddress]/page.tsx` as server component with generateMetadata() for dynamic SEO, implement getUserProfile() server function, handle loading states with Suspense
  - Build responsive profile layout: profile header with avatar and info, profile stats bar, action buttons, tabbed navigation, main content area with sidebar
  - Implement `components/ProfileHeader.tsx` with avatar display, display name, bio, social links, verification badges, join date, wallet address with copy functionality
  - Add `components/ProfileStats.tsx` showing followers, following, posts, reputation score, portfolio value, transaction count, with real-time updates
  - Create `components/ProfileActions.tsx` with follow/unfollow button, message button, share profile, add to list, report/block options
  - Implement URL parameter validation and error handling for invalid wallet addresses, profile not found scenarios, privacy restrictions
  - _Requirements: 1.1, 1.2, 1.3_

- [ ] 2.2 Implement profile customization and editing features
  - Create `components/ProfileEditor.tsx` modal component with form fields for display name, bio, location, website, social media links
  - Implement `components/AvatarUpload.tsx` with drag-and-drop image upload, image cropping and resizing, file validation, IPFS storage integration
  - Add `components/PrivacySettings.tsx` with granular privacy controls for profile visibility, activity sharing, follower lists, messaging permissions
  - Create `components/SocialLinksManager.tsx` for adding/removing social media accounts, OAuth verification for Twitter/Discord/Telegram, link validation
  - Implement profile preview functionality: preview changes before saving, revert changes option, validation and error handling for all fields
  - Add profile themes and customization: color schemes, layout preferences, display options, accessibility settings
  - _Requirements: 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8_

- [ ] 2.3 Build social interaction features and relationship management
  - Create `components/FollowButton.tsx` with follow/unfollow functionality, loading states, follow-back detection, mutual connection indicators
  - Implement `components/FollowersList.tsx` and `components/FollowingList.tsx` with paginated user lists, search functionality, mutual connections highlighting
  - Add `components/MessageButton.tsx` with direct messaging initiation, conversation creation, message thread navigation
  - Create `components/ProfileSharing.tsx` with share profile functionality, social media sharing, profile link generation, QR code generation
  - Implement relationship strength calculation: interaction frequency, mutual connections, shared interests, engagement levels
  - Add blocking and reporting features: block users, report inappropriate profiles, privacy protection, content moderation
  - _Requirements: 2.1, 2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8_

- [ ] 3. Implement activity feed and social sharing system
  - Create activity feed with post creation, sharing, and engagement features
  - Build content creation tools for sharing transactions, portfolios, and insights
  - Implement feed algorithms for personalized content discovery
  - _Requirements: 3.1, 3.2, 3.3, 3.4, 3.5, 3.6, 3.7, 3.8_

- [ ] 3.1 Build activity feed and post creation system
  - Create `components/ActivityFeed.tsx` with infinite scroll, real-time updates, post filtering, engagement tracking
  - Implement `components/PostCreator.tsx` with rich text editor, media upload, transaction sharing, portfolio sharing, user tagging
  - Add `components/PostCard.tsx` displaying post content, author info, engagement metrics (likes, comments, shares), interaction buttons
  - Create `components/PostEngagement.tsx` with like/unlike functionality, comment system, reshare options, bookmark features
  - Implement post types: text posts, image posts, transaction shares, portfolio updates, article links, poll posts
  - Add content moderation: spam detection, inappropriate content filtering, community reporting, automated moderation
  - _Requirements: 3.1, 3.2, 3.3, 3.4, 3.5, 3.6, 3.7, 3.8_

- [ ] 3.2 Create content sharing and transaction integration
  - Create `components/TransactionShare.tsx` for sharing transaction details with commentary, transaction analysis, performance metrics
  - Implement `components/PortfolioShare.tsx` with portfolio snapshot sharing, performance highlights, privacy controls for sensitive data
  - Add `components/MediaUpload.tsx` with image/video upload, file validation, compression, IPFS storage, thumbnail generation
  - Create `components/ContentEmbed.tsx` for embedding external content: articles, videos, tweets, blockchain data, market charts
  - Implement content templates: transaction analysis template, portfolio update template, market insight template, educational content template
  - Add content scheduling: schedule posts for optimal engagement times, draft management, content calendar integration
  - _Requirements: 3.1, 3.2, 3.3, 3.4, 3.5, 3.6, 3.7, 3.8_

- [ ] 3.3 Build feed algorithms and content discovery
  - Create `lib/algorithms/feed-algorithm.ts` with FeedAlgorithm class implementing generateFeed(), rankContent(), personalizeContent() methods
  - Implement content ranking: engagement-based ranking, recency weighting, user interest matching, social graph influence
  - Add personalization features: user interest tracking, content preference learning, engagement pattern analysis, recommendation engine
  - Create feed types: chronological feed, algorithmic feed, trending content, following-only feed, topic-based feeds
  - Implement content filtering: hide seen content, filter by content type, keyword filtering, user-defined filters
  - Add trending detection: identify viral content, trending topics, popular users, engagement spikes, community discussions
  - _Requirements: 3.1, 3.2, 3.3, 3.4, 3.5, 3.6, 3.7, 3.8_

- [ ] 4. Build community groups and collaboration features
  - Create community group system with creation, management, and participation
  - Implement group discussions, events, and collaborative features
  - Build group discovery and recommendation system
  - _Requirements: 4.1, 4.2, 4.3, 4.4, 4.5, 4.6, 4.7, 4.8_

- [ ] 4.1 Build community group creation and management system
  - Create `components/GroupCreator.tsx` with group creation form, group settings, privacy options, member management tools
  - Implement `components/GroupManagement.tsx` with admin controls, moderator assignment, member approval, group settings, rule management
  - Add `components/GroupDiscovery.tsx` with group search, category browsing, featured groups, recommendation engine
  - Create `components/GroupCard.tsx` displaying group info, member count, activity level, join button, group preview
  - Implement group types: public groups, private groups, invite-only groups, paid groups, verified groups
  - Add group moderation tools: content moderation, member management, rule enforcement, reporting system, automated moderation
  - _Requirements: 4.1, 4.2, 4.3, 4.4, 4.5, 4.6, 4.7, 4.8_

- [ ] 4.2 Create group discussion and collaboration features
  - Create `components/GroupFeed.tsx` with group-specific activity feed, discussion threads, pinned posts, announcement system
  - Implement `components/GroupChat.tsx` with real-time group messaging, thread discussions, file sharing, voice/video calls
  - Add `components/GroupEvents.tsx` with event creation, RSVP tracking, event calendar, reminder system, virtual event integration
  - Create `components/GroupProjects.tsx` for collaborative projects, task management, resource sharing, progress tracking
  - Implement group roles and permissions: admin, moderator, member, contributor roles with specific permissions and capabilities
  - Add group analytics: member engagement, content performance, growth metrics, activity insights, member retention
  - _Requirements: 4.1, 4.2, 4.3, 4.4, 4.5, 4.6, 4.7, 4.8_

- [ ] 5. Implement reputation and achievement system
  - Create reputation calculation engine with multiple scoring factors
  - Build achievement system with badges, levels, and recognition
  - Implement leaderboards and community recognition features
  - _Requirements: 5.1, 5.2, 5.3, 5.4, 5.5, 5.6, 5.7, 5.8_

- [ ] 5.1 Build reputation calculation and scoring system
  - Create `lib/reputation/reputation-engine.ts` with ReputationEngine class implementing calculateScore(), updateReputation(), trackContributions() methods
  - Implement reputation factors: transaction volume and frequency, DeFi participation, NFT activities, community engagement, content quality, social interactions
  - Add reputation decay: time-based decay to encourage continued activity, activity-based maintenance, reputation recovery mechanisms
  - Create reputation categories: trading reputation, DeFi expertise, NFT knowledge, community contribution, technical expertise, social influence
  - Implement reputation verification: on-chain verification of activities, community validation, peer review system, anti-gaming measures
  - Add reputation display: reputation scores, level indicators, category breakdowns, progress tracking, reputation history
  - _Requirements: 5.1, 5.2, 5.3, 5.4, 5.5, 5.6, 5.7, 5.8_

- [ ] 5.2 Create achievement and badge system
  - Create `components/AchievementSystem.tsx` with badge display, achievement tracking, progress indicators, unlock notifications
  - Implement achievement categories: trading achievements, DeFi milestones, NFT collector badges, community contributor awards, social influence recognition
  - Add achievement verification: on-chain data verification, community validation, manual review for special achievements
  - Create achievement rarity: common, rare, epic, legendary achievements with different unlock requirements and recognition levels
  - Implement achievement sharing: share achievements on social media, display on profile, achievement showcase, celebration posts
  - Add achievement rewards: reputation bonuses, special privileges, exclusive access, community recognition, monetary rewards
  - _Requirements: 5.1, 5.2, 5.3, 5.4, 5.5, 5.6, 5.7, 5.8_

- [ ] 6. Build messaging and communication system
  - Create direct messaging system with encryption and privacy
  - Implement group messaging and community discussions
  - Build notification system for all communication channels
  - _Requirements: 7.1, 7.2, 7.3, 7.4, 7.5, 7.6, 7.7, 7.8_

- [ ] 6.1 Build direct messaging system with encryption
  - Create `components/MessagingInterface.tsx` with conversation list, chat window, message composition, file sharing
  - Implement `lib/messaging/encryption.ts` with end-to-end encryption for sensitive messages, key management, secure message storage
  - Add `components/ConversationList.tsx` with conversation search, unread indicators, conversation management, archive functionality
  - Create `components/ChatWindow.tsx` with message display, typing indicators, read receipts, message reactions, reply functionality
  - Implement message types: text messages, image/video sharing, file attachments, transaction sharing, voice messages, location sharing
  - Add message moderation: spam filtering, inappropriate content detection, user blocking, message reporting, automated moderation
  - _Requirements: 7.1, 7.2, 7.3, 7.4, 7.5, 7.6, 7.7, 7.8_

- [ ] 6.2 Create notification system and communication management
  - Create `lib/notifications/notification-service.ts` with NotificationService class implementing sendNotification(), managePreferences(), trackDelivery() methods
  - Implement notification types: follow notifications, message alerts, post interactions, group activities, achievement unlocks, system announcements
  - Add notification channels: in-app notifications, email notifications, push notifications, webhook notifications, SMS notifications
  - Create `components/NotificationCenter.tsx` with notification list, read/unread status, notification actions, notification history
  - Implement notification preferences: granular notification controls, quiet hours, notification frequency, channel preferences
  - Add real-time notifications: WebSocket-based real-time updates, notification badges, sound alerts, desktop notifications
  - _Requirements: 7.1, 7.2, 7.3, 7.4, 7.5, 7.6, 7.7, 7.8_

- [ ] 7. Implement user discovery and recommendation system
  - Create user discovery engine with search and filtering
  - Build recommendation algorithms for user connections
  - Implement trending users and community highlights
  - _Requirements: 6.1, 6.2, 6.3, 6.4, 6.5, 6.6, 6.7, 6.8_

- [ ] 7.1 Build user discovery and search system
  - Create `components/UserDiscovery.tsx` with user search, advanced filters, category browsing, trending users section
  - Implement `lib/discovery/user-search.ts` with UserSearchEngine class implementing searchUsers(), filterUsers(), rankResults() methods
  - Add search filters: activity level, reputation score, interests, location, verification status, mutual connections
  - Create user categories: DeFi experts, NFT collectors, developers, traders, content creators, community leaders
  - Implement search algorithms: relevance ranking, social graph influence, activity matching, interest alignment
  - Add discovery features: suggested users, people you may know, trending profiles, new user highlights, expert recommendations
  - _Requirements: 6.1, 6.2, 6.3, 6.4, 6.5, 6.6, 6.7, 6.8_

- [ ] 7.2 Create recommendation engine and user matching
  - Create `lib/recommendations/user-recommender.ts` with UserRecommender class implementing generateRecommendations(), calculateSimilarity(), updatePreferences() methods
  - Implement recommendation algorithms: collaborative filtering, content-based filtering, social graph analysis, activity pattern matching
  - Add similarity calculation: transaction pattern similarity, interest overlap, social network proximity, engagement compatibility
  - Create recommendation types: users to follow, potential collaborators, similar traders, community matches, expert connections
  - Implement machine learning: user preference learning, recommendation accuracy tracking, algorithm optimization, feedback incorporation
  - Add recommendation personalization: user interest tracking, interaction history analysis, preference weighting, recommendation diversity
  - _Requirements: 6.1, 6.2, 6.3, 6.4, 6.5, 6.6, 6.7, 6.8_

- [ ] 8. Build analytics and insights system for users
  - Create comprehensive user analytics dashboard
  - Implement social metrics and engagement tracking
  - Build performance insights and growth recommendations
  - _Requirements: 14.1, 14.2, 14.3, 14.4, 14.5, 14.6, 14.7, 14.8_

- [ ] 8.1 Build user analytics dashboard and metrics tracking
  - Create `components/UserAnalyticsDashboard.tsx` with comprehensive analytics overview, key performance indicators, growth metrics, engagement insights
  - Implement `lib/analytics/user-analytics.ts` with UserAnalytics class implementing trackMetrics(), generateInsights(), calculateGrowth() methods
  - Add social metrics: follower growth, engagement rates, content performance, reach and impressions, interaction quality
  - Create performance tracking: profile views, post engagement, message response rates, group participation, community impact
  - Implement trend analysis: growth trends, engagement patterns, content performance over time, seasonal variations
  - Add comparative analytics: benchmark against similar users, peer group analysis, percentile rankings, competitive insights
  - _Requirements: 14.1, 14.2, 14.3, 14.4, 14.5, 14.6, 14.7, 14.8_

- [ ] 8.2 Create insights and recommendation system
  - Create `components/UserInsights.tsx` with actionable insights, growth recommendations, optimization suggestions, trend alerts
  - Implement insight generation: content optimization recommendations, engagement improvement tips, network growth strategies, community participation advice
  - Add predictive analytics: growth forecasting, engagement prediction, trend identification, opportunity detection
  - Create personalized recommendations: optimal posting times, content suggestions, user connections, group recommendations
  - Implement A/B testing: test different strategies, measure improvement, optimize recommendations, track success rates
  - Add goal tracking: set social media goals, track progress, measure achievement, adjust strategies based on performance
  - _Requirements: 14.1, 14.2, 14.3, 14.4, 14.5, 14.6, 14.7, 14.8_# Wallet Path Finding - Design Document

## Overview

The Wallet Path Finding system analyzes connections between Solana wallet addresses by examining transaction histories, token transfers, and program interactions. The system uses graph algorithms to discover direct and indirect relationships, visualizes connections in an interactive interface, and provides detailed analytics about wallet relationships.

## Architecture

### System Components

```mermaid
graph TB
    UI[Path Finding UI] --> API[Path Finding API]
    API --> Cache[Path Cache]
    API --> Analyzer[Connection Analyzer]
    Analyzer --> Solana[Solana RPC]
    Analyzer --> Graph[Graph Builder]
    Graph --> Viz[Graph Visualizer]
    Cache --> DB[(Cache Database)]
```

### Data Flow

1. **Input Validation**: Validate wallet addresses and sanitize inputs
2. **Cache Check**: Check if path analysis exists in cache
3. **Data Collection**: Fetch transaction histories from Solana RPC
4. **Connection Analysis**: Analyze transactions to identify connections
5. **Graph Construction**: Build graph representation of connections
6. **Path Finding**: Use BFS/DFS algorithms to find paths
7. **Visualization**: Render interactive graph with D3.js/Cytoscape
8. **Caching**: Store results for future queries

## Components and Interfaces

### Frontend Components

#### `WalletPathFinder`
```typescript
interface WalletPathFinderProps {
  initialSource?: string;
  initialTarget?: string;
  onAnalysisComplete?: (results: PathAnalysisResults) => void;
}

interface PathAnalysisResults {
  paths: WalletPath[];
  graph: ConnectionGraph;
  metrics: ConnectionMetrics;
  executionTime: number;
}
```

#### `ConnectionGraph`
```typescript
interface ConnectionGraphProps {
  nodes: GraphNode[];
  edges: GraphEdge[];
  onNodeClick?: (node: GraphNode) => void;
  onEdgeClick?: (edge: GraphEdge) => void;
  filters?: GraphFilters;
}

interface GraphNode {
  id: string;
  address: string;
  label?: string;
  balance: number;
  transactionCount: number;
  tokenCount: number;
  type: 'source' | 'target' | 'intermediate';
}

interface GraphEdge {
  source: string;
  target: string;
  weight: number;
  transactionCount: number;
  totalVolume: number;
  firstTransaction: Date;
  lastTransaction: Date;
  tokens: string[];
}
```

#### `PathAnalysisPanel`
```typescript
interface PathAnalysisPanelProps {
  paths: WalletPath[];
  selectedPath?: number;
  onPathSelect: (pathIndex: number) => void;
  onExport: (format: ExportFormat) => void;
}

interface WalletPath {
  nodes: string[];
  totalHops: number;
  connectionStrength: number;
  totalVolume: number;
  pathType: 'direct' | 'token_transfer' | 'program_interaction';
  transactions: PathTransaction[];
}
```

### Backend Services

#### `PathFindingService`
```typescript
class PathFindingService {
  async findPaths(
    source: string,
    target: string,
    options: PathFindingOptions
  ): Promise<PathAnalysisResults>;
  
  async getConnectionStrength(
    address1: string,
    address2: string
  ): Promise<ConnectionStrength>;
  
  async getCachedAnalysis(
    source: string,
    target: string
  ): Promise<PathAnalysisResults | null>;
}

interface PathFindingOptions {
  maxDepth: number;
  minTransactionAmount: number;
  timeRange?: DateRange;
  includeTokenTransfers: boolean;
  includeProgramInteractions: boolean;
}
```

#### `ConnectionAnalyzer`
```typescript
class ConnectionAnalyzer {
  async analyzeDirectConnections(
    address1: string,
    address2: string
  ): Promise<DirectConnection[]>;
  
  async analyzeTokenConnections(
    address1: string,
    address2: string
  ): Promise<TokenConnection[]>;
  
  async analyzeProgramConnections(
    address1: string,
    address2: string
  ): Promise<ProgramConnection[]>;
  
  async calculateConnectionStrength(
    connections: Connection[]
  ): Promise<number>;
}
```

#### `GraphBuilder`
```typescript
class GraphBuilder {
  buildGraph(connections: Connection[]): ConnectionGraph;
  optimizeGraph(graph: ConnectionGraph): ConnectionGraph;
  clusterNodes(graph: ConnectionGraph, threshold: number): ConnectionGraph;
  calculateLayout(graph: ConnectionGraph): LayoutedGraph;
}
```

## Data Models

### Connection Types

```typescript
interface DirectConnection {
  type: 'direct_transfer';
  fromAddress: string;
  toAddress: string;
  transactions: TransactionSummary[];
  totalVolume: number;
  frequency: number;
}

interface TokenConnection {
  type: 'token_transfer';
  fromAddress: string;
  toAddress: string;
  tokenMint: string;
  tokenSymbol: string;
  transfers: TokenTransfer[];
  totalAmount: number;
}

interface ProgramConnection {
  type: 'program_interaction';
  address1: string;
  address2: string;
  programId: string;
  programName?: string;
  interactions: ProgramInteraction[];
  sharedInstructions: string[];
}
```

### Graph Data Structure

```typescript
interface ConnectionGraph {
  nodes: Map<string, GraphNode>;
  edges: Map<string, GraphEdge>;
  metadata: GraphMetadata;
}

interface GraphMetadata {
  totalNodes: number;
  totalEdges: number;
  maxDepth: number;
  analysisTimestamp: Date;
  sourceAddress: string;
  targetAddress: string;
}
```

## Error Handling

### Input Validation Errors
- Invalid wallet address format
- Same source and target address
- Address not found on blockchain
- Insufficient transaction history

### Analysis Errors
- RPC connection failures
- Timeout during analysis
- Memory limitations for large graphs
- Cache corruption or unavailability

### Visualization Errors
- Graph rendering failures
- Performance issues with large datasets
- Browser compatibility issues
- Export functionality failures

## Testing Strategy

### Unit Tests
- Address validation functions
- Connection analysis algorithms
- Graph building and optimization
- Path finding algorithms
- Caching mechanisms

### Integration Tests
- End-to-end path finding workflow
- RPC integration and error handling
- Cache integration and performance
- Export functionality
- Real-time graph updates

### Performance Tests
- Large graph rendering (1000+ nodes)
- Complex path finding (6+ degrees)
- Concurrent analysis requests
- Memory usage optimization
- Cache hit/miss ratios

### User Experience Tests
- Interactive graph manipulation
- Filter application and performance
- Export functionality across formats
- Mobile responsiveness
- Accessibility compliance

## Security Considerations

### Input Sanitization
- Validate all wallet addresses
- Sanitize user inputs to prevent injection
- Rate limit analysis requests
- Implement request size limits

### Data Privacy
- No storage of sensitive transaction data
- Anonymize exported data options
- Secure caching mechanisms
- Audit trail for analysis requests

### Performance Security
- Prevent DoS through complex queries
- Implement circuit breakers
- Monitor resource usage
- Graceful degradation under load# Wallet Path Finding - Requirements Document

## Introduction

The Wallet Path Finding feature enables users to discover and analyze connections between Solana wallet addresses through transaction flows, token transfers, and shared program interactions. This feature helps users understand wallet relationships, trace fund flows, and identify potential connections in the Solana ecosystem.

## Requirements

### Requirement 1: Wallet Connection Discovery

**User Story:** As a blockchain analyst, I want to find connections between two wallet addresses, so that I can trace fund flows and understand wallet relationships.

#### Acceptance Criteria

1. WHEN a user enters a source wallet address THEN the system SHALL validate the address format and display wallet information
2. WHEN a user enters a target wallet address THEN the system SHALL validate the address format and display wallet information  
3. WHEN both addresses are valid THEN the system SHALL initiate path finding analysis
4. IF no direct connection exists THEN the system SHALL search for indirect connections up to 6 degrees of separation
5. WHEN connections are found THEN the system SHALL display all discovered paths ranked by connection strength

### Requirement 2: Interactive Graph Visualization

**User Story:** As a user, I want to see wallet connections in an interactive graph, so that I can visually explore the relationship network.

#### Acceptance Criteria

1. WHEN path analysis completes THEN the system SHALL render an interactive force-directed graph
2. WHEN a user hovers over a node THEN the system SHALL display wallet information and connection details
3. WHEN a user clicks on a node THEN the system SHALL highlight all connections for that wallet
4. WHEN a user clicks on an edge THEN the system SHALL display transaction details for that connection
5. WHEN the graph is complex THEN the system SHALL provide zoom, pan, and filtering controls

### Requirement 3: Connection Analysis Metrics

**User Story:** As a compliance officer, I want to see detailed metrics about wallet connections, so that I can assess the strength and nature of relationships.

#### Acceptance Criteria

1. WHEN displaying connections THEN the system SHALL show transaction volume between wallets
2. WHEN displaying connections THEN the system SHALL show transaction frequency over time
3. WHEN displaying connections THEN the system SHALL show shared token holdings
4. WHEN displaying connections THEN the system SHALL show shared program interactions
5. WHEN displaying connections THEN the system SHALL calculate and display a connection strength score

### Requirement 4: Path Export and Sharing

**User Story:** As a researcher, I want to export path finding results, so that I can share findings and include them in reports.

#### Acceptance Criteria

1. WHEN path analysis is complete THEN the system SHALL provide export options for results
2. WHEN exporting THEN the system SHALL support JSON format for raw data
3. WHEN exporting THEN the system SHALL support PNG format for graph visualization
4. WHEN exporting THEN the system SHALL support CSV format for connection metrics
5. WHEN sharing THEN the system SHALL generate a shareable URL with analysis parameters

### Requirement 5: Advanced Filtering and Search

**User Story:** As an investigator, I want to filter connections by various criteria, so that I can focus on specific types of relationships.

#### Acceptance Criteria

1. WHEN viewing results THEN the system SHALL allow filtering by transaction amount thresholds
2. WHEN viewing results THEN the system SHALL allow filtering by time periods
3. WHEN viewing results THEN the system SHALL allow filtering by token types
4. WHEN viewing results THEN the system SHALL allow filtering by program interactions
5. WHEN filters are applied THEN the system SHALL update the graph visualization in real-time

### Requirement 6: Performance and Scalability

**User Story:** As a user, I want path finding to complete quickly, so that I can efficiently analyze multiple wallet relationships.

#### Acceptance Criteria

1. WHEN analyzing direct connections THEN the system SHALL complete analysis within 5 seconds
2. WHEN analyzing indirect connections THEN the system SHALL complete analysis within 30 seconds
3. WHEN the graph has more than 100 nodes THEN the system SHALL implement clustering for performance
4. WHEN analysis takes longer than expected THEN the system SHALL show progress indicators
5. WHEN memory usage is high THEN the system SHALL implement pagination for large result sets# Wallet Path Finding - Implementation Plan

## Task Overview

This implementation plan breaks down the Wallet Path Finding feature into discrete, manageable coding tasks that build incrementally toward a complete solution.

## Implementation Tasks

- [ ] 1. Set up project structure and core interfaces
  - Create directory structure for path finding components and services
  - Define TypeScript interfaces for graph nodes, edges, and connections
  - Set up basic routing for `/wallet-path-finding` page
  - _Requirements: 1.1, 1.2, 1.3_

- [ ] 2. Implement wallet address validation and input handling
  - [ ] 2.1 Create wallet address validation utilities
    - Write validation functions for Solana address format
    - Implement address existence checking via RPC
    - Create error handling for invalid addresses
    - _Requirements: 1.1, 1.2_

  - [ ] 2.2 Build wallet input components
    - Create source and target wallet input fields
    - Implement address auto-completion and suggestions
    - Add wallet information display (balance, transaction count)
    - _Requirements: 1.1, 1.2_

- [ ] 3. Develop connection analysis engine
  - [ ] 3.1 Implement direct transaction analysis
    - Write functions to fetch transaction history for addresses
    - Parse transactions to identify direct transfers
    - Calculate transaction volumes and frequencies
    - _Requirements: 1.3, 3.1, 3.2_

  - [ ] 3.2 Build token transfer analysis
    - Implement SPL token transfer detection
    - Analyze shared token holdings between addresses
    - Calculate token-based connection strength
    - _Requirements: 3.1, 3.3_

  - [ ] 3.3 Create program interaction analysis
    - Detect shared program interactions between addresses
    - Analyze instruction patterns and frequencies
    - Identify program-based relationships
    - _Requirements: 3.4_

- [ ] 4. Implement path finding algorithms
  - [ ] 4.1 Build breadth-first search for direct paths
    - Implement BFS algorithm for shortest path finding
    - Handle multiple path discovery and ranking
    - Optimize for performance with large datasets
    - _Requirements: 1.4, 1.5_

  - [ ] 4.2 Create depth-limited search for indirect paths
    - Implement DFS with configurable depth limits
    - Handle path pruning and optimization
    - Implement connection strength scoring
    - _Requirements: 1.4, 3.5_

- [ ] 5. Build graph data structure and management
  - [ ] 5.1 Implement graph builder service
    - Create graph construction from connection data
    - Implement node and edge management
    - Add graph optimization and clustering
    - _Requirements: 2.1, 2.2_

  - [ ] 5.2 Create graph layout algorithms
    - Implement force-directed layout calculation
    - Add clustering for large graphs
    - Optimize layout for visualization performance
    - _Requirements: 2.1, 6.3_

- [ ] 6. Develop interactive graph visualization
  - [ ] 6.1 Create base graph visualization component
    - Integrate D3.js or Cytoscape for graph rendering
    - Implement basic node and edge rendering
    - Add zoom and pan functionality
    - _Requirements: 2.1, 2.2, 2.3_

  - [ ] 6.2 Add interactive features
    - Implement node hover and click interactions
    - Add edge click for transaction details
    - Create node highlighting and selection
    - _Requirements: 2.2, 2.3, 2.4_

  - [ ] 6.3 Implement graph filtering and controls
    - Add filter controls for connection types
    - Implement real-time graph updates
    - Create graph reset and navigation controls
    - _Requirements: 2.5, 5.1, 5.2, 5.5_

- [ ] 7. Build analysis results panel
  - [ ] 7.1 Create path listing component
    - Display discovered paths with metrics
    - Implement path selection and highlighting
    - Show path details and transaction summaries
    - _Requirements: 1.5, 3.1, 3.2_

  - [ ] 7.2 Add connection metrics display
    - Show transaction volumes and frequencies
    - Display connection strength scores
    - Create time-based analysis charts
    - _Requirements: 3.1, 3.2, 3.3, 3.5_

- [ ] 8. Implement caching and performance optimization
  - [ ] 8.1 Create path analysis caching
    - Implement Redis/memory cache for analysis results
    - Add cache invalidation strategies
    - Create cache key generation for queries
    - _Requirements: 6.1, 6.2_

  - [ ] 8.2 Optimize for large datasets
    - Implement pagination for large result sets
    - Add progressive loading for complex graphs
    - Create performance monitoring and limits
    - _Requirements: 6.3, 6.4, 6.5_

- [ ] 9. Build export and sharing functionality
  - [ ] 9.1 Implement data export features
    - Create JSON export for raw analysis data
    - Add CSV export for connection metrics
    - Implement PNG export for graph visualization
    - _Requirements: 4.2, 4.3, 4.4_

  - [ ] 9.2 Add sharing capabilities
    - Generate shareable URLs with analysis parameters
    - Create social media sharing integration
    - Add bookmark and save functionality
    - _Requirements: 4.5_

- [ ] 10. Develop filtering and search features
  - [ ] 10.1 Create advanced filtering interface
    - Build filter controls for amount thresholds
    - Add time period filtering
    - Implement token type and program filtering
    - _Requirements: 5.1, 5.2, 5.3, 5.4_

  - [ ] 10.2 Implement real-time filter application
    - Update graph visualization with filters
    - Maintain filter state across interactions
    - Add filter presets and saved searches
    - _Requirements: 5.5_

- [ ] 11. Add API endpoints and backend services
  - [ ] 11.1 Create path finding API endpoints
    - Implement `/api/wallet-path-finding` POST endpoint
    - Add connection analysis endpoints
    - Create caching and rate limiting
    - _Requirements: 1.3, 6.1, 6.2_

  - [ ] 11.2 Build supporting API services
    - Add wallet validation endpoints
    - Create export generation endpoints
    - Implement sharing URL generation
    - _Requirements: 1.1, 1.2, 4.5_

- [ ] 12. Implement error handling and loading states
  - [ ] 12.1 Create comprehensive error handling
    - Handle RPC connection failures gracefully
    - Add timeout handling for long analyses
    - Implement user-friendly error messages
    - _Requirements: 6.4_

  - [ ] 12.2 Add loading and progress indicators
    - Show progress during analysis phases
    - Add loading states for graph rendering
    - Create cancellation functionality for long operations
    - _Requirements: 6.4_

- [ ] 13. Build responsive UI and mobile support
  - [ ] 13.1 Create responsive layout
    - Implement mobile-friendly graph controls
    - Add touch interactions for graph manipulation
    - Create collapsible panels for small screens
    - _Requirements: 2.5_

  - [ ] 13.2 Optimize mobile performance
    - Reduce graph complexity on mobile devices
    - Implement simplified mobile visualization
    - Add mobile-specific interaction patterns
    - _Requirements: 6.3_

- [ ] 14. Add comprehensive testing
  - [ ] 14.1 Write unit tests for core functionality
    - Test address validation and connection analysis
    - Test path finding algorithms and graph building
    - Test caching and performance optimizations
    - _Requirements: All_

  - [ ] 14.2 Create integration and E2E tests
    - Test complete path finding workflow
    - Test graph visualization and interactions
    - Test export and sharing functionality
    - _Requirements: All_

- [ ] 15. Implement accessibility and documentation
  - [ ] 15.1 Add accessibility features
    - Implement keyboard navigation for graph
    - Add screen reader support for analysis results
    - Create high contrast mode for visualizations
    - _Requirements: 2.2, 2.3_

  - [ ] 15.2 Create user documentation
    - Write user guide for path finding features
    - Add tooltips and help text throughout UI
    - Create API documentation for developers
    - _Requirements: All_

## Implementation Notes

### Development Approach
- Start with core path finding algorithms before UI
- Implement caching early to support development testing
- Use mock data for initial UI development
- Prioritize performance optimization throughout

### Technology Choices
- **Graph Visualization**: Cytoscape.js for performance with large graphs
- **Caching**: Redis for production, in-memory for development
- **Path Finding**: Custom BFS/DFS implementation optimized for blockchain data
- **Export**: Canvas-based PNG generation, native JSON/CSV export

### Performance Considerations
- Implement progressive loading for large graphs (>100 nodes)
- Use Web Workers for intensive path finding calculations
- Cache intermediate results during multi-hop analysis
- Implement graph clustering for visualization performance

### Testing Strategy
- Mock Solana RPC calls for consistent testing
- Use snapshot testing for graph layouts
- Performance testing with large datasets
- Cross-browser testing for visualization compatibility# Account Explorer Routes Steering

## Routes Covered
- `/account/[address]` - Individual account details
- `/user/[walletAddress]` - User profile and social features

## Account Detail Page (`/account/[address]`)

### Purpose
Comprehensive account information including balances, token holdings, transaction history, NFTs, and relationship analysis.

### Key Components Required
- **AccountInfo**: Basic account information display
- **AccountOverview**: Balance and holdings summary
- **TokenAccounts**: SPL token holdings with metadata
- **TransactionHistory**: Paginated transaction list
- **TransactionGraph**: Visual transaction relationships
- **NFTHoldings**: NFT collection display
- **ProgramInteractions**: Program usage analysis
- **AccountAnalytics**: Activity statistics and insights

### Data Requirements
```typescript
interface AccountData {
  address: string;
  info: AccountInfo;
  balance: AccountBalance;
  tokens: TokenHolding[];
  transactions: Transaction[];
  nfts: NFTHolding[];
  programs: ProgramInteraction[];
  analytics: AccountAnalytics;
  relationships: AccountRelationship[];
}

interface AccountInfo {
  lamports: number;
  owner: string;
  executable: boolean;
  rentEpoch: number;
  dataSize: number;
  type: 'wallet' | 'program' | 'token_account' | 'system';
  created: number;
  lastActivity: number;
}

interface AccountBalance {
  sol: number;
  usdValue: number;
  tokens: TokenBalance[];
  totalValue: number;
  change24h: number;
}

interface TokenHolding {
  mint: string;
  symbol: string;
  name: string;
  balance: number;
  decimals: number;
  usdValue: number;
  percentage: number;
  logo?: string;
  verified: boolean;
}

interface AccountAnalytics {
  transactionCount: number;
  uniquePrograms: number;
  averageTransactionSize: number;
  activityLevel: 'inactive' | 'low' | 'moderate' | 'high';
  riskScore: number;
  labels: string[];
  tags: string[];
}

interface AccountRelationship {
  address: string;
  type: 'frequent_sender' | 'frequent_receiver' | 'token_partner' | 'program_user';
  strength: number;
  transactionCount: number;
  totalVolume: number;
  lastInteraction: number;
}
```

### Implementation Guidelines
- Use server-side rendering for account metadata
- Implement real-time balance updates
- Show progressive loading for different sections
- Cache account data with appropriate TTL
- Implement infinite scroll for transaction history
- Add export functionality for account data

### Tabbed Interface
- **Overview**: Balance, tokens, and key metrics
- **Transactions**: Full transaction history with filtering
- **Tokens**: Detailed token holdings and transfers
- **NFTs**: NFT collection with metadata
- **Programs**: Program interaction analysis
- **Analytics**: Advanced statistics and insights

### Transaction History Features
- Infinite scroll pagination
- Advanced filtering (date, type, amount, program)
- Search within transactions
- Export to CSV/JSON
- Real-time updates for new transactions
- Transaction categorization and labeling

## User Profile Page (`/user/[walletAddress]`)

### Purpose
Social features and user-centric view of wallet activity with profiles, following, and community features.

### Key Components Required
- **UserProfile**: Profile information and customization
- **ActivityFeed**: Social activity and updates
- **FollowingList**: Accounts being followed
- **FollowersList**: Accounts following this user
- **SharedContent**: Shared transactions and insights
- **UserStats**: Social and activity statistics

### Social Features
```typescript
interface UserProfile {
  walletAddress: string;
  displayName?: string;
  bio?: string;
  avatar?: string;
  verified: boolean;
  joinDate: number;
  privacy: PrivacySettings;
  stats: UserStats;
  badges: Badge[];
}

interface UserStats {
  followers: number;
  following: number;
  postsShared: number;
  transactionsAnalyzed: number;
  reputation: number;
  level: number;
}

interface ActivityFeedItem {
  id: string;
  type: 'transaction' | 'follow' | 'share' | 'comment' | 'analysis';
  timestamp: number;
  data: any;
  visibility: 'public' | 'followers' | 'private';
}

interface PrivacySettings {
  profileVisibility: 'public' | 'followers' | 'private';
  transactionHistory: 'public' | 'followers' | 'private';
  followingList: 'public' | 'followers' | 'private';
  activityFeed: 'public' | 'followers' | 'private';
}
```

### Social Interaction Features
- Follow/unfollow other wallet addresses
- Share interesting transactions with commentary
- Comment on shared content
- Like and react to posts
- Reputation system based on contributions


## API Integration

### Required Endpoints
- `GET /api/account-stats/[address]` - Get account statistics
- `GET /api/account-token-stats/[address]` - Get token holdings
- `GET /api/account-transactions/[address]` - Get transaction history
- `GET /api/account-transfers/[address]` - Get transfer history
- `GET /api/user-profile/[walletAddress]` - Get user profile
- `GET /api/user-social/[walletAddress]` - Get social data
- `POST /api/user-social/follow` - Follow/unfollow actions
- `GET /api/user-history/[walletAddress]` - Get user activity history

### Real-time Updates
- WebSocket connection for balance updates
- Server-sent events for new transactions
- Push notifications for social interactions
- Real-time activity feed updates

### Caching Strategy
- Account info: Cache for 30 seconds
- Token balances: Cache for 1 minute
- Transaction history: Cache for 300 seconds
- User profiles: Cache for 5 minutes
- Social data: Cache for 1 minute

## Testing Requirements

### Unit Tests
- Account data parsing and validation
- Balance calculations accuracy
- Token metadata resolution
- Social feature functionality
- Privacy settings enforcement

### Integration Tests
- Account page loads with valid address
- Invalid addresses show appropriate errors
- Real-time updates work correctly
- Social features function properly
- Privacy controls are enforced

### E2E Tests
- Account search and navigation
- Transaction history pagination
- Token holdings display
- Social interactions work
- Privacy settings are respected

## Performance Considerations
- Lazy load heavy components (transaction graph, NFT images)
- Implement virtual scrolling for large lists
- Use React.memo for list items
- Optimize image loading for NFTs and avatars
- Bundle split social features

## Security Considerations
- Validate wallet addresses before processing
- Sanitize user-generated content
- Rate limit social interactions
- Prevent spam and abuse
- Secure handling of private data

## Account Analysis Features

### Risk Assessment
```typescript
interface RiskAnalyzer {
  analyzeAccount: (address: string) => Promise<RiskAssessment>;
  detectSuspiciousActivity: (transactions: Transaction[]) => SuspiciousActivity[];
  calculateRiskScore: (account: AccountData) => number;
  identifyPatterns: (activity: Activity[]) => Pattern[];
}

interface RiskAssessment {
  score: number; // 0-100
  level: 'low' | 'medium' | 'high' | 'critical';
  factors: RiskFactor[];
  recommendations: string[];
  lastUpdated: number;
}

interface RiskFactor {
  type: string;
  severity: number;
  description: string;
  evidence: any[];
}
```

### Activity Patterns
```typescript
interface ActivityAnalyzer {
  analyzeTransactionPatterns: (transactions: Transaction[]) => TransactionPattern[];
  detectTradingBehavior: (transactions: Transaction[]) => TradingBehavior;
  identifyAccountType: (account: AccountData) => AccountType;
  calculateActivityScore: (account: AccountData) => number;
}

interface TransactionPattern {
  type: 'regular_trading' | 'arbitrage' | 'liquidity_provision' | 'wash_trading';
  confidence: number;
  frequency: number;
  volume: number;
  timeframe: string;
}
```

## Accessibility Requirements
- Screen reader support for account data
- Keyboard navigation for all features
- High contrast mode for visualizations
- Alternative text for charts and graphs
- Focus management in modal dialogs

## Mobile Optimization
- Responsive design for all components
- Touch-friendly navigation
- Optimized loading for mobile networks
- Simplified views for small screens
- Swipe gestures for navigation

## SEO Optimization
- Dynamic meta titles with account type
- Rich meta descriptions with account summary
- Structured data for account information
- Canonical URLs for account pages
- Social media optimization

## Monitoring and Analytics
- Track account page views and engagement
- Monitor real-time update performance
- Measure user interactions with features
- Track error rates and API failures
- Monitor social feature adoption---
inclusion: fileMatch
fileMatchPattern: ['**/ai/**/*', '**/chat/**/*', '**/analyze*', '**/anomaly*']
---

# OpenSVM AI Functionality Steering

## AI System Architecture

The AI system provides natural language blockchain analysis, anomaly detection, and educational assistance through modular components. All AI functionality follows these core principles:

- **Context Awareness**: AI understands current page context and injects relevant data
- **Streaming Responses**: Use streaming for better UX with loading states
- **Error Resilience**: Graceful degradation with fallback responses
- **Caching Strategy**: Cache responses for common queries to reduce API costs

## Component Architecture

### AI Agent Pattern
Use factory pattern for creating specialized AI agents:
```typescript
// Always inject current page context
const agent = AgentFactory.createAnalysisAgent({
  context: getCurrentPageContext(),
  capabilities: ['transaction_analysis', 'anomaly_detection']
});
```

### Core AI Tool Interfaces
```typescript
// Base interface for all AI analysis tools
interface AIAnalyzer<T, R> {
  analyze(input: T): Promise<R>;
  getContext(): PageContext;
  setContext(context: PageContext): void;
}

// Standard analysis response format
interface AnalysisResponse {
  summary: string;
  riskLevel: 'low' | 'medium' | 'high' | 'critical';
  insights: string[];
  recommendations: string[];
  confidence: number; // 0-1
}
```

### AI Chat Interface (`/components/ai/`)

#### `AIChatSidebar`
- **Purpose**: Persistent resizable sidebar for AI conversations across all pages
- **State Management**: Global state persists across page navigation
- **Context Injection**: Automatically injects current page data into conversations

##### Acceptance Criteria
- **Resize Behavior**:
  - Draggable resize handle on left edge
  - Minimum width: 300px, Maximum width: 50% of viewport
  - Width persists in localStorage across sessions
  - Smooth resize animation without content jumping
  
- **Visibility States**:
  - Closed: Completely hidden with floating AI button visible
  - Open: Sidebar visible with chat interface
  - Minimized: Collapsed to show only header with expand option
  
- **Context Awareness**:
  - Automatically detects page changes and offers to inject new context
  - Shows current context indicator (e.g., "Analyzing Account: 7xKX...")
  - Context injection prompt: "I can see you're viewing [entity]. Would you like me to analyze it?"
  
- **User Profile Integration**:
  - All conversations are saved to the user's profile for persistent access
  - User navigation history is tracked and stored in user profile
  - When viewing an account, checks for transaction connections with ALL previously visited wallets from user history
  - Displays notification: "🔗 This account has [X] transactions with [WalletName] that you viewed [timeframe] ago"
  - Provides quick action to analyze connection patterns and relationship strength
  - Cross-references user's entire exploration history to surface hidden connections
  
- **Conversation Management**:
  - Multiple conversation tabs within sidebar
  - Auto-save conversations every 30 seconds
  - Clear conversation button with confirmation
  - Export conversation as markdown/JSON
  
- **Performance Requirements**:
  - Sidebar toggle animation < 200ms
  - Context injection < 500ms
  - Message rendering < 100ms per message
  - Smooth scrolling with 60fps during resize

- **Interaction Patterns**:
  - Click outside sidebar to close (when not pinned)
  - Escape key closes sidebar
  - Floating AI button pulses when new context is available
  - Auto-focus message input when sidebar opens
  
- **Mobile Behavior**:
  - On mobile: Sidebar becomes full-screen overlay
  - Swipe down gesture to close on mobile
  - Touch-friendly resize handle (minimum 44px touch target)
  
- **Accessibility**:
  - ARIA labels for all interactive elements
  - Keyboard navigation support (Tab, Shift+Tab)
  - Screen reader announcements for context changes
  - Focus trap when sidebar is open

#### `AIChatDialog`
- **Purpose**: Full-screen modal for AI interactions
- **Features**:
  - Immersive chat experience
  - Screen sharing for complex analysis
  - Multi-modal input (text, voice, images)
  - Conversation branching and forking

#### `AIMessageBubble`
- **Purpose**: Individual message display component
- **Features**:
  - Markdown rendering with syntax highlighting
  - Code block execution for Solana queries
  - Interactive charts and visualizations
  - Copy/share functionality

### Conversation Management

#### `ConversationManager`
```typescript
interface ConversationManager {
  createConversation(context?: PageContext): Promise<Conversation>;
  addMessage(conversationId: string, message: Message): Promise<void>;
  getConversationHistory(conversationId: string): Promise<Message[]>;
  updateContext(conversationId: string, context: PageContext): Promise<void>;
  exportConversation(conversationId: string): Promise<ExportData>;
}

interface Message {
  id: string;
  role: 'user' | 'assistant' | 'system';
  content: string;
  timestamp: number;
  context?: PageContext;
  metadata?: MessageMetadata;
}

interface PageContext {
  page: string;
  entityType?: 'account' | 'transaction' | 'token' | 'block';
  entityId?: string;
  additionalData?: Record<string, any>;
}
```

## AI Capabilities

### Agentic Navigation System
The AI can autonomously navigate through the website to achieve user-requested tasks, acting as an intelligent blockchain explorer that can execute complex multi-step investigations.

#### Core Architecture
```typescript
interface AgenticNavigator {
  // Primary navigation interface
  navigateToPage(url: string): Promise<NavigationResult>;
  searchAndNavigate(query: string): Promise<NavigationResult>;
  followTransactionPath(signature: string): Promise<PathAnalysis>;
  exploreAccountConnections(address: string, depth: number): Promise<ConnectionMap>;
  executeMultiStepAnalysis(task: AnalysisTask): Promise<AnalysisResult>;
  
  // State management
  getCurrentContext(): PageContext;
  getNavigationHistory(): NavigationStep[];
  saveCheckpoint(label: string): Promise<void>;
  restoreCheckpoint(label: string): Promise<void>;
}

interface NavigationResult {
  success: boolean;
  url: string;
  context: PageContext;
  data: any;
  timestamp: number;
  reasoning: string;
  nextSuggestions: NavigationAction[];
}

interface NavigationAction {
  type: 'navigate' | 'search' | 'analyze' | 'compare' | 'follow_link' | 'extract_data';
  target: string;
  context: string;
  reasoning: string;
  priority: number;
  estimatedTime: number;
}

interface AnalysisTask {
  id: string;
  objective: string;
  steps: NavigationAction[];
  expectedOutcome: string;
  maxDepth: number;
  timeLimit: number;
  progressCallback?: (step: NavigationStep) => void;
}

interface NavigationStep {
  action: NavigationAction;
  result: NavigationResult;
  duration: number;
  insights: string[];
  errors?: Error[];
}
```

#### Implementation Strategy

##### 1. Navigation Engine
```typescript
class AgenticNavigationEngine {
  private router: NextRouter;
  private contextManager: ContextManager;
  private dataExtractor: DataExtractor;
  private progressTracker: ProgressTracker;
  
  async executeTask(task: AnalysisTask): Promise<AnalysisResult> {
    const session = this.createNavigationSession(task);
    
    try {
      for (const step of task.steps) {
        // Update user with progress
        this.notifyProgress(step, session);
        
        // Execute navigation step
        const result = await this.executeNavigationStep(step);
        
        // Extract and analyze data
        const insights = await this.extractInsights(result);
        
        // Update session state
        session.addStep(step, result, insights);
        
        // Check if objective is met early
        if (this.isObjectiveMet(task.objective, session)) {
          break;
        }
      }
      
      return this.generateAnalysisResult(session);
    } catch (error) {
      return this.handleNavigationError(error, session);
    }
  }
  
  private async executeNavigationStep(action: NavigationAction): Promise<NavigationResult> {
    switch (action.type) {
      case 'navigate':
        return await this.navigateToPage(action.target);
      case 'search':
        return await this.performSearch(action.target);
      case 'analyze':
        return await this.analyzeCurrentPage(action.context);
      case 'extract_data':
        return await this.extractPageData(action.target);
      default:
        throw new Error(`Unknown navigation action: ${action.type}`);
    }
  }
}
```

##### 2. Data Extraction System
```typescript
interface DataExtractor {
  extractAccountData(address: string): Promise<AccountData>;
  extractTransactionData(signature: string): Promise<TransactionData>;
  extractTokenData(mint: string): Promise<TokenData>;
  extractRelationships(entity: string): Promise<RelationshipData>;
  extractMarketData(context: PageContext): Promise<MarketData>;
}

interface ExtractionRule {
  pageType: string;
  selectors: Record<string, string>;
  transformers: Record<string, (data: any) => any>;
  validators: Record<string, (data: any) => boolean>;
}

// Example extraction rules
const EXTRACTION_RULES: Record<string, ExtractionRule> = {
  account: {
    pageType: 'account',
    selectors: {
      balance: '[data-testid="account-balance"]',
      tokens: '[data-testid="token-holdings"]',
      transactions: '[data-testid="transaction-list"]'
    },
    transformers: {
      balance: (text) => parseFloat(text.replace(/[^\d.]/g, '')),
      tokens: (elements) => elements.map(el => extractTokenInfo(el))
    },
    validators: {
      balance: (value) => typeof value === 'number' && value >= 0
    }
  }
};
```

#### Advanced Features

##### 1. Intelligent Path Planning
```typescript
interface PathPlanner {
  planOptimalPath(objective: string, startContext: PageContext): Promise<NavigationAction[]>;
  adaptPlanBasedOnFindings(currentPlan: NavigationAction[], newInsights: Insight[]): Promise<NavigationAction[]>;
  estimateTaskComplexity(objective: string): Promise<ComplexityEstimate>;
}

interface ComplexityEstimate {
  estimatedSteps: number;
  estimatedTime: number;
  confidence: number;
  riskFactors: string[];
  alternativeApproaches: string[];
}

// Example path planning for complex investigation
const investigateWalletDeFiActivity = async (walletAddress: string): Promise<NavigationAction[]> => {
  return [
    {
      type: 'navigate',
      target: `/account/${walletAddress}`,
      reasoning: 'Start with account overview to understand wallet composition',
      priority: 1,
      estimatedTime: 2000
    },
    {
      type: 'extract_data',
      target: 'token_holdings',
      reasoning: 'Identify DeFi tokens to understand protocol involvement',
      priority: 2,
      estimatedTime: 1000
    },
    {
      type: 'analyze',
      target: 'defi_protocols',
      reasoning: 'Analyze which DeFi protocols this wallet interacts with',
      priority: 3,
      estimatedTime: 3000
    },
    {
      type: 'follow_link',
      target: 'transaction_history',
      reasoning: 'Examine transaction patterns for DeFi activity',
      priority: 4,
      estimatedTime: 5000
    }
  ];
};
```

##### 2. Real-time Progress Communication
```typescript
interface ProgressNotification {
  type: 'step_started' | 'step_completed' | 'insight_discovered' | 'error_encountered' | 'task_completed';
  message: string;
  currentStep: number;
  totalSteps: number;
  timeElapsed: number;
  estimatedTimeRemaining: number;
  insights?: Insight[];
  data?: any;
}

// Example progress updates
const progressUpdates = [
  "🔍 Starting investigation of wallet 7xKX... (Step 1/5)",
  "📊 Analyzing token holdings - found 12 DeFi tokens (Step 2/5)",
  "🔗 Discovered connections to 3 major DeFi protocols (Step 3/5)",
  "📈 Examining transaction patterns - 847 DeFi transactions found (Step 4/5)",
  "✅ Investigation complete - generating comprehensive report (Step 5/5)"
];
```

##### 3. Cross-Page Data Correlation
```typescript
interface DataCorrelator {
  correlateAccountData(accounts: string[]): Promise<CorrelationResult>;
  findTransactionPatterns(transactions: string[]): Promise<PatternResult>;
  identifyAnomalousConnections(entities: Entity[]): Promise<AnomalyResult>;
  buildRelationshipGraph(startEntity: string, depth: number): Promise<RelationshipGraph>;
}

interface CorrelationResult {
  commonTokens: TokenCorrelation[];
  sharedTransactions: TransactionCorrelation[];
  temporalPatterns: TemporalPattern[];
  riskIndicators: RiskIndicator[];
  insights: string[];
}

// Example correlation analysis
const analyzeWalletCluster = async (walletAddresses: string[]): Promise<ClusterAnalysis> => {
  const correlations = await dataCorrelator.correlateAccountData(walletAddresses);
  
  return {
    clusterType: determineClusterType(correlations),
    riskLevel: calculateClusterRisk(correlations),
    keyFindings: extractKeyFindings(correlations),
    recommendations: generateRecommendations(correlations),
    visualizationData: prepareVisualizationData(correlations)
  };
};
```

#### User Experience Features

##### 1. Interactive Investigation Mode
- **Live Progress Tracking**: Real-time updates as AI navigates through pages
- **Breadcrumb Trail**: Visual representation of navigation path taken
- **Insight Highlights**: Key discoveries highlighted as they're found
- **User Intervention**: Ability to pause, redirect, or modify investigation mid-stream
- **Bookmark Findings**: Save interesting discoveries for later review

##### 2. Investigation Templates
```typescript
interface InvestigationTemplate {
  name: string;
  description: string;
  objective: string;
  steps: NavigationAction[];
  expectedDuration: number;
  skillLevel: 'beginner' | 'intermediate' | 'advanced';
  categories: string[];
}

const INVESTIGATION_TEMPLATES: InvestigationTemplate[] = [
  {
    name: "DeFi Portfolio Analysis",
    description: "Comprehensive analysis of a wallet's DeFi activities and positions",
    objective: "Understand DeFi strategy and risk exposure",
    steps: [...], // Predefined navigation steps
    expectedDuration: 30000, // 30 seconds
    skillLevel: 'intermediate',
    categories: ['defi', 'portfolio', 'risk-analysis']
  },
  {
    name: "Suspicious Activity Investigation",
    description: "Deep dive into potentially suspicious wallet behavior",
    objective: "Identify and analyze suspicious patterns",
    steps: [...],
    expectedDuration: 60000, // 1 minute
    skillLevel: 'advanced',
    categories: ['security', 'anomaly-detection', 'forensics']
  }
];
```

##### 3. Collaborative Investigation
- **Share Investigation Sessions**: Allow users to share ongoing investigations
- **Investigation Replay**: Replay the AI's navigation path for learning
- **Community Templates**: User-contributed investigation templates
- **Expert Validation**: Community validation of AI findings

#### Advanced Navigation Capabilities

##### 1. Multi-dimensional Analysis
```typescript
interface MultiDimensionalAnalyzer {
  analyzeAcrossTime(entity: string, timeRange: TimeRange): Promise<TemporalAnalysis>;
  analyzeAcrossNetworks(entity: string, networks: string[]): Promise<CrossNetworkAnalysis>;
  analyzeAcrossProtocols(entity: string, protocols: string[]): Promise<ProtocolAnalysis>;
  compareEntities(entities: string[], dimensions: string[]): Promise<ComparisonAnalysis>;
}

// Example: Analyze wallet behavior across different time periods
const analyzeWalletEvolution = async (walletAddress: string): Promise<EvolutionAnalysis> => {
  const timeRanges = ['1d', '7d', '30d', '90d', '1y'];
  const analyses = await Promise.all(
    timeRanges.map(range => 
      multiDimensionalAnalyzer.analyzeAcrossTime(walletAddress, range)
    )
  );
  
  return {
    evolutionPattern: identifyEvolutionPattern(analyses),
    behaviorChanges: detectBehaviorChanges(analyses),
    riskProgression: analyzeRiskProgression(analyses),
    recommendations: generateEvolutionRecommendations(analyses)
  };
};
```

##### 2. Predictive Navigation
```typescript
interface PredictiveNavigator {
  predictNextBestAction(currentContext: PageContext, objective: string): Promise<NavigationAction>;
  suggestAlternativePaths(currentPath: NavigationAction[], objective: string): Promise<NavigationAction[][]>;
  estimateSuccessProbability(path: NavigationAction[], objective: string): Promise<number>;
  optimizeNavigationStrategy(feedback: UserFeedback[]): Promise<void>;
}

// Example: AI learns from user behavior to improve navigation
const adaptiveNavigation = async (userQuery: string, userHistory: UserHistory): Promise<NavigationStrategy> => {
  const baseStrategy = await planBasicNavigation(userQuery);
  const userPreferences = extractUserPreferences(userHistory);
  const optimizedStrategy = await optimizeForUser(baseStrategy, userPreferences);
  
  return {
    primaryPath: optimizedStrategy.primaryPath,
    alternativePaths: optimizedStrategy.alternatives,
    confidenceScore: optimizedStrategy.confidence,
    personalizationFactors: optimizedStrategy.personalization
  };
};
```

This comprehensive agentic navigation system transforms the AI from a passive assistant into an active blockchain explorer that can autonomously investigate complex scenarios, discover hidden patterns, and provide deep insights through intelligent navigation and analysis.

### Natural Language Processing

#### Query Understanding
- **Intent Recognition**: Classify user queries (analysis, explanation, search, comparison, navigation)
- **Entity Extraction**: Extract addresses, signatures, token names from natural language
- **Context Awareness**: Understand references to current page data
- **Multi-turn Conversations**: Maintain context across conversation turns
- **Task Planning**: Break down complex requests into executable navigation steps

#### Response Generation
- **Explanation Generation**: Convert technical blockchain data to natural language
- **Educational Content**: Provide learning materials and concept explanations
- **Actionable Insights**: Suggest next steps and recommendations
- **Personalization**: Adapt responses to user expertise level
- **Progress Updates**: Provide real-time updates during autonomous navigation

### Blockchain Analysis

#### Transaction Analysis
```typescript
// Example AI analysis workflow
const analyzeTransaction = async (signature: string) => {
  // 1. Fetch transaction data
  const transaction = await solanaDataTool.getTransaction(signature);
  
  // 2. Parse instructions and accounts
  const parsedInstructions = await parseInstructions(transaction);
  const accountChanges = await analyzeAccountChanges(transaction);
  
  // 3. Detect patterns and anomalies
  const anomalies = await patternDetector.detectAnomalies(transaction);
  const riskLevel = await assessRisk(transaction, anomalies);
  
  // 4. Generate natural language explanation
  const explanation = await generateExplanation({
    transaction,
    instructions: parsedInstructions,
    accountChanges,
    anomalies,
    riskLevel
  });
  
  return {
    summary: explanation.summary,
    details: explanation.details,
    riskLevel,
    anomalies,
    recommendations: explanation.recommendations
  };
};
```

#### Anomaly Detection
```typescript
interface AnomalyDetectionSystem {
  // Real-time anomaly detection
  detectRealTimeAnomalies(transaction: Transaction): Promise<Anomaly[]>;
  
  // Pattern-based detection
  detectSuspiciousPatterns(timeWindow: TimeWindow): Promise<Pattern[]>;
  
  // ML-based detection
  detectMLAnomalies(features: TransactionFeatures): Promise<MLAnomaly[]>;
  
  // Cross-reference detection
  detectCrossChainAnomalies(transaction: Transaction): Promise<CrossChainAnomaly[]>;
}

interface Anomaly {
  type: 'wash_trading' | 'pump_dump' | 'sybil' | 'mev' | 'suspicious_volume';
  severity: 'low' | 'medium' | 'high' | 'critical';
  confidence: number; // 0-1
  description: string;
  evidence: Evidence[];
  relatedEntities: string[];
  recommendations: string[];
}
```

### Educational Features

#### Concept Explanation
- **Blockchain Basics**: Explain fundamental blockchain concepts
- **Solana Specifics**: Solana-specific features and mechanisms
- **DeFi Concepts**: Decentralized finance protocols and strategies
- **Security Awareness**: Common scams and security best practices

#### Interactive Learning
- **Guided Tours**: Step-by-step exploration of blockchain data
- **Quiz Mode**: Test understanding of blockchain concepts
- **Scenario Analysis**: "What if" scenarios for learning
- **Best Practices**: Recommendations for safe blockchain interaction

## AI Integration Patterns

### Context Injection
```typescript
// Inject current page context into AI conversations
const injectPageContext = (context: PageContext) => {
  const systemMessage = {
    role: 'system' as const,
    content: `
      Current page context:
      - Page: ${context.page}
      - Entity Type: ${context.entityType}
      - Entity ID: ${context.entityId}
      - Additional Data: ${JSON.stringify(context.additionalData)}
      
      Use this context to provide relevant and specific assistance.
      Reference the current data when appropriate.
    `
  };
  
  return systemMessage;
};
```

### Streaming Responses
```typescript
// Stream AI responses for better UX
const streamAIResponse = async function* (
  messages: Message[],
  onToken?: (token: string) => void
) {
  const response = await fetch('/api/ai-response', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ messages, stream: true })
  });
  
  const reader = response.body?.getReader();
  const decoder = new TextDecoder();
  
  while (reader) {
    const { done, value } = await reader.read();
    if (done) break;
    
    const chunk = decoder.decode(value);
    const lines = chunk.split('\n');
    
    for (const line of lines) {
      if (line.startsWith('data: ')) {
        const data = line.slice(6);
        if (data === '[DONE]') return;
        
        try {
          const parsed = JSON.parse(data);
          const token = parsed.choices[0]?.delta?.content;
          if (token) {
            onToken?.(token);
            yield token;
          }
        } catch (e) {
          console.error('Error parsing streaming response:', e);
        }
      }
    }
  }
};
```

### Error Handling
```typescript
// AI-specific error handling
class AIError extends Error {
  constructor(
    message: string,
    public code: AIErrorCode,
    public retryable: boolean = false
  ) {
    super(message);
    this.name = 'AIError';
  }
}

enum AIErrorCode {
  RATE_LIMIT = 'RATE_LIMIT',
  CONTEXT_TOO_LARGE = 'CONTEXT_TOO_LARGE',
  INVALID_QUERY = 'INVALID_QUERY',
  MODEL_UNAVAILABLE = 'MODEL_UNAVAILABLE',
  ANALYSIS_FAILED = 'ANALYSIS_FAILED'
}

const handleAIError = (error: AIError) => {
  switch (error.code) {
    case AIErrorCode.RATE_LIMIT:
      return 'AI service is temporarily busy. Please try again in a moment.';
    case AIErrorCode.CONTEXT_TOO_LARGE:
      return 'Query is too complex. Please try breaking it into smaller parts.';
    case AIErrorCode.INVALID_QUERY:
      return 'I didn\'t understand your query. Could you rephrase it?';
    default:
      return 'An error occurred while processing your request.';
  }
};
```

## AI API Endpoints

### `/api/ai-response`
- **Purpose**: Main AI query processing endpoint
- **Method**: POST
- **Body**: `{ messages: Message[], context?: PageContext, stream?: boolean }`
- **Response**: AI-generated response with analysis and recommendations

### `/api/analyze-transaction`
- **Purpose**: Dedicated transaction analysis endpoint
- **Method**: POST
- **Body**: `{ signature: string, analysisType?: string }`
- **Response**: Detailed transaction analysis with AI insights

### `/api/chat`
- **Purpose**: Conversational AI interface
- **Method**: POST
- **Body**: `{ conversationId?: string, message: string, context?: PageContext }`
- **Response**: Streaming or complete AI response

### `/api/anomaly`
- **Purpose**: Anomaly detection and reporting
- **Method**: GET/POST
- **Response**: Anomaly reports with AI-generated explanations

## Performance Optimization

### Caching Strategies
```typescript
// Cache AI responses for common queries
const aiResponseCache = new Map<string, CachedResponse>();

const getCachedResponse = (query: string, context: PageContext) => {
  const cacheKey = `${query}-${JSON.stringify(context)}`;
  const cached = aiResponseCache.get(cacheKey);
  
  if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
    return cached.response;
  }
  
  return null;
};

const setCachedResponse = (query: string, context: PageContext, response: string) => {
  const cacheKey = `${query}-${JSON.stringify(context)}`;
  aiResponseCache.set(cacheKey, {
    response,
    timestamp: Date.now()
  });
};
```

### Request Optimization
```typescript
// Batch multiple AI requests
const batchAIRequests = async (requests: AIRequest[]) => {
  const batches = chunk(requests, BATCH_SIZE);
  const results = [];
  
  for (const batch of batches) {
    const batchResults = await Promise.all(
      batch.map(request => processAIRequest(request))
    );
    results.push(...batchResults);
  }
  
  return results;
};
```

## Security & Privacy

### Data Protection
- **PII Filtering**: Remove personally identifiable information from queries
- **Query Sanitization**: Sanitize user inputs before processing
- **Response Filtering**: Filter sensitive information from AI responses
- **Audit Logging**: Log AI interactions for security monitoring

### Rate Limiting
- **User-based Limits**: Different limits for anonymous vs authenticated users
- **Query Complexity**: Higher limits for simple queries, lower for complex analysis
- **Adaptive Limiting**: Adjust limits based on system load and user behavior

### Content Moderation
- **Input Validation**: Validate queries for malicious content
- **Output Filtering**: Filter inappropriate or harmful AI responses
- **Abuse Detection**: Detect and prevent AI system abuse
- **Compliance**: Ensure AI responses comply with platform policies# Analytics & Monitoring Routes Steering

## Routes Covered
- `/analytics` - Main analytics dashboard
- `/analytics/defi` - DeFi protocol analytics
- `/analytics/tokens` - Token market analytics
- `/monitoring` - Network monitoring and alerts
- `/networks` - Network comparison and status

## Analytics Dashboard (`/analytics`)

### Purpose
Comprehensive analytics dashboard providing insights into Solana network performance, DeFi metrics, token markets, and ecosystem health.

### Key Components Required
- **AnalyticsOverview**: High-level network statistics
- **NetworkMetricsTable**: Real-time network performance
- **DeFiAnalytics**: DeFi protocol metrics and TVL
- **TokenAnalytics**: Token market data and trends
- **ValidatorAnalytics**: Validator performance and staking
- **EcosystemMetrics**: Overall ecosystem health indicators
- **CustomDashboard**: User-customizable widget layout

### Tabbed Interface Structure
```typescript
interface AnalyticsTab {
  id: string;
  name: string;
  component: React.ComponentType;
  data: any;
  refreshInterval: number;
}

const ANALYTICS_TABS = [
  { id: 'overview', name: 'Overview', refreshInterval: 30000 },
  { id: 'network', name: 'Network', refreshInterval: 10000 },
  { id: 'defi', name: 'DeFi', refreshInterval: 60000 },
  { id: 'tokens', name: 'Tokens', refreshInterval: 30000 },
  { id: 'validators', name: 'Validators', refreshInterval: 120000 },
  { id: 'dex', name: 'DEX', refreshInterval: 30000 },
  { id: 'nft', name: 'NFT', refreshInterval: 300000 },
  { id: 'gaming', name: 'Gaming', refreshInterval: 300000 },
  { id: 'crosschain', name: 'Cross-Chain', refreshInterval: 120000 },
  { id: 'ecosystem', name: 'Ecosystem', refreshInterval: 300000 },
  { id: 'security', name: 'Security', refreshInterval: 60000 },
  { id: 'custom', name: 'Custom', refreshInterval: 60000 }
];
```

### Data Requirements
```typescript
interface AnalyticsData {
  network: NetworkMetrics;
  defi: DeFiMetrics;
  tokens: TokenMetrics;
  validators: ValidatorMetrics;
  ecosystem: EcosystemMetrics;
  security: SecurityMetrics;
}

interface NetworkMetrics {
  tps: number;
  blockTime: number;
  epochProgress: number;
  validatorCount: number;
  stakeRatio: number;
  networkHealth: number;
  trends: MetricTrend[];
}

interface DeFiMetrics {
  totalValueLocked: number;
  protocolCount: number;
  topProtocols: Protocol[];
  volumeMetrics: VolumeMetrics;
  yieldMetrics: YieldMetrics;
  liquidityMetrics: LiquidityMetrics;
}

interface TokenMetrics {
  totalMarketCap: number;
  tradingVolume24h: number;
  activeTokens: number;
  topGainers: TokenGainer[];
  topLosers: TokenLoser[];
  newTokens: NewToken[];
}
```

### Implementation Guidelines
- Use server-side rendering for initial data
- Implement real-time updates via WebSocket/SSE
- Cache analytics data with appropriate TTL
- Show loading states for each tab
- Implement data export functionality
- Add customizable dashboard widgets

## DeFi Analytics (`/analytics/defi`)

### Purpose
Specialized DeFi analytics with protocol-specific metrics, TVL tracking, yield analysis, and liquidity monitoring.

### Key Components Required
- **TVLChart**: Total Value Locked over time
- **ProtocolRankings**: Top protocols by various metrics
- **YieldFarming**: Yield opportunities and APY tracking
- **LiquidityAnalysis**: Pool liquidity and trading volume
- **DeFiComparison**: Protocol comparison tools
- **RiskMetrics**: DeFi protocol risk assessment

### DeFi Categories
```typescript
interface DeFiCategory {
  name: string;
  protocols: Protocol[];
  totalTVL: number;
  growth24h: number;
  dominance: number;
}

const DEFI_CATEGORIES = [
  'DEX', 'Lending', 'Yield Farming', 'Derivatives', 
  'Insurance', 'Asset Management', 'Payments', 'Synthetics'
];

interface Protocol {
  name: string;
  category: string;
  tvl: number;
  volume24h: number;
  users24h: number;
  apy: number;
  riskScore: number;
  verified: boolean;
}
```

### Features to Implement
- TVL tracking across all protocols
- Yield farming opportunity scanner
- Liquidity pool analysis
- Protocol risk assessment
- Cross-protocol comparison
- Historical performance tracking

## Token Analytics (`/analytics/tokens`)

### Purpose
Token market analytics with price tracking, market cap analysis, trading volume metrics, and token ecosystem insights.

### Key Components Required
- **MarketOverview**: Overall token market statistics
- **TokenRankings**: Top tokens by market cap and volume
- **PriceCharts**: Token price movements and trends
- **TradingAnalysis**: Trading volume and liquidity analysis
- **TokenLaunchpad**: New token launches and performance
- **MarketSentiment**: Sentiment analysis and social metrics

### Market Metrics
```typescript
interface TokenMarketMetrics {
  totalMarketCap: number;
  totalVolume24h: number;
  activeTokens: number;
  newTokens24h: number;
  marketDominance: MarketDominance[];
  priceMovements: PriceMovement[];
}

interface MarketDominance {
  symbol: string;
  marketCap: number;
  dominance: number;
  change24h: number;
}
```

## Network Monitoring (`/monitoring`)

### Purpose
Real-time network monitoring with anomaly detection, alert management, and performance tracking.

### Key Components Required
- **LiveEventMonitor**: Real-time event streaming
- **AnomalyAlertsTable**: Anomaly detection and alerts
- **NetworkHealthDashboard**: Network status indicators
- **PerformanceMetrics**: Network performance tracking
- **AlertManagement**: Custom alert configuration
- **HistoricalAnalysis**: Historical event analysis

### Monitoring Features
```typescript
interface MonitoringSystem {
  realTimeEvents: EventStream;
  anomalyDetection: AnomalyDetector;
  alertManager: AlertManager;
  performanceTracker: PerformanceTracker;
  historicalAnalyzer: HistoricalAnalyzer;
}

interface EventStream {
  subscribe: (callback: (event: NetworkEvent) => void) => void;
  filter: (criteria: EventFilter) => EventStream;
  pause: () => void;
  resume: () => void;
}

interface AnomalyDetector {
  detectRealTime: (event: NetworkEvent) => Anomaly[];
  detectPatterns: (timeWindow: TimeWindow) => Pattern[];
  configureRules: (rules: DetectionRule[]) => void;
  getAnomalyHistory: () => Anomaly[];
}

interface AlertManager {
  createAlert: (config: AlertConfig) => void;
  updateAlert: (id: string, config: AlertConfig) => void;
  deleteAlert: (id: string) => void;
  getAlerts: () => Alert[];
  testAlert: (id: string) => void;
}
```

### Alert Types
- Network performance degradation
- Unusual transaction patterns
- Security threats and attacks
- Validator performance issues
- Token price anomalies
- DeFi protocol risks

## Network Comparison (`/networks`)

### Purpose
Compare different Solana networks (mainnet, devnet, testnet) with RPC endpoint monitoring and performance benchmarking.

### Key Components Required
- **NetworkComparison**: Side-by-side network comparison
- **RPCEndpointStatus**: RPC endpoint health monitoring
- **PerformanceBenchmarks**: Network performance metrics
- **NetworkSwitcher**: Easy network switching interface
- **EndpointTesting**: RPC endpoint testing tools

### Network Data
```typescript
interface NetworkInfo {
  name: string;
  type: 'mainnet' | 'devnet' | 'testnet';
  rpcEndpoints: RPCEndpoint[];
  status: 'healthy' | 'degraded' | 'down';
  metrics: NetworkMetrics;
  features: NetworkFeature[];
}

interface RPCEndpoint {
  url: string;
  provider: string;
  status: 'online' | 'offline' | 'slow';
  latency: number;
  reliability: number;
  rateLimit: number;
  features: string[];
}
```

## API Integration

### Required Endpoints
- `GET /api/analytics/overview` - Get analytics overview
- `GET /api/analytics/defi` - Get DeFi analytics
- `GET /api/analytics/tokens` - Get token analytics
- `GET /api/monitoring/events` - Get monitoring events
- `GET /api/monitoring/alerts` - Get alert configuration
- `POST /api/monitoring/alerts` - Create/update alerts
- `GET /api/networks` - Get network information
- `GET /api/networks/rpc-status` - Get RPC endpoint status

### Real-time Data
- Server-sent events for live analytics updates
- WebSocket for monitoring events
- Push notifications for critical alerts
- Real-time network status updates

### Caching Strategy
- Analytics data: Cache for 1-5 minutes depending on type
- Monitoring events: No caching (real-time)
- Network status: Cache for 30 seconds
- Historical data: Cache for 1 hour

## Testing Requirements

### Unit Tests
- Analytics calculation accuracy
- Anomaly detection algorithms
- Alert triggering logic
- Network status monitoring
- Data aggregation functions

### Integration Tests
- Real-time data updates
- Alert system functionality
- Network switching works
- Analytics tab navigation
- Export functionality

### E2E Tests
- Dashboard loads and displays data
- Real-time updates work correctly
- Alert creation and management
- Network comparison functionality
- Mobile responsiveness

## Performance Considerations
- Lazy load heavy analytics components
- Use Web Workers for complex calculations
- Implement data virtualization for large datasets
- Optimize chart rendering performance
- Bundle split analytics libraries

## Security Considerations
- Rate limit analytics API requests
- Validate alert configurations
- Secure monitoring data access
- Prevent alert spam and abuse
- Audit trail for alert changes

## Accessibility Requirements
- Screen reader support for charts and metrics
- Keyboard navigation for all features
- High contrast mode for visualizations
- Alternative text for graphs and charts
- Focus management in modal dialogs

## Mobile Optimization
- Responsive dashboard layout
- Touch-friendly chart interactions
- Optimized loading for mobile networks
- Simplified views for small screens
- Swipe gestures for navigation

## Monitoring and Analytics
- Track dashboard usage and engagement
- Monitor real-time update performance
- Measure alert accuracy and effectiveness
- Track user interactions with features
- Monitor system performance and errors# OpenSVM API Routes Documentation

## API Architecture

All API routes follow RESTful conventions and are organized under `/api/` with consistent response formats, error handling, and authentication patterns.

## Core API Endpoints

### Account APIs (`/api/account-*`)

#### `/api/account-stats/[address]`
- **Purpose**: Get comprehensive account statistics
- **Method**: GET
- **Response**: Account balance, transaction count, token holdings summary
- **Caching**: 30 seconds for active accounts, 5 minutes for inactive

#### `/api/account-token-stats/[address]`
- **Purpose**: Get detailed token holdings and statistics
- **Method**: GET
- **Response**: List of tokens with balances, USD values, percentage allocations
- **Features**: Token metadata resolution, price data integration

#### `/api/account-transactions/[address]`
- **Purpose**: Paginated transaction history for an account
- **Method**: GET
- **Query Params**: `page`, `limit`, `before`, `until`
- **Response**: Transactions with parsed instructions and metadata

#### `/api/account-transfers/[address]`
- **Purpose**: Token transfer history for an account
- **Method**: GET
- **Response**: Filtered transfers with token metadata and USD values

### Transaction APIs (`/api/transaction/`)

#### `/api/transaction/[signature]`
- **Purpose**: Get detailed transaction information
- **Method**: GET
- **Response**: Complete transaction data with parsed instructions
- **Features**: Instruction parsing, account change analysis, fee calculation

#### `/api/analyze-transaction`
- **Purpose**: AI-powered transaction analysis
- **Method**: POST
- **Body**: `{ signature: string }`
- **Response**: Natural language explanation of transaction purpose and effects

### Block APIs (`/api/block*`)

#### `/api/block`
- **Purpose**: Get block information by slot
- **Method**: GET
- **Query Params**: `slot`
- **Response**: Block metadata, transactions, validator info

#### `/api/blocks/[slot]`
- **Purpose**: Get specific block details
- **Method**: GET
- **Response**: Detailed block information with transaction list

### Token APIs (`/api/token*`)

#### `/api/token/[mint]`
- **Purpose**: Get token metadata and statistics
- **Method**: GET
- **Response**: Token info, supply, holder count, price data

#### `/api/token-stats/[account]`
- **Purpose**: Get token statistics for a specific account
- **Method**: GET
- **Response**: Token balances and transaction history

### Search APIs (`/api/search*`)

#### `/api/search`
- **Purpose**: Universal search across all blockchain entities
- **Method**: GET
- **Query Params**: `q` (query), `type` (filter), `limit`
- **Response**: Categorized search results

#### `/api/search/suggestions`
- **Purpose**: Auto-complete suggestions for search queries
- **Method**: GET
- **Query Params**: `q` (partial query)
- **Response**: Suggested completions with entity types

#### `/api/search/accounts`
- **Purpose**: Search specifically for accounts
- **Method**: GET
- **Response**: Account matches with metadata

### AI APIs (`/api/ai-*`, `/api/chat`)

#### `/api/ai-response`
- **Purpose**: Process AI queries about blockchain data
- **Method**: POST
- **Body**: `{ message: string, context?: object }`
- **Response**: AI-generated response with data analysis

#### `/api/chat`
- **Purpose**: Conversational AI interface
- **Method**: POST
- **Body**: `{ messages: ChatMessage[] }`
- **Response**: Streaming AI responses

### Analytics APIs (`/api/analytics/`)

#### `/api/analytics/overview`
- **Purpose**: High-level network statistics
- **Method**: GET
- **Response**: Network metrics, validator count, TPS, epoch info

#### `/api/analytics/defi`
- **Purpose**: DeFi protocol analytics
- **Method**: GET
- **Response**: TVL data, protocol metrics, yield information

#### `/api/analytics/tokens`
- **Purpose**: Token market analytics
- **Method**: GET
- **Response**: Token prices, volume, market cap data

### Real-time APIs (`/api/sse-*`, `/api/stream`)

#### `/api/sse-events/feed`
- **Purpose**: Server-sent events for real-time updates
- **Method**: GET (EventSource)
- **Response**: Streaming blockchain events

#### `/api/sse-alerts`
- **Purpose**: Real-time security alerts
- **Method**: GET (EventSource)
- **Response**: Anomaly detection alerts

#### `/api/stream`
- **Purpose**: WebSocket-like streaming for live data
- **Method**: GET
- **Response**: Continuous data stream

### Utility APIs

#### `/api/solana-proxy`
- **Purpose**: Proxy requests to Solana RPC with load balancing
- **Method**: POST
- **Body**: Standard Solana RPC request
- **Response**: Proxied RPC response with error handling

#### `/api/solana-rpc`
- **Purpose**: Direct Solana RPC interface
- **Method**: POST
- **Features**: Request validation, response caching, rate limiting

#### `/api/check-account-type`
- **Purpose**: Determine account type (wallet, program, token account)
- **Method**: GET
- **Query Params**: `address`
- **Response**: Account type classification

### Program APIs (`/api/program/`)

#### `/api/program/[address]`
- **Purpose**: Get program information and statistics
- **Method**: GET
- **Response**: Program metadata, instruction usage, account ownership

### Validator APIs (`/api/validator/`)

#### `/api/validator/[address]`
- **Purpose**: Get validator information and performance
- **Method**: GET
- **Response**: Validator stats, commission, stake, performance history

### NFT APIs (`/api/nft*`)

#### `/api/nft-collections`
- **Purpose**: Get NFT collection data
- **Method**: GET
- **Response**: Collection metadata, floor prices, volume

#### `/api/nft-collections/trending`
- **Purpose**: Get trending NFT collections
- **Method**: GET
- **Response**: Collections sorted by activity and volume

### User & Social APIs (`/api/user-*`)

#### `/api/user-profile/[walletAddress]`
- **Purpose**: Get user profile information
- **Method**: GET
- **Response**: User preferences, activity summary, social connections

#### `/api/user-history/[walletAddress]`
- **Purpose**: Get user's interaction history
- **Method**: GET
- **Response**: Page views, searches, bookmarks

#### `/api/user-social/follow`
- **Purpose**: Follow/unfollow wallet addresses
- **Method**: POST
- **Body**: `{ target: string, action: 'follow' | 'unfollow' }`

### Anomaly Detection APIs (`/api/anomaly/`)

#### `/api/anomaly`
- **Purpose**: Report and query anomalies
- **Method**: GET/POST
- **Response**: Anomaly reports, risk scores, related transactions

#### `/api/anomaly/similar`
- **Purpose**: Find similar anomalous patterns
- **Method**: GET
- **Response**: Related anomalies and pattern analysis

### Monetization APIs (`/api/referrals/`, `/api/share/`)

#### `/api/referrals/balance`
- **Purpose**: Get referral earnings balance
- **Method**: GET
- **Response**: Earnings, pending rewards, referral stats

#### `/api/share/generate`
- **Purpose**: Generate shareable links with tracking
- **Method**: POST
- **Body**: `{ url: string, metadata: object }`
- **Response**: Shareable link with tracking code

## API Response Patterns

### Success Response
```typescript
{
  success: true,
  data: T,
  timestamp: number,
  cached?: boolean
}
```

### Error Response
```typescript
{
  success: false,
  error: {
    code: string,
    message: string,
    details?: object
  },
  timestamp: number
}
```

### Paginated Response
```typescript
{
  success: true,
  data: T[],
  pagination: {
    page: number,
    limit: number,
    total: number,
    hasNext: boolean,
    hasPrev: boolean
  },
  timestamp: number
}
```

## Authentication & Rate Limiting

### API Keys
- Optional API keys for higher rate limits
- JWT tokens for authenticated features
- Wallet signature verification for user actions

### Rate Limiting
- Anonymous: 100 requests/minute
- Authenticated: 1000 requests/minute
- Premium: 10000 requests/minute

### CORS Policy
- Allowed origins: configured domains
- Credentials: included for authenticated requests
- Methods: GET, POST, OPTIONS

## Caching Strategy

### Cache Levels
1. **Browser Cache**: Static responses (5 minutes)
2. **CDN Cache**: Public data (1 minute)
3. **Application Cache**: Computed results (30 seconds)
4. **Database Cache**: Query results (10 seconds)

### Cache Keys
- Include relevant parameters in cache keys
- Invalidate on blockchain state changes
- Use cache tags for bulk invalidation

## Error Handling

### Common Error Codes
- `INVALID_ADDRESS`: Malformed Solana address
- `ACCOUNT_NOT_FOUND`: Account doesn't exist
- `TRANSACTION_NOT_FOUND`: Transaction not found
- `RATE_LIMIT_EXCEEDED`: Too many requests
- `INTERNAL_ERROR`: Server-side error
- `NETWORK_ERROR`: Solana RPC error

### Error Recovery
- Automatic retries for transient errors
- Fallback to alternative RPC endpoints
- Graceful degradation for non-critical features# Block Explorer Routes Steering

## Routes Covered
- `/block/[slot]` - Individual block details
- `/block/[slot]/opengraph-image` - Block social sharing images
- `/blocks` - Block list and exploration

## Block Detail Page (`/block/[slot]`)

### Purpose
Display comprehensive information about a specific Solana block including metadata, transactions, validator info, and performance metrics.

### Key Components Required
- **BlockDetails**: Main component showing block metadata
- **TransactionsInBlock**: List of all transactions in the block
- **ValidatorInfo**: Information about the block producer
- **BlockRewards**: Rewards calculation and distribution
- **BlockNavigation**: Previous/next block navigation

### Data Requirements
```typescript
interface BlockData {
  slot: number;
  blockhash: string;
  parentSlot: number;
  blockTime: number | null;
  blockHeight: number;
  transactions: Transaction[];
  rewards: Reward[];
  validator: ValidatorInfo;
  metrics: BlockMetrics;
}

interface BlockMetrics {
  transactionCount: number;
  successfulTransactions: number;
  failedTransactions: number;
  totalFees: number;
  computeUnitsConsumed: number;
  averageTransactionSize: number;
}
```

### Implementation Guidelines
- Use server-side rendering for SEO and performance
- Implement proper error handling for invalid slots
- Cache block data aggressively (blocks are immutable)
- Show loading states for transaction list
- Implement pagination for blocks with many transactions
- Add breadcrumb navigation (Home > Blocks > Block #12345)

### Performance Considerations
- Lazy load transaction details
- Implement virtual scrolling for large transaction lists
- Use React.memo for transaction list items
- Prefetch adjacent blocks for navigation

### Error Handling
- Invalid slot numbers should show 404
- Network errors should show retry mechanism
- Partial data loading should show what's available

## Block List Page (`/blocks`)

### Purpose
Browse recent blocks with real-time updates, statistics, and search functionality.

### Key Components Required
- **BlockExploreTable**: Main table showing recent blocks
- **NetworkStats**: Real-time network statistics
- **BlockFilters**: Filtering and search options
- **LoadMoreButton**: Pagination for older blocks

### Features to Implement
- Real-time block updates (WebSocket/SSE)
- Auto-refresh every 30 seconds
- Load more functionality for historical blocks
- Block statistics dashboard
- Search by slot number or blockhash
- Export functionality for block data

### Data Structure
```typescript
interface BlockListItem {
  slot: number;
  blockhash: string;
  blockTime: number;
  transactionCount: number;
  validator: string;
  fees: number;
  status: 'confirmed' | 'finalized';
}
```

### Real-time Updates
- Connect to `/api/sse-events/feed` for live block updates
- Update block list without full page refresh
- Show notification for new blocks
- Maintain scroll position during updates

## OpenGraph Images (`/block/[slot]/opengraph-image`)

### Purpose
Generate dynamic social sharing images for block pages.

### Implementation
- Use Next.js ImageResponse API
- Include key block information (slot, time, transaction count)
- Use consistent branding and styling
- Optimize for Twitter/Discord/LinkedIn sharing
- Cache generated images

### Image Content
- Block slot number prominently displayed
- Block timestamp
- Transaction count
- Validator information
- OpenSVM branding

## API Integration

### Required Endpoints
- `GET /api/block?slot={slot}` - Get specific block data
- `GET /api/blocks` - Get recent blocks list
- `GET /api/blocks/stats` - Get block statistics
- `SSE /api/sse-events/feed` - Real-time block updates

### Caching Strategy
- Block data: Cache indefinitely (immutable)
- Block list: Cache for 30 seconds
- Statistics: Cache for 10 seconds
- Use stale-while-revalidate pattern

## Testing Requirements

### Unit Tests
- Block data parsing and validation
- Component rendering with mock data
- Error state handling
- Loading state management

### Integration Tests
- Block page loads correctly with valid slot
- Invalid slots show appropriate errors
- Navigation between blocks works
- Real-time updates function properly

### E2E Tests
- Search for specific block works
- Block list pagination functions
- Social sharing generates correct images
- Mobile responsiveness

## Accessibility Requirements
- Proper heading hierarchy (h1 > h2 > h3)
- ARIA labels for interactive elements
- Keyboard navigation support
- Screen reader compatibility
- High contrast mode support

## Mobile Considerations
- Responsive table design for block list
- Touch-friendly navigation buttons
- Optimized loading for mobile networks
- Simplified view for small screens

## SEO Optimization
- Dynamic meta titles: "Block #12345 | OpenSVM"
- Meta descriptions with block summary
- Structured data for search engines
- Canonical URLs for block pages
- Sitemap inclusion for recent blocks# OpenSVM Components Documentation

## Component Architecture

Components are organized by feature area and follow consistent patterns for props, state management, error handling, and accessibility.

## Core UI Components (`/components/ui/`)

### Base Components
- **Button**: Primary, secondary, destructive, ghost variants with loading states
- **Input**: Text inputs with validation states and icons
- **Card**: Container component with header, content, and footer sections
- **Table**: Data tables with sorting, pagination, and selection
- **Dialog**: Modal dialogs with backdrop and focus management
- **Dropdown**: Dropdown menus with keyboard navigation
- **Progress**: Progress bars and loading indicators
- **Avatar**: User avatars with fallback initials
- **Badge**: Status badges and labels
- **Tooltip**: Contextual help tooltips

### Form Components
- **Form**: Form wrapper with validation and error handling
- **FormField**: Individual form fields with labels and validation
- **Select**: Dropdown select with search and multi-select
- **Checkbox**: Checkboxes with indeterminate state
- **RadioGroup**: Radio button groups
- **Switch**: Toggle switches
- **Slider**: Range sliders with multiple handles

## Blockchain-Specific Components

### Account Components (`/components/account/`)

#### `AccountInfo`
- **Purpose**: Display basic account information
- **Props**: `address`, `isSystemProgram`, `parsedOwner`
- **Features**: Address validation, copy functionality, QR code generation
- **Usage**: Account detail pages, search results

#### `AccountOverview`
- **Purpose**: Account balance and token holdings summary
- **Props**: `address`, `solBalance`, `tokenAccounts`, `isSystemProgram`
- **Features**: Balance formatting, token metadata resolution, USD values
- **State**: Loading states, error handling, refresh capability

#### `AccountTabs`
- **Purpose**: Tabbed interface for account data (tokens, transactions, NFTs)
- **Props**: `address`, `solBalance`, `tokenBalances`, `activeTab`
- **Features**: Lazy loading, URL synchronization, infinite scroll
- **Tabs**: Tokens, Transactions, NFTs, Programs, History

### Transaction Components (`/components/transaction/`)

#### `TransactionDetails`
- **Purpose**: Complete transaction information display
- **Props**: `signature`, `transaction`, `meta`
- **Features**: Instruction parsing, account changes, fee breakdown
- **Sections**: Overview, Instructions, Account Changes, Logs

#### `TransactionGraph`
- **Purpose**: Visual representation of transaction flow
- **Props**: `address`, `signature?`, `depth?`
- **Features**: Interactive graph, zoom/pan, node filtering
- **Libraries**: D3.js for rendering, Cytoscape for layout

#### `TransactionTable`
- **Purpose**: Paginated table of transactions
- **Props**: `transactions`, `loading`, `onLoadMore`
- **Features**: Sorting, filtering, infinite scroll, export
- **Columns**: Signature, Type, Age, Fee, Status

### Block Components (`/components/block/`)

#### `BlockDetails`
- **Purpose**: Block information and transaction list
- **Props**: `slot`, `block?`
- **Features**: Block metadata, transaction filtering, validator info
- **Sections**: Header, Transactions, Rewards, Statistics

#### `RecentBlocks`
- **Purpose**: Live feed of recent blocks
- **Props**: `blocks`, `onBlockSelect`, `isLoading`
- **Features**: Real-time updates, click handling, loading states
- **Updates**: WebSocket connection for live data

### Token Components (`/components/token/`)

#### `TokenDetails`
- **Purpose**: Token metadata and statistics
- **Props**: `mint`, `token?`
- **Features**: Token info, supply data, holder analysis
- **Sections**: Overview, Statistics, Holders, Transfers

#### `TokenBalance`
- **Purpose**: Display token balance with formatting
- **Props**: `balance`, `decimals`, `symbol`, `showUSD?`
- **Features**: Number formatting, USD conversion, loading states

#### `TokenTable`
- **Purpose**: Table of token holdings or transfers
- **Props**: `tokens`, `type`, `loading`
- **Features**: Sorting by balance/value, token metadata, pagination

### Program Components (`/components/program/`)

#### `ProgramDetails`
- **Purpose**: Program information and analysis
- **Props**: `address`, `program?`
- **Features**: Program metadata, instruction analysis, account ownership
- **Sections**: Overview, Instructions, Accounts, Statistics

#### `ProgramVisualizer`
- **Purpose**: Visual representation of program bytecode
- **Props**: `address`, `data`
- **Features**: Hex view, disassembly, interactive exploration
- **Views**: Hex dump, Assembly, Control flow graph

## AI Components (`/components/ai/`)

### Core AI Components

#### `AIChatSidebar`
- **Purpose**: Resizable sidebar with AI chat interface
- **Props**: `isOpen`, `onClose`, `onWidthChange`, `initialWidth`
- **Features**: Drag resize, conversation history, context awareness
- **State**: Chat messages, loading states, error handling

#### `AIAssistant`
- **Purpose**: Main AI interaction component
- **Props**: `context?`, `initialMessage?`
- **Features**: Natural language processing, blockchain data analysis
- **Capabilities**: Transaction explanation, anomaly detection, education

#### `AIChatDialog`
- **Purpose**: Modal dialog for AI interactions
- **Props**: `isOpen`, `onClose`, `context?`
- **Features**: Full-screen chat, context injection, export conversations

### AI Action Components

#### `AIAnalyzeButton`
- **Purpose**: Button to trigger AI analysis of current data
- **Props**: `data`, `type`, `onAnalysis`
- **Features**: Loading states, error handling, result display

#### `AIExplainTransaction`
- **Purpose**: AI explanation of transaction purpose and effects
- **Props**: `signature`, `transaction?`
- **Features**: Natural language explanation, technical details toggle

## Visualization Components (`/components/visualization/`)

### Chart Components

#### `NetworkResponseChart`
- **Purpose**: Real-time network performance visualization
- **Props**: `data`, `timeRange?`
- **Features**: Live updates, zoom/pan, multiple metrics
- **Library**: Chart.js with real-time plugin

#### `TokenPriceChart`
- **Purpose**: Token price history and trends
- **Props**: `mint`, `timeRange`, `data?`
- **Features**: Candlestick/line charts, volume overlay, indicators

#### `AccountActivityChart`
- **Purpose**: Account transaction activity over time
- **Props**: `address`, `timeRange`
- **Features**: Transaction volume, balance changes, activity heatmap

### Graph Components

#### `TransactionGraph`
- **Purpose**: Interactive transaction flow visualization
- **Props**: `address`, `depth?`, `filters?`
- **Features**: Force-directed layout, node clustering, path highlighting
- **Libraries**: D3.js, Cytoscape

#### `WalletConnectionGraph`
- **Purpose**: Wallet relationship visualization
- **Props**: `sourceWallet`, `targetWallet?`, `maxDepth`
- **Features**: Path finding, connection strength, interactive exploration

## Search Components (`/components/search/`)

#### `SearchSuggestions`
- **Purpose**: Auto-complete suggestions for search queries
- **Props**: `showSuggestions`, `suggestions`, `onSelect`
- **Features**: Keyboard navigation, entity type icons, recent searches

#### `SearchResults`
- **Purpose**: Categorized search results display
- **Props**: `results`, `query`, `loading`
- **Features**: Result categorization, pagination, result highlighting

#### `SearchFilters`
- **Purpose**: Advanced search filtering interface
- **Props**: `filters`, `onFilterChange`
- **Features**: Date ranges, amount filters, entity type filters

## Analytics Components (`/components/analytics/`)

#### `NetworkStats`
- **Purpose**: High-level network statistics dashboard
- **Props**: `stats`, `timeRange?`
- **Features**: Key metrics, trend indicators, comparison views

#### `DeFiAnalytics`
- **Purpose**: DeFi protocol analytics and TVL tracking
- **Props**: `protocols?`, `timeRange`
- **Features**: TVL charts, protocol comparison, yield analysis

#### `ValidatorAnalytics`
- **Purpose**: Validator performance and staking analytics
- **Props**: `validators?`, `metrics`
- **Features**: Performance rankings, stake distribution, commission analysis

## Data Display Components

### Table Components

#### `DataTable`
- **Purpose**: Generic data table with advanced features
- **Props**: `data`, `columns`, `pagination?`, `sorting?`
- **Features**: Sorting, filtering, pagination, row selection, export
- **Library**: @tanstack/react-table

#### `VirtualTable`
- **Purpose**: High-performance virtual table for large datasets
- **Props**: `data`, `columns`, `height`
- **Features**: Virtual scrolling, dynamic row heights, column resizing
- **Library**: @visactor/vtable

### List Components

#### `TransactionList`
- **Purpose**: Optimized list of transactions
- **Props**: `transactions`, `showDetails?`, `onSelect?`
- **Features**: Virtual scrolling, lazy loading, item selection

#### `AccountList`
- **Purpose**: List of accounts with metadata
- **Props**: `accounts`, `showBalances?`, `sortBy?`
- **Features**: Balance display, sorting options, bulk actions

## Layout Components

#### `PageLayout`
- **Purpose**: Standard page layout with navigation and sidebar
- **Props**: `children`, `sidebar?`, `breadcrumbs?`
- **Features**: Responsive design, sidebar toggle, breadcrumb navigation

#### `DashboardLayout`
- **Purpose**: Dashboard layout with widget areas
- **Props**: `widgets`, `layout`, `onLayoutChange?`
- **Features**: Drag-and-drop widgets, responsive grid, layout persistence

## Error Handling Components

#### `ErrorBoundary`
- **Purpose**: Catch and display component errors gracefully
- **Props**: `fallback?`, `onError?`
- **Features**: Error reporting, retry functionality, fallback UI

#### `LoadingSpinner`
- **Purpose**: Loading indicators with different styles
- **Props**: `size?`, `variant?`, `text?`
- **Features**: Multiple variants, accessible labels, timeout handling

## Component Patterns

### Props Patterns
```typescript
// Base component props
interface BaseComponentProps {
  className?: string;
  children?: React.ReactNode;
  'data-testid'?: string;
}

// Data component props
interface DataComponentProps<T> extends BaseComponentProps {
  data?: T;
  loading?: boolean;
  error?: Error | null;
  onRefresh?: () => void;
}

// Interactive component props
interface InteractiveComponentProps extends BaseComponentProps {
  disabled?: boolean;
  onClick?: (event: React.MouseEvent) => void;
  onKeyDown?: (event: React.KeyboardEvent) => void;
}
```

### State Management Patterns
```typescript
// Loading states
const [loading, setLoading] = useState(false);
const [error, setError] = useState<Error | null>(null);
const [data, setData] = useState<T | null>(null);

// Async data fetching
const fetchData = useCallback(async () => {
  setLoading(true);
  setError(null);
  try {
    const result = await api.getData();
    setData(result);
  } catch (err) {
    setError(err as Error);
  } finally {
    setLoading(false);
  }
}, []);
```

### Error Handling Patterns
```typescript
// Component error boundaries
const ErrorFallback = ({ error, resetError }: ErrorFallbackProps) => (
  <div className="error-container">
    <h2>Something went wrong</h2>
    <p>{error.message}</p>
    <button onClick={resetError}>Try again</button>
  </div>
);

// Async error handling
const handleAsyncError = (error: Error) => {
  console.error('Component error:', error);
  // Report to error tracking service
  // Show user-friendly error message
};
```

### Accessibility Patterns
```typescript
// ARIA labels and roles
<button
  aria-label="Copy address to clipboard"
  aria-describedby="copy-help-text"
  role="button"
  tabIndex={0}
>
  Copy
</button>

// Keyboard navigation
const handleKeyDown = (event: React.KeyboardEvent) => {
  if (event.key === 'Enter' || event.key === ' ') {
    event.preventDefault();
    onClick?.(event as any);
  }
};
```

### Performance Patterns
```typescript
// Memoization for expensive calculations
const expensiveValue = useMemo(() => {
  return calculateExpensiveValue(data);
}, [data]);

// Callback memoization
const handleClick = useCallback((id: string) => {
  onItemClick?.(id);
}, [onItemClick]);

// Component memoization
const MemoizedComponent = React.memo(Component, (prevProps, nextProps) => {
  return prevProps.data === nextProps.data;
});
```# OpenSVM Development Patterns & Guidelines

## Code Organization Principles

### Feature-First Architecture
- Organize code by feature/domain rather than technical layer
- Keep related functionality together (components, hooks, utils, types)
- Use barrel exports for clean imports
- Co-locate tests with source code

### Naming Conventions

#### Files and Directories
```
// Components - PascalCase
TransactionTable.tsx
AccountOverview.tsx

// Utilities - camelCase
solanaUtils.ts
formatHelpers.ts

// Directories - kebab-case
transaction-graph/
wallet-path-finding/

// API Routes - kebab-case
account-stats/
token-metadata/

// Types - PascalCase with .types.ts suffix
Transaction.types.ts
Account.types.ts
```

#### Variables and Functions
```typescript
// Variables - camelCase
const accountBalance = 1000;
const isLoading = false;

// Functions - camelCase with descriptive verbs
const fetchAccountData = async () => {};
const parseTransaction = (tx) => {};
const validateSolanaAddress = (address) => {};

// Constants - SCREAMING_SNAKE_CASE
const MAX_RETRY_ATTEMPTS = 3;
const DEFAULT_RPC_TIMEOUT = 5000;

// React Components - PascalCase
const TransactionTable = () => {};
const AccountInfo = () => {};
```

## TypeScript Patterns

### Type Definitions
```typescript
// Base types for blockchain entities
interface SolanaAddress {
  readonly value: string;
  readonly isValid: boolean;
}

interface Transaction {
  signature: string;
  slot: number;
  blockTime: number | null;
  meta: TransactionMeta | null;
  transaction: ParsedTransaction;
}

interface Account {
  address: string;
  lamports: number;
  owner: string;
  executable: boolean;
  rentEpoch: number;
  data: AccountData;
}

// API Response types
interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: ApiError;
  timestamp: number;
  cached?: boolean;
}

interface PaginatedResponse<T> extends ApiResponse<T[]> {
  pagination: {
    page: number;
    limit: number;
    total: number;
    hasNext: boolean;
    hasPrev: boolean;
  };
}
```

### Generic Patterns
```typescript
// Generic data fetching hook
function useAsyncData<T>(
  fetcher: () => Promise<T>,
  deps: React.DependencyList = []
) {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const fetchData = useCallback(async () => {
    setLoading(true);
    setError(null);
    try {
      const result = await fetcher();
      setData(result);
    } catch (err) {
      setError(err as Error);
    } finally {
      setLoading(false);
    }
  }, deps);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  return { data, loading, error, refetch: fetchData };
}

// Generic table column definition
interface TableColumn<T> {
  key: keyof T;
  header: string;
  render?: (value: T[keyof T], row: T) => React.ReactNode;
  sortable?: boolean;
  width?: string;
}
```

## React Patterns

### Component Structure
```typescript
// Standard component structure
interface ComponentProps {
  // Required props first
  data: SomeData;
  onAction: (id: string) => void;
  
  // Optional props with defaults
  loading?: boolean;
  className?: string;
  
  // Event handlers
  onClick?: (event: React.MouseEvent) => void;
  
  // Children and render props
  children?: React.ReactNode;
  renderItem?: (item: SomeData) => React.ReactNode;
}

const Component: React.FC<ComponentProps> = ({
  data,
  onAction,
  loading = false,
  className,
  onClick,
  children,
  renderItem
}) => {
  // Hooks at the top
  const [localState, setLocalState] = useState();
  const { otherData } = useCustomHook();
  
  // Event handlers
  const handleClick = useCallback((event: React.MouseEvent) => {
    onClick?.(event);
    // Additional logic
  }, [onClick]);
  
  // Effects
  useEffect(() => {
    // Side effects
  }, [data]);
  
  // Early returns for loading/error states
  if (loading) {
    return <LoadingSpinner />;
  }
  
  // Main render
  return (
    <div className={cn('component-base', className)}>
      {children}
      {/* Component content */}
    </div>
  );
};
```

### Custom Hooks Patterns
```typescript
// Data fetching hook
function useSolanaAccount(address: string) {
  return useAsyncData(
    () => fetchAccountData(address),
    [address]
  );
}

// State management hook
function useTransactionFilters() {
  const [filters, setFilters] = useState<TransactionFilters>({
    type: 'all',
    dateRange: 'week',
    minAmount: 0
  });
  
  const updateFilter = useCallback((key: keyof TransactionFilters, value: any) => {
    setFilters(prev => ({ ...prev, [key]: value }));
  }, []);
  
  const resetFilters = useCallback(() => {
    setFilters({
      type: 'all',
      dateRange: 'week',
      minAmount: 0
    });
  }, []);
  
  return { filters, updateFilter, resetFilters };
}

// WebSocket hook
function useRealtimeData<T>(endpoint: string) {
  const [data, setData] = useState<T[]>([]);
  const [connected, setConnected] = useState(false);
  
  useEffect(() => {
    const eventSource = new EventSource(endpoint);
    
    eventSource.onopen = () => setConnected(true);
    eventSource.onmessage = (event) => {
      const newData = JSON.parse(event.data);
      setData(prev => [newData, ...prev.slice(0, 99)]); // Keep last 100
    };
    eventSource.onerror = () => setConnected(false);
    
    return () => {
      eventSource.close();
      setConnected(false);
    };
  }, [endpoint]);
  
  return { data, connected };
}
```

## Error Handling Patterns

### API Error Handling
```typescript
// Centralized error handling
class ApiError extends Error {
  constructor(
    message: string,
    public code: string,
    public status?: number,
    public details?: any
  ) {
    super(message);
    this.name = 'ApiError';
  }
}

// Error boundary for components
class ErrorBoundary extends React.Component<
  { children: React.ReactNode; fallback?: React.ComponentType<any> },
  { hasError: boolean; error?: Error }
> {
  constructor(props: any) {
    super(props);
    this.state = { hasError: false };
  }
  
  static getDerivedStateFromError(error: Error) {
    return { hasError: true, error };
  }
  
  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('Component error:', error, errorInfo);
    // Report to error tracking service
  }
  
  render() {
    if (this.state.hasError) {
      const Fallback = this.props.fallback || DefaultErrorFallback;
      return <Fallback error={this.state.error} />;
    }
    
    return this.props.children;
  }
}

// Async error handling
const handleAsyncError = (error: unknown, context: string) => {
  const apiError = error instanceof ApiError ? error : new ApiError(
    'Unknown error occurred',
    'UNKNOWN_ERROR',
    undefined,
    error
  );
  
  console.error(`Error in ${context}:`, apiError);
  
  // Report to monitoring service
  if (typeof window !== 'undefined') {
    // Client-side error reporting
  }
  
  return apiError;
};
```

### Validation Patterns
```typescript
// Input validation with Zod
import { z } from 'zod';

const SolanaAddressSchema = z.string()
  .min(32, 'Address too short')
  .max(44, 'Address too long')
  .regex(/^[1-9A-HJ-NP-Za-km-z]+$/, 'Invalid characters in address');

const TransactionSignatureSchema = z.string()
  .length(88, 'Invalid signature length')
  .regex(/^[1-9A-HJ-NP-Za-km-z]+$/, 'Invalid characters in signature');

// Form validation
const AccountFormSchema = z.object({
  address: SolanaAddressSchema,
  label: z.string().min(1, 'Label required').max(50, 'Label too long'),
  tags: z.array(z.string()).max(10, 'Too many tags')
});

type AccountFormData = z.infer<typeof AccountFormSchema>;

// Validation hook
function useFormValidation<T>(schema: z.ZodSchema<T>) {
  const [errors, setErrors] = useState<Record<string, string>>({});
  
  const validate = useCallback((data: unknown): data is T => {
    try {
      schema.parse(data);
      setErrors({});
      return true;
    } catch (error) {
      if (error instanceof z.ZodError) {
        const fieldErrors: Record<string, string> = {};
        error.errors.forEach(err => {
          if (err.path.length > 0) {
            fieldErrors[err.path[0]] = err.message;
          }
        });
        setErrors(fieldErrors);
      }
      return false;
    }
  }, [schema]);
  
  return { errors, validate };
}
```

## Performance Optimization Patterns

### Memoization
```typescript
// Expensive calculations
const MemoizedComponent = React.memo(({ data, filters }) => {
  const processedData = useMemo(() => {
    return data
      .filter(item => matchesFilters(item, filters))
      .sort((a, b) => b.timestamp - a.timestamp);
  }, [data, filters]);
  
  const handleItemClick = useCallback((id: string) => {
    // Handle click
  }, []);
  
  return (
    <div>
      {processedData.map(item => (
        <Item key={item.id} data={item} onClick={handleItemClick} />
      ))}
    </div>
  );
});

// Custom comparison for memo
const arePropsEqual = (prevProps: Props, nextProps: Props) => {
  return (
    prevProps.data.length === nextProps.data.length &&
    prevProps.filters === nextProps.filters
  );
};

const OptimizedComponent = React.memo(Component, arePropsEqual);
```

### Virtual Scrolling
```typescript
// Virtual list for large datasets
function useVirtualList<T>({
  items,
  itemHeight,
  containerHeight,
  overscan = 5
}: {
  items: T[];
  itemHeight: number;
  containerHeight: number;
  overscan?: number;
}) {
  const [scrollTop, setScrollTop] = useState(0);
  
  const visibleRange = useMemo(() => {
    const start = Math.floor(scrollTop / itemHeight);
    const end = Math.min(
      start + Math.ceil(containerHeight / itemHeight) + overscan,
      items.length
    );
    
    return { start: Math.max(0, start - overscan), end };
  }, [scrollTop, itemHeight, containerHeight, items.length, overscan]);
  
  const visibleItems = useMemo(() => {
    return items.slice(visibleRange.start, visibleRange.end).map((item, index) => ({
      item,
      index: visibleRange.start + index
    }));
  }, [items, visibleRange]);
  
  return {
    visibleItems,
    totalHeight: items.length * itemHeight,
    offsetY: visibleRange.start * itemHeight,
    onScroll: (e: React.UIEvent<HTMLDivElement>) => {
      setScrollTop(e.currentTarget.scrollTop);
    }
  };
}
```

## Testing Patterns

### Component Testing
```typescript
// Test utilities
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { jest } from '@jest/globals';

// Mock providers
const TestProviders: React.FC<{ children: React.ReactNode }> = ({ children }) => (
  <SolanaProvider>
    <ThemeProvider>
      {children}
    </ThemeProvider>
  </SolanaProvider>
);

// Component test
describe('TransactionTable', () => {
  const mockTransactions = [
    {
      signature: 'test-signature-1',
      slot: 12345,
      blockTime: Date.now(),
      // ... other properties
    }
  ];
  
  it('renders transaction list', async () => {
    render(
      <TransactionTable transactions={mockTransactions} />,
      { wrapper: TestProviders }
    );
    
    expect(screen.getByText('test-signature-1')).toBeInTheDocument();
  });
  
  it('handles loading state', () => {
    render(
      <TransactionTable transactions={[]} loading={true} />,
      { wrapper: TestProviders }
    );
    
    expect(screen.getByTestId('loading-spinner')).toBeInTheDocument();
  });
  
  it('calls onTransactionClick when row is clicked', async () => {
    const onTransactionClick = jest.fn();
    
    render(
      <TransactionTable 
        transactions={mockTransactions} 
        onTransactionClick={onTransactionClick}
      />,
      { wrapper: TestProviders }
    );
    
    fireEvent.click(screen.getByText('test-signature-1'));
    
    await waitFor(() => {
      expect(onTransactionClick).toHaveBeenCalledWith('test-signature-1');
    });
  });
});
```

### API Testing
```typescript
// API route testing
import { createMocks } from 'node-mocks-http';
import handler from '@/app/api/account-stats/[address]/route';

describe('/api/account-stats/[address]', () => {
  it('returns account statistics', async () => {
    const { req, res } = createMocks({
      method: 'GET',
      query: { address: 'test-address' }
    });
    
    await handler(req, res);
    
    expect(res._getStatusCode()).toBe(200);
    
    const data = JSON.parse(res._getData());
    expect(data.success).toBe(true);
    expect(data.data).toHaveProperty('balance');
    expect(data.data).toHaveProperty('transactionCount');
  });
  
  it('handles invalid address', async () => {
    const { req, res } = createMocks({
      method: 'GET',
      query: { address: 'invalid' }
    });
    
    await handler(req, res);
    
    expect(res._getStatusCode()).toBe(400);
    
    const data = JSON.parse(res._getData());
    expect(data.success).toBe(false);
    expect(data.error.code).toBe('INVALID_ADDRESS');
  });
});
```

## Security Patterns

### Input Sanitization
```typescript
// Address validation
function validateSolanaAddress(address: string): string {
  const cleaned = address.trim();
  
  if (!cleaned) {
    throw new Error('Address cannot be empty');
  }
  
  if (!/^[1-9A-HJ-NP-Za-km-z]+$/.test(cleaned)) {
    throw new Error('Invalid characters in address');
  }
  
  if (cleaned.length < 32 || cleaned.length > 44) {
    throw new Error('Invalid address length');
  }
  
  return cleaned;
}

// SQL injection prevention (if using raw queries)
function sanitizeQuery(query: string): string {
  return query.replace(/['"\\]/g, '\\$&');
}

// XSS prevention
function sanitizeHtml(html: string): string {
  return html
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#x27;');
}
```

### Rate Limiting
```typescript
// Simple rate limiter
class RateLimiter {
  private requests = new Map<string, number[]>();
  
  constructor(
    private maxRequests: number,
    private windowMs: number
  ) {}
  
  isAllowed(identifier: string): boolean {
    const now = Date.now();
    const windowStart = now - this.windowMs;
    
    const userRequests = this.requests.get(identifier) || [];
    const validRequests = userRequests.filter(time => time > windowStart);
    
    if (validRequests.length >= this.maxRequests) {
      return false;
    }
    
    validRequests.push(now);
    this.requests.set(identifier, validRequests);
    
    return true;
  }
}

// Usage in API routes
const rateLimiter = new RateLimiter(100, 60000); // 100 requests per minute

export async function GET(request: Request) {
  const ip = request.headers.get('x-forwarded-for') || 'unknown';
  
  if (!rateLimiter.isAllowed(ip)) {
    return Response.json(
      { success: false, error: { code: 'RATE_LIMIT_EXCEEDED' } },
      { status: 429 }
    );
  }
  
  // Handle request
}
```# NFT & DeFi Routes Steering

## Routes Covered
- `/nfts` - NFT collections overview
- `/nfts/new` - New NFT collections
- `/nfts/trending` - Trending NFT collections
- `/defi/[category]` - DeFi category pages
- `/dex/[name]` - DEX-specific pages

## NFT Collections Overview (`/nfts`)

### Purpose
Browse and explore NFT collections with market data, filtering, and collection discovery features.

### Key Components Required
- **NFTCollectionsGrid**: Main grid display of collections
- **CollectionFilters**: Filtering and search controls
- **MarketOverview**: NFT market statistics
- **FeaturedCollections**: Highlighted collections section
- **CollectionCategories**: Collections grouped by category
- **TrendingSection**: Popular collections showcase

### Data Requirements
```typescript
interface NFTCollection {
  address: string;
  name: string;
  symbol: string;
  description: string;
  image: string;
  bannerImage?: string;
  creator: string;
  verified: boolean;
  marketData: NFTMarketData;
  metadata: CollectionMetadata;
  statistics: CollectionStatistics;
}

interface NFTMarketData {
  floorPrice: number;
  volume24h: number;
  volume7d: number;
  volumeChange24h: number;
  sales24h: number;
  averagePrice: number;
  marketCap: number;
  holders: number;
  listedCount: number;
  listedPercentage: number;
}

interface CollectionMetadata {
  totalSupply: number;
  mintedCount: number;
  category: string;
  tags: string[];
  website?: string;
  twitter?: string;
  discord?: string;
  royalty: number;
  launchDate: number;
}

interface CollectionStatistics {
  uniqueHolders: number;
  averageHoldingTime: number;
  whaleHolders: number;
  paperHands: number;
  diamondHands: number;
  holderDistribution: HolderDistribution[];
}
```

### Implementation Guidelines
- Use server-side rendering for SEO optimization
- Implement lazy loading for collection images
- Show loading states for market data
- Cache collection metadata appropriately
- Implement infinite scroll for large collections
- Add collection comparison functionality

### Filtering and Search Features
- Search by collection name or creator
- Filter by price range and volume
- Category-based filtering
- Sort by various metrics (floor price, volume, holders)
- Verified collections filter
- Recently launched collections

## New NFT Collections (`/nfts/new`)

### Purpose
Showcase recently launched NFT collections with launch metrics and early performance data.

### Key Components Required
- **NewCollectionsTable**: Recently launched collections
- **LaunchCalendar**: Upcoming collection launches
- **LaunchMetrics**: Launch performance indicators
- **MintingProgress**: Live minting status for active launches
- **EarlyAdopters**: Early holder analysis
- **LaunchAlerts**: Notification system for new launches

### Launch Tracking Features
```typescript
interface CollectionLaunch {
  collection: NFTCollection;
  launchDate: number;
  mintPrice: number;
  currentFloorPrice: number;
  priceChangeFromMint: number;
  mintedPercentage: number;
  uniqueMinters: number;
  averageMintsPerWallet: number;
  whaleActivity: WhaleActivity[];
  socialMetrics: SocialMetrics;
}

interface WhaleActivity {
  wallet: string;
  mintCount: number;
  totalSpent: number;
  flippedCount: number;
  currentHoldings: number;
}

interface SocialMetrics {
  twitterFollowers: number;
  discordMembers: number;
  socialGrowth24h: number;
  mentionCount: number;
  sentiment: 'positive' | 'neutral' | 'negative';
}
```

### Features to Implement
- Real-time minting progress tracking
- Launch performance analysis
- Early holder identification
- Social media integration
- Launch calendar with notifications
- Risk assessment for new collections

## Trending NFT Collections (`/nfts/trending`)

### Purpose
Display trending NFT collections based on various metrics like volume, price changes, and social activity.

### Key Components Required
- **TrendingCollectionsTable**: Collections sorted by trending metrics
- **TrendingMetrics**: Different trending algorithms
- **VolumeLeaders**: Collections by trading volume
- **PriceMovers**: Collections with significant price changes
- **SocialTrending**: Collections trending on social media
- **TrendingAlerts**: Notifications for trending collections

### Trending Algorithms
```typescript
interface TrendingCalculator {
  calculateVolumeScore: (collection: NFTCollection) => number;
  calculatePriceScore: (collection: NFTCollection) => number;
  calculateSocialScore: (collection: NFTCollection) => number;
  calculateOverallTrending: (collection: NFTCollection) => number;
}

interface TrendingMetrics {
  volumeScore: number;
  priceScore: number;
  socialScore: number;
  holderScore: number;
  overallScore: number;
  rank: number;
  change24h: number;
}
```

## DeFi Category Pages (`/defi/[category]`)

### Purpose
Category-specific DeFi analytics and protocol listings with detailed metrics and comparison tools.

### Supported Categories
- `defai` - DeFi AI protocols
- `aggregators` - DEX aggregators
- `yield-agg` - Yield aggregators
- `lending` - Lending protocols
- `derivatives` - Derivatives platforms
- `insurance` - DeFi insurance
- `payments` - Payment protocols
- `synthetics` - Synthetic assets
- `asset-management` - Asset management
- `infrastructure` - DeFi infrastructure
- `governance` - Governance protocols

### Key Components Required
- **CategoryOverview**: Category statistics and metrics
- **ProtocolRankings**: Protocols ranked by various metrics
- **CategoryComparison**: Compare protocols within category
- **TVLAnalysis**: Total Value Locked analysis
- **YieldOpportunities**: Yield farming opportunities
- **RiskAssessment**: Protocol risk analysis
- **CategoryTrends**: Historical trends and forecasting

### Data Structure
```typescript
interface DeFiCategory {
  name: string;
  description: string;
  protocols: DeFiProtocol[];
  totalTVL: number;
  totalVolume24h: number;
  protocolCount: number;
  dominanceIndex: number;
  growth: GrowthMetrics;
  risks: CategoryRisk[];
}

interface DeFiProtocol {
  name: string;
  category: string;
  tvl: number;
  volume24h: number;
  users24h: number;
  fees24h: number;
  revenue24h: number;
  apy: number;
  tokens: string[];
  chains: string[];
  riskScore: number;
  auditStatus: AuditStatus;
}

interface GrowthMetrics {
  tvlGrowth7d: number;
  tvlGrowth30d: number;
  volumeGrowth7d: number;
  volumeGrowth30d: number;
  userGrowth7d: number;
  userGrowth30d: number;
}
```

### Implementation Guidelines
- Dynamic routing for all DeFi categories
- Real-time TVL and volume updates
- Protocol comparison tools
- Risk assessment integration
- Yield opportunity scanner
- Historical performance tracking

## DEX Pages (`/dex/[name]`)

### Purpose
DEX-specific analytics and trading interface with liquidity analysis and trading tools.

### Key Components Required
- **DEXOverview**: DEX statistics and information
- **TradingInterface**: Basic trading functionality
- **LiquidityPools**: Pool analysis and metrics
- **TradingPairs**: Available trading pairs
- **VolumeAnalysis**: Trading volume breakdown
- **FeeAnalysis**: Fee structure and earnings
- **ArbitrageOpportunities**: Cross-DEX arbitrage detection

### DEX Data Structure
```typescript
interface DEXData {
  name: string;
  protocol: string;
  totalLiquidity: number;
  volume24h: number;
  fees24h: number;
  pairs: TradingPair[];
  pools: LiquidityPool[];
  users24h: number;
  transactions24h: number;
  averageTradeSize: number;
}

interface TradingPair {
  baseToken: string;
  quoteToken: string;
  price: number;
  priceChange24h: number;
  volume24h: number;
  liquidity: number;
  spread: number;
  lastTrade: number;
}

interface LiquidityPool {
  address: string;
  tokens: PoolToken[];
  totalLiquidity: number;
  volume24h: number;
  fees24h: number;
  apy: number;
  impermanentLoss: number;
  providers: number;
}
```

## API Integration

### Required Endpoints
- `GET /api/nft-collections` - Get NFT collections data
- `GET /api/nft-collections/trending` - Get trending collections
- `GET /api/nft-collections/new` - Get new collections
- `GET /api/defi/[category]` - Get DeFi category data
- `GET /api/dex/[name]` - Get DEX-specific data
- `GET /api/nft-market-stats` - Get NFT market statistics
- `GET /api/defi-tvl` - Get DeFi TVL data

### Real-time Updates
- WebSocket for live NFT sales and listings
- Server-sent events for DeFi metrics updates
- Push notifications for trending collections
- Real-time DEX trading data

### Caching Strategy
- NFT collection metadata: Cache for 1 hour
- Market data: Cache for 1-5 minutes
- DeFi protocol data: Cache for 5 minutes
- DEX data: Cache for 30 seconds
- Trending calculations: Cache for 10 minutes

## Testing Requirements

### Unit Tests
- NFT data parsing and validation
- DeFi metrics calculations
- Trending algorithm accuracy
- DEX data processing
- Market statistics computation

### Integration Tests
- NFT collection pages load correctly
- DeFi category navigation works
- DEX data displays properly
- Real-time updates function
- Filtering and search work

### E2E Tests
- NFT browsing and discovery
- DeFi protocol comparison
- DEX trading interface
- Mobile responsiveness
- Social sharing functionality

## Performance Considerations
- Lazy load NFT images and metadata
- Implement virtual scrolling for large lists
- Use React.memo for collection items
- Optimize chart rendering for DeFi data
- Bundle split heavy visualization libraries

## Security Considerations
- Validate NFT metadata before display
- Sanitize user-generated content
- Rate limit API requests
- Prevent manipulation of market data
- Secure handling of trading data

## Accessibility Requirements
- Screen reader support for market data
- Keyboard navigation for all features
- High contrast mode for charts
- Alternative text for NFT images
- Focus management in modal dialogs

## Mobile Optimization
- Responsive grid layouts for NFTs
- Touch-friendly trading interfaces
- Optimized image loading
- Simplified views for small screens
- Swipe gestures for navigation

## SEO Optimization
- Dynamic meta titles for categories
- Rich meta descriptions with market data
- Structured data for NFT collections
- Canonical URLs for all pages
- Social media optimization

## Monitoring and Analytics
- Track user engagement with NFT collections
- Monitor DeFi protocol performance
- Measure trading interface usage
- Track error rates and API failures
- Monitor market data accuracy# OpenSVM Page Specifications & Testing Requirements

## Page Analysis Overview

This document provides detailed specifications for each page in OpenSVM, analyzing current implementation status, functionality, and testing requirements. Each page is evaluated for UX/UI completeness and missing features.

---

## 1. Homepage (`/`)

### **Purpose**
Landing page and network dashboard providing search functionality, real-time network statistics, and AI assistant access.

### **Current Implementation Status: ✅ FULLY IMPLEMENTED**

#### **Working Features**
- ✅ Hero section with branding and tagline
- ✅ Universal search bar with auto-suggestions
- ✅ Real-time network statistics (TPS, validators, block height)
- ✅ Network performance chart with live data
- ✅ Recent blocks feed with click-to-view functionality
- ✅ Transaction details for selected blocks
- ✅ AI Assistant floating button
- ✅ Resizable AI chat sidebar
- ✅ Auto-refresh every 30 seconds
- ✅ Responsive design
- ✅ Search suggestions with debouncing
- ✅ Error handling and loading states

#### **UX/UI Testing Checklist**
- [ ] Search bar accepts various input types (addresses, signatures, block numbers)
- [ ] Auto-suggestions appear after 2+ characters
- [ ] Search redirects correctly based on input type
- [ ] Network stats update in real-time
- [ ] Charts render properly and show live data
- [ ] Recent blocks list updates automatically
- [ ] Block selection shows transaction details
- [ ] AI sidebar opens/closes smoothly
- [ ] AI sidebar is resizable
- [ ] Page is responsive on mobile/tablet
- [ ] Loading states are shown appropriately
- [ ] Error states are handled gracefully

#### **Missing Features: NONE**
All core homepage functionality is implemented and working.

---

## 2. Search Results (`/search`)

### **Purpose**
Universal search interface with AI-enhanced results, filtering, and multi-source search capabilities.

### **Current Implementation Status: ✅ FULLY IMPLEMENTED**

#### **Working Features**
- ✅ Universal search with query parameter handling
- ✅ Auto-redirect for specific entity types (addresses, signatures, blocks)
- ✅ AI-enhanced search results with streaming responses
- ✅ Multi-source search tabs (SVM, Telegram, DuckDuckGo, X.com)
- ✅ Search results table with sorting and pagination
- ✅ Advanced search filters
- ✅ Real-time AI analysis of search queries
- ✅ Source attribution for AI responses
- ✅ Error handling and fallback results
- ✅ Accessibility features (ARIA labels, keyboard navigation)

#### **UX/UI Testing Checklist**
- [ ] Search query from homepage redirects correctly
- [ ] Direct entity searches redirect to appropriate pages
- [ ] AI panel shows thinking/streaming states
- [ ] AI responses stream in real-time
- [ ] Search source tabs work correctly
- [ ] Results table sorts by all columns
- [ ] Pagination works properly
- [ ] Filters apply correctly to results
- [ ] Error states show appropriate messages
- [ ] Keyboard navigation works throughout
- [ ] Screen reader compatibility

#### **Missing Features: NONE**
Search functionality is comprehensive and fully implemented.

---

## 3. Account Explorer (`/account/[address]`)

### **Purpose**
Detailed account information including balances, token holdings, transaction history, and relationship analysis.

### **Current Implementation Status: ✅ FULLY IMPLEMENTED**

#### **Working Features**
- ✅ Account information display (address, owner, balance)
- ✅ Token holdings with metadata
- ✅ Transaction history with pagination
- ✅ Transaction graph visualization
- ✅ Account overview with statistics
- ✅ Tabbed interface (tokens, transactions, NFTs, programs)
- ✅ Sidebar advertisements for monetization
- ✅ Address validation and error handling
- ✅ Loading states and error boundaries
- ✅ Responsive layout with sidebar

#### **UX/UI Testing Checklist**
- [ ] Valid addresses load account information
- [ ] Invalid addresses show appropriate errors
- [ ] Token balances display correctly with USD values
- [ ] Transaction history loads and paginates
- [ ] Transaction graph renders and is interactive
- [ ] Tabs switch correctly and maintain state
- [ ] Sidebar ads are clickable and tracked
- [ ] Page is responsive across devices
- [ ] Loading states appear during data fetching
- [ ] Error boundaries catch component errors

#### **Missing Features: MINOR**
- ⚠️ NFT tab content may need more detailed implementation
- ⚠️ Programs tab could show more detailed program interactions

---

## 4. Transaction Explorer (`/tx/[signature]`)

### **Purpose**
Detailed transaction analysis including instructions, account changes, fees, and AI-powered explanations.

### **Current Implementation Status: ✅ MOSTLY IMPLEMENTED**

#### **Working Features**
- ✅ Transaction details display
- ✅ Error boundary and loading states
- ✅ Suspense for async loading
- ✅ Server-side signature parameter handling

#### **UX/UI Testing Checklist**
- [ ] Valid signatures load transaction details
- [ ] Invalid signatures show appropriate errors
- [ ] Transaction instructions are parsed and displayed
- [ ] Account changes are shown clearly
- [ ] Fee breakdown is accurate
- [ ] AI analysis explains transaction purpose
- [ ] Related transactions are linked
- [ ] Transaction graph visualization works
- [ ] Page loads quickly for recent transactions
- [ ] Historical transactions load correctly

#### **Missing Features: MODERATE**
- ⚠️ Detailed instruction parsing and display
- ⚠️ Account changes visualization
- ⚠️ AI-powered transaction explanation
- ⚠️ Related transaction discovery
- ⚠️ Transaction graph visualization

---

## 5. Block Explorer (`/block/[slot]`)

### **Purpose**
Block information including metadata, transaction list, validator details, and performance metrics.

### **Current Implementation Status: ✅ MOSTLY IMPLEMENTED**

#### **Working Features**
- ✅ Block details component integration
- ✅ Slot parameter handling
- ✅ Basic block information display

#### **UX/UI Testing Checklist**
- [ ] Valid slots load block information
- [ ] Invalid slots show appropriate errors
- [ ] Block metadata displays correctly
- [ ] Transaction list is complete and clickable
- [ ] Validator information is shown
- [ ] Block rewards are calculated
- [ ] Performance metrics are accurate
- [ ] Navigation to adjacent blocks works
- [ ] Block hash and parent hash are shown
- [ ] Timestamp formatting is correct

#### **Missing Features: MODERATE**
- ⚠️ Comprehensive block metadata display
- ⚠️ Transaction filtering and search within block
- ⚠️ Validator performance metrics
- ⚠️ Block rewards calculation and display
- ⚠️ Navigation to previous/next blocks

---

## 6. Token Explorer (`/token/[mint]`)

### **Purpose**
Token information including metadata, statistics, holder analysis, and transfer history.

### **Current Implementation Status: ✅ MOSTLY IMPLEMENTED**

#### **Working Features**
- ✅ Token details component integration
- ✅ Mint parameter handling
- ✅ Metadata generation for SEO

#### **UX/UI Testing Checklist**
- [ ] Valid mint addresses load token information
- [ ] Invalid mints show appropriate errors
- [ ] Token metadata displays correctly (name, symbol, decimals)
- [ ] Supply information is accurate
- [ ] Holder distribution is shown
- [ ] Transfer history loads and paginates
- [ ] Price charts render correctly
- [ ] Market data is up-to-date
- [ ] Token logo displays properly
- [ ] Social links work correctly

#### **Missing Features: MODERATE**
- ⚠️ Comprehensive token statistics
- ⚠️ Holder distribution analysis
- ⚠️ Price charts and market data
- ⚠️ Transfer history with filtering
- ⚠️ Token social media integration

---

## 7. Program Explorer (`/program/[address]`)

### **Purpose**
Program analysis including metadata, instruction usage, account ownership, and code visualization.

### **Current Implementation Status: ✅ PARTIALLY IMPLEMENTED**

#### **Working Features**
- ✅ Program content wrapper and client components
- ✅ Disassembly and hex view capabilities
- ✅ Program visualizer component
- ✅ Layout and OpenGraph integration

#### **UX/UI Testing Checklist**
- [ ] Valid program addresses load information
- [ ] Invalid addresses show appropriate errors
- [ ] Program metadata displays correctly
- [ ] Instruction usage statistics are shown
- [ ] Account ownership is analyzed
- [ ] Code disassembly is readable
- [ ] Hex view is properly formatted
- [ ] Program visualizer renders correctly
- [ ] Instruction history loads
- [ ] Related programs are suggested

#### **Missing Features: SIGNIFICANT**
- ❌ Complete program metadata parsing
- ❌ Instruction usage analytics
- ❌ Account ownership analysis
- ❌ Program interaction history
- ❌ Security analysis and audit information

---

## 8. Analytics Dashboard (`/analytics`)

### **Purpose**
Comprehensive analytics for DeFi, DEX, validators, cross-chain, and ecosystem metrics.

### **Current Implementation Status: ✅ FULLY IMPLEMENTED**

#### **Working Features**
- ✅ Tabbed interface with 12 different analytics categories
- ✅ URL-based tab navigation
- ✅ Keyboard navigation support
- ✅ Overview metrics with quick actions
- ✅ Specialized tabs for each analytics category
- ✅ Responsive design with proper ARIA labels
- ✅ Real-time data updates

#### **UX/UI Testing Checklist**
- [ ] All tabs load correctly
- [ ] URL updates when switching tabs
- [ ] Keyboard navigation works
- [ ] Overview metrics display correctly
- [ ] Quick actions navigate to appropriate tabs
- [ ] Each specialized tab shows relevant data
- [ ] Charts and visualizations render properly
- [ ] Data updates in real-time
- [ ] Mobile responsiveness works
- [ ] Accessibility features function correctly

#### **Missing Features: MINOR**
- ⚠️ Some specialized tabs may need more detailed data
- ⚠️ Export functionality for analytics data

---

## 9. AI Chat Interface (`/chat`)

### **Purpose**
Full-screen AI conversation interface with blockchain analysis capabilities.

### **Current Implementation Status: ✅ FULLY IMPLEMENTED**

#### **Working Features**
- ✅ Full-screen chat interface
- ✅ Tabbed interface (Agent, Assistant, Knowledge)
- ✅ AI chat functionality with Solana agent
- ✅ Message history and conversation management
- ✅ Reset and new chat functionality
- ✅ Settings and help integration
- ✅ Responsive design with proper styling

#### **UX/UI Testing Checklist**
- [ ] Chat interface loads correctly
- [ ] Messages send and receive properly
- [ ] AI responses are relevant and helpful
- [ ] Tabs switch correctly
- [ ] Reset functionality clears conversation
- [ ] New chat starts fresh conversation
- [ ] Settings panel opens correctly
- [ ] Help documentation is accessible
- [ ] Keyboard shortcuts work
- [ ] Mobile interface is usable

#### **Missing Features: MINOR**
- ⚠️ Voice input/output capabilities
- ⚠️ Conversation export functionality
- ⚠️ Advanced settings configuration

---

## 10. Network Monitoring (`/monitoring`)

### **Purpose**
Real-time network monitoring with anomaly detection and alert management.

### **Current Implementation Status: ✅ BASIC IMPLEMENTATION**

#### **Working Features**
- ✅ Live event monitor component integration
- ✅ Basic monitoring dashboard

#### **UX/UI Testing Checklist**
- [ ] Live events display in real-time
- [ ] Anomaly detection alerts appear
- [ ] Event filtering works correctly
- [ ] Alert management functions properly
- [ ] Performance metrics are accurate
- [ ] Historical data is accessible
- [ ] Export functionality works
- [ ] Notification settings are configurable

#### **Missing Features: SIGNIFICANT**
- ❌ Comprehensive anomaly detection
- ❌ Alert configuration and management
- ❌ Historical event analysis
- ❌ Performance trend analysis
- ❌ Custom monitoring rules

---

## 11. Programs List (`/programs`)

### **Purpose**
Browse and analyze all programs on Solana with activity metrics and filtering.

### **Current Implementation Status: ✅ FULLY IMPLEMENTED**

#### **Working Features**
- ✅ Program activity table with real-time data
- ✅ Multiple view modes (all, top by calls, transactions, blocks)
- ✅ Program statistics dashboard
- ✅ Auto-refresh every 45 seconds
- ✅ Load more functionality
- ✅ Program type distribution
- ✅ Click-to-navigate to program details
- ✅ Error handling and loading states

#### **UX/UI Testing Checklist**
- [ ] Program list loads correctly
- [ ] View mode switching works
- [ ] Statistics are accurate and update
- [ ] Auto-refresh functions properly
- [ ] Load more button works
- [ ] Program clicks navigate correctly
- [ ] Sorting and filtering work
- [ ] Error states are handled
- [ ] Mobile responsiveness works
- [ ] Performance is acceptable with large lists

#### **Missing Features: NONE**
Programs list is fully functional and comprehensive.

---

## 12. Tokens List (`/tokens`)

### **Purpose**
Browse all tokens with market data, filtering, and real-time updates.

### **Current Implementation Status: ✅ FULLY IMPLEMENTED**

#### **Working Features**
- ✅ Token market table with comprehensive data
- ✅ Auto-refresh every 30 seconds
- ✅ Load more functionality with pagination
- ✅ Token click navigation
- ✅ Real-time market data updates
- ✅ Error handling and loading states
- ✅ Responsive design

#### **UX/UI Testing Checklist**
- [ ] Token list loads with market data
- [ ] Auto-refresh updates prices
- [ ] Load more functionality works
- [ ] Token clicks navigate to details
- [ ] Sorting by different metrics works
- [ ] Price change indicators are accurate
- [ ] Market cap calculations are correct
- [ ] Volume data is up-to-date
- [ ] Mobile interface is usable
- [ ] Performance with large token lists

#### **Missing Features: NONE**
Tokens list is fully functional with comprehensive market data.

---

## 13. Blocks List (`/blocks`)

### **Purpose**
Browse recent blocks with statistics and real-time updates.

### **Current Implementation Status: ✅ FULLY IMPLEMENTED**

#### **Working Features**
- ✅ Block explore table with detailed information
- ✅ Real-time block statistics
- ✅ Auto-refresh every 30 seconds
- ✅ Load more functionality
- ✅ Block click navigation
- ✅ Network performance metrics
- ✅ Live status indicators
- ✅ Error handling and loading states

#### **UX/UI Testing Checklist**
- [ ] Recent blocks load correctly
- [ ] Block statistics are accurate
- [ ] Auto-refresh updates data
- [ ] Load more loads older blocks
- [ ] Block clicks navigate to details
- [ ] TPS calculations are correct
- [ ] Block time averages are accurate
- [ ] Live status indicators work
- [ ] Mobile responsiveness works
- [ ] Performance with large block lists

#### **Missing Features: NONE**
Blocks list is fully functional with comprehensive data.

---

## 14. NFT Collections (`/nfts`)

### **Purpose**
Browse NFT collections with metadata and market information.

### **Current Implementation Status: ✅ BASIC IMPLEMENTATION**

#### **Working Features**
- ✅ NFT collections grid display
- ✅ Collection images and metadata
- ✅ Error handling and loading states
- ✅ Retry mechanism for failed requests
- ✅ Responsive grid layout

#### **UX/UI Testing Checklist**
- [ ] NFT collections load correctly
- [ ] Images display properly with fallbacks
- [ ] Collection metadata is accurate
- [ ] Grid layout is responsive
- [ ] Loading states are shown
- [ ] Error states are handled gracefully
- [ ] Retry mechanism works
- [ ] Collection clicks navigate to details
- [ ] Search and filtering work
- [ ] Market data is displayed

#### **Missing Features: MODERATE**
- ⚠️ Collection detail pages
- ⚠️ Market data integration (floor price, volume)
- ⚠️ Filtering and search functionality
- ⚠️ Trending and new collections sections
- ⚠️ Collection statistics and analytics

---

## 15. Wallet Path Finding (`/wallet-path-finding`)

### **Purpose**
Analyze connections between wallets through transaction flows and token transfers.

### **Current Implementation Status: ❌ NOT IMPLEMENTED**

#### **Missing Features: COMPLETE**
- ❌ Wallet path finding interface
- ❌ Connection analysis algorithms
- ❌ Graph visualization of wallet relationships
- ❌ Path strength and frequency metrics
- ❌ Interactive network exploration
- ❌ Export and sharing functionality

#### **Required Implementation**
- Source/target wallet input fields
- Path finding algorithm integration
- Graph visualization component
- Connection strength analysis
- Interactive network exploration
- Results export functionality

---

## 16. Additional Pages (Partially Implemented)

### **Networks (`/networks`)**
- **Status**: ❌ NOT IMPLEMENTED
- **Purpose**: Compare different Solana networks and RPC endpoints
- **Missing**: Network comparison, RPC status, performance metrics

### **Validators (`/validator/[address]`)**
- **Status**: ⚠️ PARTIALLY IMPLEMENTED
- **Purpose**: Individual validator performance and statistics
- **Missing**: Comprehensive validator metrics, performance history

### **DeFi Categories (`/defi/[category]`)**
- **Status**: ⚠️ PARTIALLY IMPLEMENTED
- **Purpose**: DeFi protocol analysis by category
- **Missing**: Protocol-specific analytics, TVL tracking

### **User Profiles (`/user/[walletAddress]`)**
- **Status**: ⚠️ PARTIALLY IMPLEMENTED
- **Purpose**: User activity and social features
- **Missing**: Social features, activity tracking, preferences

---

## Testing Priority Matrix

### **High Priority (Core Functionality)**
1. Homepage search and navigation
2. Account explorer completeness
3. Transaction analysis accuracy
4. Search functionality reliability
5. Analytics data accuracy

### **Medium Priority (Enhanced Features)**
1. AI chat functionality
2. Real-time data updates
3. Program analysis completeness
4. Token market data accuracy
5. Block explorer features

### **Low Priority (Nice-to-Have)**
1. NFT collection enhancements
2. Social features
3. Advanced filtering options
4. Export functionality
5. Mobile optimizations

---

## Performance Testing Requirements

### **Load Testing**
- [ ] Homepage loads under 2 seconds
- [ ] Search results appear under 1 second
- [ ] Large data tables render smoothly
- [ ] Real-time updates don't cause lag
- [ ] Mobile performance is acceptable

### **Stress Testing**
- [ ] Handle high concurrent users
- [ ] Graceful degradation under load
- [ ] API rate limiting works correctly
- [ ] Error recovery mechanisms function
- [ ] Memory usage remains stable

### **Accessibility Testing**
- [ ] Screen reader compatibility
- [ ] Keyboard navigation works throughout
- [ ] Color contrast meets WCAG standards
- [ ] ARIA labels are comprehensive
- [ ] Focus management is proper

---

## Security Testing Requirements

### **Input Validation**
- [ ] All address inputs are validated
- [ ] SQL injection prevention works
- [ ] XSS protection is effective
- [ ] Rate limiting prevents abuse
- [ ] Error messages don't leak information

### **Data Protection**
- [ ] No sensitive data in client-side code
- [ ] API keys are properly secured
- [ ] User data is handled securely
- [ ] HTTPS is enforced everywhere
- [ ] Content Security Policy is implemented# OpenSVM Product Overview

OpenSVM is a comprehensive blockchain explorer for the Solana ecosystem that provides detailed insights into transactions, blocks, accounts, programs, and tokens on the Solana blockchain.

## Core Features

- **Blockchain Data Browsing**: Explore blocks, transactions, accounts, programs, and tokens
- **Transaction Visualization**: Interactive visualizations of transaction flows and relationships using D3.js, Cytoscape, and Three.js
- **Wallet Path Finding**: Discover connections between wallets through token transfers
- **AI Assistant**: Natural language explanations of blockchain data and transactions with anomaly detection
- **Network Statistics**: Monitor Solana network performance and health metrics
- **Token Analytics**: Track token transfers, balances, and activities
- **Real-time Event Streaming**: Live monitoring with AI-powered anomaly detection

## Target Users

- Blockchain developers and researchers
- Solana ecosystem participants
- Security analysts and auditors
- DeFi users and traders
- General blockchain enthusiasts

## Key Value Propositions

- Modern, user-friendly interface for exploring Solana blockchain
- AI-powered analysis and explanations of complex blockchain data
- Advanced visualization capabilities for understanding transaction flows
- Real-time monitoring and security alerts
- Comprehensive data coverage across the Solana ecosystem

## Page-Specific Features

### Homepage (`/`)
- **Hero Section**: Main branding and search interface
- **Network Statistics**: Real-time Solana network metrics (TPS, validators, epoch progress)
- **Search Bar**: Universal search with auto-suggestions for transactions, blocks, accounts, tokens
- **Recent Blocks**: Live feed of latest blocks with transaction counts
- **Network Performance Chart**: Visual representation of network health over time
- **AI Assistant Button**: Fixed floating button to access AI chat

### Account Explorer (`/account/[address]`)
- **Account Information**: Basic account details, owner, balance
- **Token Holdings**: List of all SPL tokens held by the account
- **Transaction History**: Paginated list of account transactions
- **Transaction Graph**: Visual representation of account's transaction relationships
- **Account Analytics**: Statistics and insights about account activity
- **Sidebar Ads**: Monetization through relevant service advertisements

### Transaction Explorer (`/tx/[signature]`)
- **Transaction Details**: Complete transaction information and metadata
- **Instruction Breakdown**: Detailed analysis of each transaction instruction
- **Account Changes**: Before/after state changes for all affected accounts
- **Transaction Graph**: Visual flow of the transaction
- **AI Analysis**: Natural language explanation of transaction purpose
- **Related Transactions**: Connections to other related transactions

### Block Explorer (`/block/[slot]`)
- **Block Information**: Block metadata, timestamp, parent hash
- **Transaction List**: All transactions included in the block
- **Block Statistics**: Performance metrics and validation info
- **Validator Information**: Details about the block producer
- **Block Rewards**: Rewards distributed for this block

### Token Explorer (`/token/[mint]`)
- **Token Metadata**: Name, symbol, decimals, supply information
- **Token Statistics**: Holder count, transfer volume, price data
- **Holder Distribution**: Top holders and distribution analysis
- **Transfer History**: Recent token transfers and activity
- **Token Analytics**: Charts showing token metrics over time

### Program Explorer (`/program/[address]`)
- **Program Information**: Program metadata and deployment details
- **Program Instructions**: Available instructions and their usage
- **Program Accounts**: Accounts owned by the program
- **Usage Statistics**: Transaction volume and interaction metrics
- **Code Analysis**: Disassembly and hex view of program bytecode

### Analytics Dashboard (`/analytics`)
- **Network Overview**: High-level Solana network statistics
- **DeFi Analytics**: DeFi protocol metrics and TVL data
- **Token Analytics**: Token market data and trends
- **Validator Analytics**: Validator performance and staking data

### AI Chat Interface (`/chat`)
- **Conversational AI**: Natural language blockchain queries
- **Context Awareness**: AI understands current page context
- **Data Analysis**: AI can analyze and explain blockchain data
- **Anomaly Detection**: AI identifies suspicious patterns
- **Educational Mode**: AI explains blockchain concepts

### Monitoring Dashboard (`/monitoring`)
- **Real-time Alerts**: Live monitoring of network events
- **Anomaly Detection**: AI-powered suspicious activity detection
- **Performance Metrics**: Network health and performance tracking
- **Alert Management**: Configure and manage custom alerts

### Wallet Path Finding (`/wallet-path-finding`)
- **Connection Analysis**: Find relationships between wallet addresses
- **Transaction Paths**: Trace token flows between wallets
- **Network Visualization**: Graph view of wallet connections
- **Path Analytics**: Statistics about connection strength and frequency

### Search Results (`/search`)
- **Universal Search**: Search across all blockchain entities
- **Filtered Results**: Separate results by type (accounts, transactions, tokens, etc.)
- **Search Suggestions**: Auto-complete and suggested searches
- **Advanced Filters**: Filter results by date, amount, type, etc.

### NFT Explorer (`/nfts`)
- **NFT Collections**: Browse and explore NFT collections
- **Trending NFTs**: Popular and trending NFT collections
- **New Collections**: Recently launched NFT projects
- **NFT Analytics**: Floor prices, volume, and market data

### DeFi Analytics (`/defi`)
- **Protocol Analytics**: DeFi protocol performance and metrics
- **TVL Tracking**: Total Value Locked across protocols
- **Yield Farming**: APY and farming opportunity analysis
- **Liquidity Analysis**: Pool liquidity and trading volume

### Network Information (`/networks`)
- **Network Comparison**: Compare different Solana networks (mainnet, devnet, testnet)
- **Network Statistics**: Performance metrics for each network
- **RPC Endpoints**: Available RPC endpoints and their status
- **Network Health**: Real-time network status and alerts# Program Explorer Routes Steering

## Routes Covered
- `/program/[address]` - Individual program details
- `/program/[address]/opengraph-image` - Program social sharing images
- `/programs` - Program list and activity metrics

## Program Detail Page (`/program/[address]`)

### Purpose
Comprehensive program analysis including metadata, instruction usage, account ownership, code visualization, and security analysis.

### Key Components Required
- **ProgramDetails**: Main program information display
- **ProgramVisualizer**: Code disassembly and hex view
- **InstructionAnalytics**: Instruction usage statistics
- **AccountOwnership**: Accounts owned by the program
- **ProgramInteractions**: Transaction history and patterns
- **SecurityAnalysis**: Audit information and risk assessment
- **ProgramMetrics**: Performance and usage metrics

### Data Requirements
```typescript
interface ProgramData {
  address: string;
  metadata: ProgramMetadata;
  code: ProgramCode;
  instructions: InstructionData[];
  accounts: OwnedAccount[];
  interactions: ProgramInteraction[];
  security: SecurityAnalysis;
  metrics: ProgramMetrics;
}

interface ProgramMetadata {
  name?: string;
  description?: string;
  version?: string;
  author?: string;
  repository?: string;
  documentation?: string;
  verified: boolean;
  deployedAt: number;
  lastUpdated: number;
  upgradeAuthority?: string;
}

interface ProgramCode {
  size: number;
  hash: string;
  disassembly: DisassemblyInstruction[];
  hexDump: string;
  entryPoints: EntryPoint[];
  dependencies: string[];
}

interface InstructionData {
  discriminator: string;
  name: string;
  usage: InstructionUsage;
  parameters: InstructionParameter[];
  accounts: AccountRequirement[];
}

interface InstructionUsage {
  totalCalls: number;
  uniqueCallers: number;
  averageComputeUnits: number;
  successRate: number;
  last24h: number;
  trend: 'increasing' | 'decreasing' | 'stable';
}

interface OwnedAccount {
  address: string;
  type: 'data' | 'executable' | 'system';
  size: number;
  lamports: number;
  lastModified: number;
  dataHash?: string;
}

interface SecurityAnalysis {
  riskLevel: 'low' | 'medium' | 'high' | 'critical';
  vulnerabilities: Vulnerability[];
  auditReports: AuditReport[];
  upgradeability: UpgradeabilityInfo;
  permissions: Permission[];
}
```

### Implementation Guidelines
- Use server-side rendering for program metadata
- Implement code syntax highlighting for disassembly
- Show progressive loading for different data sections
- Cache program code and metadata (rarely changes)
- Implement search within disassembly code
- Add copy-to-clipboard for addresses and code

### Code Visualization Features
- Hex dump view with address offsets
- Disassembly with instruction highlighting
- Control flow graph visualization
- Jump target highlighting
- Search and navigation within code
- Export functionality for code analysis

### Instruction Analytics
- Usage statistics over time
- Performance metrics per instruction
- Error rate analysis
- Caller distribution
- Compute unit consumption
- Gas optimization suggestions

## Program List Page (`/programs`)

### Purpose
Browse all programs with activity metrics, filtering, and real-time statistics.

### Key Components Required
- **ProgramActivityTable**: Main table with program metrics
- **TopPrograms**: Most active programs section
- **ProgramFilters**: Filtering and search controls
- **NetworkProgramStats**: Overall program statistics
- **ProgramCategories**: Programs grouped by type/category

### Features to Implement
- Real-time activity updates
- Program search by address or name
- Filtering by program type and activity
- Sorting by various metrics
- Program verification status
- Export functionality for program data

### Table Columns
- Program address with name (if available)
- Program type and category
- Total transactions and 24h activity
- Unique users and growth metrics
- Compute units consumed
- Success rate and reliability
- Last activity timestamp
- Verification status

### Program Categories
```typescript
interface ProgramCategory {
  name: string;
  description: string;
  programs: string[];
  totalActivity: number;
  examples: ProgramExample[];
}

const PROGRAM_CATEGORIES = [
  'DeFi Protocols',
  'NFT Marketplaces',
  'Gaming',
  'Social',
  'Infrastructure',
  'Oracles',
  'Bridges',
  'Governance',
  'Utilities',
  'Unknown'
];
```

## OpenGraph Images (`/program/[address]/opengraph-image`)

### Purpose
Generate dynamic social sharing images for program pages.

### Implementation Guidelines
- Include program name or address prominently
- Show program type and category
- Display key metrics (transactions, users)
- Include verification status indicator
- Show activity trend visualization
- Use consistent OpenSVM branding

### Image Content
```typescript
interface ProgramOGData {
  address: string;
  name?: string;
  type: string;
  category: string;
  totalTransactions: number;
  uniqueUsers: number;
  verified: boolean;
  activityTrend: 'up' | 'down' | 'stable';
}
```

## API Integration

### Required Endpoints
- `GET /api/program/[address]` - Get comprehensive program data
- `GET /api/program/[address]/code` - Get program code and disassembly
- `GET /api/program/[address]/instructions` - Get instruction analytics
- `GET /api/program/[address]/accounts` - Get owned accounts
- `GET /api/program/[address]/interactions` - Get interaction history
- `GET /api/programs` - Get program list with metrics
- `GET /api/program-discovery` - Discover new programs
- `GET /api/program-registry` - Get program registry data

### Code Analysis
- Disassemble program bytecode
- Generate control flow graphs
- Identify instruction patterns
- Extract metadata from code
- Perform security analysis

### Caching Strategy
- Program metadata: Cache for 1 hour
- Program code: Cache for 24 hours (immutable unless upgraded)
- Instruction analytics: Cache for 5 minutes
- Account data: Cache for 1 minute
- Interaction history: Cache for 30 seconds

## Testing Requirements

### Unit Tests
- Program address validation
- Code disassembly accuracy
- Instruction parsing correctness
- Security analysis algorithms
- Metrics calculation accuracy

### Integration Tests
- Program page loads with valid address
- Invalid addresses show appropriate errors
- Code visualization renders correctly
- Instruction analytics display properly
- Account ownership is accurate

### E2E Tests
- Program search and navigation
- Code viewer functionality
- Instruction analytics interactions
- Account list navigation
- Security analysis display

## Performance Considerations
- Lazy load heavy components (code viewer, analytics)
- Implement virtual scrolling for large instruction lists
- Use Web Workers for code analysis
- Cache disassembly results
- Optimize bundle size for code highlighting

## Security Considerations
- Validate program addresses before processing
- Sanitize code display to prevent XSS
- Rate limit code analysis requests
- Secure handling of program bytecode
- Prevent code injection in disassembly

## Code Analysis Features

### Disassembly Viewer
```typescript
interface DisassemblyViewer {
  // Core functionality
  displayHexDump: boolean;
  displayAssembly: boolean;
  displayControlFlow: boolean;
  
  // Navigation
  jumpToAddress: (address: string) => void;
  searchInCode: (query: string) => void;
  highlightInstruction: (offset: number) => void;
  
  // Analysis
  findReferences: (address: string) => Reference[];
  analyzeFunction: (entryPoint: string) => FunctionAnalysis;
  detectPatterns: () => CodePattern[];
}

interface FunctionAnalysis {
  entryPoint: string;
  size: number;
  instructions: number;
  complexity: number;
  calls: string[];
  jumps: string[];
  dataReferences: string[];
}
```

### Security Analysis
```typescript
interface SecurityAnalyzer {
  // Vulnerability detection
  detectBufferOverflows: () => Vulnerability[];
  detectIntegerOverflows: () => Vulnerability[];
  detectReentrancy: () => Vulnerability[];
  detectUnauthorizedAccess: () => Vulnerability[];
  
  // Code quality
  analyzeCodeQuality: () => QualityReport;
  checkBestPractices: () => BestPracticeReport;
  auditPermissions: () => PermissionAudit;
}

interface Vulnerability {
  type: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  location: CodeLocation;
  description: string;
  recommendation: string;
  cwe?: string; // Common Weakness Enumeration
}
```

## Accessibility Requirements
- Keyboard navigation for code viewer
- Screen reader support for program metrics
- High contrast mode for code highlighting
- Alternative text for visualizations
- Focus management in modal dialogs

## Mobile Optimization
- Responsive code viewer design
- Touch-friendly navigation controls
- Optimized loading for mobile networks
- Simplified view for small screens
- Horizontal scrolling for code

## SEO Optimization
- Dynamic meta titles with program name
- Rich meta descriptions with program summary
- Structured data for program information
- Canonical URLs for program pages
- Sitemap inclusion for verified programs

## Monitoring and Analytics
- Track program page views and engagement
- Monitor code analysis performance
- Measure user interactions with features
- Track error rates and API failures
- Monitor security analysis accuracy---
title: accountSubscribe
hideTableOfContents: true
h1: accountSubscribe RPC Method
---

Subscribe to an account to receive notifications when the lamports or data for a
given account public key changes

<APIMethod>

```jsonc !!request
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "accountSubscribe",
  "params": [
    // !hover 0
    "CM78CPUeXjn8o3yroDHxUtKsZZgoy4GPkPPXfouKNH12",
    // !hover(1:4) 1
    {
      // !hover encoding
      "encoding": "jsonParsed",
      // !hover commitment
      "commitment": "finalized"
    }
  ]
}
```

### !params

#### !! 0

!type string  
!required

Account Pubkey, as base-58 encoded string

#### !! 1

!type object

Configuration object containing the following fields:

##### !! commitment

!type string

The commitment describes how finalized a block is at that point in time. See
[Configuring State Commitment](/docs/rpc#configuring-state-commitment).

##### !! encoding

!type string  
!values base58 base64 base64+zstd jsonParsed

Encoding format for Account data

- `base58` is slow.
- `jsonParsed` encoding attempts to use program-specific state parsers to return
  more human-readable and explicit account state data
- If `jsonParsed` is requested but a parser cannot be found, the field falls
  back to binary encoding, detectable when the `data` field is type `string`.

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover result
  "result": 23784,
  "id": 1
}
```

!type number

Subscription id (needed to unsubscribe)

</APIMethod>

#### Notification Format:

The notification format is the same as seen in the
[getAccountInfo](/docs/rpc/http/getaccountinfo) RPC HTTP method.

Base58 encoding:

```json
{
  "jsonrpc": "2.0",
  "method": "accountNotification",
  "params": {
    "result": {
      "context": {
        "slot": 5199307
      },
      "value": {
        "data": [
          "11116bv5nS2h3y12kD1yUKeMZvGcKLSjQgX6BeV7u1FrjeJcKfsHPXHRDEHrBesJhZyqnnq9qJeUuF7WHxiuLuL5twc38w2TXNLxnDbjmuR",
          "base58"
        ],
        "executable": false,
        "lamports": 33594,
        "owner": "11111111111111111111111111111111",
        "rentEpoch": 635,
        "space": 80
      }
    },
    "subscription": 23784
  }
}
```

Parsed-JSON encoding:

```json
{
  "jsonrpc": "2.0",
  "method": "accountNotification",
  "params": {
    "result": {
      "context": {
        "slot": 5199307
      },
      "value": {
        "data": {
          "program": "nonce",
          "parsed": {
            "type": "initialized",
            "info": {
              "authority": "Bbqg1M4YVVfbhEzwA9SpC9FhsaG83YMTYoR4a8oTDLX",
              "blockhash": "LUaQTmM7WbMRiATdMMHaRGakPtCkc2GHtH57STKXs6k",
              "feeCalculator": {
                "lamportsPerSignature": 5000
              }
            }
          }
        },
        "executable": false,
        "lamports": 33594,
        "owner": "11111111111111111111111111111111",
        "rentEpoch": 635,
        "space": 80
      }
    },
    "subscription": 23784
  }
}
```
---
title: accountUnsubscribe
hideTableOfContents: true
h1: accountUnsubscribe RPC Method
---

Unsubscribe from account change notifications

<APIMethod>

```jsonc !!request
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "accountUnsubscribe",
  "params": [
    // !hover 0
    0
  ]
}
```

### !params

#### !! 0

!type number  
!required

id of the account Subscription to cancel

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover result
  "result": true,
  "id": 1
}
```

!type boolean

unsubscribe success message

</APIMethod>
---
title: blockSubscribe
hideTableOfContents: true
h1: blockSubscribe RPC Method
---

Subscribe to receive notification anytime a new block is `confirmed` or
`finalized`.

<Callout type="warn" title={"Unstable Method"}>
  This subscription is considered **unstable** and is only available if the
  validator was started with the `--rpc-pubsub-enable-block-subscription` flag.
  The format of this subscription may change in the future.
</Callout>

<APIMethod>

```jsonc !!request
{
  "jsonrpc": "2.0",
  "id": "1",
  "method": "blockSubscribe",
  "params": [
    // !hover(1:3) 0
    {
      "mentionsAccountOrProgram": "LieKvPRE8XeX3Y2xVNHjKlpAScD12lYySBVQ4HqoJ5op"
    },
    // !hover(1:6) 1
    {
      // !hover commitment
      "commitment": "confirmed",
      // !hover encoding
      "encoding": "base64",
      // !hover transactionDetails
      "transactionDetails": "full",
      // !hover maxSupportedTransactionVersion
      "maxSupportedTransactionVersion": 0,
      // !hover showRewards
      "showRewards": true
    }
  ]
}
```

### !params

#### !! 0

!type string | object  
!required

filter criteria for the logs to receive results by account type; currently
supported:

- `all` - include all transactions in block
- A JSON object with the following field:
  - `mentionsAccountOrProgram: <string>` - return only transactions that mention
    the provided public key (as base-58 encoded string). If no mentions in a
    given block, then no notification will be sent.

#### !! 1

!type object

Configuration object containing the following fields:

##### !! commitment

!type string
!values confirmed finalized
!default finalized

The commitment describes how finalized a block is at that point in time. See
[Configuring State Commitment](/docs/rpc#configuring-state-commitment).

- `processed` is not supported.

##### !! encoding

!type string  
!values json jsonParsed base58 base64  
!default json

encoding format for each returned Transaction

- `jsonParsed` attempts to use program-specific instruction parsers to return
  more human-readable and explicit data in the
  `transaction.message.instructions` list.
- If `jsonParsed` is requested but a parser cannot be found, the instruction
  falls back to regular JSON encoding (`accounts`, `data`, and `programIdIndex`
  fields).

##### !! transactionDetails

!type string  
!values full accounts signatures none  
!default full

level of transaction detail to return

- If `accounts` are requested, transaction details only include signatures and
  an annotated list of accounts in each transaction.
- Transaction metadata is limited to only: fee, err, pre_balances,
  post_balances, pre_token_balances, and post_token_balances.

##### !! maxSupportedTransactionVersion

!type number
!values 0
!default 0

Currently, the only valid value for this parameter is `0`. 
Setting it to `0` allows you to fetch all transactions, including both Versioned and legacy transactions.

This parameter determines the maximum transaction version that will be returned in the response. 
If you request a transaction with a higher version than this value, an error will be returned. 
If you omit this parameter, only legacy transactions will be returned—any versioned transaction will result in an error.


##### !! showRewards

!type bool

whether to populate the `rewards` array. If parameter not provided, the default
includes rewards.

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover result
  "result": 0,
  "id": 1
}
```

!type integer

subscription id (needed to unsubscribe)

</APIMethod>

#### Notification Format:

The notification will be an object with the following fields:

- `slot: <u64>` - The corresponding slot.
- `err: <object|null>` - Error if something went wrong publishing the
  notification otherwise null.
- `block: <object|null>` - A block object as seen in the
  [getBlock](/docs/rpc/http/getblock) RPC HTTP method.

```json
{
  "jsonrpc": "2.0",
  "method": "blockNotification",
  "params": {
    "result": {
      "context": {
        "slot": 112301554
      },
      "value": {
        "slot": 112301554,
        "block": {
          "previousBlockhash": "GJp125YAN4ufCSUvZJVdCyWQJ7RPWMmwxoyUQySydZA",
          "blockhash": "6ojMHjctdqfB55JDpEpqfHnP96fiaHEcvzEQ2NNcxzHP",
          "parentSlot": 112301553,
          "transactions": [
            {
              "transaction": [
                "OpltwoUvWxYi1P2U8vbIdE/aPntjYo5Aa0VQ2JJyeJE2g9Vvxk8dDGgFMruYfDu8/IfUWb0REppTe7IpAuuLRgIBAAkWnj4KHRpEWWW7gvO1c0BHy06wZi2g7/DLqpEtkRsThAXIdBbhXCLvltw50ZnjDx2hzw74NVn49kmpYj2VZHQJoeJoYJqaKcvuxCi/2i4yywedcVNDWkM84Iuw+cEn9/ROCrXY4qBFI9dveEERQ1c4kdU46xjxj9Vi+QXkb2Kx45QFVkG4Y7HHsoS6WNUiw2m4ffnMNnOVdF9tJht7oeuEfDMuUEaO7l9JeUxppCvrGk3CP45saO51gkwVYEgKzhpKjCx3rgsYxNR81fY4hnUQXSbbc2Y55FkwgRBpVvQK7/+clR4Gjhd3L4y+OtPl7QF93Akg1LaU9wRMs5nvfDFlggqI9PqJl+IvVWrNRdBbPS8LIIhcwbRTkSbqlJQWxYg3Bo2CTVbw7rt1ZubuHWWp0mD/UJpLXGm2JprWTePNULzHu67sfqaWF99LwmwjTyYEkqkRt1T0Je5VzHgJs0N5jY4iIU9K3lMqvrKOIn/2zEMZ+ol2gdgjshx+sphIyhw65F3J/Dbzk04LLkK+CULmN571Y+hFlXF2ke0BIuUG6AUF+4214Cu7FXnqo3rkxEHDZAk0lRrAJ8X/Z+iwuwI5cgbd9uHXZaGT2cvhRs7reawctIXtX1s3kTqM9YV+/wCpDLAp8axcEkaQkLDKRoWxqp8XLNZSKial7Rk+ELAVVKWoWLRXRZ+OIggu0OzMExvVLE5VHqy71FNHq4gGitkiKYNFWSLIE4qGfdFLZXy/6hwS+wq9ewjikCpd//C9BcCL7Wl0iQdUslxNVCBZHnCoPYih9JXvGefOb9WWnjGy14sG9j70+RSVx6BlkFELWwFvIlWR/tHn3EhHAuL0inS2pwX7ZQTAU6gDVaoqbR2EiJ47cKoPycBNvHLoKxoY9AZaBjPl6q8SKQJSFyFd9n44opAgI6zMTjYF/8Ok4VpXEESp3QaoUyTI9sOJ6oFP6f4dwnvQelgXS+AEfAsHsKXxGAIUDQENAgMEBQAGBwgIDg8IBJCER3QXl1AVDBADCQoOAAQLERITDAjb7ugh3gOuTy==",
                "base64"
              ],
              "meta": {
                "err": null,
                "status": {
                  "Ok": null
                },
                "fee": 5000,
                "preBalances": [
                  1758510880, 2067120, 1566000, 1461600, 2039280, 2039280,
                  1900080, 1865280, 0, 3680844220, 2039280
                ],
                "postBalances": [
                  1758505880, 2067120, 1566000, 1461600, 2039280, 2039280,
                  1900080, 1865280, 0, 3680844220, 2039280
                ],
                "innerInstructions": [
                  {
                    "index": 0,
                    "instructions": [
                      {
                        "programIdIndex": 13,
                        "accounts": [1, 15, 3, 4, 2, 14],
                        "data": "21TeLgZXNbtHXVBzCaiRmH"
                      },
                      {
                        "programIdIndex": 14,
                        "accounts": [3, 4, 1],
                        "data": "6qfC8ic7Aq99"
                      },
                      {
                        "programIdIndex": 13,
                        "accounts": [1, 15, 3, 5, 2, 14],
                        "data": "21TeLgZXNbsn4QEpaSEr3q"
                      },
                      {
                        "programIdIndex": 14,
                        "accounts": [3, 5, 1],
                        "data": "6LC7BYyxhFRh"
                      }
                    ]
                  },
                  {
                    "index": 1,
                    "instructions": [
                      {
                        "programIdIndex": 14,
                        "accounts": [4, 3, 0],
                        "data": "7aUiLHFjSVdZ"
                      },
                      {
                        "programIdIndex": 19,
                        "accounts": [17, 18, 16, 9, 11, 12, 14],
                        "data": "8kvZyjATKQWYxaKR1qD53V"
                      },
                      {
                        "programIdIndex": 14,
                        "accounts": [9, 11, 18],
                        "data": "6qfC8ic7Aq99"
                      }
                    ]
                  }
                ],
                "logMessages": [
                  "Program QMNeHCGYnLVDn1icRAfQZpjPLBNkfGbSKRB83G5d8KB invoke [1]",
                  "Program QMWoBmAyJLAsA1Lh9ugMTw2gciTihncciphzdNzdZYV invoke [2]"
                ],
                "preTokenBalances": [
                  {
                    "accountIndex": 4,
                    "mint": "iouQcQBAiEXe6cKLS85zmZxUqaCqBdeHFpqKoSz615u",
                    "uiTokenAmount": {
                      "uiAmount": null,
                      "decimals": 6,
                      "amount": "0",
                      "uiAmountString": "0"
                    },
                    "owner": "LieKvPRE8XeX3Y2xVNHjKlpAScD12lYySBVQ4HqoJ5op",
                    "programId": "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
                  },
                  {
                    "accountIndex": 5,
                    "mint": "iouQcQBAiEXe6cKLS85zmZxUqaCqBdeHFpqKoSz615u",
                    "uiTokenAmount": {
                      "uiAmount": 11513.0679,
                      "decimals": 6,
                      "amount": "11513067900",
                      "uiAmountString": "11513.0679"
                    },
                    "owner": "rXhAofQCT7NN9TUqigyEAUzV1uLL4boeD8CRkNBSkYk",
                    "programId": "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
                  },
                  {
                    "accountIndex": 10,
                    "mint": "Saber2gLauYim4Mvftnrasomsv6NvAuncvMEZwcLpD1",
                    "uiTokenAmount": {
                      "uiAmount": null,
                      "decimals": 6,
                      "amount": "0",
                      "uiAmountString": "0"
                    },
                    "owner": "CL9wkGFT3SZRRNa9dgaovuRV7jrVVigBUZ6DjcgySsCU",
                    "programId": "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"
                  },
                  {
                    "accountIndex": 11,
                    "mint": "Saber2gLauYim4Mvftnrasomsv6NvAuncvMEZwcLpD1",
                    "uiTokenAmount": {
                      "uiAmount": 15138.514093,
                      "decimals": 6,
                      "amount": "15138514093",
                      "uiAmountString": "15138.514093"
                    },
                    "owner": "LieKvPRE8XeX3Y2xVNHjKlpAScD12lYySBVQ4HqoJ5op",
                    "programId": "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"
                  }
                ],
                "postTokenBalances": [
                  {
                    "accountIndex": 4,
                    "mint": "iouQcQBAiEXe6cKLS85zmZxUqaCqBdeHFpqKoSz615u",
                    "uiTokenAmount": {
                      "uiAmount": null,
                      "decimals": 6,
                      "amount": "0",
                      "uiAmountString": "0"
                    },
                    "owner": "LieKvPRE8XeX3Y2xVNHjKlpAScD12lYySBVQ4HqoJ5op",
                    "programId": "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
                  },
                  {
                    "accountIndex": 5,
                    "mint": "iouQcQBAiEXe6cKLS85zmZxUqaCqBdeHFpqKoSz615u",
                    "uiTokenAmount": {
                      "uiAmount": 11513.103028,
                      "decimals": 6,
                      "amount": "11513103028",
                      "uiAmountString": "11513.103028"
                    },
                    "owner": "rXhAofQCT7NN9TUqigyEAUzV1uLL4boeD8CRkNBSkYk",
                    "programId": "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
                  },
                  {
                    "accountIndex": 10,
                    "mint": "Saber2gLauYim4Mvftnrasomsv6NvAuncvMEZwcLpD1",
                    "uiTokenAmount": {
                      "uiAmount": null,
                      "decimals": 6,
                      "amount": "0",
                      "uiAmountString": "0"
                    },
                    "owner": "CL9wkGFT3SZRRNa9dgaovuRV7jrVVigBUZ6DjcgySsCU",
                    "programId": "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"
                  },
                  {
                    "accountIndex": 11,
                    "mint": "Saber2gLauYim4Mvftnrasomsv6NvAuncvMEZwcLpD1",
                    "uiTokenAmount": {
                      "uiAmount": 15489.767829,
                      "decimals": 6,
                      "amount": "15489767829",
                      "uiAmountString": "15489.767829"
                    },
                    "owner": "BeiHVPRE8XeX3Y2xVNrSsTpAScH94nYySBVQ4HqgN9at",
                    "programId": "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"
                  }
                ],
                "rewards": []
              }
            }
          ],
          "blockTime": 1639926816,
          "blockHeight": 101210751
        },
        "err": null
      }
    },
    "subscription": 14
  }
}
```
---
title: blockUnsubscribe
hideTableOfContents: true
h1: blockUnsubscribe RPC Method
---

Unsubscribe from block notifications

<APIMethod>

```jsonc !!request
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "blockUnsubscribe",
  "params": [
    // !hover 0
    0
  ]
}
```

### !params

#### !! 0

!type integer  
!required

subscription id to cancel

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover result
  "result": true,
  "id": 1
}
```

!type boolean

unsubscribe success message

</APIMethod>
---
title: Websocket Methods
seoTitle: Solana RPC Websocket Methods
hideTableOfContents: false
h1: Solana RPC Websocket Methods
---

After connecting to the RPC PubSub websocket at `ws://<ADDRESS>/`:

- Submit subscription requests to the websocket using the methods below
- Multiple subscriptions may be active at once
- Many subscriptions take the optional
  [`commitment` parameter](/docs/rpc/#configuring-state-commitment),
  defining how finalized a change should be to trigger a notification. For
  subscriptions, if commitment is unspecified, the default value is `finalized`.

## RPC PubSub WebSocket Endpoint

Default port: `8900`

- ws://localhost:8900
- http://192.168.1.88:8900
---
title: logsSubscribe
hideTableOfContents: true
h1: logsSubscribe RPC Method
---

Subscribe to transaction logging

<APIMethod>

```jsonc !!request
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "logsSubscribe",
  "params": [
    // !hover(1:3) 0
    {
      "mentions": ["11111111111111111111111111111111"]
    },
    // !hover(1:3) 1
    {
      // !hover commitment
      "commitment": "finalized"
    }
  ]
}
```

### !params

#### !! 0

!type string | object  
!required

filter criteria for the logs to receive results by account type. The following
filters types are currently supported:

- `all` - subscribe to all transactions except for simple vote transactions
- `allWithVotes` - subscribe to all transactions, including simple vote
  transactions
- An object with the following field:
  - `mentions: [ <string> ]` - array containing a single Pubkey (as base-58
    encoded string); if present, subscribe to only transactions mentioning this
    address

<Callout type="warn" title={true}>
  The `mentions` field currently [only supports
  one](https://github.com/solana-labs/solana/blob/master/rpc/src/rpc_pubsub.rs#L481)
  Pubkey string per method call. Listing additional addresses will result in an
  error.
</Callout>

#### !! 1

!type object

Configuration object containing the following fields:

##### !! commitment

!type string

The commitment describes how finalized a block is at that point in time. See
[Configuring State Commitment](/docs/rpc#configuring-state-commitment).

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover result
  "result": 24040,
  "id": 1
}
```

!type integer

Subscription id (needed to unsubscribe)

</APIMethod>

#### Notification Format:

The notification will be an RpcResponse JSON object with value equal to:

- `signature: <string>` - The transaction signature base58 encoded.
- `err: <object|null>` - Error if transaction failed, null if transaction
  succeeded.
  [TransactionError definitions](https://github.com/solana-labs/solana/blob/c0c60386544ec9a9ec7119229f37386d9f070523/sdk/src/transaction/error.rs#L13)
- `logs: <array[string]>` - Array of log messages the transaction instructions 
  output during execution.

Example:

```json
{
  "jsonrpc": "2.0",
  "method": "logsNotification",
  "params": {
    "result": {
      "context": {
        "slot": 5208469
      },
      "value": {
        "signature": "5h6xBEauJ3PK6SWCZ1PGjBvj8vDdWG3KpwATGy1ARAXFSDwt8GFXM7W5Ncn16wmqokgpiKRLuS83KUxyZyv2sUYv",
        "err": null,
        "logs": [
          "SBF program 83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri success"
        ]
      }
    },
    "subscription": 24040
  }
}
```
---
title: logsUnsubscribe
hideTableOfContents: true
h1: logsUnsubscribe RPC Method
---

Unsubscribe from transaction logging

<APIMethod>

```jsonc !!request
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "logsUnsubscribe",
  "params": [
    // !hover 0
    0
  ]
}
```

### !params

#### !! 0

!type integer  
!required

subscription id to cancel

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover result
  "result": true,
  "id": 1
}
```

!type boolean

unsubscribe success message

</APIMethod>
{
  "title": "Websocket Methods",
  "pages": [
    "accountsubscribe",
    "accountunsubscribe",
    "blocksubscribe",
    "blockunsubscribe",
    "logssubscribe",
    "logsunsubscribe",
    "programsubscribe",
    "programunsubscribe",
    "rootsubscribe",
    "rootunsubscribe",
    "signaturesubscribe",
    "signatureunsubscribe",
    "slotsubscribe",
    "slotsupdatessubscribe",
    "slotsupdatesunsubscribe",
    "slotunsubscribe",
    "votesubscribe",
    "voteunsubscribe"
  ]
}
---
title: programSubscribe
hideTableOfContents: true
h1: programSubscribe RPC Method
---

Subscribe to a program to receive notifications when the lamports or data for an
account owned by the given program changes

<APIMethod>

```jsonc !!request
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "programSubscribe",
  "params": [
    // !hover 0
    "11111111111111111111111111111111",
    // !hover(1:4) 1
    {
      // !hover encoding
      "encoding": "base64",
      // !hover filters
      "filters": [{ "dataSize": 80 }]
    }
  ]
}
```

### !params

#### !! 0

!type string  
!required

Pubkey of the `program_id`, as base-58 encoded string

#### !! 1

!type object

Configuration object containing the following fields:

##### !! commitment

!type string

The commitment describes how finalized a block is at that point in time. See
[Configuring State Commitment](/docs/rpc#configuring-state-commitment).

##### !! filters

!type array

Filter results using various filter objects. See
[Filtering](/docs/rpc#filter-criteria).

<Callout type="info">
  The resultant account must meet **ALL** filter criteria to be included in the
  returned results
</Callout>

##### !! encoding

!type string  
!values base58 base64 base64+zstd jsonParsed

Encoding format for Account data

- `base58` is slow.
- `jsonParsed` encoding attempts to use program-specific state parsers to return
  more human-readable and explicit account state data.
- If `jsonParsed` is requested but a parser cannot be found, the field falls
  back to `base64` encoding, detectable when the `data` field is type `string`.

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover result
  "result": 24040,
  "id": 1
}
```

!type integer

Subscription id (needed to unsubscribe)

</APIMethod>

#### Notification format

The notification format is a <b>single</b> program account object as seen in the
[getProgramAccounts](/docs/rpc/http/getprogramaccounts) RPC HTTP method.

Base58 encoding:

```json
{
  "jsonrpc": "2.0",
  "method": "programNotification",
  "params": {
    "result": {
      "context": {
        "slot": 5208469
      },
      "value": {
        "pubkey": "H4vnBqifaSACnKa7acsxstsY1iV1bvJNxsCY7enrd1hq",
        "account": {
          "data": [
            "11116bv5nS2h3y12kD1yUKeMZvGcKLSjQgX6BeV7u1FrjeJcKfsHPXHRDEHrBesJhZyqnnq9qJeUuF7WHxiuLuL5twc38w2TXNLxnDbjmuR",
            "base58"
          ],
          "executable": false,
          "lamports": 33594,
          "owner": "11111111111111111111111111111111",
          "rentEpoch": 636,
          "space": 80
        }
      }
    },
    "subscription": 24040
  }
}
```

Parsed-JSON encoding:

```json
{
  "jsonrpc": "2.0",
  "method": "programNotification",
  "params": {
    "result": {
      "context": {
        "slot": 5208469
      },
      "value": {
        "pubkey": "H4vnBqifaSACnKa7acsxstsY1iV1bvJNxsCY7enrd1hq",
        "account": {
          "data": {
            "program": "nonce",
            "parsed": {
              "type": "initialized",
              "info": {
                "authority": "Bbqg1M4YVVfbhEzwA9SpC9FhsaG83YMTYoR4a8oTDLX",
                "blockhash": "LUaQTmM7WbMRiATdMMHaRGakPtCkc2GHtH57STKXs6k",
                "feeCalculator": {
                  "lamportsPerSignature": 5000
                }
              }
            }
          },
          "executable": false,
          "lamports": 33594,
          "owner": "11111111111111111111111111111111",
          "rentEpoch": 636,
          "space": 80
        }
      }
    },
    "subscription": 24040
  }
}
```
---
title: programUnsubscribe
hideTableOfContents: true
h1: programUnsubscribe RPC Method
---

Unsubscribe from program-owned account change notifications

<APIMethod>

```jsonc !!request
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "programUnsubscribe",
  "params": [
    // !hover 0
    0
  ]
}
```

### !params

#### !! 0

!type number  
!required

id of account Subscription to cancel

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover result
  "result": true,
  "id": 1
}
```

!type boolean

unsubscribe success message

</APIMethod>
---
title: rootSubscribe
hideTableOfContents: true
h1: rootSubscribe RPC Method
---

Subscribe to receive notification anytime a new root is set by the validator.

<APIMethod>

```jsonc !!request
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "rootSubscribe"
}
```

### !params

**None**

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover result
  "result": 0,
  "id": 1
}
```

!type integer

subscription id (needed to unsubscribe)

</APIMethod>

#### Notification Format:

The result is the latest root slot number.

```json
{
  "jsonrpc": "2.0",
  "method": "rootNotification",
  "params": {
    "result": 42,
    "subscription": 0
  }
}
```
---
title: rootUnsubscribe
hideTableOfContents: true
h1: rootUnsubscribe RPC Method
---

Unsubscribe from root notifications

<APIMethod>

```jsonc !!request
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "rootUnsubscribe",
  "params": [
    // !hover 0
    0
  ]
}
```

### !params

#### !! 0

!type number  
!required

subscription id to cancel

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover result
  "result": true,
  "id": 1
}
```

!type boolean

unsubscribe success message

</APIMethod>
---
title: signatureSubscribe
hideTableOfContents: true
h1: signatureSubscribe RPC Method
---

Subscribe to receive a notification when the transaction with the given
signature reaches the specified commitment level.

<Callout type="warn">
  This is a subscription to a single notification. It is automatically cancelled
  by the server once the notification, `signatureNotification`, is sent by the
  RPC.
</Callout>

<APIMethod>

```jsonc !!request
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "signatureSubscribe",
  "params": [
    // !hover 0
    "2EBVM6cB8vAAD93Ktr6Vd8p67XPbQzCJX47MpReuiCXJAtcjaxpvWpcg9Ege1Nr5Tk3a2GFrByT7WPBjdsTycY9b",
    // !hover(1:4) 1
    {
      // !hover commitment
      "commitment": "finalized",
      // !hover enableReceivedNotification
      "enableReceivedNotification": false
    }
  ]
}
```

### !params

#### !! 0

!type string  
!required

transaction signature, as base-58 encoded string

<Callout type="info">
  The transaction signature must be the first signature from the transaction
  (see [transaction id](/docs/references/terminology#transaction-id) for more
  details).
</Callout>

#### !! 1

!type object

Configuration object containing the following fields:

##### !! commitment

!type string

The commitment describes how finalized a block is at that point in time. See
[Configuring State Commitment](/docs/rpc#configuring-state-commitment).

##### !! enableReceivedNotification

!type boolean

Whether or not to subscribe for notifications when signatures are received by
the RPC, in addition to when they are processed.

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover result
  "result": 0,
  "id": 1
}
```

!type integer

subscription id (needed to unsubscribe)

</APIMethod>

#### Notification Format:

The notification will be an RpcResponse JSON object with value containing an
object with:

- `slot: <u64>` - The corresponding slot.
- `value: <object|string>` - a notification value of
  [`RpcSignatureResult`](https://github.com/solana-labs/solana/blob/6d28fd455b07e3557fc6c0c3ddf3ba03e3fe8482/rpc-client-api/src/response.rs#L265-L268),
  resulting in either:
  - when `enableReceivedNotification` is `true` and the signature is received:
    the literal string
    [`"receivedSignature"`](https://github.com/solana-labs/solana/blob/6d28fd455b07e3557fc6c0c3ddf3ba03e3fe8482/rpc-client-api/src/response.rs#L286-L288),
    or
  - when the signature is processed: `err: <object|null>`:
    - `null` if the transaction succeeded in being processed at the specified
      commitment level, or
    - a
      [`TransactionError`](https://github.com/solana-labs/solana/blob/6d28fd455b07e3557fc6c0c3ddf3ba03e3fe8482/sdk/src/transaction/error.rs#L15-L164),
      if the transaction failed

#### Example responses:

The following is an example response of a notification from a successfully
**processed** transactions:

```json
{
  "jsonrpc": "2.0",
  "method": "signatureNotification",
  "params": {
    "result": {
      "context": {
        "slot": 5207624
      },
      "value": {
        "err": null
      }
    },
    "subscription": 24006
  }
}
```

The following is an example response of a notification from a successfully
**received** transaction signature:

```json
{
  "jsonrpc": "2.0",
  "method": "signatureNotification",
  "params": {
    "result": {
      "context": {
        "slot": 5207624
      },
      "value": "receivedSignature"
    },
    "subscription": 24006
  }
}
```
---
title: signatureUnsubscribe
hideTableOfContents: true
h1: signatureUnsubscribe RPC Method
---

Unsubscribe from signature confirmation notification

<APIMethod>

```jsonc !!request
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "signatureUnsubscribe",
  "params": [
    // !hover 0
    0
  ]
}
```

### !params

#### !! 0

!type number  
!required

subscription id to cancel

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover result
  "result": true,
  "id": 1
}
```

!type boolean

unsubscribe success message

</APIMethod>
---
title: slotSubscribe
hideTableOfContents: true
h1: slotSubscribe RPC Method
---

Subscribe to receive notification anytime a slot is processed by the validator

<APIMethod>

```jsonc !!request
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "slotSubscribe"
}
```

### !params

**None**

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover result
  "result": 0,
  "id": 1
}
```

!type integer

Subscription id (needed to unsubscribe)

</APIMethod>

#### Notification Format:

The notification will be an object with the following fields:

- `parent: <u64>` - The parent slot
- `root: <u64>` - The current root slot
- `slot: <u64>` - The newly set slot value

Example:

```json
{
  "jsonrpc": "2.0",
  "method": "slotNotification",
  "params": {
    "result": {
      "parent": 75,
      "root": 44,
      "slot": 76
    },
    "subscription": 0
  }
}
```
---
title: slotsUpdatesSubscribe
hideTableOfContents: true
h1: slotsUpdatesSubscribe RPC Method
---

Subscribe to receive a notification from the validator on a variety of updates
on every slot

<Callout type="warn">
  This subscription is unstable. The format of this subscription may change in
  the future, and may not always be supported.
</Callout>

<APIMethod>

```jsonc !!request
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "slotsUpdatesSubscribe"
}
```

### !params

**None**

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover result
  "result": 0,
  "id": 1
}
```

!type integer

Subscription id (needed to unsubscribe)

</APIMethod>

### Notification Format

The notification will be an object with the following fields:

- `err: <string|undefined>` - The error message. Only present if the update is
  of type "dead".
- `parent: <u64|undefined>` - The parent slot. Only present if the update is of
  type "createdBank".
- `slot: <u64>` - The newly updated slot
- `stats: <object|undefined>` - The error message. Only present if the update is
  of type "frozen". An object with the following fields:
  - `maxTransactionsPerEntry: <u64>`,
  - `numFailedTransactions: <u64>`,
  - `numSuccessfulTransactions: <u64>`,
  - `numTransactionEntries: <u64>`,
- `timestamp: <i64>` - The Unix timestamp of the update in milliseconds
- `type: <string>` - The update type, one of:
  - "firstShredReceived"
  - "completed"
  - "createdBank"
  - "frozen"
  - "dead"
  - "optimisticConfirmation"
  - "root"

```shell
{
  "jsonrpc": "2.0",
  "method": "slotsUpdatesNotification",
  "params": {
    "result": {
      "parent": 75,
      "slot": 76,
      "timestamp": 1625081266243,
      "type": "optimisticConfirmation"
    },
    "subscription": 0
  }
}
```
---
title: slotsUpdatesUnsubscribe
hideTableOfContents: true
h1: slotsUpdatesUnsubscribe RPC Method
---

Unsubscribe from slot-update notifications

<APIMethod>

```jsonc !!request
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "slotsUpdatesUnsubscribe",
  "params": [
    // !hover 0
    0
  ]
}
```

### !params

#### !! 0

!type number  
!required

subscription id to cancel

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover result
  "result": true,
  "id": 1
}
```

!type boolean

unsubscribe success message

</APIMethod>
---
title: slotUnsubscribe
hideTableOfContents: true
h1: slotUnsubscribe RPC Method
---

Unsubscribe from slot notifications

<APIMethod>

```jsonc !!request
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "slotUnsubscribe",
  "params": [
    // !hover 0
    0
  ]
}
```

### !params

#### !! 0

!type integer  
!required

subscription id to cancel

### !!result

```jsonc !response
{
  "jsonrpc": "2.0",
  // !hover result
  "result": true,
  "id": 1
}
```

!type boolean

unsubscribe success message

</APIMethod>
---
title: getAccountInfo
hideTableOfContents: true
h1: getAccountInfo RPC Method
---

Returns all information associated with the account of provided Pubkey

<APIMethod>

```jsonc !!request curl
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "getAccountInfo",
  "params": [
    // !hover pubkey
    "vines1vzrYbzLMRdu58ou5XTby4qAqVRLmqo36NKPTg",
    // !hover(1:3) 1
    {
      // !hover commitment
      "commitment": "finalized",
      // !hover encoding
      "encoding": "base58"
    }
  ]
}
```

```ts !!request title="Kit"
import { address, createSolanaRpc } from "@solana/kit";

const rpc_url = "https://api.devnet.solana.com";
const rpc = createSolanaRpc(rpc_url);

// !hover pubkey
const publicKey = address("vines1vzrYbzLMRdu58ou5XTby4qAqVRLmqo36NKPTg");
const accountInfo = await rpc.getAccountInfo(publicKey).send();

console.log("Account Info:", accountInfo);
```

```ts !!request title="web3.js"
import { Connection, PublicKey, clusterApiUrl } from "@solana/web3.js";

const connection = new Connection(clusterApiUrl("devnet"), "confirmed");
// !hover pubkey
const publicKey = new PublicKey("vines1vzrYbzLMRdu58ou5XTby4qAqVRLmqo36NKPTg");
const accountInfo = await connection.getAccountInfo(publicKey);

console.log("Account Info:", JSON.stringify(accountInfo, null, 2));
```

```rs !!request title="Rust"
use solana_client::nonblocking::rpc_client::RpcClient;
use solana_sdk::{commitment_config::CommitmentConfig, pubkey::Pubkey};
use anyhow::Result;
use std::str::FromStr;

#[tokio::main]
async fn main() -> Result<()> {
    let client = RpcClient::new_with_commitment(
        String::from("https://api.devnet.solana.com"),
        CommitmentConfig::confirmed()
    );
    // !hover pubkey
    let pubkey = Pubkey::from_str("vines1vzrYbzLMRdu58ou5XTby4qAqVRLmqo36NKPTg")?;
    let account = client.get_account(&pubkey).await?;

