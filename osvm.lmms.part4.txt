## Technical Implementation Architecture

### File Structure and Organization
```
lib/ai/agentic/
├── core/
│   ├── NavigationController.ts
│   ├── PathPlanner.ts
│   ├── ExecutionEngine.ts
│   └── ProgressTracker.ts
├── drivers/
│   ├── NavigationDriver.ts
│   ├── DataExtractor.ts
│   └── PageAnalyzer.ts
├── templates/
│   ├── TemplateManager.ts
│   ├── InvestigationTemplate.ts
│   └── predefined/
│       ├── DeFiAnalysisTemplate.ts
│       ├── SuspiciousActivityTemplate.ts
│       └── WalletConnectionTemplate.ts
├── correlation/
│   ├── DataCorrelator.ts
│   ├── PatternDetector.ts
│   └── RelationshipAnalyzer.ts
├── state/
│   ├── SessionManager.ts
│   ├── StateManager.ts
│   └── CheckpointManager.ts
├── utils/
│   ├── ErrorHandler.ts
│   ├── CacheManager.ts
│   └── PerformanceMonitor.ts
└── types/
    ├── NavigationTypes.ts
    ├── InvestigationTypes.ts
    └── AnalysisTypes.ts

components/ai/agentic/
├── InvestigationControlPanel.tsx
├── ProgressVisualization.tsx
├── NavigationMapView.tsx
├── TemplateSelector.tsx
├── FindingsDisplay.tsx
├── InvestigationHistory.tsx
└── mobile/
    ├── MobileInvestigationView.tsx
    └── TouchOptimizedControls.tsx

app/api/agentic/
├── investigations/
│   ├── route.ts
│   ├── [sessionId]/
│   │   ├── route.ts
│   │   ├── progress/route.ts
│   │   ├── control/route.ts
│   │   └── findings/route.ts
├── templates/
│   ├── route.ts
│   └── [templateId]/route.ts
└── websocket/
    └── progress/route.ts
```

### Database Schema Design
```typescript
// Investigation Sessions Table
interface InvestigationSessionSchema {
  id: string;
  userId: string;
  objective: string;
  status: InvestigationStatus;
  planId: string;
  currentStep: number;
  startTime: Date;
  endTime?: Date;
  findings: Finding[];
  errors: NavigationError[];
  metadata: Record<string, any>;
  createdAt: Date;
  updatedAt: Date;
}

// Navigation Plans Table
interface NavigationPlanSchema {
  id: string;
  sessionId: string;
  steps: NavigationStep[];
  estimatedDuration: number;
  complexity: ComplexityLevel;
  version: number;
  createdAt: Date;
}

// Extracted Data Cache Table
interface ExtractedDataSchema {
  id: string;
  url: string;
  pageType: string;
  data: Record<string, any>;
  quality: DataQuality;
  extractedAt: Date;
  expiresAt: Date;
}

// User Investigation History Table
interface UserInvestigationHistorySchema {
  id: string;
  userId: string;
  sessionId: string;
  entitiesVisited: EntityReference[];
  connectionsDiscovered: Connection[];
  patterns: Pattern[];
  createdAt: Date;
}
```

### WebSocket/SSE Integration
```typescript
interface ProgressWebSocketHandler {
  // Connection management
  handleConnection(socket: WebSocket, sessionId: string): void;
  handleDisconnection(socket: WebSocket): void;
  
  // Message handling
  sendProgressUpdate(sessionId: string, update: ProgressUpdate): void;
  sendFindingNotification(sessionId: string, finding: Finding): void;
  sendErrorNotification(sessionId: string, error: NavigationError): void;
  
  // Subscription management
  subscribeToSession(socket: WebSocket, sessionId: string): void;
  unsubscribeFromSession(socket: WebSocket, sessionId: string): void;
}

interface SSEProgressStream {
  // Stream management
  createStream(sessionId: string): ReadableStream;
  closeStream(sessionId: string): void;
  
  // Event emission
  emitProgressEvent(sessionId: string, event: ProgressEvent): void;
  emitFindingEvent(sessionId: string, event: FindingEvent): void;
  emitCompletionEvent(sessionId: string, event: CompletionEvent): void;
}
```

## SVMAI Token Monetization System

### Token-Based Pricing Model

The AI Agentic Navigation System operates on a consumption-based pricing model using SVMAI tokens:

```typescript
interface SVMAITokenPricing {
  // Base investigation costs
  basicInvestigation: number;        // 10 SVMAI tokens
  complexInvestigation: number;      // 25 SVMAI tokens
  deepInvestigation: number;         // 50 SVMAI tokens
  
  // Per-step costs
  navigationStep: number;            // 2 SVMAI tokens per step
  dataExtraction: number;            // 1 SVMAI token per page
  patternAnalysis: number;           // 5 SVMAI tokens per analysis
  relationshipMapping: number;       // 3 SVMAI tokens per relationship
  
  // Premium features
  realTimeMonitoring: number;        // 20 SVMAI tokens per hour
  advancedVisualization: number;     // 15 SVMAI tokens per chart
  expertTemplates: number;           // 30 SVMAI tokens per template
  collaborativeFeatures: number;     // 10 SVMAI tokens per share
  
  // Subscription discounts
  premiumDiscount: number;           // 20% discount
  enterpriseDiscount: number;        // 40% discount
}

interface TokenConsumptionTracker {
  sessionId: string;
  userId: string;
  startBalance: number;
  currentBalance: number;
  tokensConsumed: number;
  consumptionBreakdown: ConsumptionItem[];
  estimatedCost: number;
  actualCost: number;
}

interface ConsumptionItem {
  action: string;
  cost: number;
  timestamp: number;
  description: string;
}
```

### Token Gating and Access Control

```typescript
class SVMAITokenGate {
  async validateInvestigationAccess(
    userId: string, 
    investigationType: InvestigationType
  ): Promise<AccessValidation> {
    const userBalance = await this.getUserTokenBalance(userId);
    const estimatedCost = this.calculateEstimatedCost(investigationType);
    
    if (userBalance < estimatedCost) {
      return {
        allowed: false,
        reason: 'insufficient_tokens',
        required: estimatedCost,
        current: userBalance,
        shortfall: estimatedCost - userBalance
      };
    }
    
    return {
      allowed: true,
      estimatedCost,
      currentBalance: userBalance
    };
  }
  
  async consumeTokens(
    userId: string, 
    sessionId: string, 
    action: string, 
    cost: number
  ): Promise<TokenConsumptionResult> {
    const currentBalance = await this.getUserTokenBalance(userId);
    
    if (currentBalance < cost) {
      // Pause investigation and prompt for token purchase
      await this.pauseInvestigation(sessionId);
      return {
        success: false,
        reason: 'insufficient_balance',
        investigationPaused: true
      };
    }
    
    // Deduct tokens and log consumption
    await this.deductTokens(userId, cost);
    await this.logConsumption(sessionId, action, cost);
    
    return {
      success: true,
      newBalance: currentBalance - cost,
      tokensConsumed: cost
    };
  }
}
```

### Pricing Tiers and Features

```ascii
┌─────────────────────────────────────────────────────────────────────────────┐
│                           SVMAI Token Pricing Tiers                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│ 🆓 FREE TIER (0 SVMAI tokens)                                               │
│ ┌─────────────────────────────────────────────────────────────────────────┐ │
│ │ • 1 basic investigation per day                                         │ │
│ │ • Up to 3 navigation steps                                              │ │
│ │ • Basic templates only                                                  │ │
│ │ • No real-time monitoring                                               │ │
│ │ • Standard support                                                      │ │
│ └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                             │
│ 💰 BASIC TIER (50000 SVMAI tokens)                                          │
│ ┌─────────────────────────────────────────────────────────────────────────┐ │
│ │ • 10 basic investigations                                               │ │
│ │ • 4 complex investigations                                              │ │
│ │ • 2 deep investigations                                                 │ │
│ │ • All standard templates                                                │ │
│ │ • Basic visualization                                                   │ │
│ │ • Investigation history                                                 │ │
│ └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                             │
│ 🚀 PREMIUM TIER (250000 SVMAI tokens + 20% bonus = 300000 SVMAI)            │
│ ┌─────────────────────────────────────────────────────────────────────────┐ │
│ │ • Unlimited basic investigations                                        │ │
│ │ • 20 complex investigations                                             │ │
│ │ • 10 deep investigations                                                │ │
│ │ • All premium templates                                                 │ │
│ │ • Advanced visualization                                                │ │
│ │ • Real-time monitoring (500 SVMAI hours)                                │ │
│ │ • Collaborative features                                                │ │
│ │ • Priority support                                                      │ │
│ └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                             │
│ 🏢 ENTERPRISE TIER (1000000 SVMAI tokens + 40% bonus = 1400000 SVMAI)       │
│ ┌─────────────────────────────────────────────────────────────────────────┐ │
│ │ • Unlimited all investigation types                                     │ │
│ │ • Custom templates and workflows                                        │ │
│ │ • Advanced analytics and reporting                                      │ │
│ │ • Unlimited real-time monitoring                                        │ │
│ │ • Team collaboration features                                           │ │
│ │ • API access                                                            │ │
│ │ • Dedicated support                                                     │ │
│ │ • White-label options                                                   │ │
│ └─────────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────┘
```

### SVMAI Token Deposit and Payment System

#### Pure SVMAI Token System

```typescript
interface SVMAITokenSystem {
  // Direct SVMAI token usage only
  svmaiWalletBalance: SVMAIWalletBalance;
  
  // Token earning (free methods)
  referralRewards: ReferralSystem;
  communityRewards: CommunityRewardSystem;
  
  // Integration with existing auth
  phantomWalletIntegration: PhantomWalletIntegration;
}

interface SVMAIWalletBalance {
  // Check user's existing SVMAI token balance
  getCurrentBalance: (wallet: PublicKey) => Promise<number>;
  
  // Consume tokens for investigations
  consumeTokens: (wallet: PublicKey, amount: number) => Promise<ConsumptionResult>;
  
  // Track token usage
  getUsageHistory: (wallet: PublicKey) => Promise<UsageRecord[]>;
}

interface PhantomWalletIntegration {
  // Leverage existing wallet connection
  getConnectedWallet: () => Promise<PublicKey>;
  checkSVMAIBalance: (wallet: PublicKey) => Promise<number>;
  
  // Token consumption for investigations
  consumeForInvestigation: (amount: number) => Promise<TransactionSignature>;
  validateSufficientBalance: (requiredAmount: number) => Promise<boolean>;
}

interface InvestigationCost {
  basicInvestigation: 10; // 10 SVMAI tokens
  complexInvestigation: 25; // 25 SVMAI tokens
  deepInvestigation: 50; // 50 SVMAI tokens
  navigationStep: 2; // 2 SVMAI per step
  dataExtraction: 1; // 1 SVMAI per page
  patternAnalysis: 5; // 5 SVMAI per analysis
}
```

#### Phantom Wallet Integration for SVMAI Deposits

```ascii
┌─────────────────────────────────────────────────────────────────────────────┐
│ ╔═══════════════════════════════════════════════════════════════════════════╗ │
│ ║                    💰 Get SVMAI Tokens - Phantom Wallet Required         ║ │
│ ╚═══════════════════════════════════════════════════════════════════════════╝ │
├─────────────────────────────────────────────────────────────────────────────┤
│ ┌─ Wallet Status ─────────────────────────────────────────────────────────┐ │
│ │ 👻 Phantom Wallet: Connected (7xKX...9mN2)                             │ │
│ │ � SAOL Balance: 2.45 SOL                                               │ │
│ │ 💎 SVMAI Balance: 127 tokens                                           │ │
│ │ � ReCquired for AI features and social access                          │ │
│ └─────────────────────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────────────────────┤
│ ┌─ Convert SOL to SVMAI (Instant) ────────────────────────────────────────┐ │
│ │ ⚡ Instant conversion via smart contract                                │ │
│ │                                                                         │ │
│ │ 📊 Current Rate: 1 SOL = 1000 SVMAI                                    │ │
│ │ 🎁 Bonus Tokens: Get extra SVMAI with larger deposits                  │ │
│ │                                                                         │ │
│ │ ┌─ Quick Amounts ─────────────────────────────────────────────────────┐ │ │
│ │ │ ┌───────────┐ ┌───────────┐ ┌───────────┐ ┌───────────┐             │ │ │
│ │ │ │ 0.1 SOL   │ │ 0.5 SOL   │ │ 1.0 SOL   │ │ 2.0 SOL   │             │ │ │
│ │ │ │ 100 SVMAI │ │ 550 SVMAI │ │ 1200 SVMAI│ │ 2800 SVMAI│             │ │ │
│ │ │ │ Basic     │ │ +10% Bonus│ │ +20% Bonus│ │ +40% Bonus│             │ │ │
│ │ │ └───────────┘ └───────────┘ └───────────┘ └───────────┘             │ │ │
│ │ └─────────────────────────────────────────────────────────────────────┘ │ │
│ │                                                                         │ │
│ │ Custom Amount: [0.75] SOL → [825] SVMAI (+75 bonus)                    │ │
│ │ [💰 Convert SOL to SVMAI]                                               │ │
│ └─────────────────────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────────────────────┤
│ ┌─ Convert SPL Tokens to SVMAI ───────────────────────────────────────────┐ │
│ │ 🪙 Use your existing SPL tokens on Solana                              │ │
│ │                                                                         │ │
│ │ Available Tokens:                                                       │ │
│ │ • USDC: 150.00 (Rate: 1 USDC = 100 SVMAI)                             │ │
│ │ • USDT: 75.50 (Rate: 1 USDT = 100 SVMAI)                              │ │
│ │ • RAY: 1,250 (Rate: 1 RAY = 15 SVMAI)                                 │ │
│ │                                                                         │ │
│ │ Convert: [10] USDC → [1000] SVMAI                                      │ │
│ │ [� Conver t SPL Tokens]                                                 │ │
│ └─────────────────────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────────────────────┤
│ ┌─ Earn SVMAI Tokens (FREE) ──────────────────────────────────────────────┐ │
│ │ 🎁 No wallet transactions required - earn through platform activity:   │ │
│ │                                                                         │ │
│ │ • 🔗 Invite Friends: +50 SVMAI per signup (wallet required)            │ │
│ │ • 📝 Daily Investigation: +5 SVMAI (first of the day)                  │ │
│ │ • 🏆 Weekly Streak: +20 SVMAI (7 days in a row)                        │ │
│ │ • 📋 Contribute Template: +25 SVMAI (when approved)                    │ │
│ │ • 🐛 Report Bugs: +100 SVMAI (valid reports)                           │ │
│ │ • 👥 Help Community: +10 SVMAI per helpful review                      │ │
│ │ • 🎯 Complete Profile: +15 SVMAI (one-time bonus)                      │ │
│ │                                                                         │ │
│ │ Today's Progress: 🔥 2/5 earning opportunities completed               │ │
│ │ [🎯 View All Earning Opportunities]                                     │ │
│ └─────────────────────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────────────────────┤
│ ┌─ Transaction History ───────────────────────────────────────────────────┐ │
│ │ 📝 Recent SVMAI Activity:                                               │ │
│ │                                                                         │ │
│ │ • 2h ago: SOL Conversion (+550 SVMAI) ✅ Confirmed                     │ │
│ │ • 1d ago: Investigation Cost (-28 SVMAI) 🔍 DeFi Analysis              │ │
│ │ • 3d ago: Referral Bonus (+50 SVMAI) 🎁 Friend joined                 │ │
│ │ • 5d ago: Daily Bonus (+5 SVMAI) 🏆 Streak: 12 days                   │ │
│ │ • 1w ago: USDC Conversion (+1000 SVMAI) 🔄 SPL Token swap              │ │
│ │                                                        [View All]       │ │
│ └─────────────────────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────────────────────┤
│ ┌─ Access Requirements ───────────────────────────────────────────────────┐ │
│ │ 🔒 SVMAI Token Requirements:                                            │ │
│ │                                                                         │ │
│ │ • AI Sidebar Access: 10 SVMAI minimum balance                          │ │
│ │ • Social Features: 25 SVMAI minimum balance                            │ │
│ │ • Basic Investigation: 10 SVMAI per investigation                       │ │
│ │ • Complex Investigation: 25 SVMAI per investigation                     │ │
│ │ • Deep Investigation: 50 SVMAI per investigation                        │ │
│ │                                                                         │ │
│ │ ✅ Current Status: All features unlocked (127 SVMAI balance)           │ │
│ └─────────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### Smart Contract Integration for SOL Deposits

```typescript
interface SVMAIDepositContract {
  // Solana program for instant SOL → SVMAI conversion
  programId: string;
  
  // Deposit functions
  depositSOL: (amount: number, userWallet: string) => Promise<TransactionSignature>;
  depositSPLToken: (tokenMint: string, amount: number, userWallet: string) => Promise<TransactionSignature>;
  
  // Rate calculation
  getCurrentRate: (inputToken: string) => Promise<ConversionRate>;
  calculateSVMAI: (inputAmount: number, inputToken: string) => Promise<SVMAIAmount>;
  
  // Bonus calculation
  calculateBonus: (svmaiAmount: number) => Promise<BonusAmount>;
}

// Example smart contract interaction
const depositSOL = async (solAmount: number) => {
  // 1. Connect user's Solana wallet
  const wallet = await window.solana.connect();
  
  // 2. Calculate SVMAI amount with bonus
  const baseAmount = solAmount * 1000; // 1 SOL = 1000 SVMAI
  const bonusAmount = calculateBonus(baseAmount);
  const totalSVMAI = baseAmount + bonusAmount;
  
  // 3. Create deposit transaction
  const transaction = new Transaction().add(
    SystemProgram.transfer({
      fromPubkey: wallet.publicKey,
      toPubkey: SVMAI_DEPOSIT_ACCOUNT,
      lamports: solAmount * LAMPORTS_PER_SOL
    })
  );
  
  // 4. Sign and send transaction
  const signature = await wallet.signAndSendTransaction(transaction);
  
  // 5. Credit SVMAI tokens to user account
  await creditSVMAITokens(wallet.publicKey.toString(), totalSVMAI);
  
  return { signature, svmaiCredited: totalSVMAI };
};
```

#### Implementation Priority (Fastest to Deploy)

```typescript
interface DepositImplementationPlan {
  // Phase 1: Immediate (1-2 days)
  phase1: {
    methods: ['solana_wallet', 'earning_system'];
    features: ['SOL deposits', 'referral rewards', 'daily bonuses'];
    complexity: 'low';
    revenue: 'medium';
  };
  
  // Phase 2: Quick (3-5 days)
  phase2: {
    methods: ['credit_card'];
    features: ['Stripe integration', 'instant delivery'];
    complexity: 'medium';
    revenue: 'high';
  };
  
  // Phase 3: Extended (1-2 weeks)
  phase3: {
    methods: ['crypto_deposits', 'bank_transfer'];
    features: ['Multi-crypto support', 'advanced features'];
    complexity: 'high';
    revenue: 'high';
  };
}
```

### Token Purchase and Management UI

```ascii
┌─────────────────────────────────────────────────────────────────────────────┐
│ ╔═══════════════════════════════════════════════════════════════════════════╗ │
│ ║                        💰 SVMAI Token Management                         ║ │
│ ╚═══════════════════════════════════════════════════════════════════════════╝ │
├─────────────────────────────────────────────────────────────────────────────┤
│ ┌─ Current Balance ───────────────────────────────────────────────────────┐ │
│ │ 💎 SVMAI Tokens: 127                                                   │ │
│ │ 📊 Usage This Month: 73 tokens                                         │ │
│ │ 📈 Estimated Remaining: ~5 complex investigations                      │ │
│ │ ⚡ Token Earning Rate: +12 SVMAI this week                             │ │
│ └─────────────────────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────────────────────┤
│ ┌─ Investigation Cost Estimator ──────────────────────────────────────────┐ │
│ │ 🔍 Investigation Type: [Complex DeFi Analysis ▼]                       │ │
│ │ 📊 Estimated Steps: 8-12                                               │ │
│ │ ⏱️  Estimated Duration: 3-5 minutes                                     │ │
│ │ 💰 Estimated Cost: 25-35 SVMAI tokens                                  │ │
│ │                                                                         │ │
│ │ ✅ You have sufficient balance                                          │ │
│ │ [🚀 Start Investigation] [⚙️ Customize]                                 │ │
│ └─────────────────────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────────────────────┤
│ ┌─ Token Package Options ─────────────────────────────────────────────────┐ │
│ │ 💎 Available Token Packages:                                           │ │
│ │                                                                         │ │
│ │ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐         │ │
│ │ │ 100 SVMAI   │ │ 500 SVMAI   │ │ 1000 SVMAI  │ │ 2000 SVMAI  │         │ │
│ │ │ Basic Pack  │ │ Premium     │ │ Pro Pack    │ │ Enterprise  │         │ │
│ │ │             │ │ +100 Bonus  │ │ +300 Bonus  │ │ +800 Bonus  │         │ │
│ │ │ = 100 Total │ │ = 600 Total │ │ = 1300 Total│ │ = 2800 Total│         │ │
│ │ └─────────────┘ └─────────────┘ └─────────────┘ └─────────────┘         │ │
│ │                                                                         │ │
│ │ 🎯 Recommended: Premium (600 SVMAI total) for your usage pattern       │ │
│ └─────────────────────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────────────────────┤
│ ┌─ Token Earning Opportunities ───────────────────────────────────────────┐ │
│ │ 🎁 Earn More SVMAI Tokens:                                             │ │
│ │                                                                         │ │
│ │ • 🔗 Refer Friends: +50 SVMAI per successful referral                  │ │
│ │ • 📝 Contribute Templates: +25 SVMAI per validated template            │ │
│ │ • 🏆 Daily Investigation: +5 SVMAI for first investigation daily       │ │
│ │ • 🔥 Weekly Streak: +20 SVMAI for 7-day investigation streak           │ │
│ │ • 🐛 Report Bugs: +100 SVMAI per valid bug report                      │ │
│ │ • 👥 Community Help: +10 SVMAI per helpful review                      │ │
│ │                                                                         │ │
│ │ [🎯 View All Earning Opportunities]                                     │ │
│ └─────────────────────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────────────────────┤
│ ┌─ Usage Analytics ───────────────────────────────────────────────────────┐ │
│ │ 📊 Token Consumption Breakdown (Last 30 Days):                          │ │
│ │                                                                         │ │
│ │ Navigation Steps     ████████████░░░░ 65% (47 tokens)                   │ │
│ │ Pattern Analysis     ██████░░░░░░░░░░ 20% (15 tokens)                   │ │
│ │ Data Extraction      ████░░░░░░░░░░░░ 10% (7 tokens)                    │ │
│ │ Premium Features     ██░░░░░░░░░░░░░░ 5% (4 tokens)                     │ │
│ │                                                                         │ │
│ │ ! Most Used: DeFi Portfolio Analysis (12 investigations)                │ │
│ │ ? Suggestion: Consider Premium package for 20% bonus tokens             │ │
│ └─────────────────────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────────────────────┤
│ ┌─ Recent Transactions ───────────────────────────────────────────────────┐ │
│ │ 📝 Transaction History:                                                 │ │
│ │                                                                         │ │
│ │ • 2h ago: DeFi Risk Analysis (-28 SVMAI)                                │ │
│ │ • 1d ago: Wallet Connection Map (-15 SVMAI)                             │ │
│ │ • 2d ago: Premium Package (+600 SVMAI)                                  │ │
│ │ • 3d ago: Suspicious Activity Check (-22 SVMAI)                         │ │
│ │ • 4d ago: Daily Investigation Bonus (+5 SVMAI)                          │ │
│ │ • 5d ago: Template Contribution (+25 SVMAI)                             │ │
│ │                                                        [View All]       │ │
│ └─────────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Revenue Optimization Features

```typescript
interface RevenueOptimization {
  // Dynamic pricing based on demand
  dynamicPricing: DynamicPricingEngine;
  
  // Usage-based recommendations
  usageAnalyzer: UsageAnalyzer;
  
  // Subscription upselling
  subscriptionManager: SubscriptionManager;
  
  // Token earning opportunities
  tokenRewards: TokenRewardSystem;
}

interface DynamicPricingEngine {
  adjustPricing(demand: number, supply: number): PricingAdjustment;
  getPeakHourPricing(): PricingMultiplier;
  getVolumeDiscounts(usage: number): DiscountRate;
}

interface TokenRewardSystem {
  // Earn tokens through platform engagement
  referralRewards: number;        // 50 SVMAI per successful referral
  contentContribution: number;    // 25 SVMAI per validated template
  communityModeration: number;    // 10 SVMAI per helpful review
  bugReporting: number;          // 100 SVMAI per valid bug report
  
  // Daily/weekly challenges
  dailyInvestigationBonus: number;  // 5 SVMAI for first investigation
  weeklyStreakBonus: number;        // 20 SVMAI for 7-day streak
  monthlyChallenge: number;         // 200 SVMAI for monthly goals
}
```

### Integration with Existing Systems

```typescript
interface SVMAIIntegration {
  // User profile integration
  userProfile: {
    tokenBalance: number;
    subscriptionTier: 'free' | 'basic' | 'premium' | 'enterprise';
    usageHistory: TokenUsageRecord[];
    preferences: TokenPreferences;
  };
  
  // Payment processing
  paymentGateway: {
    processPurchase: (amount: number, tokens: number) => Promise<PaymentResult>;
    handleSubscription: (tier: string) => Promise<SubscriptionResult>;
    processRefund: (transactionId: string) => Promise<RefundResult>;
  };
  
  // Analytics and reporting
  analytics: {
    trackTokenUsage: (userId: string, action: string, cost: number) => void;
    generateUsageReport: (userId: string, period: string) => UsageReport;
    calculateROI: (userId: string) => ROIMetrics;
  };
}
```

## Monitoring and Analytics

### Performance Metrics
- Investigation completion rates
- Average investigation duration
- Error rates by navigation type
- User satisfaction scores
- Template usage statistics
- **Token consumption patterns**
- **Revenue per user metrics**
- **Subscription conversion rates**

### System Health Monitoring
- Resource utilization tracking
- Error rate monitoring
- Response time tracking
- Cache hit rates
- Queue depth monitoring
- **Token transaction processing**
- **Payment gateway health**

### User Behavior Analytics
- Most popular investigation types
- Template effectiveness ratings
- User interaction patterns
- Abandonment points in investigations
- Feature adoption rates
- **Token spending behavior**
- **Price sensitivity analysis**
- **Upselling opportunity identification**
---

## File: ./.kiro/specs/ai-agentic-navigation/requirements.md

# AI Agentic Navigation System Requirements

## Introduction

The AI Agentic Navigation System transforms the OpenSVM AI assistant from a passive question-answering tool into an autonomous blockchain explorer that can navigate through the website to achieve user-requested tasks. This system enables the AI to conduct multi-step investigations, discover hidden patterns, and provide comprehensive analysis by intelligently moving between different pages and data sources within the platform.

## Requirements

### Requirement 1: Autonomous Navigation Engine

**User Story:** As a blockchain researcher, I want the AI to autonomously navigate through different pages on OpenSVM to gather comprehensive data for my analysis, so that I can get complete insights without manually visiting multiple pages.

#### Acceptance Criteria

1. WHEN a user requests a complex analysis THEN the AI SHALL create a navigation plan with multiple steps to gather required data
2. WHEN executing navigation steps THEN the AI SHALL navigate to relevant pages (accounts, transactions, tokens, blocks) programmatically
3. WHEN navigating to a new page THEN the AI SHALL extract relevant data using predefined extraction rules
4. WHEN navigation fails THEN the AI SHALL implement retry logic and alternative path planning
5. WHEN navigation is successful THEN the AI SHALL update the current context and continue to the next step
6. WHEN all navigation steps are complete THEN the AI SHALL synthesize findings into a comprehensive analysis
7. WHEN navigation exceeds time limits THEN the AI SHALL provide partial results and explain what was completed
8. WHEN user interrupts navigation THEN the AI SHALL pause execution and allow user to modify the investigation plan

### Requirement 2: Intelligent Path Planning

**User Story:** As a user requesting complex blockchain analysis, I want the AI to plan the most efficient path through the platform to gather the information I need, so that I get accurate results in the shortest time possible.

#### Acceptance Criteria

1. WHEN receiving a user request THEN the AI SHALL analyze the objective and create an optimal navigation plan
2. WHEN planning navigation THEN the AI SHALL estimate complexity, time requirements, and success probability
3. WHEN creating plans THEN the AI SHALL prioritize high-value data sources and minimize redundant navigation
4. WHEN new insights are discovered THEN the AI SHALL adapt the navigation plan to explore relevant connections
5. WHEN multiple paths are possible THEN the AI SHALL suggest alternative approaches with trade-offs
6. WHEN planning fails THEN the AI SHALL break down complex objectives into simpler, achievable sub-tasks
7. WHEN user preferences are available THEN the AI SHALL incorporate user history and preferences into path planning
8. WHEN risk factors are identified THEN the AI SHALL warn users and suggest safer alternative approaches

### Requirement 3: Real-time Progress Communication

**User Story:** As a user waiting for AI analysis, I want to see real-time updates on what the AI is doing and what it has discovered, so that I can understand the investigation process and intervene if needed.

#### Acceptance Criteria

1. WHEN navigation begins THEN the AI SHALL display initial progress with estimated completion time
2. WHEN each step starts THEN the AI SHALL show current action with reasoning and expected duration
3. WHEN data is extracted THEN the AI SHALL highlight key discoveries and insights in real-time
4. WHEN errors occur THEN the AI SHALL explain the issue and show recovery actions being taken
5. WHEN significant findings are made THEN the AI SHALL immediately surface important discoveries to the user
6. WHEN navigation is complete THEN the AI SHALL provide a summary of the investigation path taken
7. WHEN user requests updates THEN the AI SHALL provide detailed status including time elapsed and remaining
8. WHEN investigation is paused THEN the AI SHALL save current state and allow resumption later

### Requirement 4: Data Extraction and Correlation

**User Story:** As a blockchain analyst, I want the AI to extract and correlate data from multiple pages to identify patterns and relationships that wouldn't be visible from a single page, so that I can discover hidden connections and insights.

#### Acceptance Criteria

1. WHEN visiting pages THEN the AI SHALL extract structured data using configurable extraction rules
2. WHEN data is extracted THEN the AI SHALL validate data quality and completeness before processing
3. WHEN multiple entities are analyzed THEN the AI SHALL identify correlations and relationships between them
4. WHEN patterns are detected THEN the AI SHALL quantify pattern strength and statistical significance
5. WHEN anomalies are found THEN the AI SHALL flag suspicious activities and provide evidence
6. WHEN building relationships THEN the AI SHALL create weighted connection graphs with relationship strength
7. WHEN correlating data THEN the AI SHALL consider temporal patterns and time-based relationships
8. WHEN analysis is complete THEN the AI SHALL provide visualizable data for relationship graphs and patterns

### Requirement 5: Investigation Templates and Workflows

**User Story:** As a user with specific analysis needs, I want to use predefined investigation templates for common blockchain analysis scenarios, so that I can quickly get standardized analysis without explaining complex requirements.

#### Acceptance Criteria

1. WHEN templates are requested THEN the AI SHALL provide categorized investigation templates for different use cases
2. WHEN a template is selected THEN the AI SHALL customize the investigation based on user input and context
3. WHEN templates are executed THEN the AI SHALL follow predefined workflows while adapting to specific data
4. WHEN template execution varies THEN the AI SHALL explain deviations and reasoning for changes
5. WHEN templates are insufficient THEN the AI SHALL suggest modifications or alternative approaches
6. WHEN new patterns emerge THEN the AI SHALL recommend creating new templates based on successful investigations
7. WHEN templates are shared THEN the AI SHALL allow users to save and share custom investigation workflows
8. WHEN template results differ THEN the AI SHALL compare outcomes with expected results and explain variations

### Requirement 6: Multi-dimensional Analysis Capabilities

**User Story:** As a comprehensive blockchain researcher, I want the AI to analyze entities across multiple dimensions (time, networks, protocols, relationships), so that I can understand the complete context and evolution of blockchain activities.

#### Acceptance Criteria

1. WHEN temporal analysis is requested THEN the AI SHALL analyze entity behavior across different time periods
2. WHEN cross-protocol analysis is needed THEN the AI SHALL examine entity interactions across multiple DeFi protocols
3. WHEN network analysis is required THEN the AI SHALL compare entity behavior across different blockchain networks
4. WHEN relationship analysis is performed THEN the AI SHALL map entity connections with varying relationship strengths
5. WHEN evolution tracking is requested THEN the AI SHALL identify behavior changes and trend patterns over time
6. WHEN comparative analysis is needed THEN the AI SHALL benchmark entities against peers and market averages
7. WHEN risk assessment is performed THEN the AI SHALL evaluate risk factors across multiple dimensions
8. WHEN analysis is complete THEN the AI SHALL provide multi-dimensional visualizations and insights

### Requirement 7: User History Integration and Connection Discovery

**User Story:** As a returning user, I want the AI to remember my previous explorations and automatically identify connections between current analysis and my historical activity, so that I can build upon my previous research and discover hidden relationships.

#### Acceptance Criteria

1. WHEN user views new entities THEN the AI SHALL check for connections with previously visited entities from user history
2. WHEN connections are found THEN the AI SHALL notify user with connection details and relationship strength
3. WHEN building analysis THEN the AI SHALL incorporate insights from user's complete exploration history
4. WHEN patterns emerge THEN the AI SHALL reference similar patterns from user's previous investigations
5. WHEN recommendations are made THEN the AI SHALL consider user's historical interests and research focus
6. WHEN investigations are saved THEN the AI SHALL store complete navigation paths and findings in user profile
7. WHEN users return THEN the AI SHALL suggest continuing previous investigations or exploring related areas
8. WHEN privacy is configured THEN the AI SHALL respect user settings for history retention and sharing

### Requirement 8: Interactive Investigation Control

**User Story:** As a user conducting AI-assisted research, I want to be able to pause, modify, or redirect the AI's investigation in real-time, so that I can guide the analysis based on emerging insights or changing requirements.

#### Acceptance Criteria

1. WHEN investigation is running THEN the AI SHALL provide pause, resume, and stop controls
2. WHEN user pauses investigation THEN the AI SHALL save current state and allow modification of remaining steps
3. WHEN user redirects investigation THEN the AI SHALL adapt the plan while preserving valuable discoveries
4. WHEN user adds constraints THEN the AI SHALL modify navigation to respect new limitations or focus areas
5. WHEN user requests specific exploration THEN the AI SHALL incorporate user suggestions into the navigation plan
6. WHEN investigation branches THEN the AI SHALL allow users to choose which paths to explore further
7. WHEN findings are questioned THEN the AI SHALL provide evidence and allow users to request verification
8. WHEN investigation is modified THEN the AI SHALL explain how changes affect expected outcomes and timing

### Requirement 9: Collaborative Investigation Features

**User Story:** As a member of a research team, I want to share AI investigation sessions with colleagues and learn from community-validated investigation patterns, so that we can collaborate effectively and benefit from collective knowledge.

#### Acceptance Criteria

1. WHEN investigations are complete THEN the AI SHALL allow users to share investigation sessions with others
2. WHEN sharing investigations THEN the AI SHALL provide replay functionality showing the complete navigation path
3. WHEN community templates exist THEN the AI SHALL suggest proven investigation patterns from other users
4. WHEN investigations are validated THEN the AI SHALL allow expert review and validation of findings
5. WHEN patterns are successful THEN the AI SHALL recommend contributing investigation templates to community
6. WHEN collaborative features are used THEN the AI SHALL maintain privacy controls for sensitive investigations
7. WHEN learning from community THEN the AI SHALL incorporate validated patterns into its planning algorithms
8. WHEN investigations are replayed THEN the AI SHALL provide educational commentary explaining decision points

### Requirement 10: Performance and Scalability

**User Story:** As a user expecting responsive AI assistance, I want the agentic navigation system to perform efficiently even with complex multi-step investigations, so that I can get results quickly without system delays.

#### Acceptance Criteria

1. WHEN navigation begins THEN the AI SHALL start providing results within 2 seconds of request
2. WHEN executing steps THEN the AI SHALL complete individual navigation actions within 5 seconds each
3. WHEN processing data THEN the AI SHALL use caching to avoid redundant data fetching and processing
4. WHEN multiple investigations run THEN the AI SHALL manage resources to prevent system overload
5. WHEN complex analysis is performed THEN the AI SHALL use progressive disclosure to show results incrementally
6. WHEN errors cause delays THEN the AI SHALL implement exponential backoff and circuit breaker patterns
7. WHEN system load is high THEN the AI SHALL prioritize user requests and queue background processing
8. WHEN investigations are resource-intensive THEN the AI SHALL warn users and provide estimated completion times

### Requirement 11: Error Handling and Recovery

**User Story:** As a user relying on AI analysis, I want the system to gracefully handle errors and provide meaningful recovery options, so that temporary issues don't prevent me from getting the analysis I need.

#### Acceptance Criteria

1. WHEN navigation errors occur THEN the AI SHALL attempt automatic recovery with alternative approaches
2. WHEN data extraction fails THEN the AI SHALL try alternative extraction methods or skip non-critical data
3. WHEN API limits are reached THEN the AI SHALL implement intelligent rate limiting and retry strategies
4. WHEN network issues arise THEN the AI SHALL cache partial results and resume when connectivity returns
5. WHEN invalid data is encountered THEN the AI SHALL validate inputs and provide clear error explanations
6. WHEN investigations fail THEN the AI SHALL provide partial results and explain what was successfully completed
7. WHEN recovery is impossible THEN the AI SHALL suggest alternative investigation approaches
8. WHEN errors are resolved THEN the AI SHALL resume investigations from the last successful checkpoint

### Requirement 12: SVMAI Token Monetization and Premium Features

**User Story:** As a platform operator, I want to monetize the AI agentic navigation system through SVMAI token consumption, so that we can generate revenue while providing premium AI-powered blockchain analysis capabilities.

#### Acceptance Criteria

1. WHEN users start investigations THEN the system SHALL require SVMAI token payment based on investigation complexity and duration
2. WHEN token balance is insufficient THEN the system SHALL prevent investigation start and prompt for token purchase
3. WHEN investigations are running THEN the system SHALL consume SVMAI tokens in real-time based on resources used
4. WHEN premium features are accessed THEN the system SHALL charge additional SVMAI tokens for advanced capabilities
5. WHEN investigations are paused THEN the system SHALL pause token consumption and preserve remaining balance
6. WHEN investigations complete THEN the system SHALL provide detailed token usage breakdown and cost analysis
7. WHEN users have premium subscriptions THEN the system SHALL provide discounted token rates and bonus features
8. WHEN token consumption exceeds limits THEN the system SHALL gracefully pause investigations and offer upgrade options

### Requirement 13: Security and Privacy Controls

**User Story:** As a privacy-conscious user, I want the AI navigation system to respect my privacy settings and handle my investigation data securely, so that my research activities and interests remain protected.

#### Acceptance Criteria

1. WHEN investigations are performed THEN the AI SHALL respect user privacy settings for data collection and storage
2. WHEN sensitive data is encountered THEN the AI SHALL apply appropriate filtering and anonymization
3. WHEN investigations are shared THEN the AI SHALL remove personally identifiable information
4. WHEN user data is stored THEN the AI SHALL encrypt investigation history and findings
5. WHEN access controls are configured THEN the AI SHALL enforce permissions for investigation features
6. WHEN audit trails are required THEN the AI SHALL log investigation activities for security monitoring
7. WHEN data retention policies apply THEN the AI SHALL automatically purge old investigation data
8. WHEN privacy violations are detected THEN the AI SHALL alert users and prevent unauthorized data access
---

## File: ./.kiro/specs/ai-agentic-navigation/tasks.md

# AI Agentic Navigation System Implementation Tasks

## Implementation Plan

Convert the AI Agentic Navigation System design into a series of prompts for a code-generation LLM that will implement each step in a test-driven manner. Prioritize best practices, incremental progress, and early testing, ensuring no big jumps in complexity at any stage. Make sure that each prompt builds on the previous prompts, and ends with wiring things together. There should be no hanging or orphaned code that isn't integrated into a previous step. Focus ONLY on tasks that involve writing, modifying, or testing code.

- [ ] 1. Core Navigation Infrastructure Setup
  - Create `lib/ai/agentic/types/NavigationTypes.ts` with all core interfaces (NavigationController, InvestigationRequest, NavigationSession, etc.)
  - Create `lib/ai/agentic/types/InvestigationTypes.ts` with Finding, Evidence, Insight, EntityReference interfaces
  - Create `lib/ai/agentic/types/AnalysisTypes.ts` with correlation and pattern detection types
  - Implement `lib/ai/agentic/core/NavigationController.ts` class with session CRUD operations using Map-based in-memory storage
  - Create `lib/ai/agentic/state/SessionManager.ts` for session lifecycle management with automatic cleanup
  - Add `lib/ai/agentic/utils/ErrorHandler.ts` with NavigationError classification and recovery strategies
  - Create `lib/ai/agentic/utils/Logger.ts` with structured logging for investigation activities
  - Write comprehensive unit tests in `__tests__/agentic/core/NavigationController.test.ts` with mock session scenarios
  - Write unit tests in `__tests__/agentic/state/SessionManager.test.ts` for session lifecycle management
  - _Requirements: 1.1, 1.2, 1.3, 1.5_

- [ ] 2. Path Planning Engine Implementation
  - Create `lib/ai/agentic/core/PathPlanner.ts` with NavigationPlan creation using graph algorithms
  - Implement `lib/ai/agentic/core/ComplexityEstimator.ts` with time/resource estimation based on step types and dependencies
  - Create `lib/ai/agentic/utils/PlanOptimizer.ts` with A* pathfinding for optimal navigation routes
  - Add `lib/ai/agentic/core/PlanValidator.ts` with dependency checking and circular reference detection
  - Implement plan adaptation logic in PathPlanner for dynamic re-planning based on new findings
  - Create predefined investigation patterns in `lib/ai/agentic/patterns/` for common blockchain analysis scenarios
  - Write unit tests in `__tests__/agentic/core/PathPlanner.test.ts` with complex multi-step plan scenarios
  - Write unit tests in `__tests__/agentic/core/ComplexityEstimator.test.ts` with various plan complexity calculations
  - Write integration tests in `__tests__/agentic/integration/PlanExecution.test.ts` for end-to-end plan creation and validation
  - _Requirements: 2.1, 2.2, 2.3, 2.4_

- [ ] 3. Navigation Driver and Page Interaction
  - Create `lib/ai/agentic/drivers/NavigationDriver.ts` using Next.js router with programmatic navigation
  - Implement `lib/ai/agentic/drivers/PageAnalyzer.ts` for detecting current page type using URL patterns and DOM analysis
  - Create `lib/ai/agentic/drivers/ContextDetector.ts` for extracting current page context (entity type, ID, metadata)
  - Add `lib/ai/agentic/utils/NavigationWaiter.ts` with Promise-based page load detection using MutationObserver
  - Implement timeout handling with exponential backoff in NavigationDriver for failed page loads
  - Create `lib/ai/agentic/drivers/BrowserStateManager.ts` for tracking navigation history and browser state
  - Add URL validation and sanitization in NavigationDriver to prevent navigation to invalid/malicious URLs
  - Write integration tests in `__tests__/agentic/drivers/NavigationDriver.test.ts` using jsdom and mock router
  - Write unit tests in `__tests__/agentic/drivers/PageAnalyzer.test.ts` with various page type detection scenarios
  - Write integration tests in `__tests__/agentic/integration/NavigationFlow.test.ts` for complete navigation workflows
  - _Requirements: 1.2, 1.3, 1.4_

- [ ] 4. Data Extraction System Foundation
  - Create `lib/ai/agentic/extraction/DataExtractor.ts` with rule-based extraction using CSS selectors and XPath
  - Implement `lib/ai/agentic/extraction/ExtractionRuleManager.ts` with dynamic rule loading and validation
  - Create extraction rules in `lib/ai/agentic/extraction/rules/` for each page type (AccountExtractionRule.ts, TransactionExtractionRule.ts, etc.)
  - Add `lib/ai/agentic/extraction/DataValidator.ts` with schema validation using Zod for extracted data
  - Implement `lib/ai/agentic/extraction/QualityAssessor.ts` for data completeness and accuracy scoring
  - Create `lib/ai/agentic/extraction/DataTransformer.ts` for normalizing extracted data into standard formats
  - Add retry logic and fallback extraction methods in DataExtractor for robust data collection
  - Write unit tests in `__tests__/agentic/extraction/DataExtractor.test.ts` with mock DOM elements and extraction scenarios
  - Write unit tests in `__tests__/agentic/extraction/ExtractionRules.test.ts` for each page-specific extraction rule
  - Write integration tests in `__tests__/agentic/integration/DataExtraction.test.ts` with real page HTML fixtures
  - _Requirements: 4.1, 4.2, 4.3, 4.4_

- [ ] 5. Execution Engine Core Logic
  - Create `lib/ai/agentic/core/ExecutionEngine.ts` with async step execution using worker queues
  - Implement `lib/ai/agentic/state/CheckpointManager.ts` with JSON serialization for investigation state persistence
  - Create `lib/ai/agentic/core/ResourceManager.ts` with semaphore-based concurrency control for investigation limits
  - Add `lib/ai/agentic/core/StepExecutor.ts` with individual step execution logic and error boundary handling
  - Implement recovery strategies in ExecutionEngine with alternative step generation and retry mechanisms
  - Create `lib/ai/agentic/state/ExecutionContext.ts` for maintaining execution state across steps
  - Add circuit breaker pattern in StepExecutor for handling unreliable data sources and API failures
  - Write integration tests in `__tests__/agentic/core/ExecutionEngine.test.ts` with mock navigation steps and error scenarios
  - Write unit tests in `__tests__/agentic/state/CheckpointManager.test.ts` for state serialization and restoration
  - Write unit tests in `__tests__/agentic/core/ResourceManager.test.ts` for concurrent investigation management
  - _Requirements: 1.4, 1.5, 1.6, 11.1, 11.2_

- [ ] 6. Progress Tracking and Communication System
  - Create `lib/ai/agentic/core/ProgressTracker.ts` with EventEmitter-based progress monitoring and WebSocket integration
  - Implement `lib/ai/agentic/communication/NotificationSystem.ts` with SSE streams using Next.js API routes
  - Create `lib/ai/agentic/communication/ProgressWebSocketHandler.ts` for real-time bidirectional communication
  - Add `lib/ai/agentic/visualization/ProgressDataGenerator.ts` for creating visualization-ready progress data structures
  - Implement `lib/ai/agentic/communication/SubscriptionManager.ts` with user session management and cleanup
  - Create `app/api/agentic/progress/[sessionId]/route.ts` SSE endpoint with streaming progress updates
  - Add `app/api/agentic/websocket/progress/route.ts` WebSocket handler for real-time progress communication
  - Create progress notification queue system in ProgressTracker with Redis-like in-memory storage
  - Write unit tests in `__tests__/agentic/core/ProgressTracker.test.ts` with mock WebSocket connections
  - Write integration tests in `__tests__/agentic/communication/ProgressCommunication.test.ts` for end-to-end progress flow
  - _Requirements: 3.1, 3.2, 3.3, 3.4, 3.5_

- [ ] 7. Investigation Template System
  - Create `lib/ai/agentic/templates/TemplateManager.ts` with JSON-based template storage and CRUD operations
  - Implement `lib/ai/agentic/templates/InvestigationTemplate.ts` class with Zod schema validation
  - Create `lib/ai/agentic/templates/TemplateInstantiator.ts` with parameter substitution using template literals
  - Add predefined templates in `lib/ai/agentic/templates/predefined/DeFiAnalysisTemplate.ts` with step definitions
  - Create `lib/ai/agentic/templates/predefined/SuspiciousActivityTemplate.ts` for anomaly detection workflows
  - Add `lib/ai/agentic/templates/predefined/WalletConnectionTemplate.ts` for relationship analysis
  - Implement `lib/ai/agentic/templates/TemplateValidator.ts` with dependency validation and circular reference detection
  - Create `app/api/agentic/templates/route.ts` for template CRUD operations with authentication
  - Write unit tests in `__tests__/agentic/templates/TemplateManager.test.ts` with template lifecycle scenarios
  - Write integration tests in `__tests__/agentic/templates/TemplateExecution.test.ts` for template instantiation and execution
  - _Requirements: 5.1, 5.2, 5.3, 5.4_

- [ ] 8. Data Correlation and Pattern Detection
  - Create `lib/ai/agentic/correlation/DataCorrelator.ts` with graph-based entity relationship analysis
  - Implement `lib/ai/agentic/correlation/PatternDetector.ts` using statistical analysis and machine learning algorithms
  - Add `lib/ai/agentic/correlation/RelationshipAnalyzer.ts` with weighted graph algorithms for connection strength
  - Create `lib/ai/agentic/correlation/AnomalyDetector.ts` with outlier detection using z-score and isolation forest
  - Implement `lib/ai/agentic/correlation/GraphBuilder.ts` for creating relationship graphs with D3.js-compatible data
  - Add `lib/ai/agentic/correlation/TemporalAnalyzer.ts` for time-series pattern detection and trend analysis
  - Create correlation scoring algorithms in DataCorrelator using Pearson correlation and mutual information
  - Implement pattern matching using regex and fuzzy matching for transaction pattern detection
  - Write unit tests in `__tests__/agentic/correlation/DataCorrelator.test.ts` with mock entity data and relationships
  - Write unit tests in `__tests__/agentic/correlation/PatternDetector.test.ts` with known suspicious activity patterns
  - _Requirements: 4.5, 4.6, 4.7, 4.8_

- [ ] 9. Multi-dimensional Analysis Capabilities
  - Create `lib/ai/agentic/analysis/MultiDimensionalAnalyzer.ts` with time-series and cross-protocol analysis
  - Implement `lib/ai/agentic/analysis/TemporalAnalyzer.ts` using sliding window algorithms for behavior tracking
  - Add `lib/ai/agentic/analysis/CrossProtocolAnalyzer.ts` with protocol-specific analysis logic for DeFi platforms
  - Create `lib/ai/agentic/analysis/NetworkAnalyzer.ts` for cross-chain analysis and network comparison
  - Implement `lib/ai/agentic/analysis/BehaviorChangeDetector.ts` using change point detection algorithms
  - Add `lib/ai/agentic/analysis/EntityEvolutionTracker.ts` with state machine-based evolution modeling
  - Create `lib/ai/agentic/analysis/ComparisonEngine.ts` for entity benchmarking against peer groups
  - Implement statistical analysis methods using libraries like simple-statistics for trend analysis
  - Write integration tests in `__tests__/agentic/analysis/MultiDimensionalAnalysis.test.ts` with time-series data
  - Write unit tests in `__tests__/agentic/analysis/BehaviorChangeDetector.test.ts` with behavior change scenarios
  - _Requirements: 6.1, 6.2, 6.3, 6.4, 6.5_

- [ ] 10. User History Integration and Connection Discovery
  - Create `lib/ai/agentic/history/UserHistoryIntegrator.ts` with integration to existing user profile system
  - Implement `lib/ai/agentic/history/ConnectionDiscoverer.ts` with graph traversal algorithms for finding entity connections
  - Add `lib/ai/agentic/history/HistoryAnalyzer.ts` for analyzing user exploration patterns and preferences
  - Create `lib/ai/agentic/history/NotificationGenerator.ts` for generating connection discovery notifications
  - Implement `lib/ai/agentic/history/InvestigationHistoryManager.ts` with investigation session persistence
  - Add `lib/ai/agentic/history/EntityConnectionCache.ts` with LRU cache for frequently accessed connections
  - Create database integration in UserHistoryIntegrator using existing user profile schema
  - Implement connection strength calculation using graph algorithms and interaction frequency
  - Write integration tests in `__tests__/agentic/history/UserHistoryIntegration.test.ts` with mock user profile data
  - Write unit tests in `__tests__/agentic/history/ConnectionDiscoverer.test.ts` with entity relationship scenarios
  - _Requirements: 7.1, 7.2, 7.3, 7.4, 7.5_

- [ ] 11. Interactive Investigation Control Interface
  - Create `lib/ai/agentic/control/InvestigationController.ts` with real-time investigation control using EventEmitter patterns
  - Implement `lib/ai/agentic/control/PauseResumeManager.ts` with investigation state freezing and restoration
  - Add `lib/ai/agentic/control/PlanModifier.ts` for dynamic plan modification with dependency validation
  - Create `lib/ai/agentic/control/BranchingManager.ts` for investigation path branching and parallel execution
  - Implement `lib/ai/agentic/control/UserInputHandler.ts` with real-time user input processing and validation
  - Add `lib/ai/agentic/control/InteractionQueue.ts` for queuing user interactions during investigation execution
  - Create WebSocket integration in InvestigationController for bidirectional real-time communication
  - Implement investigation modification UI state synchronization with optimistic updates
  - Write integration tests in `__tests__/agentic/control/InvestigationControl.test.ts` with user interaction scenarios
  - Write unit tests in `__tests__/agentic/control/PlanModifier.test.ts` for dynamic plan modification logic
  - _Requirements: 8.1, 8.2, 8.3, 8.4, 8.5_

- [ ] 12. Error Handling and Recovery System
  - Create `lib/ai/agentic/recovery/ErrorClassifier.ts` with NavigationError taxonomy and severity classification
  - Implement `lib/ai/agentic/recovery/RetryManager.ts` with exponential backoff and jitter for failed operations
  - Add `lib/ai/agentic/recovery/AlternativePathGenerator.ts` for generating backup navigation routes
  - Create `lib/ai/agentic/recovery/CircuitBreaker.ts` with state machine pattern for unreliable service protection
  - Implement `lib/ai/agentic/recovery/RecoveryStrategist.ts` with decision tree for recovery action selection
  - Add `lib/ai/agentic/recovery/FailureAnalyzer.ts` for root cause analysis and failure pattern detection
  - Create error recovery metrics collection in ErrorClassifier with failure rate tracking
  - Implement graceful degradation strategies with partial result delivery when full recovery fails
  - Write unit tests in `__tests__/agentic/recovery/ErrorClassifier.test.ts` with comprehensive error scenarios
  - Write integration tests in `__tests__/agentic/recovery/RecoveryFlow.test.ts` for end-to-end error recovery
  - _Requirements: 11.1, 11.2, 11.3, 11.4, 11.5_

- [ ] 13. Performance Optimization and Caching
  - Create `lib/ai/agentic/cache/CacheManager.ts` with LRU cache implementation and TTL support for extracted data
  - Implement `lib/ai/agentic/cache/PlanCache.ts` with plan fingerprinting and similarity-based cache hits
  - Add `lib/ai/agentic/optimization/ResourcePool.ts` with semaphore-based resource allocation and queuing
  - Create `lib/ai/agentic/optimization/PrefetchManager.ts` with predictive prefetching based on navigation patterns
  - Implement `lib/ai/agentic/monitoring/PerformanceMonitor.ts` with metrics collection and performance profiling
  - Add `lib/ai/agentic/optimization/LoadBalancer.ts` for distributing investigation load across available resources
  - Create cache invalidation strategies in CacheManager with dependency-based invalidation
  - Implement performance benchmarking suite with automated performance regression detection
  - Write performance tests in `__tests__/agentic/performance/CachePerformance.test.ts` with cache hit rate validation
  - Write load tests in `__tests__/agentic/performance/ConcurrencyLoad.test.ts` for concurrent investigation handling
  - _Requirements: 10.1, 10.2, 10.3, 10.4, 10.5_

- [ ] 14. SVMAI Token Monetization and Pure Token System
  - Create `lib/ai/agentic/monetization/SVMAITokenGate.ts` with token balance validation, consumption tracking, and minimum balance requirements for AI features
  - Implement `lib/ai/agentic/monetization/PricingEngine.ts` with investigation complexity-based pricing and real-time cost estimation
  - Add `lib/ai/agentic/monetization/TokenConsumptionTracker.ts` with real-time SVMAI usage monitoring and automatic investigation pause on insufficient balance
  - Create `lib/ai/agentic/monetization/PhantomWalletIntegration.ts` leveraging existing wallet connection for SVMAI balance checking and consumption
  - Implement `lib/ai/agentic/monetization/SVMAIBalanceManager.ts` for checking user's existing SVMAI token balance from their Phantom wallet
  - Add `lib/ai/agentic/monetization/TokenRewardSystem.ts` with earning opportunities (referrals, daily bonuses, community rewards, streak bonuses)
  - Create `lib/ai/agentic/monetization/AccessController.ts` with SVMAI balance requirements for AI sidebar (10 SVMAI) and social features (25 SVMAI)
  - Implement `lib/ai/agentic/monetization/InvestigationCostCalculator.ts` with dynamic pricing based on investigation type and complexity
  - Add `lib/ai/agentic/monetization/TokenEarningEngine.ts` for processing free token earning through platform engagement
  - Create `app/api/agentic/tokens/balance/route.ts` for real-time SVMAI balance queries from user's Phantom wallet
  - Implement `app/api/agentic/tokens/consume/route.ts` for consuming SVMAI tokens during investigations with transaction logging
  - Add `app/api/agentic/tokens/earn/route.ts` for processing free token earning opportunities and referral tracking
  - Create `components/ai/agentic/SVMAIBalanceDisplay.tsx` with live balance updates from Phantom wallet and usage analytics
  - Implement `components/ai/agentic/InvestigationCostEstimator.tsx` with real-time cost calculation and balance validation
  - Add `components/ai/agentic/TokenEarningDashboard.tsx` with gamified earning progress and daily/weekly challenges
  - Create `components/ai/agentic/AccessRequirementDisplay.tsx` showing SVMAI requirements for different features
  - Write unit tests in `__tests__/agentic/monetization/SVMAITokenGate.test.ts` with balance validation and consumption scenarios
  - Write integration tests in `__tests__/agentic/monetization/PhantomIntegration.test.ts` for wallet balance checking and token consumption
  - Write end-to-end tests in `__tests__/agentic/monetization/TokenGatedAccess.test.ts` for complete SVMAI balance-to-feature-access flow
  - _Requirements: 12.1, 12.2, 12.3, 12.4, 12.5, 12.6, 12.7, 12.8_

- [ ] 15. Security and Privacy Controls
  - Create `lib/ai/agentic/security/DataSanitizer.ts` with PII detection and redaction using regex and ML models
  - Implement `lib/ai/agentic/security/AccessController.ts` with role-based access control and permission validation
  - Add `lib/ai/agentic/security/AuditLogger.ts` with structured logging and tamper-proof audit trails
  - Create `lib/ai/agentic/security/EncryptionManager.ts` with AES encryption for sensitive investigation data
  - Implement `lib/ai/agentic/security/RateLimiter.ts` with sliding window rate limiting per user and IP
  - Add `lib/ai/agentic/security/InputValidator.ts` with comprehensive input sanitization and validation
  - Create `lib/ai/agentic/security/PrivacyFilter.ts` for filtering sensitive data based on user privacy settings
  - Implement secure data transmission with HTTPS enforcement and certificate pinning
  - Write security tests in `__tests__/agentic/security/DataSanitization.test.ts` with PII detection scenarios
  - Write penetration tests in `__tests__/agentic/security/SecurityValidation.test.ts` for access control validation
  - _Requirements: 13.1, 13.2, 13.3, 13.4, 13.5, 13.6, 13.7, 13.8_

- [ ] 15. API Integration and Endpoints
  - Create `app/api/agentic/investigations/route.ts` with CRUD operations for investigation management
  - Implement `app/api/agentic/investigations/[sessionId]/route.ts` for individual investigation control
  - Add `app/api/agentic/investigations/[sessionId]/progress/route.ts` SSE endpoint for progress streaming
  - Create `app/api/agentic/investigations/[sessionId]/control/route.ts` for pause/resume/modify operations
  - Implement `app/api/agentic/investigations/[sessionId]/findings/route.ts` for findings retrieval and export
  - Add `app/api/agentic/websocket/investigations/route.ts` WebSocket handler for real-time bidirectional communication
  - Create API middleware for authentication, rate limiting, and request validation
  - Implement OpenAPI specification generation with automated API documentation
  - Write API integration tests in `__tests__/agentic/api/InvestigationAPI.test.ts` with full CRUD scenarios
  - Write WebSocket tests in `__tests__/agentic/api/WebSocketAPI.test.ts` for real-time communication validation
  - _Requirements: 1.1, 3.1, 8.1, 10.7_

- [ ] 16. UI Components for Agentic Navigation
  - Create `components/ai/agentic/InvestigationControlPanel.tsx` with Material-UI or Tailwind styling and real-time state updates
  - Implement `components/ai/agentic/ProgressVisualization.tsx` with D3.js or Recharts for navigation path visualization
  - Add `components/ai/agentic/NavigationMapView.tsx` with Cytoscape.js for interactive relationship graph display
  - Create `components/ai/agentic/TemplateSelector.tsx` with searchable template library and parameter customization
  - Implement `components/ai/agentic/FindingsDisplay.tsx` with collapsible findings cards and export functionality
  - Add `components/ai/agentic/InvestigationHistory.tsx` with virtualized list for large investigation histories
  - Create `components/ai/agentic/mobile/MobileInvestigationView.tsx` with responsive design and touch gestures
  - Implement WebSocket integration in UI components for real-time progress updates using useEffect and useState hooks
  - Write component tests in `__tests__/components/agentic/InvestigationControlPanel.test.tsx` using React Testing Library
  - Write visual regression tests in `__tests__/components/agentic/VisualRegression.test.tsx` using Storybook and Chromatic
  - _Requirements: 3.6, 5.7, 8.6, 9.2_

- [ ] 17. Investigation Templates and Workflows
  - Create `lib/ai/agentic/templates/predefined/DeFiPortfolioAnalysis.ts` with step-by-step DeFi protocol analysis workflow
  - Implement `lib/ai/agentic/templates/predefined/SuspiciousActivityDetection.ts` with anomaly detection patterns and thresholds
  - Add `lib/ai/agentic/templates/predefined/WalletConnectionMapping.ts` with graph traversal and relationship strength analysis
  - Create `lib/ai/agentic/templates/predefined/TokenFlowAnalysis.ts` for tracing token movements across accounts
  - Implement `lib/ai/agentic/templates/predefined/CrossProtocolAnalysis.ts` for multi-protocol DeFi activity investigation
  - Add `lib/ai/agentic/workflows/WorkflowEngine.ts` with state machine pattern for complex multi-step investigations
  - Create template validation logic with parameter type checking and dependency resolution
  - Implement template versioning system with backward compatibility and migration support
  - Write integration tests in `__tests__/agentic/templates/WorkflowExecution.test.ts` with end-to-end template execution
  - Write performance tests in `__tests__/agentic/templates/TemplatePerformance.test.ts` for template execution speed benchmarks
  - _Requirements: 5.1, 5.2, 5.3, 5.4, 5.5_

- [ ] 18. Collaborative Investigation Features
  - Create `lib/ai/agentic/collaboration/InvestigationSharing.ts` with secure sharing links and access control
  - Implement `lib/ai/agentic/collaboration/SessionReplay.ts` with step-by-step investigation replay functionality
  - Add `lib/ai/agentic/collaboration/CommunityTemplates.ts` with template rating, review, and contribution system
  - Create `lib/ai/agentic/collaboration/ExpertValidation.ts` with expert review workflow and validation badges
  - Implement `lib/ai/agentic/collaboration/InvestigationExporter.ts` with JSON, PDF, and CSV export formats
  - Add `lib/ai/agentic/collaboration/ImportValidator.ts` with investigation session import validation and sanitization
  - Create `lib/ai/agentic/collaboration/FeedbackSystem.ts` with investigation quality rating and improvement suggestions
  - Implement collaborative editing features with operational transformation for real-time template editing
  - Write integration tests in `__tests__/agentic/collaboration/SharingFlow.test.ts` for complete sharing and replay workflows
  - Write security tests in `__tests__/agentic/collaboration/SharingSecurityTest.ts` for access control and data privacy
  - _Requirements: 9.1, 9.2, 9.3, 9.4, 9.5_

- [ ] 19. Advanced Analytics and Insights Generation
  - Create `lib/ai/agentic/insights/InsightGenerator.ts` with machine learning algorithms for pattern recognition and insight extraction
  - Implement `lib/ai/agentic/insights/RecommendationEngine.ts` with collaborative filtering and content-based recommendations
  - Add `lib/ai/agentic/insights/TrendAnalyzer.ts` with time-series analysis and trend detection using statistical methods
  - Create `lib/ai/agentic/insights/ReportGenerator.ts` with automated report creation using templates and data visualization
  - Implement `lib/ai/agentic/insights/AnomalyScorer.ts` with ensemble methods for anomaly scoring and ranking
  - Add `lib/ai/agentic/insights/PatternMatcher.ts` with regex and fuzzy matching for known suspicious patterns
  - Create `lib/ai/agentic/insights/ContextualInsights.ts` for generating insights based on user context and investigation history
  - Implement natural language generation for insight explanations using template-based text generation
  - Write unit tests in `__tests__/agentic/insights/InsightGeneration.test.ts` with known patterns and expected insights
  - Write integration tests in `__tests__/agentic/insights/RecommendationAccuracy.test.ts` for recommendation quality validation
  - _Requirements: 4.8, 6.6, 6.7, 6.8_

- [ ] 20. System Integration and End-to-End Testing
  - Modify `components/ai/AIChatSidebar.tsx` to integrate agentic navigation triggers with natural language processing
  - Create `lib/ai/agentic/integration/ChatIntegration.ts` for seamless integration with existing AI chat system
  - Implement `lib/ai/agentic/integration/UserProfileConnector.ts` for connecting with user profile and history systems
  - Add `lib/ai/agentic/integration/QueryParser.ts` with NLP for detecting investigation requests in chat messages
  - Create `lib/ai/agentic/integration/ContextBridge.ts` for sharing context between chat and investigation systems
  - Implement `lib/ai/agentic/integration/NotificationBridge.ts` for unified notification system across AI features
  - Add investigation trigger buttons and UI elements to existing AI sidebar with seamless user experience
  - Create unified state management for AI chat and agentic navigation using Redux or Zustand
  - Write end-to-end tests in `__tests__/agentic/e2e/CompleteInvestigationFlow.test.ts` using Playwright for full user workflows
  - Write integration tests in `__tests__/agentic/integration/SystemIntegration.test.ts` for cross-system communication
  - _Requirements: 1.8, 7.6, 8.7, 8.8_

- [ ] 21. Performance Monitoring and Optimization
  - Create `lib/ai/agentic/monitoring/MetricsCollector.ts` with performance metrics collection using custom hooks and timers
  - Implement `lib/ai/agentic/monitoring/DashboardDataProvider.ts` for real-time monitoring dashboard data aggregation
  - Add `lib/ai/agentic/monitoring/PerformanceOptimizer.ts` with automatic optimization based on usage patterns and bottlenecks
  - Create `lib/ai/agentic/monitoring/QueueManager.ts` with priority-based investigation queue management and load balancing
  - Implement `lib/ai/agentic/monitoring/AlertSystem.ts` with threshold-based alerting for performance degradation
  - Add `lib/ai/agentic/monitoring/ResourceMonitor.ts` for tracking memory, CPU, and network usage during investigations
  - Create performance monitoring dashboard components with real-time charts and alerts
  - Implement automated performance regression detection with baseline comparison and alerting
  - Write performance tests in `__tests__/agentic/performance/LoadTesting.test.ts` with concurrent investigation scenarios
  - Write monitoring tests in `__tests__/agentic/monitoring/MetricsAccuracy.test.ts` for metrics collection validation
  - _Requirements: 10.6, 10.7, 10.8_

- [ ] 22. Documentation and Developer Tools
  - Create comprehensive API documentation in `docs/agentic-navigation-api.md` with OpenAPI specification and code examples
  - Implement `tools/agentic/TemplateBuilder.ts` as a CLI tool for creating and validating investigation templates
  - Add `tools/agentic/InvestigationDebugger.ts` with step-by-step debugging and state inspection capabilities
  - Create `docs/user-guides/investigation-tutorials.md` with step-by-step tutorials for common investigation scenarios
  - Implement `tools/agentic/PerformanceProfiler.ts` for profiling investigation performance and identifying bottlenecks
  - Add `docs/developer-guides/extending-agentic-navigation.md` with guides for adding new investigation capabilities
  - Create interactive documentation with Storybook for UI components and investigation workflows
  - Implement automated documentation generation from TypeScript interfaces and JSDoc comments
  - Write documentation tests in `__tests__/agentic/docs/DocumentationValidation.test.ts` for code example accuracy
  - Write developer tool tests in `__tests__/agentic/tools/DeveloperTools.test.ts` for CLI tool functionality
  - _Requirements: 5.6, 9.6, 9.7_

- [ ] 23. Final Integration and Production Readiness
  - Integrate all agentic navigation components into main application with proper dependency injection and service registration
  - Create `lib/ai/agentic/config/FeatureFlags.ts` with feature flag system for gradual rollout and A/B testing
  - Implement `lib/ai/agentic/deployment/ProductionMonitoring.ts` with comprehensive logging, metrics, and alerting
  - Add `lib/ai/agentic/deployment/BackupManager.ts` with automated backup and recovery procedures for investigation data
  - Create `lib/ai/agentic/deployment/HealthChecker.ts` with health checks for all agentic navigation services
  - Implement `lib/ai/agentic/deployment/GracefulShutdown.ts` with proper cleanup and state preservation during deployments
  - Add production configuration management with environment-specific settings and secrets management
  - Create deployment scripts and CI/CD pipeline integration for automated testing and deployment
  - Write final integration tests in `__tests__/agentic/production/ProductionReadiness.test.ts` for production environment validation
  - Write disaster recovery tests in `__tests__/agentic/production/DisasterRecovery.test.ts` for backup and recovery procedures
  - _Requirements: 1.7, 10.8, 11.6, 12.6, 12.7_
---

## File: ./.kiro/specs/anthropic-api-compatibility/design.md

# Anthropic API Proxy with SVMAI Billing Design

## Overview

The Anthropic API Proxy allows users to access Anthropic's Claude models using SVMAI tokens for payment. Users get Anthropic-compatible API keys and can use Claude CLI and other tools seamlessly, while OpenSVM forwards requests to Anthropic API and handles SVMAI billing through a simple database accounting system.

## Architecture

### System Components

```ascii
┌─────────────────────────────────────────────────────────────────────────────┐
│                    🔄 Anthropic API Proxy with SVMAI Billing                │
└─────────────────────────────────────────────────────────────────────────────┘
                                       │
                    ┌──────────────────┼──────────────────┐
                    │                  │                  │
         ┌──────────▼─────────┐ ┌──────▼──────┐ ┌────────▼────────┐
         │   API Key Manager  │ │ Proxy Gateway│ │ SVMAI Billing   │
         │                    │ │             │ │                 │
         │ • Key Generation   │ │ • Auth      │ │ • Balance Check │
         │ • Key Validation   │ │ • Forward   │ │ • Token Deduct  │
         │ • User Mapping     │ │ • Stream    │ │ • Usage Track   │
         │ • Key Storage      │ │ • Response  │ │ • Qdrant DB     │
         └────────────────────┘ └─────────────┘ └─────────────────┘
                    │                  │                  │
         ┌──────────▼─────────┐ ┌──────▼──────┐ ┌────────▼────────┐
         │ Anthropic Client   │ │ Deposit     │ │ Balance         │
         │                    │ │ Monitor     │ │ Database        │
         │ • Real API Calls   │ │             │ │                 │
         │ • Master Account   │ │ • Multisig  │ │ • User Records  │
         │ • Token Tracking   │ │ • On-chain  │ │ • Transactions  │
         │ • Error Handling   │ │ • Confirm   │ │ • Qdrant Store  │
         └────────────────────┘ └─────────────┘ └─────────────────┘
```

### Request Flow

```ascii
┌─────────────────────────────────────────────────────────────────────────────┐
│                           📊 Proxy Request Flow                             │
└─────────────────────────────────────────────────────────────────────────────┘

1. User Request (Claude CLI / SDK)
   │
   ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ POST https://opensvm.com/v1/messages                                        │
│ Authorization: Bearer sk-ant-api03-[user-key]                              │
│ Content-Type: application/json                                              │
│                                                                             │
│ {                                                                           │
│   "model": "claude-3-sonnet-20240229",                                     │
│   "max_tokens": 1024,                                                      │
│   "messages": [{"role": "user", "content": "Hello Claude"}]                │
│ }                                                                           │
└─────────────────────────────────────────────────────────────────────────────┘
   │
   ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ 🔐 Authentication & Balance Check                                           │
│                                                                             │
│ 1. Extract API key from Authorization header                               │
│ 2. Validate key format and lookup user in database                         │
│ 3. Check user's SVMAI balance in Qdrant                                    │
│ 4. Estimate request cost and verify sufficient balance                     │
│ 5. Reserve tokens for the request                                          │
└─────────────────────────────────────────────────────────────────────────────┘
   │
   ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ 🔄 Forward to Anthropic API                                                │
│                                                                             │
│ POST https://api.anthropic.com/v1/messages                                 │
│ Authorization: Bearer [OpenSVM-Master-Key]                                 │
│ Content-Type: application/json                                              │
│                                                                             │
│ [Same request body - forwarded exactly]                                    │
└─────────────────────────────────────────────────────────────────────────────┘
   │
   ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ 📤 Response & Billing                                                      │
│                                                                             │
│ 1. Receive response from Anthropic API                                     │
│ 2. Extract actual token usage from response                                │
│ 3. Calculate SVMAI cost and deduct from user balance                       │
│ 4. Log transaction in Qdrant                                               │
│ 5. Forward exact response back to user                                     │
└─────────────────────────────────────────────────────────────────────────────┘
```

## Core Components

### API Key Management System

```typescript
interface APIKeyManager {
  // Key generation and lifecycle
  generateKey: (userId: string, keyName: string, permissions: KeyPermissions) => Promise<APIKey>;
  validateKey: (keyString: string) => Promise<KeyValidation>;
  revokeKey: (keyId: string) => Promise<void>;
  listUserKeys: (userId: string) => Promise<APIKey[]>;
  
  // Key format and security
  formatKey: (keyData: KeyData) => string; // sk-ant-api03-[base64-encoded-data]
  hashKey: (keyString: string) => string;
  encryptKeyData: (data: KeyData) => string;
}

interface APIKey {
  id: string;
  userId: string;
  name: string;
  keyHash: string; // Never store the actual key
  permissions: KeyPermissions;
  rateLimit: RateLimit;
  createdAt: Date;
  lastUsedAt?: Date;
  expiresAt?: Date;
  isActive: boolean;
  usageStats: UsageStats;
}

interface KeyPermissions {
  maxTokensPerRequest: number;
  maxRequestsPerMinute: number;
  maxRequestsPerDay: number;
  allowedModels: string[];
  allowStreaming: boolean;
  allowToolUse: boolean;
  allowBlockchainEnhancement: boolean;
}

interface KeyValidation {
  isValid: boolean;
  keyId?: string;
  userId?: string;
  permissions?: KeyPermissions;
  remainingQuota?: QuotaInfo;
  error?: string;
}
```

### Anthropic API Adapter

```typescript
interface AnthropicAdapter {
  // Request/response transformation
  transformRequest: (anthropicRequest: AnthropicRequest) => Promise<InternalRequest>;
  transformResponse: (internalResponse: InternalResponse) => AnthropicResponse;
  
  // Streaming support
  createStreamingResponse: (internalStream: AsyncIterable<InternalChunk>) => AsyncIterable<AnthropicChunk>;
  
  // Error handling
  formatError: (error: InternalError) => AnthropicError;
  
  // Tool calling support
  transformToolCalls: (tools: AnthropicTool[]) => InternalTool[];
  formatToolResults: (results: InternalToolResult[]) => AnthropicToolResult[];
}

interface AnthropicRequest {
  model: string;
  max_tokens: number;
  messages: AnthropicMessage[];
  system?: string;
  temperature?: number;
  top_p?: number;
  top_k?: number;
  stop_sequences?: string[];
  stream?: boolean;
  tools?: AnthropicTool[];
}

interface AnthropicResponse {
  id: string;
  type: "message";
  role: "assistant";
  content: AnthropicContent[];
  model: string;
  stop_reason: "end_turn" | "max_tokens" | "stop_sequence" | "tool_use";
  stop_sequence?: string;
  usage: {
    input_tokens: number;
    output_tokens: number;
  };
}

interface AnthropicMessage {
  role: "user" | "assistant";
  content: string | AnthropicContent[];
}

interface AnthropicContent {
  type: "text" | "tool_use" | "tool_result";
  text?: string;
  id?: string;
  name?: string;
  input?: any;
  content?: any;
  is_error?: boolean;
}
```

### Usage Tracking and Analytics

```typescript
interface UsageTracker {
  // Request tracking
  trackRequest: (keyId: string, request: RequestMetrics) => Promise<void>;
  trackResponse: (keyId: string, response: ResponseMetrics) => Promise<void>;
  
  // Rate limiting
  checkRateLimit: (keyId: string) => Promise<RateLimitStatus>;
  incrementUsage: (keyId: string, tokens: number) => Promise<void>;
  
  // Analytics
  getUserUsage: (userId: string, timeRange: TimeRange) => Promise<UsageAnalytics>;
  getKeyUsage: (keyId: string, timeRange: TimeRange) => Promise<KeyUsageStats>;
  
  // SVMAI Token Deposit System
  initiateDeposit: (userId: string, amount: number) => Promise<DepositTransaction>;
  confirmDeposit: (transactionSignature: string) => Promise<DepositResult>;
  consumeSVMAITokens: (userId: string, amount: number, purpose: string) => Promise<ConsumptionResult>;
  getInternalBalance: (userId: string) => Promise<SVMAIBalance>;
  calculateSVMAICost: (inputTokens: number, outputTokens: number, model: string) => Promise<number>;
  generateSVMAIReport: (userId: string, period: BillingPeriod) => Promise<SVMAIUsageReport>;
}

interface RequestMetrics {
  timestamp: Date;
  endpoint: string;
  model: string;
  inputTokens: number;
  maxTokens: number;
  streaming: boolean;
  hasTools: boolean;
  blockchainEnhanced: boolean;
}

interface ResponseMetrics {
  timestamp: Date;
  outputTokens: number;
  responseTime: number;
  success: boolean;
  errorType?: string;
  cacheHit: boolean;
}

interface UsageAnalytics {
  totalRequests: number;
  totalTokens: number;
  averageResponseTime: number;
  errorRate: number;
  topModels: ModelUsage[];
  dailyUsage: DailyUsage[];
  costBreakdown: CostBreakdown;
}
```

### Blockchain Context Enhancement

```typescript
interface BlockchainContextEngine {
  // Context detection
  detectBlockchainContext: (messages: AnthropicMessage[]) => Promise<BlockchainContext>;
  extractEntities: (content: string) => Promise<BlockchainEntity[]>;
  
  // Data enrichment
  enrichWithSolanaData: (entities: BlockchainEntity[]) => Promise<EnrichedData>;
  addMarketContext: (tokens: string[]) => Promise<MarketData>;
  addDeFiContext: (protocols: string[]) => Promise<DeFiData>;
  
  // Response enhancement
  enhanceResponse: (response: string, context: BlockchainContext) => Promise<string>;
  addDataCitations: (response: string, sources: DataSource[]) => string;
}

interface BlockchainContext {
  hasBlockchainContent: boolean;
  entities: BlockchainEntity[];
  contextType: 'transaction' | 'account' | 'token' | 'defi' | 'general';
  confidence: number;
  suggestedEnhancements: Enhancement[];
}

interface BlockchainEntity {
  type: 'address' | 'transaction' | 'token' | 'program' | 'block';
  value: string;
  confidence: number;
  metadata?: any;
}

interface Enhancement {
  type: 'real_time_data' | 'historical_analysis' | 'market_context' | 'defi_analysis';
  description: string;
  dataRequired: string[];
  estimatedTokens: number;
}
```

## API Endpoints

### Core Anthropic-Compatible Endpoints

```typescript
// POST /v1/messages - Main chat completions endpoint
interface MessagesEndpoint {
  path: "/v1/messages";
  method: "POST";
  headers: {
    "Authorization": "Bearer sk-ant-api03-[key]";
    "Content-Type": "application/json";
    "anthropic-version": "2023-06-01";
  };
  body: AnthropicRequest;
  response: AnthropicResponse | StreamingResponse;
}

// GET /v1/models - List available models
interface ModelsEndpoint {
  path: "/v1/models";
  method: "GET";
  response: {
    data: Model[];
  };
}

interface Model {
  id: string;
  object: "model";
  created: number;
  owned_by: "anthropic";
  display_name: string;
  max_tokens: number;
}
```

### OpenSVM-Specific Management Endpoints

```typescript
// POST /api/anthropic-keys - Generate new API key
interface GenerateKeyEndpoint {
  path: "/api/anthropic-keys";
  method: "POST";
  body: {
    name: string;
    permissions?: Partial<KeyPermissions>;
    expiresIn?: number; // days
  };
  response: {
    key: string; // sk-ant-api03-[generated-key]
    keyId: string;
    name: string;
    permissions: KeyPermissions;
    createdAt: string;
  };
}

// GET /api/anthropic-keys - List user's API keys
interface ListKeysEndpoint {
  path: "/api/anthropic-keys";
  method: "GET";
  response: {
    keys: APIKeyInfo[];
    total: number;
  };
}

// DELETE /api/anthropic-keys/[keyId] - Revoke API key
interface RevokeKeyEndpoint {
  path: "/api/anthropic-keys/[keyId]";
  method: "DELETE";
  response: {
    success: boolean;
    message: string;
  };
}

// GET /api/anthropic-keys/[keyId]/usage - Get usage statistics
interface KeyUsageEndpoint {
  path: "/api/anthropic-keys/[keyId]/usage";
  method: "GET";
  query: {
    period?: "day" | "week" | "month";
    start?: string;
    end?: string;
  };
  response: {
    usage: KeyUsageStats;
    billing: BillingData;
    charts: ChartData[];
  };
}
```

## User Interface Components

### API Key Management Dashboard

```ascii
┌─────────────────────────────────────────────────────────────────────────────┐
│ ╔═══════════════════════════════════════════════════════════════════════════╗ │
│ ║                    🔑 Anthropic API Keys Management                       ║ │
│ ╚═══════════════════════════════════════════════════════════════════════════╝ │
├─────────────────────────────────────────────────────────────────────────────┤
│ ┌─ Create New API Key ────────────────────────────────────────────────────┐ │
│ │                                                                         │ │
│ │ Key Name: [My App Integration          ] 📝                             │ │
│ │                                                                         │ │
│ │ Permissions:                                                            │ │
│ │ ☑ Chat Completions    ☑ Streaming      ☑ Tool Use                     │ │
│ │ ☑ Blockchain Enhancement               ☐ Admin Functions               │ │
│ │                                                                         │ │
│ │ Rate Limits:                                                            │ │
│ │ • Max Tokens/Request: [4096    ▼] • Requests/Minute: [60    ▼]        │ │
│ │ • Requests/Day: [10000  ▼]           • Models: [All Models ▼]         │ │
│ │                                                                         │ │
│ │ Expiration: [Never ▼] (30 days, 90 days, 1 year, Never)               │ │
│ │                                                                         │ │
│ │ [🔑 Generate API Key]                                                   │ │
│ └─────────────────────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────────────────────┤
│ ┌─ Your API Keys ─────────────────────────────────────────────────────────┐ │
│ │                                                                         │ │
│ │ ┌─ My App Integration ──────────────────────────────────────────────────┐ │ │
│ │ │ 🔑 sk-ant-api03-••••••••••••••••••••••••••••••••••••••••••••••••••••│ │ │
│ │ │ Created: 2024-01-15  │  Last Used: 2 hours ago  │  Status: ✅ Active │ │ │
│ │ │                                                                     │ │ │
│ │ │ Usage This Month: 45,230 tokens │ Requests: 1,247 │ Cost: 127 SVMAI│ │ │
│ │ │ Rate Limit: 60/min │ Daily: 8,432/10,000 │ Models: All            │ │ │
│ │ │                                                                     │ │ │
│ │ │ [📊 View Usage] [⚙️ Edit] [🗑️ Revoke] [📋 Copy Key]                │ │ │
│ │ └─────────────────────────────────────────────────────────────────────┘ │ │
│ │                                                                         │ │
│ │ ┌─ Development Testing ─────────────────────────────────────────────────┐ │ │
│ │ │ 🔑 sk-ant-api03-••••••••••••••••••••••••••••••••••••••••••••••••••••│ │ │
│ │ │ Created: 2024-01-10  │  Last Used: 5 days ago   │  Status: ✅ Active │ │ │
│ │ │                                                                     │ │ │
│ │ │ Usage This Month: 2,150 tokens │ Requests: 89 │ Cost: $0.58        │ │ │
│ │ │ Rate Limit: 30/min │ Daily: 12/5,000 │ Models: Claude-3-Haiku     │ │ │
│ │ │                                                                     │ │ │
│ │ │ [📊 View Usage] [⚙️ Edit] [🗑️ Revoke] [📋 Copy Key]                │ │ │
│ │ └─────────────────────────────────────────────────────────────────────┘ │ │
│ │                                                                         │ │
│ │ Total Keys: 2/10 │ Monthly Usage: 47,380 tokens │ Total Cost: $13.03  │ │
│ └─────────────────────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────────────────────┤
│ ┌─ Integration Guide ─────────────────────────────────────────────────────┐ │
│ │ 🔧 Quick Start with Popular SDKs:                                      │ │
│ │                                                                         │ │
│ │ Python (anthropic):                                                     │ │
│ │ ```python                                                               │ │
│ │ import anthropic                                                        │ │
│ │ client = anthropic.Anthropic(                                           │ │
│ │     api_key="sk-ant-api03-your-key-here",                              │ │
│ │     base_url="https://opensvm.com/v1"  # OpenSVM endpoint              │ │
│ │ )                                                                       │ │
│ │ ```                                                                     │ │
│ │                                                                         │ │
│ │ JavaScript (@anthropic-ai/sdk):                                         │ │
│ │ ```javascript                                                           │ │
│ │ import Anthropic from '@anthropic-ai/sdk';                              │ │
│ │ const anthropic = new Anthropic({                                       │ │
│ │   apiKey: 'sk-ant-api03-your-key-here',                                │ │
│ │   baseURL: 'https://opensvm.com/v1'                                     │ │
│ │ });                                                                     │ │
│ │ ```                                                                     │ │
│ │                                                                         │ │
│ │ [📖 View Full Documentation] [🧪 Test API] [💬 Get Support]            │ │
│ └─────────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Usage Analytics Dashboard

```ascii
┌─────────────────────────────────────────────────────────────────────────────┐
│ ╔═══════════════════════════════════════════════════════════════════════════╗ │
│ ║                    📊 API Usage Analytics - My App Integration            ║ │
│ ╚═══════════════════════════════════════════════════════════════════════════╝ │
├─────────────────────────────────────────────────────────────────────────────┤
│ ┌─ Usage Overview ────────────────────────────────────────────────────────┐ │
│ │ Time Period: [Last 30 Days ▼]                                          │ │
│ │                                                                         │ │
│ │ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐         │ │
│ │ │   Requests  │ │   Tokens    │ │ Avg Response│ │    Cost     │         │ │
│ │ │    1,247    │ │   45,230    │ │   1.2s      │ │   $12.45    │         │ │
│ │ │   +15.3%    │ │   +22.1%    │ │   -0.1s     │ │   +18.7%    │         │ │
│ │ └─────────────┘ └─────────────┘ └─────────────┘ └─────────────┘         │ │
│ └─────────────────────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────────────────────┤
│ ┌─ Usage Trends ──────────────────────────────────────────────────────────┐ │
│ │                                                                         │ │
│ │     📈 Daily Requests                    📊 Token Usage                 │ │
│ │     100 ┤                                4000 ┤                        │ │
│ │      80 ┤     ●                          3200 ┤   ●                     │ │
│ │      60 ┤   ●   ●                        2400 ┤ ●   ●                   │ │
│ │      40 ┤ ●       ●                      1600 ┤       ●                 │ │
│ │      20 ┤           ●                     800 ┤         ●               │ │
│ │       0 └─────────────────────────────────  0 └─────────────────────────│ │
│ │         1/1  1/8  1/15 1/22 1/29              1/1  1/8  1/15 1/22 1/29 │ │
│ └─────────────────────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────────────────────┤
│ ┌─ Model Usage Breakdown ─────────────────────────────────────────────────┐ │
│ │                                                                         │ │
│ │ Claude-3-Sonnet    ████████████████████████████████████████ 65% (812)   │ │
│ │ Claude-3-Haiku     ████████████████████ 25% (312)                      │ │
│ │ Claude-3-Opus      ████████ 10% (123)                                  │ │
│ │                                                                         │ │
│ │ 💡 Optimization Tip: Consider using Haiku for simple queries to reduce │ │
│ │    costs. Estimated savings: $3.20/month                               │ │
│ └─────────────────────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────────────────────┤
│ ┌─ Feature Usage ─────────────────────────────────────────────────────────┐ │
│ │                                                                         │ │
│ │ 🔄 Streaming Requests:     847 (68%)                                   │ │
│ │ 🛠️  Tool Use:               234 (19%)                                   │ │
│ │ ⛓️  Blockchain Enhanced:    456 (37%)                                   │ │
│ │ 📊 Average Tokens/Request:  36.3                                       │ │
│ │ ⚡ Cache Hit Rate:          23%                                         │ │
│ └─────────────────────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────────────────────┤
│ ┌─ Rate Limit Status ─────────────────────────────────────────────────────┐ │
│ │                                                                         │ │
│ │ Current Minute:  [████████████████████████████████████████] 45/60      │ │
│ │ Today:          [████████████████████████████████████████] 8,432/10,000│ │
│ │ This Month:     [████████████████████████████████████████] 45,230/100K │ │
│ │                                                                         │ │
│ │ ✅ All limits healthy. Next reset: 47 seconds                          │ │
│ └─────────────────────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────────────────────┤
│ ┌─ Recent Requests ───────────────────────────────────────────────────────┐ │
│ │                                                                         │ │
│ │ 🕐 2 min ago │ POST /v1/messages │ claude-3-sonnet │ 234 tokens │ ✅    │ │
│ │ 🕐 5 min ago │ POST /v1/messages │ claude-3-haiku  │ 89 tokens  │ ✅    │ │
│ │ 🕐 8 min ago │ POST /v1/messages │ claude-3-sonnet │ 456 tokens │ ✅    │ │
│ │ 🕐 12 min ago│ POST /v1/messages │ claude-3-sonnet │ 123 tokens │ ❌ 429│ │
│ │                                                                         │ │
│ │ [📋 Export Usage Data] [📧 Setup Alerts] [📈 Detailed Analytics]       │ │
│ └─────────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────┘
```

## Security Implementation

### API Key Security

```typescript
interface APIKeySecurity {
  // Key generation
  generateSecureKey: () => Promise<{
    keyString: string; // sk-ant-api03-[base64-encoded-data]
    keyHash: string;   // For storage
    keyId: string;     // Internal identifier
  }>;
  
  // Key validation
  validateKeyFormat: (key: string) => boolean;
  validateKeySignature: (key: string) => boolean;
  
  // Storage security
  hashKeyForStorage: (key: string) => string;
  encryptSensitiveData: (data: any) => string;
  
  // Access control
  checkPermissions: (keyId: string, action: string) => Promise<boolean>;
  auditKeyUsage: (keyId: string, action: string, metadata: any) => Promise<void>;
}

// Key format: sk-ant-api03-[version][user-id][random-data][checksum]
const KEY_FORMAT = /^sk-ant-api03-[A-Za-z0-9+/]{64}$/;

interface KeyComponents {
  version: string;     // 2 bytes
  userId: string;      // 16 bytes (UUID)
  randomData: string;  // 32 bytes
  checksum: string;    // 4 bytes (CRC32)
}
```

### Rate Limiting Implementation

```typescript
interface RateLimiter {
  // Sliding window rate limiting
  checkLimit: (keyId: string, window: TimeWindow) => Promise<RateLimitResult>;
  incrementUsage: (keyId: string, tokens: number) => Promise<void>;
  
  // Dynamic rate limiting
  adjustLimitsBasedOnLoad: (systemLoad: number) => Promise<void>;
  
  // Quota management
  checkQuota: (keyId: string, period: QuotaPeriod) => Promise<QuotaStatus>;
  resetQuota: (keyId: string, period: QuotaPeriod) => Promise<void>;
}

interface RateLimitResult {
  allowed: boolean;
  remaining: number;
  resetTime: Date;
  retryAfter?: number; // seconds
}

interface QuotaStatus {
  used: number;
  limit: number;
  remaining: number;
  resetDate: Date;
  percentUsed: number;
}
```

## Integration Examples

### Python SDK Integration

```python
import anthropic
import os

# Initialize client with OpenSVM endpoint
client = anthropic.Anthropic(
    api_key=os.environ.get("OPENSVM_API_KEY"),  # sk-ant-api03-...
    base_url="https://opensvm.com/v1"
)

# Standard Anthropic API call with blockchain enhancement
response = client.messages.create(
    model="claude-3-sonnet-20240229",
    max_tokens=1024,
    messages=[
        {
            "role": "user", 
            "content": "Analyze this Solana transaction: 5x7K8mNzE3QqJ9..."
        }
    ]
)

# Response includes OpenSVM's blockchain expertise
print(response.content[0].text)
# "This Solana transaction represents a token swap on Raydium DEX..."
```

### JavaScript SDK Integration

```javascript
import Anthropic from '@anthropic-ai/sdk';

const anthropic = new Anthropic({
  apiKey: process.env.OPENSVM_API_KEY, // sk-ant-api03-...
  baseURL: 'https://opensvm.com/v1'
});

// Streaming request with blockchain context
const stream = await anthropic.messages.create({
  model: 'claude-3-sonnet-20240229',
  max_tokens: 1024,
  stream: true,
  messages: [
    {
      role: 'user',
      content: 'What are the risks of this DeFi protocol: Raydium?'
    }
  ]
});

for await (const chunk of stream) {
  if (chunk.type === 'content_block_delta') {
    process.stdout.write(chunk.delta.text);
  }
}
```

### cURL Example

```bash
curl -X POST https://opensvm.com/v1/messages \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer sk-ant-api03-your-key-here" \
  -H "anthropic-version: 2023-06-01" \
  -d '{
    "model": "claude-3-sonnet-20240229",
    "max_tokens": 1024,
    "messages": [
      {
        "role": "user",
        "content": "Explain how Solana consensus works"
      }
    ]
  }'
```

## Performance and Scalability

### Caching Strategy

```typescript
interface CacheManager {
  // Response caching
  cacheResponse: (requestHash: string, response: any, ttl: number) => Promise<void>;
  getCachedResponse: (requestHash: string) => Promise<any | null>;
  
  // Key validation caching
  cacheKeyValidation: (keyHash: string, validation: KeyValidation) => Promise<void>;
  getCachedValidation: (keyHash: string) => Promise<KeyValidation | null>;
  
  // Rate limit caching
  cacheRateLimit: (keyId: string, limits: RateLimitData) => Promise<void>;
  getRateLimitData: (keyId: string) => Promise<RateLimitData | null>;
}

// Cache TTL configuration
const CACHE_TTL = {
  keyValidation: 300,    // 5 minutes
  rateLimit: 60,         // 1 minute
  response: 3600,        // 1 hour (for cacheable responses)
  blockchainData: 30,    // 30 seconds (real-time data)
};
```

### Load Balancing and Scaling

```typescript
interface LoadBalancer {
  // Request distribution
  routeRequest: (request: APIRequest) => Promise<ServiceEndpoint>;
  
  // Health monitoring
  checkServiceHealth: (endpoint: ServiceEndpoint) => Promise<HealthStatus>;
  
  // Auto-scaling
  scaleServices: (metrics: SystemMetrics) => Promise<ScalingAction>;
}

interface ServiceEndpoint {
  id: string;
  url: string;
  region: string;
  capacity: number;
  currentLoad: number;
  healthStatus: 'healthy' | 'degraded' | 'unhealthy';
}
```

This design provides a comprehensive foundation for implementing an Anthropic API-compatible system that seamlessly integrates with existing SDKs while providing OpenSVM's enhanced blockchain capabilities.
---

## File: ./.kiro/specs/anthropic-api-compatibility/requirements.md

# Anthropic API Proxy with SVMAI Billing Requirements

## Introduction

This feature creates a proxy service that forwards user requests to Anthropic's API while allowing users to pay with SVMAI tokens. Users get Anthropic-compatible API keys and can use Claude CLI and other tools seamlessly, while OpenSVM handles the billing conversion (SVMAI → USD) and API forwarding.

## Requirements

### Requirement 1: API Key Generation and Management

**User Story:** As a developer, I want to generate API keys that work with Claude CLI and Anthropic SDKs, so that I can use Anthropic's models while paying with SVMAI tokens.

#### Acceptance Criteria

1. WHEN a user requests API key generation THEN the system SHALL create a key with Anthropic-compatible format (sk-ant-api03-...)
2. WHEN a user generates an API key THEN the system SHALL store the key securely and link it to their SVMAI balance
3. WHEN a user views their API keys THEN the system SHALL display key name, creation date, usage stats, and remaining SVMAI balance
4. WHEN a user deletes an API key THEN the system SHALL immediately revoke access and stop forwarding requests
5. WHEN API key is used THEN the system SHALL validate key existence and user's SVMAI balance before forwarding

### Requirement 2: Anthropic API Proxy Service

**User Story:** As a developer, I want my requests forwarded to real Anthropic API, so that I get authentic Claude responses while paying with SVMAI tokens.

#### Acceptance Criteria

1. WHEN a request is made to `/v1/messages` with valid API key THEN the system SHALL forward the request to Anthropic API using OpenSVM's master account
2. WHEN Anthropic returns a response THEN the system SHALL forward the exact response back to the user maintaining full compatibility
3. WHEN streaming is requested THEN the system SHALL proxy the stream in real-time maintaining Anthropic's SSE format
4. WHEN Anthropic returns errors THEN the system SHALL forward the exact error responses to maintain SDK compatibility
5. WHEN requests are forwarded THEN the system SHALL track token usage from Anthropic's response for billing

### Requirement 3: SVMAI Token Deposit and Database Balance Tracking

**User Story:** As a user, I want to deposit SVMAI tokens to OpenSVM's multisig address and have my balance tracked in the database, so that I can pay for Anthropic API access with a simple accounting system.

#### Acceptance Criteria

1. WHEN users want API access THEN the system SHALL provide deposit interface to transfer SVMAI tokens to OpenSVM's multisig address
2. WHEN API requests are forwarded THEN the system SHALL deduct SVMAI tokens from user's database balance record based on Anthropic's token usage
3. WHEN user has insufficient database balance THEN the system SHALL return HTTP 402 Payment Required before forwarding to Anthropic
4. WHEN SVMAI deposits are confirmed on-chain THEN the system SHALL update user's balance record in Qdrant database
5. WHEN users check balance THEN the system SHALL show current database balance and usage costs (no withdrawal option - deposits are permanent)

### Requirement 4: Usage Tracking and Cost Calculation

**User Story:** As a user, I want to see my API usage and SVMAI costs, so that I can monitor consumption and manage my token balance.

#### Acceptance Criteria

1. WHEN API requests are forwarded THEN the system SHALL track input/output tokens from Anthropic's response and calculate SVMAI costs
2. WHEN users view dashboard THEN the system SHALL display usage statistics, SVMAI costs, and remaining balance
3. WHEN token usage occurs THEN the system SHALL deduct SVMAI tokens in real-time and update balance immediately
4. WHEN costs are calculated THEN the system SHALL use transparent SVMAI pricing (e.g., 100 SVMAI = 1000 Anthropic tokens)
5. WHEN balance is low THEN the system SHALL show warnings and deposit prompts to prevent service interruption
---

## File: ./.kiro/specs/anthropic-api-compatibility/tasks.md

# Anthropic API Proxy with SVMAI Billing Implementation Tasks

## Implementation Plan

Convert the Anthropic API Proxy design into a series of prompts for a code-generation LLM that will implement each step in a test-driven manner. Focus on the core proxy functionality: API key generation, request forwarding to Anthropic API, SVMAI token billing, and basic usage tracking.

- [x] 1. Core API Key Management
  - Create `lib/anthropic-proxy/types/ProxyTypes.ts` with core interfaces (APIKey, UserBalance, ProxyRequest, ProxyResponse)
  - Create `lib/anthropic-proxy/types/AnthropicTypes.ts` with Anthropic API request/response interfaces matching official specification
  - Implement `lib/anthropic-proxy/core/APIKeyManager.ts` with key generation in Anthropic format (sk-ant-api03-[data])
  - Create `lib/anthropic-proxy/storage/KeyStorage.ts` with Qdrant database integration for API key storage
  - Add `lib/anthropic-proxy/utils/KeyGenerator.ts` with secure random key generation and validation
  - Write unit tests in `__tests__/anthropic-proxy/core/APIKeyManager.test.ts` with key generation scenarios
  - _Requirements: 1.1, 1.2, 1.3, 1.4, 1.5_

- [x] 2. SVMAI Balance Management with Qdrant
  - Create `lib/anthropic-proxy/billing/SVMAIBalanceManager.ts` with Qdrant database balance tracking
  - Implement `lib/anthropic-proxy/billing/DepositMonitor.ts` with Solana transaction monitoring for multisig deposits
  - Add `lib/anthropic-proxy/billing/TokenConsumption.ts` with per-request SVMAI deduction logic
  - Create `lib/anthropic-proxy/storage/BalanceStorage.ts` with Qdrant operations for user balances
  - Implement `lib/anthropic-proxy/utils/PricingCalculator.ts` with simple SVMAI-to-token conversion rates
  - Write unit tests in `__tests__/anthropic-proxy/billing/SVMAIBalanceManager.test.ts` with balance scenarios
  - _Requirements: 3.1, 3.2, 3.3, 3.4, 3.5_

- [x] 3. Anthropic API Proxy Core
  - Create `lib/anthropic-proxy/core/AnthropicClient.ts` with HTTP client for forwarding requests to Anthropic API
  - Implement `lib/anthropic-proxy/core/RequestForwarder.ts` with request/response proxying logic
  - Add `lib/anthropic-proxy/core/StreamingProxy.ts` with server-sent events streaming support
  - Create `lib/anthropic-proxy/auth/ProxyAuth.ts` with API key validation and user lookup
  - Implement `lib/anthropic-proxy/middleware/BalanceCheck.ts` with pre-request balance validation
  - Write integration tests in `__tests__/anthropic-proxy/core/AnthropicClient.test.ts` with API forwarding scenarios
  - _Requirements: 2.1, 2.2, 2.3, 2.4, 2.5_

- [x] 4. Usage Tracking and Billing
  - Create `lib/anthropic-proxy/tracking/UsageTracker.ts` with token usage extraction from Anthropic responses
  - Implement `lib/anthropic-proxy/billing/BillingProcessor.ts` with post-request SVMAI deduction
  - Add `lib/anthropic-proxy/storage/UsageStorage.ts` with Qdrant integration for usage logs
  - Create `lib/anthropic-proxy/reporting/UsageReporter.ts` with basic usage statistics
  - Write unit tests in `__tests__/anthropic-proxy/tracking/UsageTracker.test.ts` with billing scenarios
  - _Requirements: 4.1, 4.2, 4.3, 4.4, 4.5_

- [x] 5. API Endpoints Implementation
  - Create `app/api/v1/messages/route.ts` with main proxy endpoint that forwards to Anthropic API (exact same route as api.anthropic.com/v1/messages)
  - Implement `app/api/v1/models/route.ts` with available models endpoint (exact same route as api.anthropic.com/v1/models)
  - Research and implement any other Anthropic API routes needed for full SDK compatibility (e.g., /v1/complete if it exists)
  - Add `app/api/opensvm/anthropic-keys/route.ts` with API key CRUD operations (OpenSVM-specific management routes)
  - Create `app/api/opensvm/balance/route.ts` with SVMAI balance checking endpoint
  - Implement `app/api/opensvm/deposit/route.ts` with deposit initiation and monitoring
  - Add `app/api/opensvm/usage/route.ts` with usage statistics endpoint
  - Write API tests in `__tests__/anthropic-proxy/api/ProxyEndpoints.test.ts` with full request/response validation
  - _Requirements: 2.1, 2.2, 3.4, 4.3_

- [x] 6. User Interface Components
  - Create `components/anthropic-proxy/APIKeyManager.tsx` with key creation and management interface
  - Implement `components/anthropic-proxy/SVMAIDepositModal.tsx` with deposit interface showing multisig address
  - Add `components/anthropic-proxy/BalanceDisplay.tsx` with current SVMAI balance and usage stats
  - Create `components/anthropic-proxy/UsageDashboard.tsx` with simple usage charts and statistics
  - Implement `components/anthropic-proxy/IntegrationGuide.tsx` with Claude CLI setup instructions
  - Write component tests in `__tests__/components/anthropic-proxy/APIKeyManager.test.tsx`
  - _Requirements: 1.3, 3.5, 4.4_

- [x] 7. Solana Integration for Deposits
  - Create `lib/anthropic-proxy/solana/DepositMonitor.ts` with on-chain transaction monitoring
  - Implement `lib/anthropic-proxy/solana/MultisigManager.ts` with multisig address management
  - Add `lib/anthropic-proxy/solana/TransactionProcessor.ts` with deposit confirmation logic
  - Create `lib/anthropic-proxy/utils/SolanaUtils.ts` with address validation and transaction parsing
  - Write integration tests in `__tests__/anthropic-proxy/solana/DepositFlow.test.ts`
  - _Requirements: 3.1, 3.4_

- [x] 8. Error Handling and Monitoring
  - Create `lib/anthropic-proxy/errors/ProxyErrorHandler.ts` with Anthropic-compatible error forwarding
  - Implement `lib/anthropic-proxy/monitoring/ProxyMonitor.ts` with basic request/response logging
  - Add `lib/anthropic-proxy/utils/ErrorFormatter.ts` with proper error response formatting
  - Write error handling tests in `__tests__/anthropic-proxy/errors/ErrorHandling.test.ts`
  - _Requirements: 2.4, 4.2_


- [x] 9. Production Deployment and Integration
  - Integrate proxy components into main OpenSVM application
  - Create environment configuration for OpenRouter API keys and multisig addresses
  - Add rate limiting and basic security measures
  - Write end-to-end tests in `__tests__/anthropic-proxy/e2e/FullProxyFlow.test.ts`
  - _Requirements: 1.5, 2.5, 3.5, 4.5_
---

## File: ./.kiro/specs/block-explorer-enhancements/design.md

# Block Explorer Enhancements Design

## Overview

The Block Explorer Enhancements design provides a comprehensive solution for exploring Solana blocks with advanced analytics, social features, and performance optimization. The system builds upon the existing block explorer implementation (BlockDetails, BlockExploreTable, TransactionsInBlock components and /api/block, /api/blocks endpoints) and extends it with three main routes (`/block/[slot]`, `/blocks`, and `/block/[slot]/opengraph-image`) plus extensive functionality for block analysis, program statistics, account activity tracking, and user engagement features.

## Architecture

### High-Level Architecture

```mermaid
graph TB
    subgraph "Client Layer"
        A[Block Detail Page] --> B[Block List Page]
        A --> C[OpenGraph Generator]
        B --> A
    end
    
    subgraph "API Layer"
        D[Block API] --> E[Analytics Engine]
        D --> F[Cache Layer]
        E --> G[Program Analyzer]
        E --> H[Account Analyzer]
        E --> I[Transfer Analyzer]
    end
    
    subgraph "Data Layer"
        J[Solana RPC] --> K[Block Data Store]
        L[Visit Analytics DB] --> M[User Preferences DB]
        N[Bookmark System] --> O[Alert System]
    end
    
    A --> D
    B --> D
    C --> D
    D --> J
    E --> L
    F --> K
```

### Component Architecture

The block explorer follows a modular component architecture with clear separation of concerns:

- **Presentation Layer**: React components for UI rendering
- **Business Logic Layer**: Custom hooks and services for data processing
- **Data Access Layer**: API clients and caching mechanisms
- **Analytics Layer**: Specialized analyzers for programs, accounts, and transfers

## Components and Interfaces

### Core Components

#### BlockDetailsPage Component
```typescript
interface BlockDetailsPageProps {
  slot: number;
  initialData?: BlockData;
}

interface BlockData {
  slot: number;
  blockhash: string;
  parentSlot: number;
  blockTime: number | null;
  blockHeight: number;
  transactions: Transaction[];
  rewards: Reward[];
  validator: ValidatorInfo;
  metrics: BlockMetrics;
  programStats: ProgramStats[];
  accountActivity: AccountActivity;
  transfers: SimpleTransfer[];
  visitStats: VisitStatistics;
}
```

#### BlockListPage Component
```typescript
interface BlockListPageProps {
  initialBlocks?: BlockListItem[];
  filters?: BlockFilters;
}

interface BlockListItem {
  slot: number;
  blockhash: string;
  blockTime: number;
  transactionCount: number;
  validator: string;
  fees: number;
  status: 'confirmed' | 'finalized';
  programActivity: ProgramSummary[];
  topAccounts: AccountSummary[];
}
```

### Analytics Components

#### ProgramStatsDisplay Component
```typescript
interface ProgramStatsDisplayProps {
  programStats: ProgramStats[];
  onProgramClick: (programId: string) => void;
}

interface ProgramStats {
  programId: string;
  programName?: string;
  transactionCount: number;
  solVolume: number;
  splTokenVolumes: TokenVolume[];
  computeUnitsUsed: number;
  successRate: number;
}

interface TokenVolume {
  mint: string;
  symbol: string;
  amount: number;
  usdValue?: number;
}
```

#### AccountActivityDisplay Component
```typescript
interface AccountActivityDisplayProps {
  topAccountsByVolume: AccountActivity[];
  topAccountsByPnL: AccountActivity[];
  onAccountClick: (address: string) => void;
}

interface AccountActivity {
  address: string;
  rank: number;
  volume: number;
  pnl?: number;
  transactionCount: number;
  tokens: TokenActivity[];
}

interface TokenActivity {
  mint: string;
  symbol: string;
  netChange: number;
  usdValue?: number;
}
```

#### TransferAnalysisDisplay Component
```typescript
interface TransferAnalysisDisplayProps {
  transfers: SimpleTransfer[];
  onAddressClick: (address: string) => void;
}

interface SimpleTransfer {
  rank: number;
  fromAddress: string;
  toAddress: string;
  tokenMint: string;
  tokenSymbol: string;
  amount: number;
  usdValue?: number;
  signature: string;
}
```

### Social and Analytics Components

#### VisitStatistics Component
```typescript
interface VisitStatisticsProps {
  blockSlot: number;
  visitCount: number;
  onExpand: () => void;
  expanded: boolean;
}

interface VisitHistory {
  walletAddress: string;
  visitTime: number;
  sessionDuration?: number;
  referrer?: string;
}
```

#### BlockComparison Component
```typescript
interface BlockComparisonProps {
  primaryBlock: BlockData;
  comparisonBlocks: BlockData[];
  onAddComparison: () => void;
  onRemoveComparison: (slot: number) => void;
}

interface ComparisonMetrics {
  metric: string;
  primaryValue: number;
  comparisonValues: number[];
  trend: 'higher' | 'lower' | 'similar';
}
```

#### BookmarkManager Component
```typescript
interface BookmarkManagerProps {
  blockSlot: number;
  isBookmarked: boolean;
  onToggleBookmark: () => void;
  onAddNote: (note: string) => void;
  onAddTags: (tags: string[]) => void;
}

interface Bookmark {
  blockSlot: number;
  note?: string;
  tags: string[];
  createdAt: number;
  updatedAt: number;
}
```

## Data Models

### Block Data Model
```typescript
interface BlockMetrics {
  transactionCount: number;
  successfulTransactions: number;
  failedTransactions: number;
  totalFees: number;
  computeUnitsConsumed: number;
  averageTransactionSize: number;
  blockProcessingTime: number;
  networkEfficiency: number;
}

interface ValidatorInfo {
  address: string;
  name?: string;
  commission: number;
  activatedStake: number;
  performance: ValidatorPerformance;
}

interface ValidatorPerformance {
  uptime: number;
  skipRate: number;
  averageBlockTime: number;
  rank: number;
}
```

### Analytics Data Models
```typescript
interface ProgramAnalytics {
  programId: string;
  metadata: ProgramMetadata;
  blockActivity: ProgramBlockActivity;
  historicalTrends: ProgramTrend[];
}

interface ProgramBlockActivity {
  transactionCount: number;
  uniqueUsers: number;
  solVolume: number;
  splTokenVolumes: Map<string, number>;
  computeUnitsConsumed: number;
  averageComputePerTx: number;
  successRate: number;
}

interface AccountAnalytics {
  address: string;
  blockActivity: AccountBlockActivity;
  riskScore: number;
  labels: string[];
}

interface AccountBlockActivity {
  transactionCount: number;
  totalVolume: number;
  pnl: number;
  tokenActivities: TokenActivity[];
  programInteractions: string[];
}
```

### Visit Analytics Data Model
```typescript
interface VisitAnalytics {
  blockSlot: number;
  totalVisits: number;
  uniqueVisitors: number;
  visitHistory: VisitRecord[];
  geographicDistribution: GeographicData[];
  referrerSources: ReferrerData[];
}

interface VisitRecord {
  id: string;
  walletAddress?: string;
  ipHash: string;
  visitTime: number;
  sessionDuration: number;
  userAgent: string;
  referrer?: string;
  actions: UserAction[];
}

interface UserAction {
  type: 'view' | 'click' | 'share' | 'bookmark';
  target: string;
  timestamp: number;
}
```

## Error Handling

### Error Types and Handling Strategy

```typescript
enum BlockExplorerErrorType {
  INVALID_SLOT = 'INVALID_SLOT',
  BLOCK_NOT_FOUND = 'BLOCK_NOT_FOUND',
  NETWORK_ERROR = 'NETWORK_ERROR',
  ANALYTICS_ERROR = 'ANALYTICS_ERROR',
  CACHE_ERROR = 'CACHE_ERROR',
  RATE_LIMIT_ERROR = 'RATE_LIMIT_ERROR'
}

interface BlockExplorerError {
  type: BlockExplorerErrorType;
  message: string;
  details?: any;
  retryable: boolean;
  retryAfter?: number;
}

class BlockErrorHandler {
  static handleSlotError(slot: string): BlockExplorerError {
    if (!this.isValidSlot(slot)) {
      return {
        type: BlockExplorerErrorType.INVALID_SLOT,
        message: `Invalid slot number: ${slot}`,
        retryable: false
      };
    }
    // Additional error handling logic
  }

  static handleNetworkError(error: any): BlockExplorerError {
    return {
      type: BlockExplorerErrorType.NETWORK_ERROR,
      message: 'Failed to fetch block data',
      details: error,
      retryable: true,
      retryAfter: 5000
    };
  }
}
```

### Error Recovery Mechanisms

1. **Automatic Retry**: Network errors trigger automatic retry with exponential backoff
2. **Partial Data Display**: Show available data while indicating missing sections
3. **Fallback Data Sources**: Use cached data or alternative RPC endpoints
4. **User-Friendly Messages**: Convert technical errors to actionable user messages
5. **Error Reporting**: Log errors for monitoring and debugging

## Testing Strategy

### Unit Testing Approach

```typescript
// Example test structure for block analytics
describe('ProgramAnalyzer', () => {
  describe('analyzeBlockPrograms', () => {
    it('should calculate program volumes correctly', () => {
      const mockTransactions = createMockTransactions();
      const result = ProgramAnalyzer.analyzeBlockPrograms(mockTransactions);
      
      expect(result).toHaveLength(3);
      expect(result[0].solVolume).toBe(1500);
      expect(result[0].splTokenVolumes.get('USDC')).toBe(10000);
    });

    it('should handle empty transaction list', () => {
      const result = ProgramAnalyzer.analyzeBlockPrograms([]);
      expect(result).toEqual([]);
    });

    it('should sort programs by volume descending', () => {
      const mockTransactions = createMockTransactions();
      const result = ProgramAnalyzer.analyzeBlockPrograms(mockTransactions);
      
      expect(result[0].solVolume).toBeGreaterThan(result[1].solVolume);
    });
  });
});
```

### Integration Testing Strategy

1. **API Integration Tests**: Test block data fetching and processing
2. **Component Integration Tests**: Test component interactions and data flow
3. **Analytics Integration Tests**: Test program, account, and transfer analysis
4. **Cache Integration Tests**: Test caching behavior and invalidation
5. **Real-time Updates Tests**: Test WebSocket connections and live updates

### End-to-End Testing Scenarios

1. **Block Navigation Flow**: Navigate from block list to block details
2. **Analytics Interaction Flow**: Click through program stats to program pages
3. **Social Features Flow**: Bookmark blocks and view visit statistics
4. **Comparison Flow**: Compare multiple blocks side-by-side
5. **Mobile Experience Flow**: Test responsive design and touch interactions

## Performance Optimization

### Caching Strategy

```typescript
interface CacheConfig {
  blockData: {
    ttl: number; // Infinite for confirmed blocks
    strategy: 'immutable';
  };
  blockList: {
    ttl: 30000; // 30 seconds
    strategy: 'stale-while-revalidate';
  };
  analytics: {
    ttl: 300000; // 5 minutes
    strategy: 'background-refresh';
  };
  visitStats: {
    ttl: 60000; // 1 minute
    strategy: 'real-time-update';
  };
}

class BlockCacheManager {
  private cache = new Map<string, CacheEntry>();
  
  async getBlockData(slot: number): Promise<BlockData> {
    const cacheKey = `block:${slot}`;
    const cached = this.cache.get(cacheKey);
    
    if (cached && !this.isExpired(cached)) {
      return cached.data;
    }
    
    const data = await this.fetchBlockData(slot);
    this.cache.set(cacheKey, {
      data,
      timestamp: Date.now(),
      ttl: this.isConfirmedBlock(slot) ? Infinity : 300000
    });
    
    return data;
  }
}
```

### Data Processing Optimization

1. **Lazy Loading**: Load analytics data on-demand when tabs are accessed
2. **Virtual Scrolling**: Handle large transaction lists efficiently
3. **Memoization**: Cache expensive calculations like PnL computations
4. **Background Processing**: Process analytics in Web Workers
5. **Progressive Loading**: Show basic data first, then enhance with analytics

### Bundle Optimization

```typescript
// Code splitting for heavy analytics components
const ProgramStatsDisplay = lazy(() => import('./ProgramStatsDisplay'));
const AccountActivityDisplay = lazy(() => import('./AccountActivityDisplay'));
const BlockComparison = lazy(() => import('./BlockComparison'));

// Optimize chart libraries
const ChartComponent = lazy(() => 
  import('recharts').then(module => ({ default: module.LineChart }))
);
```

## Security Considerations

### Data Privacy and Protection

1. **Visit Analytics Privacy**: Hash IP addresses and provide opt-out mechanisms
2. **User Data Encryption**: Encrypt sensitive user preferences and bookmarks
3. **Rate Limiting**: Implement rate limits for analytics API endpoints
4. **Input Validation**: Validate all slot numbers and user inputs
5. **XSS Prevention**: Sanitize all user-generated content (notes, tags)

### API Security

```typescript
class BlockAPISecurityMiddleware {
  static validateSlotInput(slot: string): boolean {
    const slotNumber = parseInt(slot);
    return !isNaN(slotNumber) && slotNumber >= 0 && slotNumber <= MAX_SLOT;
  }

  static rateLimitCheck(userIP: string, endpoint: string): boolean {
    const key = `${userIP}:${endpoint}`;
    const requests = this.requestCounts.get(key) || 0;
    
    if (requests > RATE_LIMITS[endpoint]) {
      throw new RateLimitError(`Rate limit exceeded for ${endpoint}`);
    }
    
    this.requestCounts.set(key, requests + 1);
    return true;
  }
}
```

## Accessibility and Mobile Design

### Accessibility Implementation

1. **Semantic HTML**: Use proper heading hierarchy and ARIA labels
2. **Keyboard Navigation**: Full keyboard accessibility for all features
3. **Screen Reader Support**: Descriptive labels for complex data visualizations
4. **High Contrast Mode**: Support for high contrast themes
5. **Focus Management**: Proper focus handling in modals and dynamic content

### Mobile-First Design

```typescript
// Responsive breakpoints
const breakpoints = {
  mobile: '320px',
  tablet: '768px',
  desktop: '1024px',
  wide: '1440px'
};

// Mobile-optimized components
const MobileBlockDetails = {
  layout: 'stacked',
  navigation: 'swipe-enabled',
  analytics: 'collapsible-sections',
  charts: 'touch-optimized'
};
```

## Real-time Features

### WebSocket Integration

```typescript
class BlockRealtimeManager {
  private ws: WebSocket;
  private subscribers = new Map<string, Function[]>();

  connect() {
    this.ws = new WebSocket(WS_ENDPOINT);
    
    this.ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      
      switch (data.type) {
        case 'new_block':
          this.notifySubscribers('block_update', data.block);
          break;
        case 'visit_update':
          this.notifySubscribers('visit_stats', data.stats);
          break;
      }
    };
  }

  subscribeToBlockUpdates(callback: (block: BlockData) => void) {
    this.addSubscriber('block_update', callback);
  }

  subscribeToVisitStats(blockSlot: number, callback: (stats: VisitStats) => void) {
    this.addSubscriber(`visit_stats:${blockSlot}`, callback);
  }
}
```

## Monitoring and Analytics

### Performance Monitoring

1. **Page Load Times**: Track block page load performance
2. **API Response Times**: Monitor block data fetching speed
3. **Analytics Processing Time**: Measure program/account analysis performance
4. **Cache Hit Rates**: Monitor caching effectiveness
5. **Error Rates**: Track and alert on error frequencies

### User Analytics

1. **Feature Usage**: Track which analytics features are most used
2. **Navigation Patterns**: Understand how users explore blocks
3. **Engagement Metrics**: Measure time spent on different sections
4. **Conversion Tracking**: Track bookmark and sharing actions
5. **Performance Impact**: Measure user experience metrics

This comprehensive design provides a robust foundation for implementing the block explorer enhancements with advanced analytics, social features, and optimal performance.
---

## File: ./.kiro/specs/block-explorer-enhancements/requirements.md

# Block Explorer Enhancements Requirements

## Introduction

This specification defines the requirements for enhancing the existing block explorer functionality in OpenSVM. The current implementation includes basic block details display, transaction listing, and block exploration tables. This enhancement focuses on adding advanced analytics, social sharing capabilities, performance metrics, and comprehensive block analysis features to provide users with deeper insights into Solana blocks, their transactions, validators, and network performance.

## Requirements

### Requirement 1: Individual Block Detail Page

**User Story:** As a blockchain analyst, I want to view comprehensive information about a specific Solana block, so that I can analyze block composition, validator performance, and transaction patterns.

#### Acceptance Criteria

1. WHEN a user navigates to `/block/[slot]` with a valid slot number THEN the system SHALL display comprehensive block information including metadata, transactions, validator info, and performance metrics
2. WHEN a user provides an invalid slot number THEN the system SHALL display a 404 error page with helpful navigation options
3. WHEN block data is loading THEN the system SHALL show progressive loading states for different sections (metadata, transactions, validator info)
4. WHEN a block contains many transactions THEN the system SHALL implement pagination or virtual scrolling for optimal performance
5. WHEN a user views a block THEN the system SHALL provide navigation to previous and next blocks
6. WHEN a user clicks on a transaction in the block THEN the system SHALL navigate to the transaction detail page
7. WHEN a user clicks on the validator address THEN the system SHALL navigate to the validator detail page
8. WHEN block data fails to load THEN the system SHALL show retry mechanisms and error handling

### Requirement 2: Block List and Exploration

**User Story:** As a network monitor, I want to browse recent blocks with real-time updates and search functionality, so that I can track network activity and identify patterns.

#### Acceptance Criteria

1. WHEN a user visits `/blocks` THEN the system SHALL display a table of recent blocks with key metrics (slot, time, transactions, validator, fees)
2. WHEN new blocks are produced THEN the system SHALL update the block list in real-time without full page refresh
3. WHEN a user scrolls to the bottom of the block list THEN the system SHALL load more historical blocks automatically
4. WHEN a user searches for a specific slot or blockhash THEN the system SHALL filter the results accordingly
5. WHEN a user clicks on a block in the list THEN the system SHALL navigate to the block detail page
6. WHEN the system updates with new blocks THEN it SHALL maintain the user's scroll position and show notifications
7. WHEN a user wants to export block data THEN the system SHALL provide export functionality in CSV/JSON formats
8. WHEN real-time updates fail THEN the system SHALL fall back to periodic refresh and show connection status

### Requirement 3: Block Performance Metrics

**User Story:** As a validator operator, I want to see detailed performance metrics for blocks, so that I can understand network efficiency and validator performance.

#### Acceptance Criteria

1. WHEN viewing a block detail page THEN the system SHALL display transaction count, success rate, total fees, and compute units consumed
2. WHEN viewing block metrics THEN the system SHALL show average transaction size and processing efficiency
3. WHEN comparing blocks THEN the system SHALL provide performance indicators relative to network averages
4. WHEN viewing validator performance THEN the system SHALL show block production statistics and timing metrics
5. WHEN metrics are calculated THEN the system SHALL ensure accuracy and provide data sources
6. WHEN performance data is unavailable THEN the system SHALL show appropriate fallback messages

### Requirement 4: Block Program Analytics

**User Story:** As a DeFi analyst, I want to see which programs were used in a block and their transaction volumes, so that I can understand protocol activity and market dynamics.

#### Acceptance Criteria

1. WHEN viewing a block detail page THEN the system SHALL display statistics about programs used in the block
2. WHEN showing program stats THEN the system SHALL include transaction count and volume in SOL for each program
3. WHEN displaying program volumes THEN the system SHALL show SPL token volumes for each program involved
4. WHEN programs are listed THEN the system SHALL sort by volume and provide program names/identifiers
5. WHEN program data is clicked THEN the system SHALL navigate to the program detail page
6. WHEN program statistics are unavailable THEN the system SHALL show appropriate fallback messages

### Requirement 5: Block Account Activity Analysis

**User Story:** As a trading analyst, I want to see the most active accounts in a block by volume and PnL, so that I can identify significant market participants and trading patterns.

#### Acceptance Criteria

1. WHEN viewing a block detail page THEN the system SHALL display top 20 accounts by transaction volume
2. WHEN showing account rankings THEN the system SHALL display top 20 accounts by profit and loss (PnL)
3. WHEN account volumes are calculated THEN the system SHALL include both SOL and SPL token values
4. WHEN PnL is calculated THEN the system SHALL show realized gains/losses from transactions in the block
5. WHEN accounts are listed THEN the system SHALL provide account addresses and clickable links to account pages
6. WHEN account data is clicked THEN the system SHALL navigate to the account detail page

### Requirement 6: Block Transfer Analysis

**User Story:** As a blockchain researcher, I want to see simple wallet-to-wallet transfers in a block, so that I can analyze direct payment patterns and user behavior.

#### Acceptance Criteria

1. WHEN viewing a block detail page THEN the system SHALL display top 50 simple SPL transfers from wallet to wallet
2. WHEN showing transfers THEN the system SHALL exclude program interactions and focus on direct wallet transfers
3. WHEN transfers are listed THEN the system SHALL show sender, receiver, token type, and amount
4. WHEN transfer amounts are displayed THEN the system SHALL show both token amounts and USD values where available
5. WHEN transfers are sorted THEN the system SHALL rank by transfer value in descending order
6. WHEN transfer addresses are clicked THEN the system SHALL navigate to the respective account pages

### Requirement 7: Block Social Sharing and Visit Analytics

**User Story:** As a blockchain educator, I want to share interesting blocks on social media with rich previews and see engagement analytics, so that I can discuss network events, educate others, and understand community interest.

#### Acceptance Criteria

1. WHEN a block page is shared on social media THEN the system SHALL generate dynamic OpenGraph images with block information
2. WHEN generating social images THEN the system SHALL include slot number, timestamp, transaction count, and validator info
3. WHEN social images are created THEN the system SHALL use consistent OpenSVM branding and styling
4. WHEN images are generated THEN the system SHALL cache them for performance and cost optimization
5. WHEN sharing fails THEN the system SHALL provide fallback sharing options
6. WHEN images are displayed THEN they SHALL be optimized for different social platforms (Twitter, Discord, LinkedIn)
7. WHEN viewing a block page THEN the system SHALL display a small section showing total visit count for that block
8. WHEN a user clicks on the visit statistics section THEN the system SHALL expand to show detailed visit history
9. WHEN visit history is displayed THEN the system SHALL show user wallet addresses and visit timestamps
10. WHEN visit data is collected THEN the system SHALL respect user privacy and provide opt-out mechanisms
11. WHEN visit statistics are shown THEN the system SHALL update counts in real-time as new visitors arrive
12. WHEN displaying visitor addresses THEN the system SHALL make them clickable links to account pages

### Requirement 8: Block Data Caching and Performance

**User Story:** As a system administrator, I want block data to be cached efficiently, so that users experience fast loading times and the system handles high traffic effectively.

#### Acceptance Criteria

1. WHEN block data is requested THEN the system SHALL cache immutable block data indefinitely
2. WHEN block lists are requested THEN the system SHALL cache results for 30 seconds with stale-while-revalidate
3. WHEN block statistics are requested THEN the system SHALL cache for 10 seconds to balance freshness and performance
4. WHEN serving cached data THEN the system SHALL include appropriate cache headers and timestamps
5. WHEN cache misses occur THEN the system SHALL fetch data efficiently and update caches
6. WHEN memory usage is high THEN the system SHALL implement cache eviction policies

### Requirement 9: Block Search and Filtering

**User Story:** As a blockchain researcher, I want to search and filter blocks by various criteria, so that I can find specific blocks and analyze patterns.

#### Acceptance Criteria

1. WHEN a user searches by slot number THEN the system SHALL navigate directly to the block detail page
2. WHEN a user searches by blockhash THEN the system SHALL find and display the matching block
3. WHEN a user applies filters THEN the system SHALL filter blocks by date range, validator, transaction count, or fees
4. WHEN search results are displayed THEN the system SHALL highlight matching terms and provide relevance scoring
5. WHEN no results are found THEN the system SHALL show helpful suggestions and alternative searches
6. WHEN filters are applied THEN the system SHALL update the URL to allow bookmarking and sharing

### Requirement 10: Block Navigation and Breadcrumbs

**User Story:** As a user exploring the blockchain, I want clear navigation and context awareness, so that I can easily move between blocks and understand my location.

#### Acceptance Criteria

1. WHEN viewing a block detail page THEN the system SHALL show breadcrumb navigation (Home > Blocks > Block #12345)
2. WHEN on a block page THEN the system SHALL provide previous/next block navigation buttons
3. WHEN navigation buttons are clicked THEN the system SHALL prefetch adjacent block data for smooth transitions
4. WHEN breadcrumbs are displayed THEN each level SHALL be clickable and lead to the appropriate page
5. WHEN navigation fails THEN the system SHALL show error states and alternative navigation options
6. WHEN using keyboard navigation THEN all navigation elements SHALL be accessible via keyboard shortcuts

### Requirement 11: Mobile and Accessibility Support

**User Story:** As a mobile user with accessibility needs, I want the block explorer to work well on my device and with assistive technologies, so that I can access blockchain data anywhere.

#### Acceptance Criteria

1. WHEN viewing on mobile devices THEN the system SHALL provide responsive design with touch-friendly interfaces
2. WHEN using screen readers THEN the system SHALL provide proper ARIA labels and semantic HTML structure
3. WHEN using keyboard navigation THEN all interactive elements SHALL be accessible via keyboard
4. WHEN in high contrast mode THEN the system SHALL maintain readability and visual hierarchy
5. WHEN loading on slow networks THEN the system SHALL optimize for mobile performance and show appropriate loading states
6. WHEN using touch gestures THEN the system SHALL support swipe navigation between blocks

### Requirement 12: Error Handling and Resilience

**User Story:** As a user of the block explorer, I want the system to handle errors gracefully and provide helpful feedback, so that I can understand issues and continue using the application.

#### Acceptance Criteria

1. WHEN invalid slot numbers are provided THEN the system SHALL show 404 pages with suggestions for valid ranges
2. WHEN network errors occur THEN the system SHALL provide retry mechanisms and show connection status
3. WHEN partial data is available THEN the system SHALL display what's available and indicate missing information
4. WHEN API timeouts occur THEN the system SHALL show timeout messages and automatic retry options
5. WHEN JavaScript errors occur THEN the system SHALL use error boundaries to prevent complete page crashes
6. WHEN errors are logged THEN the system SHALL provide sufficient information for debugging without exposing sensitive data

### Requirement 13: Block Comparison and Historical Analysis

**User Story:** As a blockchain analyst, I want to compare blocks and analyze historical trends, so that I can identify patterns, anomalies, and network evolution over time.

#### Acceptance Criteria

1. WHEN viewing a block THEN the system SHALL provide a "Compare" button to compare with other blocks
2. WHEN comparing blocks THEN the system SHALL show side-by-side metrics (fees, transactions, compute units, etc.)
3. WHEN analyzing block trends THEN the system SHALL show historical charts for key metrics over time
4. WHEN detecting anomalies THEN the system SHALL highlight blocks with unusual characteristics (high fees, low success rate, etc.)
5. WHEN viewing block patterns THEN the system SHALL show validator performance trends and block timing analysis
6. WHEN historical data is displayed THEN the system SHALL allow filtering by time ranges and specific metrics

### Requirement 14: Block Bookmarking and Alerts

**User Story:** As a network monitor, I want to bookmark interesting blocks and set up alerts for specific block conditions, so that I can track important events and be notified of significant changes.

#### Acceptance Criteria

1. WHEN viewing a block THEN the system SHALL provide a bookmark button to save blocks to a personal list
2. WHEN bookmarking blocks THEN the system SHALL allow adding notes and tags for organization
3. WHEN setting up alerts THEN the system SHALL allow notifications for blocks meeting specific criteria (high fees, specific validators, etc.)
4. WHEN alerts are triggered THEN the system SHALL send notifications via email, browser notifications, or webhooks
5. WHEN managing bookmarks THEN the system SHALL provide a dedicated page to view and organize saved blocks
6. WHEN alerts are configured THEN the system SHALL provide management interface to edit or disable alerts

### Requirement 15: SEO and Discoverability

**User Story:** As a content creator, I want block pages to be discoverable by search engines and have rich metadata, so that blockchain content can be found and shared effectively.

#### Acceptance Criteria

1. WHEN search engines crawl block pages THEN the system SHALL provide dynamic meta titles like "Block #12345 | OpenSVM"
2. WHEN generating meta descriptions THEN the system SHALL include block summary with key metrics
3. WHEN providing structured data THEN the system SHALL use appropriate schema markup for blockchain data
4. WHEN generating canonical URLs THEN the system SHALL ensure consistent URLs for block pages
5. WHEN creating sitemaps THEN the system SHALL include recent blocks for search engine indexing
6. WHEN pages are shared THEN the system SHALL provide rich social media previews with block information
---

## File: ./.kiro/specs/block-explorer-enhancements/tasks.md

# Block Explorer Enhancements Implementation Plan

- [-] 1. Set up core block data infrastructure and API endpoints
  - Create block data types and interfaces for comprehensive block information
  - Implement API endpoints for block fetching, analytics, and real-time updates
  - Set up caching layer with appropriate TTL strategies for different data types
  - _Requirements: 1.1, 1.8, 8.1, 8.2, 8.3_

- [x] 1.1 Create block data models and TypeScript interfaces
  - Create `lib/types/block.types.ts` with comprehensive BlockData interface including slot, blockhash, parentSlot, blockTime, blockHeight, transactions[], rewards[], validator, metrics, programStats[], accountActivity, transfers[], visitStats
  - Define BlockMetrics interface with transactionCount, successfulTransactions, failedTransactions, totalFees, computeUnitsConsumed, averageTransactionSize, blockProcessingTime, networkEfficiency
  - Create ValidatorInfo interface with address, name, commission, activatedStake, performance object containing uptime, skipRate, averageBlockTime, rank
  - Implement ProgramStats interface with programId, programName, transactionCount, solVolume, splTokenVolumes (Map<string, TokenVolume>), computeUnitsUsed, successRate
  - Define AccountActivity interface with address, rank, volume, pnl, transactionCount, tokens (TokenActivity[])
  - Create SimpleTransfer interface with rank, fromAddress, toAddress, tokenMint, tokenSymbol, amount, usdValue, signature
  - Implement VisitAnalytics interface with blockSlot, totalVisits, uniqueVisitors, visitHistory (VisitRecord[]), geographicDistribution, referrerSources
  - Add BookmarkData interface with blockSlot, note, tags[], createdAt, updatedAt timestamps
  - _Requirements: 1.1, 4.1, 5.1, 6.1, 7.7_

- [x] 1.2 Implement core block API endpoints
  - Create `app/api/block/[slot]/route.ts` with GET handler that validates slot parameter using parseInt() and range checking, fetches block data from Solana RPC using getBlock() with maxSupportedTransactionVersion, processes transactions to extract program stats/account activity/transfers using analyzer services, implements error handling for invalid slots (return 404) and network errors (return 500 with retry headers)
  - Implement `app/api/blocks/route.ts` with GET handler supporting query parameters: limit (default 50, max 100), before (slot number for gpagination), validator (filter by validator address), implement cursor-based pagination using slot numbers, return BlockListItem[] with slot, blockhash, blockTime, transactionCount, validator, fees, status fields
  - Add `app/api/blocks/stats/route.ts` returning network statistics: currentSlot, averageBlockTime, tps, validatorCount, epochInfo, recentBlockMetrics (average fees, transaction counts, success rates over last 100 blocks)
  - Implement input validation using Zod schemas for all query parameters and path parameters
  - Add rate limiting using lib/rate-limiter.ts with different limits per endpoint (block detail: 100/min, block list: 200/min, stats: 500/min)
  - _Requirements: 1.1, 2.1, 3.1_

- [ ] 1.3 Set up block data caching system
  - Create `lib/cache/block-cache.ts` with BlockCacheManager class implementing get/set/invalidate methods, use Map<string, CacheEntry> for in-memory cache with TTL tracking, implement cache key patterns: "block:{slot}", "blocks:list:{limit}:{before}", "blocks:stats"
  - Configure cache TTL strategies: confirmed blocks (slot < currentSlot - 32) = infinite cache, recent blocks = 5 minutes, block lists = 30 seconds, block stats = 10 seconds
  - Implement stale-while-revalidate pattern: serve stale data immediately while fetching fresh data in background, update cache asynchronously
  - Add cache warming for recent blocks: pre-fetch and cache last 100 blocks on startup, implement background refresh job every 30 seconds
  - Create cache metrics tracking: hit/miss rates, memory usage, eviction counts, expose via /api/cache/metrics endpoint
  - Implement cache eviction policy: LRU eviction when memory usage > 80%, prioritize keeping confirmed blocks over recent data
  - _Requirements: 8.1, 8.2, 8.3, 8.4_

- [ ] 2. Build block detail page with comprehensive information display
  - Create BlockDetailsPage component with metadata, transactions, and validator info
  - Implement progressive loading states and error handling
  - Add navigation controls for previous/next blocks with prefetching
  - _Requirements: 1.1, 1.2, 1.3, 1.4, 1.5, 10.1, 10.2, 10.3_

- [ ] 2.1 Create BlockDetailsPage main component
  - Create `app/block/[slot]/page.tsx` as server component with generateMetadata() function for dynamic SEO, implement getBlockData() server function using fetch to /api/block/[slot], handle loading states with Suspense wrapper
  - Build responsive layout using CSS Grid: header section (breadcrumbs + block info), main content area with 3-column layout on desktop (metadata | transactions | analytics), stack vertically on mobile
  - Implement breadcrumb navigation component in `components/BlockBreadcrumbs.tsx` with structured data markup, use Next.js Link components: Home > Blocks > Block #{slot}, add JSON-LD structured data for breadcrumbs
  - Add error boundary wrapper using `components/ErrorBoundary.tsx` to catch and display block not found (404) or network errors, implement retry button that refetches data
  - Create loading skeleton components matching final layout structure, use React Suspense with fallback showing skeleton for each section
  - Implement URL parameter validation: parse slot from params, validate as positive integer, redirect invalid slots to /blocks with error message
  - _Requirements: 1.1, 10.1, 15.1, 15.2_

- [ ] 2.2 Implement block metadata and validator information display
  - Create `components/BlockMetadata.tsx` component displaying block info card with slot number, blockhash (truncated with copy button), parentSlot, blockTime (formatted as human-readable date + relative time), blockHeight, status badge (confirmed/finalized)
  - Build `components/ValidatorInfo.tsx` component showing validator address (with link to validator page), name (from validator registry), commission percentage, activated stake amount, performance metrics (uptime %, skip rate, average block time, network rank)
  - Create `components/BlockMetrics.tsx` displaying transaction statistics (total count, successful/failed breakdown with percentages), fee information (total fees in SOL + USD, average fee per transaction), compute units (total consumed, average per transaction, efficiency score vs network average), block processing time and network efficiency rating
  - Implement `components/BlockNavigation.tsx` with previous/next slot buttons, use Next.js router.prefetch() to preload adjacent blocks on hover, disable buttons at network boundaries, add keyboard shortcuts (left/right arrows), show loading states during navigation
  - Add copy-to-clipboard functionality for all addresses and hashes using navigator.clipboard API with fallback for older browsers, show toast notifications on successful copy
  - _Requirements: 1.1, 3.1, 3.2, 10.2, 10.3_

- [ ] 2.3 Build transaction list with pagination and filtering
  - Create `components/TransactionsInBlock.tsx` using @tanstack/react-virtual for virtual scrolling, implement FixedSizeList with itemHeight=60px, renderItem function displaying transaction signature (truncated), type (parsed from instructions), status (success/failed with color coding), fee amount, timestamp
  - Implement transaction filtering with `components/TransactionFilters.tsx`: filter by transaction type (transfer, swap, mint, burn, program interaction), status (success/failed), fee range (min/max SOL), program involved (dropdown with program names), add debounced search input for signature/address filtering
  - Create transaction row component `components/TransactionRow.tsx` with click handler using Next.js router.push() to navigate to /tx/[signature], implement hover effects and loading states, add context menu with copy signature/view details options
  - Add infinite scroll functionality: detect when user scrolls near bottom (within 100px), trigger loadMoreTransactions() function, show loading spinner at bottom, handle end-of-data state
  - Implement transaction type parsing: analyze instruction data to determine transaction type (SPL token transfer, DEX swap, NFT mint, etc.), use program registry to identify known programs, fallback to "Program Interaction" for unknown programs
  - _Requirements: 1.4, 1.6, 9.3_

- [ ] 3. Implement program analytics and statistics display
  - Create ProgramStatsDisplay component showing program usage in blocks
  - Calculate and display SOL and SPL token volumes per program
  - Add program interaction tracking and performance metrics
  - _Requirements: 4.1, 4.2, 4.3, 4.4, 4.5_

- [ ] 3.1 Build program analysis engine
  - Create `lib/analyzers/program-analyzer.ts` with ProgramAnalyzer class containing analyzeBlockPrograms(transactions: Transaction[]) method, iterate through all transactions and instructions to extract program interactions, use Map<string, ProgramStats> to accumulate statistics per program
  - Implement program volume calculation: for each instruction, identify SOL transfers by analyzing account balance changes (preBalances vs postBalances), track SPL token transfers by parsing instruction data for token program calls, calculate USD values using token price API
  - Add compute units tracking: extract computeUnitsConsumed from transaction meta, attribute compute units to programs based on instruction execution, calculate averageComputePerTx and efficiency metrics
  - Create program success rate calculation: track successful vs failed transactions per program, analyze error logs to categorize failure types, calculate reliability scores
  - Implement program registry integration: use existing program-registry.ts to resolve program names, categorize programs by type (DEX, lending, NFT, etc.), add program metadata (description, website, verified status)
  - Add caching for program analysis results: cache processed program stats for 5 minutes, implement incremental updates for new blocks, use program-specific cache keys
  - _Requirements: 4.1, 4.2, 4.3_

- [ ] 3.2 Create ProgramStatsDisplay component
  - Create `components/ProgramStatsDisplay.tsx` with responsive table using @tanstack/react-table, implement columns: program name/address, transaction count, SOL volume, top SPL tokens (with amounts), compute units used, success rate percentage, implement sorting for all numeric columns with default sort by SOL volume descending
  - Add program row click handler using Next.js router.push() to navigate to /program/[address], implement hover effects showing program description tooltip, add program verification badges for known/verified programs
  - Create expandable rows showing detailed SPL token breakdown: token symbol, amount, USD value, percentage of total program volume, implement collapse/expand animation using framer-motion
  - Add program category filtering: dropdown to filter by program type (DEX, lending, NFT, gaming, etc.), implement search input to filter by program name/address with debouncing
  - Implement loading skeleton matching table structure, add empty state when no programs found, handle error states with retry functionality
  - Add export functionality: CSV export button generating downloadable file with all program statistics, include timestamp and block slot in filename
  - _Requirements: 4.4, 4.5_

- [ ] 4. Build account activity analysis and top accounts display
  - Create AccountActivityDisplay component for top accounts by volume and PnL
  - Implement account ranking algorithms and profit/loss calculations
  - Add account interaction tracking and volume analysis
  - _Requirements: 5.1, 5.2, 5.3, 5.4, 5.5, 5.6_

- [ ] 4.1 Implement account activity analysis engine
  - Create `lib/analyzers/account-analyzer.ts` with AccountAnalyzer class containing analyzeBlockAccounts(transactions: Transaction[]) method, use Map<string, AccountActivity> to track per-account statistics, iterate through all transactions to extract account interactions from instruction accounts and balance changes
  - Implement volume calculation: track SOL volume by analyzing preBalances vs postBalances for each account, calculate net SOL change per account, track SPL token volumes by parsing token transfer instructions, sum inbound/outbound token amounts per account
  - Add PnL calculation logic: for each account, calculate realized PnL by tracking token/SOL price at transaction time vs current price, identify buy/sell transactions by analyzing balance changes, calculate unrealized PnL for current holdings, handle DEX swaps and liquidity provision/withdrawal
  - Create account ranking system: rank top 20 accounts by total volume (SOL + SPL tokens in USD), rank top 20 accounts by PnL (profit/loss in USD), implement tie-breaking by transaction count, filter out program accounts to focus on user wallets
  - Add token activity tracking: for each account, track TokenActivity[] with mint, symbol, netChange (positive/negative), usdValue, transaction count per token, identify major token movements and trading patterns
  - Implement caching and optimization: cache account analysis results for 5 minutes, use incremental processing for new blocks, optimize for blocks with high transaction counts (>1000 transactions)
  - _Requirements: 5.1, 5.2, 5.4_

- [ ] 4.2 Create AccountActivityDisplay component
  - Create `components/AccountActivityDisplay.tsx` with two-column responsive layout: left column showing "Top Accounts by Volume" table, right column showing "Top Accounts by PnL" table, stack vertically on mobile
  - Implement volume table with columns: rank (#1-20), account address (truncated with copy button), total volume (SOL + USD equivalent), transaction count, top tokens traded (show 30 most significant), use color coding for volume ranges (green for high, yellow for medium)
  - Build PnL table with columns: rank (#1-20), account address (truncated), realized PnL (positive in green, negative in red), unrealized PnL, total PnL percentage, major token positions, add profit/loss indicators with arrows and percentages
  - Add account row click handlers using Next.js router.push() to navigate to /account/[address], implement hover effects showing account preview tooltip with balance and recent activity
  - Create loading skeletons for both tables, handle empty states when no significant account activity found, add refresh button to reload account analysis
  - Implement export functionality: CSV export for both volume and PnL rankings, include detailed token breakdowns and timestamps
  - _Requirements: 5.3, 5.5, 5.6_

- [ ] 5. Implement simple transfer analysis and display
  - Create TransferAnalysisDisplay component for wallet-to-wallet transfers
  - Filter and rank top 50 simple SPL transfers by value
  - Add transfer visualization with sender, receiver, and amounts
  - _Requirements: 6.1, 6.2, 6.3, 6.4, 6.5, 6.6_

- [ ] 5.1 Build transfer analysis engine
  - Create `lib/analyzers/transfer-analyzer.ts` with TransferAnalyzer class containing analyzeSimpleTransfers(transactions: Transaction[]) method, filter transactions to identify direct wallet-to-wallet SPL token transfers by checking instruction program is Token Program and instruction type is Transfer
  - Implement transfer filtering logic: exclude transactions involving program accounts (check account.owner !== SystemProgram), focus on transfers between user wallets, filter out DEX swaps, liquidity operations, and complex multi-instruction transactions
  - Add transfer ranking system: calculate USD value for each transfer using real-time token prices from price API, rank top 50 transfers by USD value descending, include fallback ranking by token amount when USD price unavailable
  - Create transfer data extraction: parse transfer instruction to get source account, destination account, token mint, amount, extract wallet addresses from account info, resolve token metadata (symbol, decimals, name) from token registry
  - Implement transfer validation: verify transfer actually occurred by checking account balance changes, handle failed transfers appropriately, validate token mint addresses and amounts
  - Add caching and optimization: cache transfer analysis results for 3 minutes, optimize parsing for blocks with many transfers, use batch token price lookups
  - _Requirements: 6.1, 6.2, 6.5_

- [ ] 5.2 Create TransferAnalysisDisplay component
  - Create `components/TransferAnalysisDisplay.tsx` with responsive table using @tanstack/react-table, implement columns: rank (#1-50), from address (truncated with copy button), to address (truncated with copy button), token symbol with logo, amount (formatted with decimals), USD value (when available), transaction signature (truncated, clickable)
  - Add address click handlers using Next.js router.push() to navigate to /account/[address], implement hover effects showing address preview tooltips with balance and account type
  - Create transfer row styling with alternating colors, add transfer direction indicators (arrows), use color coding for transfer amounts (green for large transfers, blue for medium)
  - Implement loading skeleton matching table structure, handle empty state when no transfers found, add refresh button to reload transfer analysis
  - Add filtering functionality: filter by token type (dropdown with token symbols), minimum transfer amount slider, address search input with debouncing
  - Create export functionality: CSV export button generating downloadable file with all transfer data, include block slot and timestamp in filename
  - _Requirements: 6.3, 6.4, 6.6_

- [ ] 6. Build block list page with real-time updates and filtering
  - Create BlockListPage component with auto-refreshing block table
  - Implement WebSocket/SSE for real-time block updates
  - Add search and filtering functionality for blocks
  - _Requirements: 2.1, 2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8_

- [ ] 6.1 Create BlockListPage main component
  - Create `app/blocks/page.tsx` as server component with initial data fetching from /api/blocks, implement responsive layout with header section (network stats dashboard), main content area with block table, sidebar with filters and search
  - Build `components/BlockExploreTable.tsx` using @tanstack/react-table with columns: slot number (clickable), blockhash (truncated with copy), block time (relative + absolute), transaction count, validator (name + address), total fees, status badge, implement sorting for all columns with default sort by slot descending
  - Implement infinite scroll using Intersection Observer API: detect when user scrolls within 200px of bottom, trigger loadMoreBlocks() function fetching next page using cursor-based pagination (before parameter), show loading spinner during fetch, handle end-of-data state
  - Create `components/NetworkStatsCard.tsx` displaying current network metrics: current slot, average block time (last 100 blocks), current TPS, total validators, epoch progress bar, network health indicator (green/yellow/red based on performance)
  - Add block row click handler using Next.js router.push() to navigate to /block/[slot], implement hover effects with block preview tooltip showing transaction breakdown and validator info
  - Implement loading skeleton for initial page load and infinite scroll, handle error states with retry functionality, add refresh button to reload current data
  - _Requirements: 2.1, 2.3, 2.6_

- [ ] 6.2 Implement real-time block updates
  - Create `lib/realtime/block-updates.ts` with BlockRealtimeManager class using EventSource for SSE connection to /api/sse-events/feed, implement reconnection logic with exponential backoff, handle connection states (connecting, connected, disconnected, error)
  - Build real-time update handler: listen for 'new_block' events, update block list state by prepending new blocks to existing array, maintain maximum list size (remove oldest blocks when > 1000), implement optimistic updates with rollback on error
  - Add notification system using `components/BlockNotification.tsx`: show toast notification for new blocks with slot number and transaction count, implement notification queue to avoid spam, add dismiss functionality and auto-hide after 5 seconds
  - Implement scroll position preservation: save current scroll position before updates, restore position after DOM updates, handle edge case when user is at top (auto-scroll to show new blocks), maintain scroll position when user is browsing historical blocks
  - Add connection status indicator in header: show green dot for connected, yellow for reconnecting, red for disconnected, implement retry button for manual reconnection, display last update timestamp
  - Handle WebSocket fallback: if SSE fails, fall back to polling /api/blocks every 30 seconds, implement progressive backoff for failed requests, show degraded performance warning to user
  - _Requirements: 2.2, 2.6, 2.8_

- [ ] 6.3 Add block search and filtering functionality
  - Create `components/BlockSearchFilters.tsx` with search input supporting slot numbers (exact match) and blockhash (partial match with autocomplete), implement debounced search with 300ms delay, add search history dropdown showing recent searches
  - Build filtering interface with date range picker (from/to dates), validator dropdown (populated from validator registry), transaction count range slider (min/max), fee range slider (SOL amounts), status filter (confirmed/finalized)
  - Implement advanced search with URL parameter synchronization: update URL query params when filters change, support bookmarkable filter URLs, restore filters from URL on page load
  - Add export functionality: create `components/BlockExportButton.tsx` with CSV/JSON export options, generate downloadable files with current filtered results, include metadata (export timestamp, filter criteria, total records)
  - Create search result highlighting: highlight matching terms in slot numbers and blockhashes, show search result count and applied filters summary, add clear filters button
  - Implement search performance optimization: use search index for fast lookups, cache search results for 1 minute, implement search suggestions based on user history
  - _Requirements: 2.4, 2.7, 9.1, 9.2, 9.3, 9.5, 9.6_

- [ ] 7. Implement social sharing and visit analytics
  - Create OpenGraph image generation for block pages
  - Build visit statistics tracking and display system
  - Add expandable visit history with user addresses and timestamps
  - _Requirements: 7.1, 7.2, 7.3, 7.4, 7.5, 7.6, 7.7, 7.8, 7.9, 7.10, 7.11, 7.12_

- [ ] 7.1 Build OpenGraph image generation system
  - Create `app/block/[slot]/opengraph-image/route.tsx` using Next.js ImageResponse API, implement dynamic image generation with block slot prominently displayed, block timestamp (formatted as readable date), transaction count with icon, validator name/address, OpenSVM branding and logo
  - Build image layout with responsive design: 1200x630px for optimal social sharing, use consistent color scheme matching OpenSVM brand, implement text truncation for long validator names, add background gradient or pattern
  - Implement image caching: cache generated images for 24 hours using Next.js built-in caching, add cache headers for CDN optimization, implement cache invalidation when block data changes
  - Add platform-specific optimization: optimize for Twitter (summary_large_image), Discord embeds, test image rendering across different social platforms
  - Create fallback handling: show default image when block data unavailable, handle error states gracefully, implement retry logic for failed image generation
  - Add performance optimization: lazy load fonts, optimize image size, use efficient image formats (WebP with PNG fallback)
  - _Requirements: 7.1, 7.2, 7.3, 7.4, 7.5, 7.6_

- [ ] 7.2 Implement visit analytics tracking system
  - Create `lib/analytics/visit-tracker.ts` with VisitTracker class implementing trackVisit(blockSlot, userInfo) method, hash IP addresses using crypto.createHash('sha256'), store visit records with blockSlot, hashedIP, walletAddress (if connected), timestamp, userAgent, referrer
  - Build database schema: VisitRecord table with id, blockSlot, hashedIP, walletAddress, visitTime, sessionDuration, referrer, userAgent fields, VisitStats table with blockSlot, totalVisits, uniqueVisitors, lastUpdated
  - Add real-time visit count updates: use WebSocket to broadcast visit count changes, implement debounced updates (max 1 update per 5 seconds), cache visit counts in Redis for performance
  - Create visit analytics API endpoints: GET /api/visit-stats/[blockSlot] returning visit count and basic stats, GET /api/visit-history/[blockSlot] returning paginated visit history (with privacy filtering)
  - Implement geographic and referrer tracking: extract country from IP (using MaxMind GeoLite2), track referrer sources (direct, social media, search engines), aggregate data for analytics dashboard
  - _Requirements: 7.7, 7.10, 7.11_

- [ ] 7.3 Create VisitStatistics component
  - Create `components/VisitStatistics.tsx` with collapsible section showing visit count badge, implement useState for expanded/collapsed state, display total visits and unique visitors with icons, add expand/collapse button with smooth animation using framer-motion
  - Build expandable visit history section with `components/VisitHistoryTable.tsx` using @tanstack/react-table, implement columns: visitor wallet address (truncated with copy button), visit timestamp (relative + absolute time), session duration, referrer source, implement pagination for large visit histories
  - Add visitor address click handlers using Next.js router.push() to navigate to /account/[address], implement hover effects showing visitor preview tooltip with account balance and activity level
  - Implement real-time visit count updates using WebSocket subscription, update visit count without full component re-render, show new visitor notifications with fade-in animation
  - Add privacy controls: show opt-out toggle for visit tracking, display privacy notice explaining data collection, implement visitor anonymization options
  - Create loading skeleton for visit statistics, handle empty state when no visits recorded, add refresh button to reload visit data
  - _Requirements: 7.8, 7.9, 7.12_

- [ ] 8. Build block comparison and historical analysis features
  - Create BlockComparison component for side-by-side block analysis
  - Implement historical trend analysis and anomaly detection
  - Add block performance comparison tools and metrics visualization
  - _Requirements: 13.1, 13.2, 13.3, 13.4, 13.5, 13.6_

- [ ] 8.1 Create block comparison system
  - Create `components/BlockComparison.tsx` with side-by-side layout supporting up to 4 blocks, implement block selection interface with search/autocomplete for slot numbers, display comparison metrics in responsive grid: transaction count, fees, compute units, success rate, validator info, processing time
  - Build `components/BlockComparisonSelector.tsx` with input fields for slot numbers, validation for existing blocks, add/remove comparison blocks functionality, implement drag-and-drop reordering of comparison blocks
  - Add metrics calculation engine: calculate percentage differences between blocks, identify outliers and anomalies, compute relative performance scores, highlight significant differences with color coding
  - Create `components/ComparisonMetricsChart.tsx` using recharts library: line charts showing metrics over time for selected blocks, bar charts for direct metric comparison, implement zoom/pan functionality for detailed analysis
  - Implement comparison export functionality: generate PDF reports with comparison data, CSV export with detailed metrics, shareable comparison URLs with block selections
  - Add comparison history: save recent comparisons in localStorage, provide quick access to frequently compared block ranges, implement comparison templates for common analysis patterns
  - _Requirements: 13.1, 13.2, 13.3_

- [ ] 8.2 Implement anomaly detection and trend analysis
  - Create `lib/analyzers/anomaly-detector.ts` with AnomalyDetector class implementing detectBlockAnomalies(blocks: BlockData[]) method, identify unusual characteristics: abnormally high/low transaction counts (>2 standard deviations), excessive fees (>95th percentile), poor success rates (<90%), unusual compute unit consumption
  - Build trend analysis engine in `lib/analyzers/trend-analyzer.ts`: calculate moving averages for key metrics over time windows (1h, 6h, 24h), identify trend patterns (increasing, decreasing, stable, volatile), detect trend reversals and inflection points
  - Implement validator performance analysis: track validator block production timing, identify validators with consistently slow blocks, analyze skip rates and performance degradation over time, correlate validator performance with network conditions
  - Create `components/AnomalyHighlights.tsx` displaying detected anomalies with severity levels (low, medium, high, critical), provide explanations for each anomaly type, add filtering by anomaly category and time range
  - Add historical data filtering interface: date range picker with preset options (last hour, day, week, month), metric-specific filters (transaction count, fees, compute units), validator-specific analysis, export filtered data for further analysis
  - Implement alerting for detected anomalies: real-time anomaly notifications, configurable thresholds for different anomaly types, integration with existing alert system, anomaly history tracking and reporting
  - _Requirements: 13.4, 13.5, 13.6_

- [ ] 9. Implement bookmarking and alert system
  - Create bookmark management system for saving interesting blocks
  - Build alert configuration for specific block conditions
  - Add notification system with multiple delivery methods
  - _Requirements: 14.1, 14.2, 14.3, 14.4, 14.5, 14.6_

- [ ] 9.1 Build bookmark management system
  - Create `components/BookmarkManager.tsx` with bookmark toggle button (star icon), implement useState for bookmark status, use localStorage or database to persist bookmarks, show visual feedback (filled/empty star) for bookmark state
  - Build bookmark organization interface with `components/BookmarkNoteEditor.tsx`: text area for adding notes to bookmarks, tag input with autocomplete for existing tags, implement tag suggestions based on block characteristics (high-fee, anomaly, validator-specific)
  - Create dedicated bookmark management page at `app/bookmarks/page.tsx`: display bookmarked blocks in sortable table with columns (slot, timestamp, note, tags, actions), implement filtering by tags and date range, add bulk actions (delete, export, tag management)
  - Implement bookmark data persistence: create API endpoints POST/DELETE /api/bookmarks/[blockSlot], use database schema with userId, blockSlot, note, tags[], createdAt, updatedAt fields, implement user authentication integration
  - Add bookmark synchronization across devices: sync bookmarks to user account when logged in, handle offline bookmark storage with sync on reconnection, implement conflict resolution for concurrent bookmark changes
  - Create bookmark export functionality: generate JSON/CSV exports of bookmarked blocks with notes and tags, implement bookmark import from exported files, add sharing functionality for bookmark collections
  - _Requirements: 14.1, 14.2, 14.5_

- [ ] 9.2 Implement alert configuration system
  - Create `components/AlertConfiguration.tsx` with alert setup form: condition type dropdown (high fees, low success rate, specific validator, transaction count threshold), threshold value inputs with validation, notification method checkboxes (email, browser, webhook), alert name and description fields
  - Build alert management dashboard at `app/alerts/page.tsx`: display active alerts in sortable table with columns (name, condition, threshold, status, last triggered), implement toggle switches for enable/disable alerts, add edit/delete actions with confirmation dialogs
  - Implement notification delivery system in `lib/alerts/notification-service.ts`: email notifications using SendGrid/Nodemailer with HTML templates, browser push notifications using Web Push API, webhook delivery with retry logic and failure handling
  - Create alert evaluation engine in `lib/alerts/alert-evaluator.ts`: continuously monitor new blocks against alert conditions, implement debouncing to prevent spam (max 1 alert per condition per 5 minutes), track alert history and performance metrics
  - Add alert template system: pre-configured alert templates for common scenarios (network congestion, validator issues, fee spikes), allow users to customize templates, implement alert sharing between users
  - Create alert analytics dashboard: show alert trigger frequency, false positive rates, notification delivery success rates, user engagement with alerts, implement alert optimization suggestions
  - _Requirements: 14.3, 14.4, 14.6_

- [ ] 10. Add comprehensive error handling and resilience
  - Implement error boundaries and graceful error handling
  - Create retry mechanisms for network failures
  - Add user-friendly error messages and recovery options
  - _Requirements: 12.1, 12.2, 12.3, 12.4, 12.5, 12.6_

- [ ] 10.1 Create error handling system
  - Create `lib/errors/block-error-handler.ts` with BlockErrorHandler class implementing handleSlotError(), handleNetworkError(), handleAnalyticsError() methods, define error types enum (INVALID_SLOT, BLOCK_NOT_FOUND, NETWORK_ERROR, ANALYTICS_ERROR, CACHE_ERROR, RATE_LIMIT_ERROR)
  - Implement automatic retry with exponential backoff: create RetryManager class with retry logic (initial delay 1s, max delay 30s, max attempts 3), implement jitter to prevent thundering herd, track retry attempts per request
  - Create user-friendly error components: `components/BlockNotFoundError.tsx` with suggestions for valid slot ranges, `components/NetworkError.tsx` with retry button and connection status, `components/AnalyticsError.tsx` with fallback to basic block data
  - Add error boundary components: `components/BlockErrorBoundary.tsx` wrapping block pages, implement error reporting to monitoring service, provide fallback UI showing partial data when possible
  - Implement error logging and monitoring: log errors with context (user agent, timestamp, request details), integrate with error tracking service (Sentry), create error analytics dashboard
  - Create error recovery mechanisms: implement graceful degradation (show basic data when analytics fail), provide manual refresh options, cache last known good data for fallback
  - _Requirements: 12.1, 12.2, 12.4, 12.6_

- [ ] 10.2 Implement partial data display and fallbacks
  - Create `components/PartialDataWrapper.tsx` component that gracefully handles missing data sections, implement conditional rendering for available data, show placeholder cards for missing sections with "Data unavailable" messages, provide manual refresh buttons for failed sections
  - Build fallback data sources: implement cached data usage when live data fails, use stale cache data with "Last updated" timestamps, implement alternative RPC endpoint fallbacks, create offline mode with cached data only
  - Add progressive loading states: show skeleton loaders for each data section independently, implement section-by-section loading (metadata loads first, then analytics), allow users to interact with loaded sections while others are still loading
  - Create error boundaries for each major section: wrap program analytics, account activity, and transfer analysis in separate error boundaries, implement section-specific error recovery, allow other sections to work when one fails
  - Implement data validation and sanitization: validate all API responses before rendering, handle malformed data gracefully, provide fallback values for missing fields, log data quality issues for monitoring
  - Add user feedback mechanisms: show data freshness indicators, provide "Report issue" buttons for data problems, implement user-friendly explanations for missing data
  - _Requirements: 12.3, 12.5_

- [ ] 11. Optimize for mobile and accessibility
  - Implement responsive design for all block explorer components
  - Add accessibility features including ARIA labels and keyboard navigation
  - Optimize touch interactions and mobile performance
  - _Requirements: 11.1, 11.2, 11.3, 11.4, 11.5, 11.6_

- [ ] 11.1 Implement responsive design and mobile optimization
  - Create mobile-first responsive layouts using CSS Grid and Flexbox: implement breakpoints at 320px (mobile), 768px (tablet), 1024px (desktop), 1440px (wide), use CSS custom properties for consistent spacing and typography across devices
  - Optimize table designs for mobile: implement horizontal scrolling for wide tables with sticky first column, create card-based layouts for mobile (stack table rows as cards), add swipe indicators for scrollable content, implement pull-to-refresh functionality
  - Add touch-friendly navigation: increase touch target sizes to minimum 44px, implement swipe gestures for block navigation (swipe left/right for prev/next block), add haptic feedback for touch interactions, optimize button spacing for thumb navigation
  - Create mobile-specific components: `components/mobile/MobileBlockCard.tsx` for condensed block display, `components/mobile/MobileTransactionList.tsx` with optimized scrolling, implement collapsible sections for mobile to reduce screen clutter
  - Implement progressive enhancement: ensure core functionality works without JavaScript, add touch-specific enhancements progressively, optimize images and assets for mobile networks, implement lazy loading for off-screen content
  - Add mobile performance optimizations: implement virtual scrolling for long lists, use intersection observer for lazy loading, minimize bundle size for mobile, implement service worker for offline functionality
  - _Requirements: 11.1, 11.5_

- [ ] 11.2 Add comprehensive accessibility features
  - Implement proper ARIA labels and semantic HTML structure: use semantic HTML5 elements (main, section, article, nav, aside), add ARIA labels for all interactive elements, implement proper heading hierarchy (h1 > h2 > h3), use role attributes for complex components (tablist, tab, tabpanel for analytics sections)
  - Add keyboard navigation support: implement focus management with proper tab order, add keyboard shortcuts (arrow keys for table navigation, Enter/Space for activation), create skip links for main content areas, implement focus trapping in modals and dropdowns
  - Create high contrast mode support: implement CSS custom properties for colors, add high contrast theme toggle, ensure minimum 4.5:1 contrast ratio for normal text and 3:1 for large text, test with Windows High Contrast mode
  - Add screen reader compatibility: provide descriptive alt text for all images and icons, implement live regions for dynamic content updates, add screen reader only text for context, use proper form labels and fieldsets
  - Implement accessibility testing: integrate @axe-core/react for automated testing, add manual testing checklist, implement keyboard-only navigation testing, test with screen readers (NVDA, JAWS, VoiceOver)
  - Create accessibility documentation: document keyboard shortcuts, provide accessibility statement, implement user feedback mechanism for accessibility issues
  - _Requirements: 11.2, 11.3, 11.4, 11.6_

- [ ] 12. Implement SEO optimization and discoverability
  - Add dynamic meta tags and structured data for block pages
  - Create sitemap generation for recent blocks
  - Implement canonical URLs and social media optimization
  - _Requirements: 15.1, 15.2, 15.3, 15.4, 15.5, 15.6_

- [ ] 12.1 Create SEO optimization system
  - Implement dynamic meta title and description generation in `app/block/[slot]/page.tsx` generateMetadata() function: create titles like "Block #12345 - 1,234 transactions | OpenSVM", generate descriptions with key metrics "Block #12345 produced by [validator] with 1,234 transactions, 0.5 SOL fees, 98% success rate"
  - Add structured data markup using JSON-LD: implement blockchain-specific schema for blocks, transactions, validators, add breadcrumb structured data, create organization markup for OpenSVM, implement WebPage and Dataset schemas
  - Create canonical URL generation: ensure consistent URLs for block pages (/block/12345), implement redirect from alternative URLs, add canonical link tags to prevent duplicate content
  - Build sitemap generation system: create dynamic sitemap including recent blocks (last 10,000), implement sitemap index for large datasets, add lastmod timestamps for blocks, exclude invalid/non-existent blocks
  - Add Open Graph and Twitter Card optimization: implement dynamic OG tags with block information, create Twitter Card meta tags, add proper image dimensions and alt text
  - _Requirements: 15.1, 15.2, 15.3, 15.4, 15.5_

- [ ] 12.2 Optimize social media sharing
  - Enhance OpenGraph image generation with rich block information: add block performance indicators (high/low fees, success rate), include trending program icons, show network health status, implement dynamic color coding based on block characteristics
  - Implement Twitter Card sharing optimization: create twitter:card meta tags with summary_large_image, add twitter:site and twitter:creator tags, implement og:type and article tags, optimize image dimensions for platform
  - Add social media preview testing and validation: create preview testing tool for developers, implement automated testing for different social platforms, validate image rendering and meta tag extraction, add debugging tools for social sharing issues
  - Create platform-specific sharing buttons: implement native sharing APIs where available, add copy-to-clipboard for sharing URLs, track sharing analytics and popular platforms, implement sharing success/failure feedback
  - Add social sharing analytics: track which blocks are shared most frequently, analyze sharing patterns and popular platforms, implement sharing conversion tracking, create sharing performance dashboard
  - _Requirements: 15.6_

- [ ] 13. Add performance monitoring and analytics
  - Implement performance tracking for page load times and API responses
  - Create user analytics for feature usage and engagement
  - Add monitoring for cache effectiveness and error rates
  - Build alerting system for performance degradation

- [ ] 13.1 Create performance monitoring system
  - Create `lib/monitoring/performance-monitor.ts` with PerformanceMonitor class implementing trackPageLoad(), trackAPIResponse(), trackCacheHitRate() methods, use Performance API to measure page load times, track Time to First Byte (TTFB), First Contentful Paint (FCP), Largest Contentful Paint (LCP)
  - Implement API response monitoring: track response times for all block-related endpoints, measure 95th percentile response times, identify slow queries and bottlenecks, implement automatic alerting for response times > 2 seconds
  - Add cache hit rate monitoring: track cache performance for block data, analytics results, and image generation, calculate hit/miss ratios, monitor cache memory usage and eviction rates, implement cache warming effectiveness metrics
  - Create performance dashboards using `components/PerformanceDashboard.tsx`: display real-time performance metrics, show historical trends and patterns, implement alerting for performance degradation, add performance budget tracking
  - Implement analytics processing time tracking: measure time for program analysis, account analysis, transfer analysis, identify performance bottlenecks in analytics engines, track processing time vs block complexity correlation
  - Add user experience monitoring: track user interactions and engagement, measure time to interactive, monitor error rates and user satisfaction, implement performance impact on user behavior analysis

- [ ] 13.2 Build user analytics and engagement tracking
  - Create `lib/analytics/user-analytics.ts` with UserAnalytics class implementing trackFeatureUsage(), trackNavigation(), trackEngagement() methods, use localStorage and server-side tracking to monitor user behavior patterns, track feature adoption rates and usage frequency
  - Implement navigation pattern analysis: track user flow through block explorer (homepage → block list → block details → related pages), identify common user journeys and drop-off points, measure time spent on each page and section
  - Add engagement metrics tracking: measure scroll depth on block pages, track clicks on analytics sections (program stats, account activity, transfers), monitor user interactions with filters and search functionality, calculate session duration and bounce rates
  - Create conversion tracking system: track bookmark creation and usage patterns, monitor social sharing frequency and platforms, measure alert setup and effectiveness, track export functionality usage
  - Build user analytics dashboard: display user behavior insights, show feature usage statistics, identify popular content and user preferences, implement cohort analysis for user retention
  - Add privacy-compliant analytics: implement opt-out mechanisms, anonymize user data, respect privacy preferences, provide analytics transparency to users

- [ ] 14. Comprehensive testing and quality assurance
  - Write unit tests for all analytics engines and components
  - Create integration tests for API endpoints and real-time features
  - Implement end-to-end tests for complete user workflows
  - Add performance testing for large datasets and concurrent users

- [ ] 14.1 Write comprehensive unit tests
  - Create `__tests__/analyzers/program-analyzer.test.ts` testing ProgramAnalyzer.analyzeBlockPrograms() with mock transaction data, test volume calculations for SOL and SPL tokens, verify program ranking and success rate calculations, test edge cases (empty transactions, malformed data, unknown programs)
  - Build `__tests__/analyzers/account-analyzer.test.ts` testing AccountAnalyzer.analyzeBlockAccounts() with various account scenarios, test PnL calculations with different token price scenarios, verify account ranking algorithms, test performance with large transaction sets
  - Create `__tests__/analyzers/transfer-analyzer.test.ts` testing TransferAnalyzer.analyzeSimpleTransfers() with different transfer types, verify filtering logic excludes program interactions, test transfer ranking and USD value calculations, test edge cases (failed transfers, unknown tokens)
  - Add component tests in `__tests__/components/` directory: test BlockDetailsPage rendering with mock data, test ProgramStatsDisplay sorting and filtering, test AccountActivityDisplay with empty/error states, test TransferAnalysisDisplay interactions
  - Implement error handling tests: test API error responses, test network timeout scenarios, test invalid slot number handling, test cache failure recovery, test analytics engine failures with graceful degradation
  - Create performance tests: test analytics processing time with large blocks (>1000 transactions), test memory usage during analysis, test cache effectiveness and hit rates

- [ ] 14.2 Create integration and end-to-end tests
  - Create `__tests__/integration/api-integration.test.ts` testing all block API endpoints with real Solana data, test API response times and data accuracy, verify caching behavior and cache invalidation, test rate limiting and error handling
  - Build `__tests__/integration/realtime-integration.test.ts` testing WebSocket/SSE connections for real-time block updates, verify connection recovery and fallback mechanisms, test notification delivery and user experience
  - Create end-to-end tests using Playwright in `e2e/block-explorer.spec.ts`: test complete user workflows (homepage → block list → block details → analytics), verify navigation between blocks, test search and filtering functionality, test bookmark and alert creation
  - Add mobile responsiveness tests: test touch interactions and swipe gestures, verify responsive layouts on different screen sizes, test mobile-specific components and optimizations
  - Implement accessibility compliance tests: automated testing with @axe-core/playwright, keyboard navigation testing, screen reader compatibility testing, color contrast validation
  - Create performance integration tests: test page load times under various conditions, verify analytics processing performance with large blocks, test real-time update performance impact

  - Configure application monitoring and error tracking: set up Sentry for error tracking with custom error boundaries, implement DataDog/New Relic for APM monitoring, configure log aggregation with ELK stack or similar, set up uptime monitoring with PingDom/StatusPage
  - Set up performance alerts and automated scaling: configure alerts for response time degradation (>2s), memory usage alerts (>80%), CPU usage monitoring, implement auto-scaling based on traffic patterns, set up database performance monitoring
  - Create maintenance procedures and backup strategies: implement automated database backups with point-in-time recovery, create deployment rollback procedures, set up blue-green deployment for zero-downtime updates, document incident response procedures
  - Add health check endpoints: implement /api/health with database connectivity checks, cache system health, external API availability, create detailed /api/health/detailed endpoint for monitoring systems
  - Configure alerting and on-call procedures: set up PagerDuty/OpsGenie for critical alerts, create escalation procedures, implement alert fatigue prevention with intelligent grouping, set up status page for user communication
  - Create performance baselines and SLAs: establish performance benchmarks for all endpoints, set up SLA monitoring and reporting, implement performance regression detection, create capacity planning procedures
---

## File: ./.kiro/specs/implementation-roadmap.md

# OpenSVM Implementation Roadmap

## Overview

This document provides a comprehensive roadmap for implementing missing features and enhancements across the OpenSVM platform. The specs are organized by priority and implementation complexity to guide development efforts effectively.

## Completed Specs

### 1. Wallet Path Finding (Priority: HIGH - Complete Missing Feature)
**Status**: ❌ Not Implemented  
**Effort**: Large (15 tasks, ~8-10 weeks)  
**Impact**: High - Core missing feature

**Location**: `.kiro/specs/wallet-path-finding/`

**Summary**: Complete implementation of wallet connection analysis through transaction flows, token transfers, and program interactions. Includes interactive graph visualization, connection strength analysis, and export capabilities.

**Key Components**:
- Connection analysis engine with BFS/DFS algorithms
- Interactive graph visualization with D3.js/Cytoscape
- Advanced filtering and export functionality
- Caching and performance optimization

### 2. Transaction Explorer Enhancements (Priority: HIGH - Core Feature Enhancement)
**Status**: ⚠️ Partially Implemented  
**Effort**: Large (14 tasks, ~6-8 weeks)  
**Impact**: High - Enhances core functionality

**Location**: `.kiro/specs/transaction-explorer-enhancements/`

**Summary**: Comprehensive enhancement of transaction analysis with detailed instruction parsing, account change visualization, AI explanations, and related transaction discovery.

**Key Components**:
- Detailed instruction parsing with program registry
- Account changes visualization with before/after states
- AI-powered transaction explanations
- Related transaction discovery and graph visualization
- Advanced transaction metrics and failure analysis

### 3. Network Monitoring Enhancements (Priority: MEDIUM - Security & Operations)
**Status**: ⚠️ Basic Implementation  
**Effort**: Large (15 tasks, ~8-10 weeks)  
**Impact**: Medium-High - Security and operational excellence

**Location**: `.kiro/specs/network-monitoring-enhancements/`

**Summary**: Transform basic monitoring into comprehensive anomaly detection, alert management, historical analysis, and custom monitoring rules system.

**Key Components**:
- ML-based and rule-based anomaly detection
- Comprehensive alert management with multiple notification channels
- Historical analysis with trend forecasting
- Custom monitoring rules engine
- Real-time dashboard with customizable widgets

## Pending Specs (To Be Created)

### 4. Token Explorer Enhancements (Priority: MEDIUM)
**Status**: ⚠️ Mostly Implemented  
**Estimated Effort**: Medium (8-10 tasks, ~4-5 weeks)  
**Impact**: Medium - Market data integration

**Missing Components**:
- Comprehensive token statistics and holder analysis
- Price charts and market data integration
- Transfer history with advanced filtering
- Token social media and community integration
- Holder distribution analysis and whale tracking

### 5. Block Explorer Enhancements (Priority: MEDIUM)
**Status**: ⚠️ Mostly Implemented  
**Estimated Effort**: Medium (6-8 tasks, ~3-4 weeks)  
**Impact**: Medium - Enhanced block analysis

**Missing Components**:
- Comprehensive block metadata display
- Transaction filtering and search within blocks
- Validator performance metrics integration
- Block rewards calculation and display
- Navigation to adjacent blocks with performance metrics

### 6. Program Explorer Enhancements (Priority: MEDIUM)
**Status**: ⚠️ Partially Implemented  
**Estimated Effort**: Large (10-12 tasks, ~6-7 weeks)  
**Impact**: Medium - Developer tools

**Missing Components**:
- Complete program metadata parsing and display
- Instruction usage analytics and statistics
- Account ownership analysis and visualization
- Program interaction history and patterns
- Security analysis and audit information integration

### 7. NFT Collections Enhancements (Priority: LOW-MEDIUM)
**Status**: ⚠️ Basic Implementation  
**Estimated Effort**: Medium (6-8 tasks, ~3-4 weeks)  
**Impact**: Low-Medium - NFT ecosystem support

**Missing Components**:
- Collection detail pages with comprehensive metadata
- Market data integration (floor price, volume, trends)
- Advanced filtering and search functionality
- Trending and new collections sections
- Collection statistics and analytics dashboard

### 8. Networks Comparison Page (Priority: LOW)
**Status**: ❌ Not Implemented  
**Estimated Effort**: Small (4-5 tasks, ~2-3 weeks)  
**Impact**: Low - Infrastructure comparison

**Missing Components**:
- Network comparison interface (mainnet, devnet, testnet)
- RPC endpoint status and performance monitoring
- Network-specific statistics and health metrics
- Performance benchmarking across networks

### 9. User Profiles and Social Features (Priority: MEDIUM-HIGH)
**Status**: ⚠️ Partially Implemented  
**Effort**: Large (16 tasks, ~10-12 weeks)  
**Impact**: High - Community and collaboration platform

**Location**: `.kiro/specs/user-profiles-social-features/`

**Summary**: Transform OpenSVM into a collaborative blockchain analysis platform with wallet-based authentication, social following, content sharing, community groups, and reputation systems.

**Key Components**:
- Wallet-based authentication and multi-wallet profiles
- Social following system with personalized activity feeds
- Content sharing and collaboration tools
- Community groups with threaded discussions
- Reputation system with badges and gamification
- Comprehensive notification and privacy systems

## Implementation Priority Matrix

### Phase 1: Core Missing Features (Immediate - Next 3 months)
1. **Wallet Path Finding** - Complete missing core feature
2. **Transaction Explorer Enhancements** - Enhance primary user journey

### Phase 2: Community & Advanced Analytics (3-6 months)
3. **User Profiles and Social Features** - Transform into collaborative platform
4. **Network Monitoring Enhancements** - Security and operational excellence

### Phase 3: Enhanced Data Analysis (6-9 months)
5. **Token Explorer Enhancements** - Market data integration
6. **Block Explorer Enhancements** - Complete block analysis
7. **Program Explorer Enhancements** - Developer-focused features

### Phase 4: Ecosystem Completion (9-12 months)
8. **NFT Collections Enhancements** - NFT ecosystem support
9. **Networks Comparison Page** - Infrastructure tools

## Resource Allocation Recommendations

### Development Team Structure
- **2-3 Senior Full-Stack Developers**: Core feature implementation
- **1 Frontend Specialist**: UI/UX and visualization components
- **1 Backend/Infrastructure Engineer**: Performance, caching, and scalability
- **1 AI/ML Engineer**: AI explanations and anomaly detection (part-time)

### Timeline Estimates

#### Phase 1 (Immediate Priority)
- **Wallet Path Finding**: 8-10 weeks (2 developers)
- **Transaction Explorer Enhancements**: 6-8 weeks (2 developers)
- **Total Phase 1**: ~3-4 months with parallel development

#### Phase 2 (Enhanced Analytics)
- **Network Monitoring**: 8-10 weeks (1-2 developers)
- **Token Explorer**: 4-5 weeks (1 developer)
- **Block Explorer**: 3-4 weeks (1 developer)
- **Total Phase 2**: ~3-4 months

## Success Metrics

### User Engagement Metrics
- Time spent on enhanced pages (target: +50% vs current)
- Feature adoption rates (target: >60% of active users)
- User retention improvement (target: +20%)

### Technical Performance Metrics
- Page load times (target: <2s for all enhanced pages)
- API response times (target: <500ms for 95th percentile)
- Error rates (target: <1% for all new features)

### Business Impact Metrics
- User satisfaction scores (target: >4.5/5)
- Feature usage analytics (target: >40% monthly active usage)
- Support ticket reduction (target: -30% for related issues)

## Risk Mitigation

### Technical Risks
- **Complex Graph Visualizations**: Start with simpler implementations, iterate
- **AI Integration Costs**: Implement caching and rate limiting early
- **Performance with Large Datasets**: Use pagination and progressive loading

### Resource Risks
- **Developer Availability**: Plan for 20% buffer in timelines
- **Third-party Dependencies**: Have fallback plans for external services
- **Scope Creep**: Strict adherence to spec requirements, defer enhancements

### User Experience Risks
- **Feature Complexity**: Implement progressive disclosure and help systems
- **Mobile Performance**: Test early and often on mobile devices
- **Accessibility**: Include accessibility testing in all development cycles

## Next Steps

1. **Review and Approve Specs**: Stakeholder review of completed specs
2. **Create Remaining Specs**: Develop specs for Phase 2 features
3. **Resource Planning**: Finalize development team assignments
4. **Technical Architecture Review**: Ensure scalability and performance
5. **Begin Phase 1 Implementation**: Start with Wallet Path Finding

This roadmap provides a clear path forward for implementing all missing features while maintaining focus on user value and technical excellence.
---

## File: ./.kiro/specs/network-monitoring-enhancements/design.md

# Network Monitoring Enhancements - Design Document

## Overview

The enhanced Network Monitoring system provides comprehensive real-time and historical analysis of Solana network activity with advanced anomaly detection, customizable alerting, and detailed performance analytics. The system combines machine learning-based anomaly detection with rule-based monitoring to provide comprehensive network oversight.

## Architecture

### System Components

```mermaid
graph TB
    Events[Event Stream] --> Processor[Event Processor]
    Processor --> Detector[Anomaly Detector]
    Processor --> Rules[Rule Engine]
    Processor --> Storage[Event Storage]
    
    Detector --> ML[ML Models]
    Detector --> Alerts[Alert Manager]
    Rules --> Alerts
    
    Alerts --> Notifications[Notification Service]
    Storage --> Analytics[Analytics Engine]
    Analytics --> Dashboard[Dashboard UI]
    
    Dashboard --> API[Monitoring API]
    API --> Cache[Redis Cache]
```

### Data Flow

1. **Event Ingestion**: Real-time blockchain events from Solana RPC
2. **Event Processing**: Parse, enrich, and categorize events
3. **Anomaly Detection**: ML-based and rule-based anomaly identification
4. **Alert Generation**: Create alerts based on detected anomalies
5. **Notification Dispatch**: Send alerts via configured channels
6. **Historical Storage**: Store events for analysis and reporting
7. **Analytics Processing**: Generate trends and insights
8. **Dashboard Updates**: Real-time dashboard updates via WebSocket

## Components and Interfaces

### Frontend Components

#### `EnhancedMonitoringDashboard`
```typescript
interface EnhancedMonitoringDashboardProps {
  timeRange: TimeRange;
  onTimeRangeChange: (range: TimeRange) => void;
  customLayout?: DashboardLayout;
}

interface DashboardLayout {
  widgets: DashboardWidget[];
  layout: GridLayout;
  refreshInterval: number;
}

interface DashboardWidget {
  id: string;
  type: 'metric' | 'chart' | 'alert' | 'table' | 'map';
  title: string;
  config: WidgetConfig;
  position: GridPosition;
}
```

#### `AnomalyDetectionPanel`
```typescript
interface AnomalyDetectionPanelProps {
  anomalies: DetectedAnomaly[];
  onAnomalyClick: (anomaly: DetectedAnomaly) => void;
  filters: AnomalyFilters;
  onFiltersChange: (filters: AnomalyFilters) => void;
}

interface DetectedAnomaly {
  id: string;
  type: AnomalyType;
  severity: 'low' | 'medium' | 'high' | 'critical';
  confidence: number;
  timestamp: Date;
  description: string;
  affectedEntities: string[];
  evidence: AnomalyEvidence[];
  status: 'active' | 'investigating' | 'resolved' | 'false_positive';
}

type AnomalyType = 
  | 'volume_spike'
  | 'wash_trading'
  | 'large_transfer'
  | 'unusual_program_usage'
  | 'validator_anomaly'
  | 'fee_anomaly';
```

#### `AlertManagementPanel`
```typescript
interface AlertManagementPanelProps {
  alerts: AlertRule[];
  onCreateAlert: (rule: AlertRule) => void;
  onUpdateAlert: (id: string, rule: AlertRule) => void;
  onDeleteAlert: (id: string) => void;
}

interface AlertRule {
  id: string;
  name: string;
  description: string;
  conditions: AlertCondition[];
  actions: AlertAction[];
  enabled: boolean;
  severity: AlertSeverity;
  cooldownPeriod: number;
  tags: string[];
}

interface AlertCondition {
  metric: string;
  operator: 'gt' | 'lt' | 'eq' | 'ne' | 'contains';
  value: number | string;
  timeWindow: number;
  aggregation?: 'sum' | 'avg' | 'max' | 'min' | 'count';
}

interface AlertAction {
  type: 'email' | 'webhook' | 'sms' | 'slack';
  config: ActionConfig;
  enabled: boolean;
}
```

#### `HistoricalAnalysisPanel`
```typescript
interface HistoricalAnalysisPanelProps {
  timeRange: TimeRange;
  metrics: HistoricalMetric[];
  onMetricSelect: (metric: string) => void;
  onExport: (format: 'csv' | 'json') => void;
}

interface HistoricalMetric {
  name: string;
  data: TimeSeriesData[];
  trend: TrendAnalysis;
  anomalies: HistoricalAnomaly[];
}

interface TimeSeriesData {
  timestamp: Date;
  value: number;
  metadata?: Record<string, any>;
}

interface TrendAnalysis {
  direction: 'up' | 'down' | 'stable';
  strength: number;
  forecast: ForecastData[];
  seasonality?: SeasonalityPattern;
}
```

#### `CustomRulesPanel`
```typescript
interface CustomRulesPanelProps {
  rules: MonitoringRule[];
  onCreateRule: (rule: MonitoringRule) => void;
  onUpdateRule: (id: string, rule: MonitoringRule) => void;
  onDeleteRule: (id: string) => void;
}

interface MonitoringRule {
  id: string;
  name: string;
  description: string;
  targets: RuleTarget[];
  conditions: RuleCondition[];
  actions: RuleAction[];
  enabled: boolean;
  priority: number;
  tags: string[];
}

interface RuleTarget {
  type: 'address' | 'program' | 'token' | 'validator';
  value: string;
  label?: string;
}

interface RuleCondition {
  field: string;
  operator: ComparisonOperator;
  value: any;
  logicalOperator?: 'AND' | 'OR';
}
```

### Backend Services

#### `AnomalyDetectionService`
```typescript
class AnomalyDetectionService {
  async detectAnomalies(
    events: NetworkEvent[],
    timeWindow: number
  ): Promise<DetectedAnomaly[]>;
  
  async trainModel(
    historicalData: HistoricalData,
    modelType: ModelType
  ): Promise<MLModel>;
  
  async updateAnomalyStatus(
    anomalyId: string,
    status: AnomalyStatus,
    feedback?: string
  ): Promise<void>;
}
```

#### `AlertManagerService`
```typescript
class AlertManagerService {
  async createAlert(rule: AlertRule): Promise<string>;
  async updateAlert(id: string, rule: AlertRule): Promise<void>;
  async deleteAlert(id: string): Promise<void>;
  async evaluateAlerts(events: NetworkEvent[]): Promise<TriggeredAlert[]>;
  async sendNotification(alert: TriggeredAlert): Promise<void>;
}
```

#### `HistoricalAnalyticsService`
```typescript
class HistoricalAnalyticsService {
  async getHistoricalMetrics(
    metric: string,
    timeRange: TimeRange,
    granularity: Granularity
  ): Promise<TimeSeriesData[]>;
  
  async analyzeTrends(
    data: TimeSeriesData[]
  ): Promise<TrendAnalysis>;
  
  async generateForecast(
    data: TimeSeriesData[],
    periods: number
  ): Promise<ForecastData[]>;
  
  async exportData(
    query: AnalyticsQuery,
    format: ExportFormat
  ): Promise<ExportResult>;
}
```

#### `CustomRulesEngine`
```typescript
class CustomRulesEngine {
  async createRule(rule: MonitoringRule): Promise<string>;
  async updateRule(id: string, rule: MonitoringRule): Promise<void>;
  async deleteRule(id: string): Promise<void>;
  async evaluateRules(event: NetworkEvent): Promise<RuleMatch[]>;
  async optimizeRules(): Promise<OptimizationReport>;
}
```

## Data Models

### Event and Anomaly Models

```typescript
interface NetworkEvent {
  id: string;
  timestamp: Date;
  type: EventType;
  source: string;
  data: EventData;
  metadata: EventMetadata;
  processed: boolean;
}

interface AnomalyEvidence {
  type: 'statistical' | 'pattern' | 'rule';
  description: string;
  confidence: number;
  data: any;
}

interface TriggeredAlert {
  id: string;
  ruleId: string;
  ruleName: string;
  severity: AlertSeverity;
  timestamp: Date;
  message: string;
  context: AlertContext;
  actions: AlertAction[];
}
```

### Analytics Models

```typescript
interface PerformanceMetrics {
  tps: number;
  avgConfirmationTime: number;
  avgFee: number;
  validatorUptime: number;
  networkLatency: number;
  errorRate: number;
}

interface ForecastData {
  timestamp: Date;
  predicted: number;
  confidence: number;
  upperBound: number;
  lowerBound: number;
}

interface SeasonalityPattern {
  period: 'hourly' | 'daily' | 'weekly';
  strength: number;
  peaks: Date[];
  troughs: Date[];
}
```

## Error Handling

### Data Processing Errors
- Event stream interruptions
- Malformed event data
- Processing pipeline failures
- Storage system unavailability

### Detection Errors
- ML model failures
- Rule evaluation errors
- False positive management
- Confidence threshold adjustments

### Notification Errors
- Delivery failures
- Rate limiting issues
- Channel configuration errors
- Retry mechanism failures

## Testing Strategy

### Unit Tests
- Anomaly detection algorithms
- Alert rule evaluation
- Trend analysis calculations
- Custom rule engine logic
- Notification delivery systems

### Integration Tests
- End-to-end monitoring workflow
- Real-time event processing
- Historical data analysis
- Dashboard real-time updates
- Alert notification delivery

### Performance Tests
- High-volume event processing
- Real-time anomaly detection
- Dashboard rendering performance
- Historical query performance
- Concurrent user handling

### Security Tests
- Input validation and sanitization
- Access control for sensitive data
- Alert configuration security
- Data export permissions
- API endpoint security
---

## File: ./.kiro/specs/network-monitoring-enhancements/requirements.md

# Network Monitoring Enhancements - Requirements Document

## Introduction

The Network Monitoring system currently provides basic live event monitoring but lacks comprehensive anomaly detection, alert management, historical analysis, and custom monitoring rules. These enhancements will create a robust monitoring platform for Solana network security and performance analysis.

## Requirements

### Requirement 1: Comprehensive Anomaly Detection

**User Story:** As a security analyst, I want automated anomaly detection across multiple metrics, so that I can identify potential threats and unusual network behavior quickly.

#### Acceptance Criteria

1. WHEN monitoring network activity THEN the system SHALL detect unusual transaction volume spikes
2. WHEN analyzing transaction patterns THEN the system SHALL identify potential wash trading activities
3. WHEN monitoring token transfers THEN the system SHALL detect suspicious large transfers
4. WHEN analyzing program interactions THEN the system SHALL identify unusual program usage patterns
5. WHEN detecting anomalies THEN the system SHALL calculate confidence scores and severity levels

### Requirement 2: Alert Configuration and Management

**User Story:** As a network administrator, I want to configure custom alerts for specific conditions, so that I can be notified of events relevant to my monitoring needs.

#### Acceptance Criteria

1. WHEN configuring alerts THEN the system SHALL allow setting thresholds for various metrics
2. WHEN creating alerts THEN the system SHALL support multiple notification channels (email, webhook, SMS)
3. WHEN alerts trigger THEN the system SHALL provide detailed context and recommended actions
4. WHEN managing alerts THEN the system SHALL allow enabling/disabling and modification of existing alerts
5. WHEN alerts are frequent THEN the system SHALL implement rate limiting and alert grouping

### Requirement 3: Historical Event Analysis

**User Story:** As a researcher, I want to analyze historical network events and trends, so that I can understand long-term patterns and investigate past incidents.

#### Acceptance Criteria

1. WHEN accessing historical data THEN the system SHALL provide events from the past 30 days minimum
2. WHEN analyzing trends THEN the system SHALL show time-series charts for key metrics
3. WHEN investigating incidents THEN the system SHALL allow filtering events by time, type, and severity
4. WHEN comparing periods THEN the system SHALL provide period-over-period analysis tools
5. WHEN exporting data THEN the system SHALL support CSV and JSON export formats

### Requirement 4: Performance Trend Analysis

**User Story:** As a network operator, I want to track network performance trends over time, so that I can identify degradation patterns and plan capacity improvements.

#### Acceptance Criteria

1. WHEN monitoring performance THEN the system SHALL track TPS trends over multiple time periods
2. WHEN analyzing network health THEN the system SHALL monitor validator performance and uptime
3. WHEN tracking efficiency THEN the system SHALL measure average transaction fees and confirmation times
4. WHEN identifying bottlenecks THEN the system SHALL highlight performance degradation patterns
5. WHEN forecasting THEN the system SHALL provide trend projections based on historical data

### Requirement 5: Custom Monitoring Rules

**User Story:** As a compliance officer, I want to create custom monitoring rules for specific addresses or programs, so that I can track entities of interest automatically.

#### Acceptance Criteria

1. WHEN creating rules THEN the system SHALL allow monitoring specific wallet addresses
2. WHEN creating rules THEN the system SHALL allow monitoring specific program interactions
3. WHEN creating rules THEN the system SHALL support complex conditions with AND/OR logic
4. WHEN rules trigger THEN the system SHALL log events with full context and evidence
5. WHEN managing rules THEN the system SHALL provide rule performance metrics and optimization suggestions

### Requirement 6: Real-time Dashboard and Visualization

**User Story:** As a monitoring operator, I want a comprehensive real-time dashboard, so that I can monitor network health and respond to issues quickly.

#### Acceptance Criteria

1. WHEN viewing the dashboard THEN the system SHALL display key network metrics in real-time
2. WHEN monitoring alerts THEN the system SHALL show active alerts with severity indicators
3. WHEN analyzing trends THEN the system SHALL provide interactive charts with drill-down capabilities
4. WHEN customizing views THEN the system SHALL allow dashboard layout personalization
5. WHEN sharing insights THEN the system SHALL support dashboard sharing and embedding
---

## File: ./.kiro/specs/network-monitoring-enhancements/tasks.md

# Network Monitoring Enhancements - Implementation Plan

## Task Overview

This implementation plan enhances the existing basic monitoring system with comprehensive anomaly detection, alert management, historical analysis, and custom monitoring capabilities.

## Implementation Tasks

- [ ] 1. Enhance event processing and storage infrastructure
  - [ ] 1.1 Upgrade event ingestion system
    - Enhance existing LiveEventMonitor to capture more event types
    - Implement event enrichment with additional metadata
    - Add event categorization and tagging system
    - _Requirements: 1.1, 4.1_

  - [ ] 1.2 Build event storage and indexing
    - Implement time-series database for historical event storage
    - Create efficient indexing for fast event queries
    - Add data retention policies and archiving
    - _Requirements: 3.1, 3.3_

- [ ] 2. Implement anomaly detection engine
  - [ ] 2.1 Build statistical anomaly detection
    - Create baseline calculation for normal network behavior
    - Implement statistical outlier detection algorithms
    - Add confidence scoring for detected anomalies
    - _Requirements: 1.1, 1.5_

  - [ ] 2.2 Develop pattern-based anomaly detection
    - Implement wash trading detection algorithms
    - Create suspicious transfer pattern recognition
    - Add unusual program usage pattern detection
    - _Requirements: 1.2, 1.3, 1.4_

  - [ ] 2.3 Build machine learning anomaly models
    - Train ML models on historical network data
    - Implement real-time model inference
    - Add model retraining and performance monitoring
    - _Requirements: 1.1, 1.5_

- [ ] 3. Create comprehensive alert management system
  - [ ] 3.1 Build alert rule configuration interface
    - Create UI for defining custom alert conditions
    - Implement threshold setting with multiple metrics
    - Add alert rule testing and validation
    - _Requirements: 2.1, 2.4_

  - [ ] 3.2 Implement notification channels
    - Add email notification system with templates
    - Implement webhook notifications for external systems
    - Create SMS notification integration
    - _Requirements: 2.2_

  - [ ] 3.3 Build alert management and tracking
    - Create alert dashboard with status tracking
    - Implement alert acknowledgment and resolution workflow
    - Add alert grouping and rate limiting
    - _Requirements: 2.3, 2.5_

- [ ] 4. Develop historical analysis and reporting
  - [ ] 4.1 Build historical data query system
    - Create efficient time-series data queries
    - Implement data aggregation and summarization
    - Add filtering and search capabilities
    - _Requirements: 3.1, 3.3_

  - [ ] 4.2 Create trend analysis engine
    - Implement time-series trend calculation
    - Add seasonality detection and analysis
    - Create period-over-period comparison tools
    - _Requirements: 3.2, 3.4, 4.2_

  - [ ] 4.3 Build data export functionality
    - Implement CSV export for historical data
    - Add JSON export with metadata
    - Create scheduled report generation
    - _Requirements: 3.5_

- [ ] 5. Implement performance monitoring and analytics
  - [ ] 5.1 Build network performance tracking
    - Create TPS monitoring with trend analysis
    - Implement validator performance tracking
    - Add network latency and health metrics
    - _Requirements: 4.1, 4.2_

  - [ ] 5.2 Develop efficiency metrics analysis
    - Track average transaction fees over time
    - Monitor confirmation time trends
    - Create network efficiency scoring
    - _Requirements: 4.3_

  - [ ] 5.3 Add performance forecasting
    - Implement trend-based performance forecasting
    - Create capacity planning recommendations
    - Add performance degradation early warning
    - _Requirements: 4.4, 4.5_

- [ ] 6. Create custom monitoring rules engine
  - [ ] 6.1 Build rule definition system
    - Create interface for defining custom monitoring rules
    - Implement complex condition logic (AND/OR)
    - Add rule targeting for specific addresses/programs
    - _Requirements: 5.1, 5.2, 5.3_

  - [ ] 6.2 Implement rule evaluation engine
    - Create real-time rule evaluation system
    - Add rule performance monitoring and optimization
    - Implement rule conflict detection and resolution
    - _Requirements: 5.4, 5.5_

  - [ ] 6.3 Build rule management interface
    - Create UI for rule creation and editing
    - Add rule testing and simulation capabilities
    - Implement rule performance analytics
    - _Requirements: 5.5_

- [ ] 7. Enhance monitoring dashboard
  - [ ] 7.1 Build real-time metrics dashboard
    - Create customizable widget system for key metrics
    - Implement real-time data updates via WebSocket
    - Add interactive charts with drill-down capabilities
    - _Requirements: 6.1, 6.3_

  - [ ] 7.2 Create alert visualization panel
    - Build active alerts display with severity indicators
    - Implement alert timeline and history visualization
    - Add alert correlation and grouping display
    - _Requirements: 6.2_

  - [ ] 7.3 Add dashboard customization features
    - Implement drag-and-drop dashboard layout
    - Create dashboard templates and presets
    - Add dashboard sharing and collaboration features
    - _Requirements: 6.4, 6.5_

- [ ] 8. Build anomaly investigation tools
  - [ ] 8.1 Create anomaly detail views
    - Build detailed anomaly information panels
    - Implement evidence presentation and analysis
    - Add anomaly correlation and relationship mapping
    - _Requirements: 1.5_

  - [ ] 8.2 Add anomaly feedback system
    - Create false positive reporting mechanism
    - Implement anomaly status tracking (investigating, resolved)
    - Add feedback loop for model improvement
    - _Requirements: 1.5_

- [ ] 9. Implement API endpoints for monitoring features
  - [ ] 9.1 Create anomaly detection APIs
    - Add `/api/monitoring/anomalies` endpoint
    - Implement `/api/monitoring/alerts` endpoint
    - Create `/api/monitoring/rules` endpoint
    - _Requirements: All_

  - [ ] 9.2 Build historical analytics APIs
    - Add `/api/monitoring/historical` endpoint
    - Implement `/api/monitoring/trends` endpoint
    - Create `/api/monitoring/export` endpoint
    - _Requirements: 3.1, 3.2, 3.5_

- [ ] 10. Add real-time communication infrastructure
  - [ ] 10.1 Implement WebSocket for real-time updates
    - Create WebSocket server for dashboard updates
    - Add real-time alert notifications
    - Implement event streaming for live monitoring
    - _Requirements: 6.1, 6.2_

  - [ ] 10.2 Build notification delivery system
    - Create reliable notification queue system
    - Implement delivery confirmation and retry logic
    - Add notification rate limiting and throttling
    - _Requirements: 2.2, 2.5_

- [ ] 11. Enhance existing monitoring page
  - [ ] 11.1 Integrate new components into monitoring page
    - Replace basic LiveEventMonitor with enhanced dashboard
    - Add tabbed interface for different monitoring views
    - Implement responsive layout for all new features
    - _Requirements: All_

  - [ ] 11.2 Add navigation and user experience improvements
    - Create intuitive navigation between monitoring features
    - Add contextual help and tooltips
    - Implement keyboard shortcuts for power users
    - _Requirements: All_

- [ ] 12. Implement caching and performance optimization
  - [ ] 12.1 Add intelligent caching for analytics
    - Implement Redis caching for frequently accessed metrics
    - Add cache invalidation strategies for real-time data
    - Create cache warming for dashboard performance
    - _Requirements: All_

  - [ ] 12.2 Optimize for high-volume event processing
    - Implement event batching and bulk processing
    - Add horizontal scaling capabilities
    - Create performance monitoring and alerting
    - _Requirements: 1.1, 4.1_

- [ ] 13. Build comprehensive testing suite
  - [ ] 13.1 Create unit tests for monitoring services
    - Test anomaly detection algorithm accuracy
    - Test alert rule evaluation correctness
    - Test trend analysis and forecasting accuracy
    - _Requirements: All_

  - [ ] 13.2 Add integration and performance tests
    - Test end-to-end monitoring workflow
    - Test real-time dashboard updates
    - Test high-volume event processing performance
    - _Requirements: All_

- [ ] 14. Implement security and access control
  - [ ] 14.1 Add role-based access control
    - Implement user roles for monitoring features
    - Add permission system for alert management
    - Create audit logging for sensitive operations
    - _Requirements: All_

  - [ ] 14.2 Secure sensitive monitoring data
    - Implement data encryption for stored events
    - Add secure API authentication
    - Create data retention and privacy controls
    - _Requirements: All_

- [ ] 15. Create documentation and user training
  - [ ] 15.1 Build user documentation
    - Create user guide for monitoring features
    - Add troubleshooting documentation
    - Build API documentation for developers
    - _Requirements: All_

  - [ ] 15.2 Add contextual help and onboarding
    - Create interactive tutorials for new users
    - Add contextual help throughout the interface
    - Implement feature discovery and tips
    - _Requirements: All_

## Implementation Notes

### Development Approach
- Build on existing LiveEventMonitor component
- Implement anomaly detection incrementally with different algorithms
- Use event-driven architecture for real-time processing
- Prioritize performance and scalability from the start

### Technology Choices
- **Time-series Database**: InfluxDB or TimescaleDB for event storage
- **Real-time Processing**: Apache Kafka or Redis Streams
- **Machine Learning**: TensorFlow.js or Python microservices
- **Caching**: Redis for performance optimization
- **WebSocket**: Socket.io for real-time dashboard updates

### Performance Considerations
- Implement event sampling for high-volume periods
- Use database partitioning for historical data
- Cache frequently accessed analytics queries
- Implement circuit breakers for external dependencies

### Security Considerations
- Validate all user inputs for alert rules and custom rules
- Implement rate limiting for API endpoints
- Secure notification channels with proper authentication
- Audit all configuration changes and sensitive operations
---

## File: ./.kiro/specs/program-explorer-enhancements/design.md

# Program Explorer Enhancements Design

## Overview

The Program Explorer Enhancements design provides a comprehensive solution for analyzing Solana programs with advanced code analysis, security assessment, performance monitoring, and developer tools. The system transforms the basic program explorer into a full-featured platform for developers, auditors, and researchers to understand program functionality, assess security, and optimize performance.

## Architecture

### High-Level Architecture

```mermaid
graph TB
    subgraph "Client Layer"
        A[Program Detail Page] --> B[Program List Page]
        A --> C[Code Analyzer]
        A --> D[Security Analyzer]
        B --> E[Program Discovery]
        C --> F[Disassembly Viewer]
    end
    
    subgraph "API Layer"
        G[Program API] --> H[Code Analysis Engine]
        G --> I[Security Engine]
        H --> J[Disassembly Service]
        I --> K[Vulnerability Scanner]
        L[Analytics API] --> M[Usage Analytics]
        N[Performance API] --> O[Metrics Collector]
    end
    
    subgraph "Data Layer"
        P[Qdrant Vector DB] --> Q[Program Patterns]
        P --> R[Security Signatures]
        P --> S[Performance Patterns]
        T[PostgreSQL] --> U[Program Metadata]
        T --> V[Usage Statistics]
        W[Redis Cache] --> X[Analysis Results]
    end
    
    A --> G
    C --> H
    D --> I
    E --> L
    F --> J
    G --> P
    H --> P
    I --> P
    M --> P
```

### Component Architecture

The program explorer follows a modular architecture with specialized analysis engines:

- **Presentation Layer**: React components with code visualization and analysis tools
- **Analysis Layer**: Specialized engines for code analysis, security assessment, and performance monitoring
- **Data Access Layer**: Multi-database approach with Qdrant for vectors, PostgreSQL for metadata
- **Integration Layer**: External APIs for program data, security databases, and performance metrics

## Layout Design Scheme

### Program Detail Page Layout (`/program/[address]`)

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                                    Header                                           │
│  ┌─────────────────┐  ┌──────────────────────────────────────────────────────────┐ │
│  │   Program Icon  │  │  Program Name • Verified Badge • Category               │ │
│  │   & Address     │  │  Deploy Date • Last Updated • Version                   │ │
│  │   (Copy Button) │  │  Author • Repository Link • Documentation               │ │
│  └─────────────────┘  └──────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────────────┐
│                              Quick Stats Bar                                        │
│  Transactions: 1.2M  │  Users: 45K  │  Success Rate: 98.5%  │  Security: 85/100   │
│  Compute Units: 2.1M │  Rank: #23   │  Performance: 92/100  │  Last Activity: 2m  │
└─────────────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────────────┐
│                                  Tab Navigation                                     │
│  [ Overview ] [ Code Analysis ] [ Security ] [ Performance ] [ Dependencies ]      │
└─────────────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────────────┐
│                                 Main Content Area                                   │
│                                                                                     │
│  ┌─────────────────────────────────────┐  ┌─────────────────────────────────────┐  │
│  │                                     │  │                                     │  │
│  │           Primary Panel             │  │           Secondary Panel           │  │
│  │                                     │  │                                     │  │
│  │  (Content changes based on         │  │  • Similar Programs                 │  │
│  │   selected tab)                    │  │  • Dependencies                     │  │
│  │                                     │  │  • Recent Activity                  │  │
│  │                                     │  │  • Quick Actions                    │  │
│  │                                     │  │  • Export Options                   │  │
│  │                                     │  │                                     │  │
│  └─────────────────────────────────────┘  └─────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

### Overview Tab Layout

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                              Program Overview                                       │
│                                                                                     │
│  ┌─────────────────────────────────────┐  ┌─────────────────────────────────────┐  │
│  │         Program Metadata            │  │        Activity Metrics             │  │
│  │  • Description                      │  │  • Transaction Volume Chart         │  │
│  │  • Category & Tags                  │  │  • User Growth Chart                │  │
│  │  • Deployment Info                  │  │  • Success Rate Trend               │  │
│  │  • Upgrade Authority                │  │  • Compute Unit Usage               │  │
│  └─────────────────────────────────────┘  └─────────────────────────────────────┘  │
│                                                                                     │
│  ┌─────────────────────────────────────┐  ┌─────────────────────────────────────┐  │
│  │      Instruction Analytics          │  │       Account Ownership             │  │
│  │  • Top Instructions Table           │  │  • Owned Accounts List              │  │
│  │  • Usage Statistics                 │  │  • Account Types Distribution       │  │
│  │  • Performance Metrics              │  │  • Data Size & Activity             │  │
│  │  • Caller Distribution              │  │  • Relationship Graph               │  │
│  └─────────────────────────────────────┘  └─────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

### Code Analysis Tab Layout

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                              Code Analysis Tools                                    │
│                                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐ │
│  │                          Code Viewer Controls                                   │ │
│  │  [Hex Dump] [Disassembly] [Control Flow] | Search: [_______] | Jump: [_____]   │ │
│  └─────────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                     │
│  ┌─────────────────────────────────────┐  ┌─────────────────────────────────────┐  │
│  │                                     │  │                                     │  │
│  │         Code Viewer                 │  │       Analysis Results             │  │
│  │                                     │  │                                     │  │
│  │  Address  | Bytes    | Assembly     │  │  • Code Patterns Detected          │  │
│  │  0x1000   | 48 89 e5 | mov %rsp,%rbp│  │  • Optimization Opportunities      │  │
│  │  0x1003   | 48 83 ec | sub $0x20,%rsp│  │  • Complexity Metrics             │  │
│  │  0x1007   | 20       |              │  │  • Function Analysis               │  │
│  │  ...      | ...      | ...          │  │  • Jump Targets & References       │  │
│  │                                     │  │  • Export Options                   │  │
│  │  [Line numbers and highlighting]    │  │                                     │  │
│  │                                     │  │                                     │  │
│  └─────────────────────────────────────┘  └─────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

### Security Tab Layout

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                              Security Assessment                                    │
│                                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐ │
│  │                          Security Score Dashboard                               │ │
│  │  Overall Score: 85/100 [████████▒▒] | Risk Level: MEDIUM | Last Scan: 2h ago   │ │
│  └─────────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                     │
│  ┌─────────────────────────────────────┐  ┌─────────────────────────────────────┐  │
│  │        Vulnerabilities              │  │         Audit Reports               │  │
│  │                                     │  │                                     │  │
│  │  🔴 Critical (0)                    │  │  • Trail of Bits - PASS            │  │
│  │  🟠 High (1)                        │  │    Date: 2024-01-15                │  │
│  │    • Buffer Overflow Risk           │  │    Findings: 3 Low, 1 Medium       │  │
│  │      Location: 0x1234               │  │                                     │  │
│  │  🟡 Medium (3)                      │  │  • Neodyme - CONDITIONAL           │  │
│  │  🟢 Low (2)                         │  │    Date: 2024-02-01                │  │
│  │                                     │  │    Findings: 2 Medium              │  │
│  │  [View Details] [Export Report]     │  │                                     │  │
│  └─────────────────────────────────────┘  └─────────────────────────────────────┘  │
│                                                                                     │
│  ┌─────────────────────────────────────┐  ┌─────────────────────────────────────┐  │
│  │       Code Quality Metrics          │  │      Upgrade & Permissions         │  │
│  │                                     │  │                                     │  │
│  │  Complexity: 7.2/10                 │  │  Upgradeable: Yes                   │  │
│  │  Maintainability: 85/100            │  │  Authority: 0x5678...               │  │
│  │  Test Coverage: 78/100              │  │  Governance: Multisig               │  │
│  │  Documentation: 92/100              │  │  Risk Level: Medium                 │  │
│  │  Best Practices: 88/100             │  │                                     │  │
│  └─────────────────────────────────────┘  └─────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

### Performance Tab Layout

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                             Performance Analytics                                   │
│                                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐ │
│  │                        Performance Metrics Overview                             │ │
│  │  Avg Compute: 1,250 CU | P95: 2,100 CU | Success: 98.5% | Throughput: 45 TPS  │ │
│  └─────────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                     │
│  ┌─────────────────────────────────────┐  ┌─────────────────────────────────────┐  │
│  │        Performance Charts           │  │      Optimization Suggestions       │  │
│  │                                     │  │                                     │  │
│  │  [Compute Units Over Time Chart]    │  │  🚀 High Impact                     │  │
│  │  [Success Rate Trend Chart]         │  │    • Optimize loop at 0x1234       │  │
│  │  [Execution Time Distribution]      │  │      Potential savings: 200 CU     │  │
│  │  [Resource Usage Breakdown]         │  │                                     │  │
│  │                                     │  │  ⚡ Medium Impact                   │  │
│  │  Time Range: [Last 7 days ▼]       │  │    • Cache computation result       │  │
│  │                                     │  │      Potential savings: 50 CU      │  │
│  └─────────────────────────────────────┘  └─────────────────────────────────────┘  │
│                                                                                     │
│  ┌─────────────────────────────────────┐  ┌─────────────────────────────────────┐  │
│  │      Instruction Performance        │  │        Resource Usage              │  │
│  │                                     │  │                                     │  │
│  │  Instruction | Avg CU | Calls | %   │  │  Memory: 2.1 MB (85% of limit)     │  │
│  │  transfer    | 1,200  | 45K   | 35% │  │  Storage: 512 KB                   │  │
│  │  swap        | 2,100  | 23K   | 28% │  │  Network: 1.2 MB/day               │  │
│  │  mint        | 800    | 12K   | 15% │  │  CPU: 12% avg utilization          │  │
│  │  burn        | 600    | 8K    | 10% │  │                                     │  │
│  └─────────────────────────────────────┘  └─────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

### Program List Page Layout (`/programs`)

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                                Programs Explorer                                    │
│                                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐ │
│  │                          Search & Filter Controls                               │ │
│  │  Search: [________________] | Category: [All ▼] | Activity: [All ▼] | Sort: [▼] │ │
│  │  Verified: ☑ | Security Score: [0────●────100] | Performance: [0────●────100]   │ │
│  └─────────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                     │
│  ┌─────────────────────────────────────┐  ┌─────────────────────────────────────┐  │
│  │                                     │  │                                     │  │
│  │         Programs Table              │  │        Category Overview           │  │
│  │                                     │  │                                     │  │
│  │ Name/Address | Category | Activity  │  │  📊 DeFi: 1,234 programs           │  │
│  │ Jupiter      | DEX      | ████████  │  │  🎮 Gaming: 567 programs           │  │
│  │ Serum        | DEX      | ███████▒  │  │  🖼️ NFT: 890 programs              │  │
│  │ Raydium      | AMM      | ██████▒▒  │  │  🏗️ Infrastructure: 234 programs   │  │
│  │ ...          | ...      | ...       │  │  📱 Social: 123 programs           │  │
│  │                                     │  │                                     │  │
│  │ [Load More] [Export List]           │  │  [View All Categories]             │  │
│  │                                     │  │                                     │  │
│  └─────────────────────────────────────┘  └─────────────────────────────────────┘  │
│                                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐ │
│  │                            Network Program Statistics                           │ │
│  │  Total Programs: 3,456 | Active (24h): 1,234 | New (7d): 45 | Avg Score: 82   │ │
│  └─────────────────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

### Global Program Similarity Browser Page Layout (`/programs/similarity-browser`)

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                        Global Program Similarity Browser                            │
│                                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐ │
│  │                          Similarity Search Controls                             │ │
│  │  Search Mode: [Browse All ▼] | Similarity Type: [Bytecode ▼] [Semantic ▼]      │ │
│  │  Min Similarity: [0.7] | Category Filter: [All ▼] | Sort: [Similarity ▼]       │ │
│  │  [🔍 Search Similar Programs] [📊 View Clusters] [📤 Export Results]            │ │
│  └─────────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐ │
│  │                            Similarity Type Tabs                                │ │
│  │  [Bytecode Similarity] [Semantic Similarity] [Transaction Patterns] [Mixed]    │ │
│  └─────────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                     │
│  ┌─────────────────────────────────────────┐  ┌─────────────────────────────────────┐  │
│  │                                     │  │                                     │  │
│  │      Similar Programs Table         │  │      Similarity Network View       │  │
│  │                                     │  │                                     │  │
│  │ Program A | Program B | Similarity  │  │  ┌─────────────────────────────────┐ │  │
│  │ Jupiter   | Raydium   | 94.2%      │  │  │                                 │ │  │
│  │ Serum     | Openbook  | 89.7%      │  │  │     Interactive Network        │ │  │
│  │ Orca      | Whirlpool | 87.3%      │  │  │                                 │ │  │
│  │ Marinade  | Lido      | 82.1%      │  │  │  ● Program Nodes (Size=Activity)│ │  │
│  │ ...       | ...       | ...        │  │  │  ─ Similarity Edges (Thickness) │ │  │
│  │                                     │  │  │  🎨 Color by Category          │ │  │
│  │ [Load More] [Compare Selected]      │  │  │  🔍 Zoom & Pan Controls        │ │  │
│  │                                     │  │  │                                 │ │  │
│  └─────────────────────────────────────┘  │  └─────────────────────────────────┘ │  │
│                                          └─────────────────────────────────────┘  │
│                                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐ │
│  │                           Similarity Insights Panel                             │ │
│  │                                                                                 │ │
│  │  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────┐ │ │
│  │  │  Top Clusters   │  │ Common Patterns │  │ Similarity Dist │  │ Categories  │ │ │
│  │  │                 │  │                 │  │                 │  │             │ │ │
│  │  │  DEX Cluster    │  │  Token Swap     │  │  90-100%: 45    │  │  DeFi: 67%  │ │ │
│  │  │  23 programs    │  │  156 programs   │  │  80-90%:  123   │  │  Gaming: 12%│ │ │
│  │  │  Avg: 91.2%     │  │                 │  │  70-80%:  234   │  │  NFT: 15%   │ │ │
│  │  │                 │  │  Liquidity Pool │  │  60-70%:  89    │  │  Other: 6%  │ │ │
│  │  │  AMM Cluster    │  │  89 programs    │  │  <60%:    12    │  │             │ │ │
│  │  │  15 programs    │  │                 │  │                 │  │             │ │ │
│  │  │  Avg: 86.7%     │  │  Staking        │  │  [View Chart]   │  │ [Details]   │ │ │
│  │  │                 │  │  67 programs    │  │                 │  │             │ │ │
│  │  └─────────────────┘  └─────────────────┘  └─────────────────┘  └─────────────┘ │ │
│  └─────────────────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

### Program Similarity Matrix Page Layout (`/programs/similarity-matrix`)

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                          Program Similarity Matrix View                             │
│                                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐ │
│  │                            Matrix Configuration                                 │ │
│  │  Programs: [Top 50 ▼] | Similarity: [Bytecode ▼] | Threshold: [0.6]           │ │
│  │  Display: [Heatmap ▼] | Sort: [Similarity ▼] | [🔄 Refresh] [📤 Export]        │ │
│  └─────────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐ │
│  │                          Similarity Heatmap Matrix                              │ │
│  │                                                                                 │ │
│  │        │Jupiter│Raydium│Serum │Orca  │Marinade│...                              │ │
│  │  ──────┼───────┼───────┼──────┼──────┼────────┼───                              │ │
│  │ Jupiter│ 100%  │ 94.2% │ 78.1%│ 65.3%│  45.2% │...                              │ │
│  │ Raydium│ 94.2% │ 100%  │ 82.7%│ 89.1%│  52.8% │...                              │ │
│  │ Serum  │ 78.1% │ 82.7% │ 100% │ 71.4%│  38.9% │...                              │ │
│  │ Orca   │ 65.3% │ 89.1% │ 71.4%│ 100% │  67.2% │...                              │ │
│  │Marinade│ 45.2% │ 52.8% │ 38.9%│ 67.2%│  100%  │...                              │ │
│  │  ...   │  ...  │  ...  │ ...  │ ...  │   ...  │...                              │ │
│  │                                                                                 │ │
│  │  🟥 90-100%  🟧 80-90%  🟨 70-80%  🟩 60-70%  🟦 50-60%  ⬜ <50%                │ │
│  │                                                                                 │ │
│  └─────────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                     │
│  ┌─────────────────────────────────────┐  ┌─────────────────────────────────────┐  │
│  │        Matrix Statistics            │  │       Selected Pair Analysis        │  │
│  │                                     │  │                                     │  │
│  │  Total Comparisons: 2,500           │  │  Jupiter ↔ Raydium                  │  │
│  │  High Similarity (>90%): 45         │  │  Similarity: 94.2%                  │  │
│  │  Medium Similarity (70-90%): 234    │  │  Type: Fork/Library                 │  │
│  │  Low Similarity (50-70%): 456       │  │                                     │  │
│  │  No Similarity (<50%): 1,765        │  │  Common Features:                   │  │
│  │                                     │  │  • Token swap logic                 │  │
│  │  Average Similarity: 67.3%          │  │  • AMM calculations                 │  │
│  │  Highest Pair: Jupiter-Raydium      │  │  • Fee collection                   │  │
│  │  Most Connected: Jupiter (23 links) │  │                                     │  │
│  │                                     │  │  [View Detailed Comparison]         │  │
│  └─────────────────────────────────────┘  └─────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

### Mobile Layout Adaptations

```
Mobile Program Detail (< 768px):
┌─────────────────────────────┐
│        Program Header       │
│  Icon | Name & Address      │
│       | Category & Status   │
└─────────────────────────────┘
┌─────────────────────────────┐
│      Collapsible Stats      │
│  [Tap to expand metrics]    │
└─────────────────────────────┘
┌─────────────────────────────┐
│      Tab Navigation         │
│ [Overview][Code][Security]  │
│    [Performance][More]      │
└─────────────────────────────┘
┌─────────────────────────────┐
│                             │
│      Stacked Content        │
│   (Single column layout)    │
│                             │
│  • Primary content first    │
│  • Secondary content below  │
│  • Collapsible sections     │
│                             │
└─────────────────────────────┘
```

## Components and Interfaces

### Core Program Components

#### ProgramDetailsPage Component
```typescript
interface ProgramDetailsPageProps {
  address: string;
  initialData?: ProgramData;
}

interface ProgramData {
  address: string;
  metadata: ProgramMetadata;
  code: ProgramCode;
  instructions: InstructionData[];
  accounts: OwnedAccount[];
  interactions: ProgramInteraction[];
  security: SecurityAnalysis;
  metrics: ProgramMetrics;
  dependencies: ProgramDependency[];
  performance: PerformanceMetrics;
  documentation: ProgramDocumentation;
}

interface ProgramMetadata {
  name?: string;
  description?: string;
  version?: string;
  author?: string;
  repository?: string;
  documentation?: string;
  verified: boolean;
  deployedAt: number;
  lastUpdated: number;
  upgradeAuthority?: string;
  category: string;
  tags: string[];
}

interface ProgramCode {
  size: number;
  hash: string;
  disassembly: DisassemblyInstruction[];
  hexDump: string;
  entryPoints: EntryPoint[];
  dependencies: string[];
  controlFlowGraph: ControlFlowNode[];
  codePatterns: CodePattern[];
}
```

#### ProgramListPage Component
```typescript
interface ProgramListPageProps {
  initialPrograms?: ProgramListItem[];
  filters?: ProgramFilters;
  sortBy?: ProgramSortOption;
}

interface ProgramListItem {
  address: string;
  name?: string;
  category: string;
  verified: boolean;
  deployedAt: number;
  lastActivity: number;
  transactionCount: number;
  uniqueUsers: number;
  computeUnitsConsumed: number;
  successRate: number;
  securityScore: number;
  performanceScore: number;
}

interface ProgramFilters {
  categories: string[];
  verified: boolean;
  activityLevel: 'low' | 'medium' | 'high';
  deploymentDateRange: [number, number];
  securityScoreRange: [number, number];
  performanceScoreRange: [number, number];
}
```

### Code Analysis Components

#### CodeAnalyzer Component
```typescript
interface CodeAnalyzerProps {
  programAddress: string;
  codeData: ProgramCode;
  onPatternDetected: (pattern: CodePattern) => void;
}

interface DisassemblyInstruction {
  address: string;
  opcode: string;
  operands: string[];
  bytes: number[];
  comment?: string;
  jumpTarget?: string;
  references: Reference[];
}

interface ControlFlowNode {
  id: string;
  address: string;
  instructions: DisassemblyInstruction[];
  successors: string[];
  predecessors: string[];
  type: 'basic_block' | 'function_entry' | 'function_exit' | 'branch' | 'loop';
}

interface CodePattern {
  type: 'vulnerability' | 'optimization' | 'best_practice' | 'anti_pattern';
  name: string;
  description: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  locations: CodeLocation[];
  recommendation: string;
}
```

#### DisassemblyViewer Component
```typescript
interface DisassemblyViewerProps {
  disassembly: DisassemblyInstruction[];
  hexDump: string;
  controlFlowGraph: ControlFlowNode[];
  onNavigate: (address: string) => void;
}

interface DisassemblyViewerState {
  currentAddress: string;
  highlightedInstructions: string[];
  showHexDump: boolean;
  showControlFlow: boolean;
  searchQuery: string;
  bookmarks: string[];
}

interface NavigationFeatures {
  jumpToAddress: (address: string) => void;
  searchInCode: (query: string) => SearchResult[];
  highlightInstruction: (address: string) => void;
  addBookmark: (address: string, label: string) => void;
  findReferences: (address: string) => Reference[];
}
```

### Security Analysis Components

#### SecurityAnalyzer Component
```typescript
interface SecurityAnalyzerProps {
  programData: ProgramData;
  securityAnalysis: SecurityAnalysis;
  onVulnerabilityFound: (vulnerability: Vulnerability) => void;
}

interface SecurityAnalysis {
  riskScore: number; // 0-100
  riskLevel: 'low' | 'medium' | 'high' | 'critical';
  vulnerabilities: Vulnerability[];
  auditReports: AuditReport[];
  upgradeability: UpgradeabilityInfo;
  permissions: Permission[];
  codeQuality: CodeQualityMetrics;
}

interface Vulnerability {
  id: string;
  type: 'buffer_overflow' | 'integer_overflow' | 'reentrancy' | 'access_control' | 'logic_error';
  severity: 'low' | 'medium' | 'high' | 'critical';
  location: CodeLocation;
  description: string;
  impact: string;
  recommendation: string;
  cwe?: string; // Common Weakness Enumeration
  cvss?: number; // Common Vulnerability Scoring System
}

interface AuditReport {
  auditor: string;
  date: number;
  version: string;
  findings: AuditFinding[];
  overallRating: 'pass' | 'conditional_pass' | 'fail';
  reportUrl?: string;
}
```

### Performance Analysis Components

#### PerformanceAnalyzer Component
```typescript
interface PerformanceAnalyzerProps {
  programAddress: string;
  performanceMetrics: PerformanceMetrics;
  onOptimizationFound: (optimization: OptimizationSuggestion) => void;
}

interface PerformanceMetrics {
  computeUnitsAverage: number;
  computeUnitsMedian: number;
  computeUnitsP95: number;
  executionTimeAverage: number;
  successRate: number;
  errorRate: number;
  throughput: number;
  resourceUsage: ResourceUsage;
  trends: PerformanceTrend[];
}

interface ResourceUsage {
  memoryUsage: number;
  storageUsage: number;
  networkActivity: number;
  cpuUtilization: number;
}

interface OptimizationSuggestion {
  type: 'compute_optimization' | 'memory_optimization' | 'storage_optimization' | 'algorithm_improvement';
  description: string;
  potentialSavings: number; // Estimated compute unit savings
  difficulty: 'easy' | 'medium' | 'hard';
  codeLocation?: CodeLocation;
  example?: string;
}
```

### Analytics Components

#### InstructionAnalytics Component
```typescript
interface InstructionAnalyticsProps {
  programAddress: string;
  instructionData: InstructionData[];
  usageMetrics: InstructionUsageMetrics;
}

interface InstructionData {
  discriminator: string;
  name: string;
  usage: InstructionUsage;
  parameters: InstructionParameter[];
  accounts: AccountRequirement[];
  computeUnits: ComputeUnitMetrics;
}

interface InstructionUsage {
  totalCalls: number;
  uniqueCallers: number;
  averageComputeUnits: number;
  successRate: number;
  last24h: number;
  trend: 'increasing' | 'decreasing' | 'stable';
  callerDistribution: CallerStats[];
}

interface ComputeUnitMetrics {
  average: number;
  median: number;
  p95: number;
  min: number;
  max: number;
  trend: number[]; // Historical data points
}
```

#### AccountOwnershipAnalyzer Component
```typescript
interface AccountOwnershipAnalyzerProps {
  programAddress: string;
  ownedAccounts: OwnedAccount[];
  accountRelationships: AccountRelationship[];
}

interface OwnedAccount {
  address: string;
  type: 'data' | 'executable' | 'system';
  size: number;
  lamports: number;
  lastModified: number;
  dataHash?: string;
  dataStructure?: DataStructure;
  accessPattern: AccessPattern;
}

interface AccountRelationship {
  fromAccount: string;
  toAccount: string;
  relationshipType: 'references' | 'owns' | 'delegates' | 'inherits';
  strength: number; // 0-100
  lastInteraction: number;
}

interface DataStructure {
  fields: DataField[];
  size: number;
  alignment: number;
  version?: number;
}
```

## Data Models

### Program Analysis Data Models
```typescript
interface ProgramInteraction {
  signature: string;
  caller: string;
  instruction: string;
  timestamp: number;
  computeUnits: number;
  success: boolean;
  accounts: string[];
  data: any;
}

interface ProgramDependency {
  address: string;
  name?: string;
  type: 'library' | 'program' | 'system';
  version?: string;
  relationship: 'imports' | 'calls' | 'inherits';
  critical: boolean;
}

interface ProgramMetrics {
  totalTransactions: number;
  uniqueUsers: number;
  totalComputeUnits: number;
  averageComputePerTx: number;
  successRate: number;
  growthRate: number;
  activityLevel: 'inactive' | 'low' | 'moderate' | 'high';
  rank: number;
}
```

### Security Data Models
```typescript
interface CodeQualityMetrics {
  complexity: number; // Cyclomatic complexity
  maintainability: number; // 0-100
  testCoverage: number; // 0-100
  documentation: number; // 0-100
  bestPractices: number; // 0-100
  codeSmells: CodeSmell[];
}

interface CodeSmell {
  type: string;
  severity: 'minor' | 'major' | 'critical';
  location: CodeLocation;
  description: string;
  suggestion: string;
}

interface UpgradeabilityInfo {
  upgradeable: boolean;
  upgradeAuthority?: string;
  upgradeHistory: UpgradeEvent[];
  governanceModel?: string;
  riskLevel: 'low' | 'medium' | 'high';
}
```

## Qdrant Integration Design

### Vector Collections Structure

```typescript
interface ProgramVectorCollections {
  programs: 'program_vectors';
  code_patterns: 'code_pattern_vectors';
  security_signatures: 'security_vectors';
  performance_patterns: 'performance_vectors';
  instruction_patterns: 'instruction_vectors';
}

interface ProgramVector {
  id: string; // program address
  vector: number[]; // 512-dimensional embedding
  payload: {
    address: string;
    category: string;
    codeSize: number;
    instructionCount: number;
    complexityScore: number;
    securityScore: number;
    performanceScore: number;
    activityLevel: number;
    deployedAt: number;
    lastUpdated: number;
    dependencies: string[];
    features: string[];
  };
}

interface CodePatternVector {
  id: string; // unique pattern id
  vector: number[]; // Code pattern embedding
  payload: {
    patternType: 'vulnerability' | 'optimization' | 'best_practice';
    severity: number;
    programAddress: string;
    location: CodeLocation;
    description: string;
    confidence: number;
    detectedAt: number;
  };
}
```

### Vector Search Operations

```typescript
class ProgramVectorService {
  async findSimilarPrograms(programAddress: string, limit: number = 10): Promise<SimilarProgram[]> {
    const programVector = await this.getProgramVector(programAddress);
    
    const searchResult = await this.qdrantClient.search('program_vectors', {
      vector: programVector.vector,
      limit,
      filter: {
        must_not: [{ key: 'address', match: { value: programAddress } }]
      }
    });
    
    return searchResult.map(result => ({
      address: result.payload.address,
      similarity: result.score,
      reason: this.calculateSimilarityReason(programVector.payload, result.payload)
    }));
  }

  async detectCodePatterns(programAddress: string): Promise<CodePattern[]> {
    const codeData = await this.getProgramCode(programAddress);
    const codeVector = await this.generateCodeVector(codeData);
    
    const searchResult = await this.qdrantClient.search('code_pattern_vectors', {
      vector: codeVector,
      limit: 100,
      score_threshold: 0.8
    });
    
    return searchResult.map(result => ({
      type: result.payload.patternType,
      confidence: result.score,
      location: result.payload.location,
      description: result.payload.description,
      severity: result.payload.severity
    }));
  }
}
```

## Error Handling

### Error Types and Recovery

```typescript
enum ProgramExplorerErrorType {
  INVALID_ADDRESS = 'INVALID_ADDRESS',
  PROGRAM_NOT_FOUND = 'PROGRAM_NOT_FOUND',
  CODE_ANALYSIS_ERROR = 'CODE_ANALYSIS_ERROR',
  SECURITY_ANALYSIS_ERROR = 'SECURITY_ANALYSIS_ERROR',
  PERFORMANCE_ERROR = 'PERFORMANCE_ERROR',
  DISASSEMBLY_ERROR = 'DISASSEMBLY_ERROR',
  QDRANT_ERROR = 'QDRANT_ERROR'
}

class ProgramErrorHandler {
  static handleAddressError(address: string): ProgramExplorerError {
    if (!this.isValidProgramAddress(address)) {
      return {
        type: ProgramExplorerErrorType.INVALID_ADDRESS,
        message: `Invalid program address: ${address}`,
        retryable: false,
        suggestions: ['Check the address format', 'Search by program name instead']
      };
    }
  }

  static handleCodeAnalysisError(error: any): ProgramExplorerError {
    return {
      type: ProgramExplorerErrorType.CODE_ANALYSIS_ERROR,
      message: 'Code analysis temporarily unavailable',
      retryable: true,
      retryAfter: 30000,
      fallback: 'basic_program_info'
    };
  }
}
```

## Testing Strategy

### Unit Testing Approach

```typescript
describe('ProgramAnalyzer', () => {
  describe('analyzeProgram', () => {
    it('should analyze program code correctly', async () => {
      const mockProgramData = createMockProgramData();
      const result = await ProgramAnalyzer.analyzeProgram(mockProgramData);
      
      expect(result.securityScore).toBeGreaterThan(0);
      expect(result.performanceScore).toBeGreaterThan(0);
      expect(result.codePatterns).toBeInstanceOf(Array);
    });

    it('should detect security vulnerabilities', async () => {
      const mockVulnerableProgram = createMockVulnerableProgram();
      const result = await ProgramAnalyzer.analyzeProgram(mockVulnerableProgram);
      
      expect(result.vulnerabilities.length).toBeGreaterThan(0);
      expect(result.riskLevel).toBe('high');
    });
  });

  describe('disassembleProgram', () => {
    it('should generate disassembly correctly', async () => {
      const mockBytecode = createMockBytecode();
      const result = await ProgramAnalyzer.disassembleProgram(mockBytecode);
      
      expect(result.instructions).toBeInstanceOf(Array);
      expect(result.controlFlowGraph).toBeDefined();
    });
  });
});
```

### Integration Testing Strategy

1. **API Integration Tests**: Test all program-related endpoints
2. **Qdrant Integration Tests**: Test vector search and storage
3. **Code Analysis Tests**: Test disassembly and pattern detection
4. **Security Analysis Tests**: Test vulnerability detection
5. **Performance Analysis Tests**: Test metrics calculation

## Performance Optimization

### Caching Strategy

```typescript
interface ProgramCacheConfig {
  programMetadata: {
    ttl: 3600000; // 1 hour
    strategy: 'background-refresh';
  };
  codeAnalysis: {
    ttl: 7200000; // 2 hours
    strategy: 'lazy-refresh';
  };
  securityAnalysis: {
    ttl: 1800000; // 30 minutes
    strategy: 'background-refresh';
  };
  performanceMetrics: {
    ttl: 300000; // 5 minutes
    strategy: 'real-time-update';
  };
  disassembly: {
    ttl: 86400000; // 24 hours
    strategy: 'immutable';
  };
}

class ProgramCacheManager {
  async getProgramData(address: string): Promise<ProgramData> {
    const cacheKey = `program:${address}`;
    const cached = await this.redis.get(cacheKey);
    
    if (cached) {
      this.backgroundRefresh(address);
      return JSON.parse(cached);
    }
    
    const data = await this.fetchProgramData(address);
    await this.redis.setex(cacheKey, 3600, JSON.stringify(data));
    
    return data;
  }
}
```

## Security Considerations

### Code Analysis Security

1. **Sandboxed Analysis**: Run code analysis in isolated environments
2. **Input Validation**: Validate all program addresses and parameters
3. **Resource Limits**: Implement timeouts and memory limits for analysis
4. **Audit Trails**: Log all analysis operations and results

### Data Protection

```typescript
class ProgramSecurityManager {
  static validateAnalysisInput(input: any): boolean {
    return this.sanitizeInput(input) && this.checkInputLimits(input);
  }
  
  static sanitizeDisassembly(disassembly: any): any {
    // Remove potentially sensitive information
    return this.filterSensitiveData(disassembly);
  }
  
  static auditAnalysisOperation(operation: string, user: string, program: string): void {
    this.logSecurityEvent({
      type: 'program_analysis',
      operation,
      user,
      program,
      timestamp: Date.now()
    });
  }
}
```

## Additional Features and Enhancements

### Program Comparison and Benchmarking

```typescript
interface ProgramComparison {
  programs: string[]; // Up to 5 programs
  metrics: ComparisonMetric[];
  benchmarks: BenchmarkResult[];
  recommendations: ComparisonInsight[];
}

interface ComparisonMetric {
  name: string;
  values: number[];
  unit: string;
  trend: 'higher_better' | 'lower_better';
}

interface BenchmarkResult {
  category: string;
  leader: string;
  scores: { [programAddress: string]: number };
  insights: string[];
}
```

### Program Version History and Change Tracking

```typescript
interface ProgramVersionHistory {
  versions: ProgramVersion[];
  changeLog: ChangeLogEntry[];
  migrationGuide?: MigrationGuide;
  deprecationNotices: DeprecationNotice[];
}

interface ProgramVersion {
  version: string;
  deployedAt: number;
  codeHash: string;
  changes: CodeChange[];
  breakingChanges: boolean;
  securityImpact: 'none' | 'low' | 'medium' | 'high';
}

interface CodeChange {
  type: 'addition' | 'modification' | 'deletion';
  location: CodeLocation;
  description: string;
  impact: string;
}
```

### Developer Tools and IDE Integration

```typescript
interface DeveloperTools {
  codeExport: CodeExportOptions;
  ideIntegration: IDEPlugin[];
  testingTools: TestingFramework[];
  debuggingTools: DebuggerInterface;
}

interface CodeExportOptions {
  formats: ('rust' | 'c' | 'assembly' | 'json')[];
  includeComments: boolean;
  includeMetadata: boolean;
  optimizationLevel: 'none' | 'basic' | 'aggressive';
}

interface TestingFramework {
  name: string;
  testCases: TestCase[];
  coverage: CoverageReport;
  fuzzingResults: FuzzingResult[];
}
```

### Community Features and Social Integration

```typescript
interface ProgramCommunity {
  discussions: Discussion[];
  reviews: ProgramReview[];
  contributions: CommunityContribution[];
  expertAnalysis: ExpertAnalysis[];
}

interface ProgramReview {
  reviewer: string;
  rating: number; // 1-5 stars
  aspects: {
    security: number;
    performance: number;
    codeQuality: number;
    documentation: number;
  };
  review: string;
  timestamp: number;
  helpful: number; // Helpful votes
}

interface ExpertAnalysis {
  expert: string;
  credentials: string[];
  analysis: string;
  recommendations: string[];
  riskAssessment: string;
  timestamp: number;
}
```

### Advanced Analytics and Machine Learning

```typescript
interface MLAnalytics {
  anomalyDetection: AnomalyReport[];
  predictiveAnalysis: PredictiveInsight[];
  patternRecognition: PatternAnalysis[];
  riskPrediction: RiskPrediction;
}

interface AnomalyReport {
  type: 'performance' | 'security' | 'usage' | 'behavior';
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  detectedAt: number;
  confidence: number;
  recommendation: string;
}

interface PredictiveInsight {
  metric: string;
  prediction: number;
  timeframe: string;
  confidence: number;
  factors: PredictionFactor[];
}
```

### Program Ecosystem Mapping

```typescript
interface EcosystemMap {
  programClusters: ProgramCluster[];
  interactionNetwork: InteractionEdge[];
  ecosystemHealth: EcosystemMetrics;
  influenceMap: InfluenceNode[];
}

interface ProgramCluster {
  id: string;
  programs: string[];
  category: string;
  centralProgram: string;
  cohesionScore: number;
  description: string;
}

interface InteractionEdge {
  from: string;
  to: string;
  interactionType: 'calls' | 'inherits' | 'composes' | 'depends';
  frequency: number;
  strength: number;
}
```

### Real-time Monitoring and Alerting

```typescript
interface RealTimeMonitoring {
  liveMetrics: LiveMetric[];
  alerts: ProgramAlert[];
  healthStatus: HealthStatus;
  performanceStream: PerformanceEvent[];
}

interface ProgramAlert {
  id: string;
  type: 'performance_degradation' | 'security_issue' | 'unusual_activity' | 'error_spike';
  severity: 'info' | 'warning' | 'error' | 'critical';
  message: string;
  timestamp: number;
  acknowledged: boolean;
  actions: AlertAction[];
}

interface HealthStatus {
  overall: 'healthy' | 'warning' | 'critical';
  components: {
    performance: HealthComponent;
    security: HealthComponent;
    availability: HealthComponent;
    usage: HealthComponent;
  };
  lastUpdated: number;
}
```

## Monitoring and Analytics

### Performance Monitoring

1. **Analysis Performance**: Track code analysis and disassembly times
2. **API Response Times**: Monitor all program-related endpoints
3. **Qdrant Performance**: Track vector search response times
4. **Security Scan Performance**: Monitor vulnerability detection times
5. **User Engagement**: Track feature usage and user interactions
6. **Real-time Metrics**: Monitor program health and performance in real-time
7. **Predictive Analytics**: Use ML to predict performance issues and optimization opportunities

### Business Analytics

1. **Program Discovery**: Track which programs are most viewed
2. **Analysis Usage**: Monitor which analysis features are most used
3. **Security Insights**: Track security issues discovered
4. **Performance Trends**: Monitor program performance over time
5. **Community Engagement**: Track reviews, discussions, and expert analysis
6. **Ecosystem Evolution**: Monitor program ecosystem changes and trends

### Advanced Features Integration

1. **Program Comparison Dashboard**: Side-by-side program analysis and benchmarking
2. **Version Control Integration**: Track program changes and provide migration guides
3. **Developer Toolchain**: Export tools, IDE plugins, and testing frameworks
4. **Community Platform**: Reviews, discussions, and expert analysis
5. **ML-Powered Insights**: Anomaly detection, predictive analysis, and pattern recognition
6. **Ecosystem Visualization**: Program relationship mapping and influence analysis
7. **Real-time Monitoring**: Live metrics, alerts, and health status tracking

This comprehensive design provides a robust foundation for implementing the program explorer enhancements with advanced code analysis, security assessment, performance monitoring, community features, and cutting-edge analytics capabilities.
---

## File: ./.kiro/specs/program-explorer-enhancements/requirements.md

# Program Explorer Enhancements Requirements

## Introduction

This specification defines the requirements for enhancing the program explorer functionality in OpenSVM, covering individual program details, code analysis, instruction usage analytics, account ownership analysis, and security assessment. The program explorer is essential for developers, auditors, and researchers to understand Solana programs, analyze their behavior, and assess their security and performance.

## Requirements

### Requirement 1: Individual Program Detail Page

**User Story:** As a Solana developer, I want to view comprehensive information about a specific program, so that I can understand its functionality, analyze its code, and assess its security.

#### Acceptance Criteria

1. WHEN a user navigates to `/program/[address]` with a valid program address THEN the system SHALL display comprehensive program information including metadata, code analysis, instruction usage, account ownership, and security assessment
2. WHEN a user provides an invalid program address THEN the system SHALL display a 404 error page with suggestions for valid program searches
3. WHEN program data is loading THEN the system SHALL show progressive loading states for different sections (metadata, code, instructions, accounts)
4. WHEN program metadata is unavailable THEN the system SHALL show fallback information using on-chain data and code analysis
5. WHEN a user views program details THEN the system SHALL provide links to related programs and dependencies
6. WHEN code analysis is displayed THEN the system SHALL show disassembly, hex dump, and control flow visualization
7. WHEN instruction usage is shown THEN the system SHALL display usage statistics and performance metrics
8. WHEN account ownership is displayed THEN the system SHALL show owned accounts and their relationships

### Requirement 2: Program Code Analysis and Visualization

**User Story:** As a security auditor, I want to analyze program code with disassembly and visualization tools, so that I can understand program logic and identify potential security issues.

#### Acceptance Criteria

1. WHEN viewing program code THEN the system SHALL display hex dump with address offsets and byte highlighting
2. WHEN disassembly is shown THEN the system SHALL provide assembly code with instruction highlighting and jump target identification
3. WHEN control flow is analyzed THEN the system SHALL generate control flow graphs showing program execution paths
4. WHEN code navigation is used THEN the system SHALL support jump-to-address, search within code, and instruction highlighting
5. WHEN code patterns are detected THEN the system SHALL identify common patterns and potential vulnerabilities
6. WHEN code is exported THEN the system SHALL provide export functionality for disassembly and analysis results
7. WHEN code analysis fails THEN the system SHALL show appropriate error messages and retry options
8. WHEN large programs are analyzed THEN the system SHALL implement pagination and virtual scrolling for performance

### Requirement 3: Instruction Usage Analytics

**User Story:** As a program analyst, I want to see detailed instruction usage statistics and performance metrics, so that I can understand program behavior and optimize performance.

#### Acceptance Criteria

1. WHEN instruction analytics are displayed THEN the system SHALL show usage statistics for each instruction type
2. WHEN performance metrics are calculated THEN the system SHALL display average compute units, success rates, and execution times
3. WHEN usage trends are analyzed THEN the system SHALL show instruction usage over time with trend indicators
4. WHEN caller analysis is performed THEN the system SHALL identify unique callers and usage patterns
5. WHEN instruction comparison is done THEN the system SHALL compare instruction performance across different programs
6. WHEN usage alerts are configured THEN the system SHALL notify users of significant usage changes
7. WHEN analytics are exported THEN the system SHALL provide detailed analytics reports in multiple formats
8. WHEN real-time usage is tracked THEN the system SHALL update instruction statistics with live data

### Requirement 4: Account Ownership Analysis

**User Story:** As a blockchain researcher, I want to analyze accounts owned by programs and their relationships, so that I can understand program ecosystem and data structures.

#### Acceptance Criteria

1. WHEN account ownership is analyzed THEN the system SHALL display all accounts owned by the program
2. WHEN account types are classified THEN the system SHALL categorize accounts by type (data, executable, system)
3. WHEN account relationships are mapped THEN the system SHALL show relationships between owned accounts
4. WHEN account activity is tracked THEN the system SHALL display account modification history and patterns
5. WHEN account data is analyzed THEN the system SHALL parse and display account data structures where possible
6. WHEN account search is used THEN the system SHALL support filtering and searching within owned accounts
7. WHEN account export is performed THEN the system SHALL provide account data export functionality
8. WHEN account monitoring is enabled THEN the system SHALL track changes to owned accounts in real-time

### Requirement 5: Program Interaction History and Patterns

**User Story:** As a DeFi analyst, I want to analyze program interaction history and identify usage patterns, so that I can understand program adoption and ecosystem integration.

#### Acceptance Criteria

1. WHEN interaction history is displayed THEN the system SHALL show recent program interactions with transaction details
2. WHEN usage patterns are analyzed THEN the system SHALL identify common interaction patterns and sequences
3. WHEN caller analysis is performed THEN the system SHALL show top callers and their interaction frequency
4. WHEN integration mapping is done THEN the system SHALL identify programs that interact with this program
5. WHEN usage metrics are calculated THEN the system SHALL show transaction volume, unique users, and growth metrics
6. WHEN seasonal patterns are detected THEN the system SHALL identify usage patterns over different time periods
7. WHEN interaction export is provided THEN the system SHALL export interaction data for further analysis
8. WHEN real-time monitoring is enabled THEN the system SHALL track new interactions and usage changes

### Requirement 6: Program Security Analysis and Audit Information

**User Story:** As a security researcher, I want to see security analysis and audit information for programs, so that I can assess program safety and identify potential risks.

#### Acceptance Criteria

1. WHEN security analysis is performed THEN the system SHALL check for common vulnerability patterns and security issues
2. WHEN audit information is available THEN the system SHALL display security audit results and findings
3. WHEN risk assessment is calculated THEN the system SHALL provide comprehensive risk scores and explanations
4. WHEN vulnerability detection is run THEN the system SHALL identify potential buffer overflows, integer overflows, and access control issues
5. WHEN upgrade analysis is performed THEN the system SHALL analyze program upgradeability and governance mechanisms
6. WHEN permission analysis is done THEN the system SHALL identify program permissions and potential privilege escalation risks
7. WHEN security alerts are configured THEN the system SHALL notify users of security issues and updates
8. WHEN security reports are generated THEN the system SHALL provide detailed security assessment reports

### Requirement 7: Program List and Discovery

**User Story:** As a developer, I want to browse and discover programs with activity metrics and filtering options, so that I can find relevant programs and analyze ecosystem trends.

#### Acceptance Criteria

1. WHEN visiting `/programs` THEN the system SHALL display a comprehensive list of programs with activity metrics
2. WHEN program list is sorted THEN the system SHALL support sorting by activity, transactions, users, and deployment date
3. WHEN programs are filtered THEN the system SHALL provide filters for program type, activity level, and verification status
4. WHEN program search is used THEN the system SHALL support search by address, name, and functionality
5. WHEN program categories are shown THEN the system SHALL group programs by type (DeFi, gaming, NFT, infrastructure)
6. WHEN activity metrics are displayed THEN the system SHALL show transaction counts, user counts, and growth trends
7. WHEN new programs are highlighted THEN the system SHALL show recently deployed programs with deployment metrics
8. WHEN program list is exported THEN the system SHALL provide export functionality with current activity data

### Requirement 8: Program Performance Metrics and Optimization

**User Story:** As a performance engineer, I want to see detailed performance metrics and optimization suggestions for programs, so that I can improve program efficiency and reduce costs.

#### Acceptance Criteria

1. WHEN performance metrics are displayed THEN the system SHALL show compute unit consumption, execution times, and efficiency scores
2. WHEN optimization suggestions are provided THEN the system SHALL identify potential performance improvements and cost reductions
3. WHEN performance trends are analyzed THEN the system SHALL show performance changes over time and identify degradation
4. WHEN benchmarking is performed THEN the system SHALL compare program performance against similar programs
5. WHEN resource usage is tracked THEN the system SHALL monitor memory usage, storage consumption, and network activity
6. WHEN performance alerts are configured THEN the system SHALL notify users of performance issues and anomalies
7. WHEN optimization reports are generated THEN the system SHALL provide detailed performance analysis and recommendations
8. WHEN performance monitoring is enabled THEN the system SHALL track performance metrics in real-time

### Requirement 9: Program Dependencies and Integration Analysis

**User Story:** As a system architect, I want to analyze program dependencies and integrations, so that I can understand program relationships and ecosystem architecture.

#### Acceptance Criteria

1. WHEN dependency analysis is performed THEN the system SHALL identify programs and libraries that this program depends on
2. WHEN integration mapping is done THEN the system SHALL show programs that integrate with or call this program
3. WHEN dependency graphs are generated THEN the system SHALL visualize program dependency relationships
4. WHEN version tracking is enabled THEN the system SHALL track program versions and upgrade dependencies
5. WHEN impact analysis is performed THEN the system SHALL assess the impact of program changes on dependent systems
6. WHEN ecosystem mapping is done THEN the system SHALL show the program's role in the broader Solana ecosystem
7. WHEN dependency alerts are configured THEN the system SHALL notify users of dependency changes and updates
8. WHEN integration export is provided THEN the system SHALL export dependency and integration data for analysis

### Requirement 10: Program Development and Deployment Analytics

**User Story:** As a project manager, I want to track program development activity and deployment patterns, so that I can understand development trends and project health.

#### Acceptance Criteria

1. WHEN development activity is tracked THEN the system SHALL monitor program updates, deployments, and code changes
2. WHEN deployment analytics are shown THEN the system SHALL display deployment frequency, success rates, and rollback patterns
3. WHEN developer activity is analyzed THEN the system SHALL identify development teams and contribution patterns
4. WHEN version history is displayed THEN the system SHALL show program version history and change logs
5. WHEN development metrics are calculated THEN the system SHALL show development velocity, bug fix rates, and feature additions
6. WHEN project health is assessed THEN the system SHALL provide project health scores based on development activity
7. WHEN development alerts are configured THEN the system SHALL notify users of development milestones and issues
8. WHEN development reports are generated THEN the system SHALL provide comprehensive development analytics reports

### Requirement 11: Program Documentation and Educational Resources

**User Story:** As a developer learning Solana, I want to access program documentation and educational resources, so that I can understand how programs work and learn from examples.

#### Acceptance Criteria

1. WHEN documentation is available THEN the system SHALL display program documentation, README files, and API references
2. WHEN educational content is provided THEN the system SHALL offer tutorials, examples, and best practices
3. WHEN code examples are shown THEN the system SHALL provide interactive code examples and usage patterns
4. WHEN learning paths are available THEN the system SHALL suggest learning resources based on program complexity
5. WHEN community content is integrated THEN the system SHALL show community-contributed documentation and guides
6. WHEN documentation search is used THEN the system SHALL support searching within documentation and resources
7. WHEN documentation export is provided THEN the system SHALL allow downloading documentation for offline use
8. WHEN documentation updates are tracked THEN the system SHALL notify users of documentation changes and additions

### Requirement 12: Program Testing and Validation Tools

**User Story:** As a QA engineer, I want to test and validate program functionality, so that I can ensure program correctness and identify potential issues.

#### Acceptance Criteria

1. WHEN testing tools are provided THEN the system SHALL offer program testing interfaces and validation tools
2. WHEN test cases are generated THEN the system SHALL create automated test cases based on program analysis
3. WHEN validation is performed THEN the system SHALL validate program inputs, outputs, and state changes
4. WHEN fuzzing is enabled THEN the system SHALL provide fuzzing tools to test program robustness
5. WHEN test results are displayed THEN the system SHALL show test execution results and coverage metrics
6. WHEN regression testing is performed THEN the system SHALL compare program behavior across different versions
7. WHEN test reports are generated THEN the system SHALL provide comprehensive testing and validation reports
8. WHEN continuous testing is enabled THEN the system SHALL monitor program behavior and detect regressions

### Requirement 13: Data Storage and Vector Search Integration

**User Story:** As a system architect, I want all processed program analytics data to be stored in Qdrant for efficient vector search and similarity analysis, so that the system can provide fast recommendations and complex queries.

#### Acceptance Criteria

1. WHEN program analytics are processed THEN the system SHALL store all processed data (code analysis, instruction usage, security assessment, performance metrics) in Qdrant collections
2. WHEN program similarity is calculated THEN the system SHALL use Qdrant vector embeddings to find similar programs based on functionality and characteristics
3. WHEN security analysis is performed THEN the system SHALL store security patterns and vulnerability signatures as vectors in Qdrant
4. WHEN performance analysis is completed THEN the system SHALL store performance patterns and optimization opportunities in Qdrant for fast lookup
5. WHEN program recommendations are generated THEN the system SHALL use Qdrant similarity search to find related programs and dependencies
6. WHEN code patterns are analyzed THEN the system SHALL store code patterns and architectural patterns as searchable vectors
7. WHEN data is queried THEN the system SHALL use Qdrant's filtering and search capabilities for complex analytics queries
8. WHEN data is updated THEN the system SHALL maintain data consistency between Qdrant and other storage systems

### Requirement 14: Performance Optimization and Caching

**User Story:** As a system administrator, I want the program explorer to perform efficiently under high load, so that users experience fast response times and reliable service.

#### Acceptance Criteria

1. WHEN program data is cached THEN the system SHALL implement appropriate caching strategies for different data types
2. WHEN real-time updates are provided THEN the system SHALL optimize for minimal latency and resource usage
3. WHEN large datasets are handled THEN the system SHALL implement pagination and virtual scrolling
4. WHEN API responses are optimized THEN the system SHALL minimize response sizes and implement compression
5. WHEN database queries are executed THEN the system SHALL use efficient indexing and query optimization
6. WHEN CDN is utilized THEN the system SHALL cache static assets and optimize global delivery
7. WHEN performance monitoring is implemented THEN the system SHALL track response times and system health
8. WHEN scaling is required THEN the system SHALL support horizontal scaling and load balancing

### Requirement 15: Mobile Optimization and Accessibility

**User Story:** As a mobile user with accessibility needs, I want the program explorer to work seamlessly on mobile devices and with assistive technologies, so that I can access program information anywhere.

#### Acceptance Criteria

1. WHEN using mobile devices THEN the system SHALL provide responsive design optimized for touch interaction
2. WHEN accessibility features are used THEN the system SHALL support screen readers and keyboard navigation
3. WHEN mobile performance is optimized THEN the system SHALL minimize data usage and loading times
4. WHEN touch gestures are implemented THEN the system SHALL support swipe navigation and touch-friendly controls
5. WHEN offline functionality is provided THEN the system SHALL cache essential data for offline viewing
6. WHEN mobile-specific features are used THEN the system SHALL integrate with device capabilities (notifications, sharing)
7. WHEN accessibility standards are met THEN the system SHALL comply with WCAG 2.1 AA guidelines
8. WHEN mobile testing is performed THEN the system SHALL work across different devices and browsers
---

## File: ./.kiro/specs/program-explorer-enhancements/tasks.md

# Program Explorer Enhancements Implementation Plan

- [ ] 1. Set up core program data infrastructure and Qdrant integration
  - Create program data types and interfaces for comprehensive program information
  - Implement Qdrant collections for program vectors, code patterns, and similarity analysis
  - Set up API endpoints for program fetching, analysis, and real-time updates
  - Configure caching layer with appropriate TTL strategies for different data types
  - _Requirements: 1.1, 13.1, 13.2, 14.1, 14.2_

- [ ] 1.1 Create program data models and TypeScript interfaces
  - Create `lib/types/program.types.ts` with comprehensive ProgramData interface including address, metadata, code, instructions[], accounts[], interactions[], security, metrics, dependencies[], performance, documentation
  - Define ProgramMetadata interface with name, description, version, author, repository, documentation, verified, deployedAt, lastUpdated, upgradeAuthority, category, tags[]
  - Create ProgramCode interface with size, hash, disassembly[], hexDump, entryPoints[], dependencies[], controlFlowGraph[], codePatterns[]
  - Implement SecurityAnalysis interface with riskScore, riskLevel, vulnerabilities[], auditReports[], upgradeability, permissions[], codeQuality
  - Define PerformanceMetrics interface with computeUnitsAverage, computeUnitsMedian, computeUnitsP95, executionTimeAverage, successRate, errorRate, throughput, resourceUsage, trends[]
  - Create InstructionData interface with discriminator, name, usage, parameters[], accounts[], computeUnits
  - Add OwnedAccount interface with address, type, size, lamports, lastModified, dataHash, dataStructure, accessPattern
  - Implement SimilarityAnalysis interfaces with SimilarProgram, BytecodeOverlap, FunctionMatch, InstructionSimilarity, SemanticSimilarity
  - Create ProgramCluster interface with id, programs[], centralProgram, averageSimilarity, clusterType, commonFeatures[], description, cohesionScore, separationScore
  - _Requirements: 1.1, 2.1, 3.1, 4.1, 5.1, 6.1, 8.1, 9.1_

- [ ] 1.2 Set up Qdrant vector database integration for program analysis
  - Create `lib/qdrant/program-vectors.ts` with QdrantProgramService class implementing createCollections(), storeProgramVector(), searchSimilarPrograms(), storeCodePattern(), searchCodePatterns(), storeSimilarityVector() methods
  - Configure Qdrant collections: program_vectors (512-dim embeddings with payload: address, category, codeSize, instructionCount, complexityScore, securityScore, performanceScore, activityLevel, deployedAt, lastUpdated, dependencies[], features[]), code_pattern_vectors (code pattern embeddings with patternType, severity, programAddress, location, description, confidence, detectedAt), bytecode_similarity (bytecode embeddings for similarity search), semantic_similarity (semantic behavior embeddings), transaction_patterns (transaction pattern vectors)
  - Implement vector generation using OpenAI embeddings API for program characteristics, code patterns, bytecode similarity, and semantic behavior
  - Create vector search operations with filtering capabilities for similar program discovery, code pattern matching, and cluster analysis
  - Add vector upsert operations for real-time updates when program data changes
  - Implement similarity scoring algorithms for bytecode overlap, semantic similarity, and functional equivalence
  - _Requirements: 13.1, 13.2, 13.3, 13.4, 13.5, 13.6, 13.7, 13.8_- [ 
] 1.3 Implement core program API endpoints
  - Create `app/api/program/[address]/route.ts` with GET handler that validates program address using base58 validation and length checking, fetches program account data from Solana RPC using getAccountInfo() and getProgramAccounts(), processes program metadata and code using program analysis services, implements error handling for invalid addresses (return 404) and network errors (return 500 with retry headers)
  - Implement `app/api/programs/route.ts` with GET handler supporting query parameters: limit (default 50, max 100), offset (for pagination), sortBy (activity, transactions, users, deployedAt), filterBy (category, verified, activityLevel), search (name/address search), return ProgramListItem[] with address, name, category, verified, deployedAt, lastActivity, transactionCount, uniqueUsers, computeUnitsConsumed, successRate, securityScore, performanceScore
  - Add `app/api/programs/similarity/route.ts` with POST handler accepting targetProgram, similarityType, threshold, maxResults parameters, use Qdrant similarity search to find similar programs, return SimilarityAnalysisResult with similarPrograms[], analysisMetadata, clusters[], visualizationData
  - Create `app/api/programs/clusters/route.ts` with POST handler supporting clusteringAlgorithm, similarityThreshold, maxClusters parameters, perform program clustering using machine learning algorithms, return ClusterAnalysisResult with clusters[], outliers[], clusteringMetrics, visualizationData
  - Implement input validation using Zod schemas for all query parameters and path parameters
  - Add rate limiting using lib/rate-limiter.ts with different limits per endpoint (program detail: 200/min, program list: 500/min, similarity: 50/min, clustering: 10/min)
  - _Requirements: 1.1, 7.1, 7.2, 7.3, 7.4, 7.5, 7.6, 7.7, 7.8_

- [ ] 1.4 Set up program data caching system
  - Create `lib/cache/program-cache.ts` with ProgramCacheManager class implementing get/set/invalidate methods for different data types, use Redis for production with Map<string, CacheEntry> fallback for development
  - Configure cache TTL strategies: program metadata = 1 hour (rarely changes), code analysis = 2 hours (computationally expensive), security analysis = 30 minutes (important for safety), performance metrics = 5 minutes (real-time updates), disassembly = 24 hours (immutable unless upgraded), similarity analysis = 1 hour (expensive computation)
  - Implement cache key patterns: "program:{address}", "program:code:{address}", "program:security:{address}", "program:performance:{address}", "program:similarity:{address}:{type}", "programs:list:{params_hash}", "programs:clusters:{algorithm}:{threshold}"
  - Add cache warming for popular programs: pre-fetch and cache top 100 programs by activity on startup, implement background refresh job every 10 minutes for active programs
  - Create cache metrics tracking: hit/miss rates, memory usage, eviction counts, expose via /api/cache/metrics endpoint for monitoring
  - Implement cache invalidation triggers: invalidate program cache when new deployments detected, invalidate analysis cache when program upgrades occur, invalidate similarity cache when new similar programs are discovered
  - _Requirements: 14.1, 14.2, 14.3, 14.4, 14.5, 14.6, 14.7, 14.8_

- [ ] 2. Build program detail page with comprehensive information display
  - Create ProgramDetailsPage component with metadata, code analysis, security assessment, and performance monitoring
  - Implement progressive loading states and error handling for different data sections
  - Add tabbed interface for different analysis views and real-time updates
  - _Requirements: 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8_

- [ ] 2.1 Create ProgramDetailsPage main component
  - Create `app/program/[address]/page.tsx` as server component with generateMetadata() function for dynamic SEO, implement getProgramData() server function using fetch to /api/program/[address], handle loading states with Suspense wrapper
  - Build responsive layout using CSS Grid: header section (program info + quick stats), tab navigation (Overview | Code Analysis | Security | Performance | Dependencies), main content area with primary and secondary panels, sidebar with similar programs and quick actions
  - Implement tabbed navigation component in `components/ProgramTabs.tsx` with URL synchronization, lazy loading of tab content, keyboard navigation support, tab state management
  - Add error boundary wrapper using `components/ProgramErrorBoundary.tsx` to catch and display program not found (404) or network errors, implement retry button that refetches data
  - Create loading skeleton components matching final layout structure, use React Suspense with fallback showing skeleton for each section
  - Implement URL parameter validation: parse address from params, validate as base58 string with correct length, redirect invalid addresses to /programs with error message
  - _Requirements: 1.1, 1.2, 1.3_

- [ ] 2.2 Implement program metadata and quick stats display
  - Create `components/ProgramHeader.tsx` component displaying program icon/logo, name, verified badge, category, address (with copy button), deployment date, last updated, version, author, repository link, documentation link
  - Build `components/ProgramQuickStats.tsx` component showing key metrics: total transactions, unique users, success rate, security score, performance score, last activity, rank, with real-time updates and color coding
  - Create `components/ProgramMetadata.tsx` displaying detailed metadata: description, category and tags, deployment information, upgrade authority, governance model, with expandable sections for detailed information
  - Implement real-time updates using WebSocket connection for live metrics, show last update timestamp, implement update animations and notifications
  - Add copy-to-clipboard functionality for program address, upgrade authority, and other identifiers using navigator.clipboard API with fallback
  - Create sharing functionality: generate shareable program analysis links, social media integration, bookmark functionality
  - _Requirements: 1.1, 1.2, 1.3, 1.4, 1.5_

- [ ] 2.3 Build program overview tab with activity metrics and analytics
  - Create `components/ProgramOverview.tsx` with four-quadrant layout: program metadata panel, activity metrics panel, instruction analytics panel, account ownership panel
  - Implement `components/ActivityMetricsChart.tsx` using recharts library showing transaction volume over time, user growth chart, success rate trends, compute unit usage patterns, with multiple timeframe options (24h, 7d, 30d, 1y)
  - Add `components/InstructionAnalyticsTable.tsx` using @tanstack/react-table displaying top instructions with columns: instruction name, total calls, unique callers, average compute units, success rate, trend indicator, usage percentage
  - Create `components/AccountOwnershipDisplay.tsx` showing owned accounts list with account address, type (data/executable/system), size, lamports, last modified, with filtering and search capabilities
  - Implement real-time data updates for all metrics, show loading states during data fetching, handle empty states when no data available
  - Add export functionality for all analytics data: CSV export for instruction analytics, account ownership data, activity metrics with timestamps
  - _Requirements: 1.1, 3.1, 3.2, 3.3, 3.4, 3.5, 3.6, 3.7, 3.8, 4.1, 4.2, 4.3, 4.4, 4.5, 4.6, 4.7, 4.8, 5.1, 5.2, 5.3, 5.4, 5.5, 5.6, 5.7, 5.8_

- [ ] 3. Implement comprehensive code analysis and visualization system
  - Create code analysis engine with disassembly, hex dump, and control flow analysis
  - Build interactive code viewer with navigation, search, and pattern detection
  - Implement code pattern recognition and vulnerability detection
  - _Requirements: 2.1, 2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8_

- [ ] 3.1 Build code analysis engine
  - Create `lib/analyzers/code-analyzer.ts` with CodeAnalyzer class containing analyzeProgram(programAddress: string) method, fetch program bytecode using Solana RPC, implement disassembly using capstone.js or similar disassembler, generate hex dump with address offsets and byte highlighting
  - Implement control flow analysis: identify basic blocks and function boundaries, detect jump targets and branch instructions, generate control flow graph using graph algorithms, identify loops, conditionals, and function calls
  - Add code pattern detection: identify common vulnerability patterns (buffer overflows, integer overflows, reentrancy), detect optimization opportunities, recognize coding patterns and best practices, flag potential security issues
  - Create instruction analysis: parse assembly instructions and operands, identify instruction types and categories, calculate instruction frequency and usage patterns, detect unusual or suspicious instruction sequences
  - Implement function analysis: identify function entry and exit points, analyze function parameters and return values, calculate function complexity metrics, detect recursive functions and call chains
  - Store analysis results in Qdrant: create code pattern vectors for similar pattern detection, enable fast lookup of known code issues, implement pattern matching for new programs
  - _Requirements: 2.1, 2.2, 2.3, 2.4, 2.5_

- [ ] 3.2 Create interactive disassembly viewer
  - Create `components/DisassemblyViewer.tsx` with code viewer interface supporting hex dump view, disassembly view, control flow graph view, with toggle buttons and view synchronization
  - Implement `components/CodeNavigation.tsx` with search functionality (search within code, jump to address, find references), navigation controls (previous/next function, jump to target), bookmarking system (save important addresses, add notes)
  - Add `components/HexDumpDisplay.tsx` showing hex bytes with address offsets, byte highlighting on hover, ASCII representation, clickable bytes for detailed information
  - Build `components/AssemblyDisplay.tsx` with syntax highlighting for assembly instructions, operand highlighting, jump target identification, instruction tooltips with detailed information
  - Create `components/ControlFlowGraph.tsx` using D3.js or Cytoscape for graph visualization, interactive nodes and edges, zoom and pan functionality, node highlighting and selection
  - Implement code export functionality: export disassembly to text files, save control flow graphs as images, export analysis results as JSON, provide API for programmatic access
  - _Requirements: 2.1, 2.2, 2.3, 2.4, 2.6, 2.8_

- [ ] 3.3 Implement code pattern recognition and analysis
  - Create `lib/analyzers/pattern-detector.ts` with PatternDetector class implementing detectPatterns(disassembly: DisassemblyInstruction[]) method, use pattern matching algorithms to identify known code patterns, detect security vulnerabilities and optimization opportunities
  - Build vulnerability detection system: identify buffer overflow patterns, detect integer overflow conditions, recognize reentrancy vulnerabilities, flag access control issues, detect logic errors and edge cases
  - Add optimization detection: identify inefficient code patterns, detect redundant computations, recognize optimization opportunities, suggest performance improvements, calculate potential savings
  - Create code quality analysis: measure cyclomatic complexity, assess maintainability metrics, evaluate coding standards compliance, identify code smells and anti-patterns
  - Implement pattern visualization: highlight detected patterns in code viewer, provide pattern explanations and recommendations, show pattern severity and confidence levels, link to educational resources
  - Store pattern analysis in Qdrant: create pattern signature vectors for similar pattern detection, enable pattern-based program similarity, implement pattern clustering and analysis
  - _Requirements: 2.5, 2.6, 2.7, 2.8_-
 [ ] 4. Build comprehensive security analysis and assessment system
  - Create security analysis engine with vulnerability detection and risk scoring
  - Implement audit report integration and security metrics calculation
  - Build security visualization and reporting tools
  - _Requirements: 6.1, 6.2, 6.3, 6.4, 6.5, 6.6, 6.7, 6.8_

- [ ] 4.1 Build security analysis engine
  - Create `lib/analyzers/security-analyzer.ts` with SecurityAnalyzer class containing analyzeProgramSecurity(programData: ProgramData) method, implement comprehensive security assessment including vulnerability detection, risk scoring, and audit analysis
  - Implement vulnerability detection algorithms: buffer overflow detection using stack analysis, integer overflow detection in arithmetic operations, reentrancy detection in cross-program invocations, access control analysis for privilege escalation, logic error detection in conditional statements
  - Add risk scoring system: calculate overall risk score (0-100) based on multiple factors, weight vulnerabilities by severity and exploitability, consider program complexity and attack surface, factor in audit results and community feedback
  - Create audit report integration: fetch audit reports from major security firms, parse audit findings and recommendations, correlate audit results with automated analysis, track audit coverage and completeness
  - Implement upgradeability analysis: analyze upgrade authority and governance mechanisms, assess upgrade risks and centralization concerns, track upgrade history and patterns, evaluate governance token distribution
  - Store security analysis in Qdrant: create security pattern vectors for vulnerability detection, enable security-based program similarity, implement threat intelligence sharing
  - _Requirements: 6.1, 6.2, 6.3, 6.4, 6.5, 6.6, 6.7, 6.8_

- [ ] 4.2 Create security visualization and reporting components
  - Create `components/SecurityDashboard.tsx` with security score display (0-100 with color coding), risk level indicator (low/medium/high/critical), vulnerability summary with counts by severity, audit status and coverage metrics
  - Build `components/VulnerabilityList.tsx` using @tanstack/react-table displaying vulnerabilities with columns: type, severity, location, description, impact, recommendation, CWE/CVE references, with filtering and sorting capabilities
  - Implement `components/AuditReportsDisplay.tsx` showing audit reports from security firms, audit findings and recommendations, audit dates and versions, overall audit ratings, with links to full reports
  - Add `components/SecurityTrends.tsx` using recharts to show security score trends over time, vulnerability discovery and resolution rates, audit frequency and coverage, security improvement metrics
  - Create `components/UpgradeabilityAnalysis.tsx` displaying upgrade authority information, governance model analysis, upgrade history and patterns, centralization risk assessment
  - Implement security report generation: comprehensive security assessment reports, vulnerability details and remediation guidance, audit summary and recommendations, exportable PDF reports
  - _Requirements: 6.1, 6.2, 6.3, 6.4, 6.5, 6.6, 6.7, 6.8_

- [ ] 5. Implement performance analysis and optimization system
  - Create performance monitoring engine with metrics collection and analysis
  - Build performance visualization and optimization recommendation system
  - Implement performance benchmarking and comparison tools
  - _Requirements: 8.1, 8.2, 8.3, 8.4, 8.5, 8.6, 8.7, 8.8_

- [ ] 5.1 Build performance analysis engine
  - Create `lib/analyzers/performance-analyzer.ts` with PerformanceAnalyzer class implementing analyzePerformance(programAddress: string) method, collect performance metrics from transaction history, calculate compute unit statistics, analyze execution times and success rates
  - Implement metrics calculation: average, median, and P95 compute unit consumption, execution time distribution and trends, success rate and error analysis, throughput and transaction volume metrics, resource usage patterns
  - Add performance trend analysis: identify performance degradation over time, detect performance anomalies and spikes, analyze seasonal patterns and usage cycles, correlate performance with network conditions
  - Create optimization detection: identify performance bottlenecks in code, detect inefficient algorithms and data structures, recognize optimization opportunities, estimate potential performance improvements
  - Implement benchmarking system: compare performance against similar programs, establish performance baselines and targets, track performance improvements over time, generate performance rankings
  - Store performance data in Qdrant: create performance pattern vectors for similar performance analysis, enable performance-based program recommendations, implement performance clustering
  - _Requirements: 8.1, 8.2, 8.3, 8.4, 8.5, 8.6, 8.7, 8.8_

- [ ] 5.2 Create performance visualization and optimization components
  - Create `components/PerformanceOverview.tsx` with performance metrics dashboard showing average compute units, P95 compute units, success rate, throughput, with real-time updates and trend indicators
  - Build `components/PerformanceCharts.tsx` using recharts library displaying compute units over time, success rate trends, execution time distribution, resource usage breakdown, with multiple timeframe options
  - Implement `components/OptimizationSuggestions.tsx` showing optimization opportunities ranked by impact, potential compute unit savings, implementation difficulty, code locations, with detailed explanations and examples
  - Add `components/InstructionPerformance.tsx` using @tanstack/react-table displaying instruction-level performance metrics: instruction type, average compute units, call frequency, performance percentage, with sorting and filtering
  - Create `components/ResourceUsageDisplay.tsx` showing memory usage, storage consumption, network activity, CPU utilization, with usage limits and optimization recommendations
  - Implement performance report generation: detailed performance analysis reports, optimization recommendations and implementation guides, benchmarking results and comparisons, exportable performance data
  - _Requirements: 8.1, 8.2, 8.3, 8.4, 8.5, 8.6, 8.7, 8.8_

- [ ] 6. Build program similarity analysis and clustering system
  - Create similarity analysis engine with bytecode and semantic comparison
  - Implement program clustering algorithms and visualization
  - Build similarity search interface and results display
  - _Requirements: Custom requirement for similarity analysis based on user request_

- [ ] 6.1 Build program similarity analysis engine
  - Create `lib/analyzers/similarity-analyzer.ts` with SimilarityAnalyzer class implementing analyzeSimilarity(targetProgram: string, similarityType: SimilarityType) method, support multiple similarity types (bytecode, semantic, functional, behavioral, structural)
  - Implement bytecode similarity analysis: compare raw bytecode using sequence alignment algorithms, calculate bytecode overlap percentages, identify identical code sequences, detect code modifications and variations, use fuzzy hashing for approximate matching
  - Add semantic similarity analysis: analyze transaction patterns and behavior, compare program functionality and use cases, evaluate API compatibility and interface similarity, assess functional equivalence using symbolic execution
  - Create function-level similarity: identify identical functions using hash comparison, detect similar functions with minor modifications, analyze function call graphs and dependencies, compare function complexity and structure
  - Implement instruction pattern matching: compare instruction sequences and patterns, detect similar algorithmic approaches, identify common code libraries and templates, analyze control flow similarities
  - Store similarity vectors in Qdrant: create bytecode embeddings for fast similarity search, generate semantic behavior vectors, implement similarity indexing for efficient queries, enable real-time similarity updates
  - _Requirements: Custom requirement for bytecode and semantic similarity analysis_

- [ ] 6.2 Implement program clustering algorithms
  - Create `lib/clustering/program-clusterer.ts` with ProgramClusterer class implementing clusterPrograms(programs: string[], algorithm: ClusteringAlgorithm) method, support multiple clustering algorithms (K-means, hierarchical, DBSCAN, spectral clustering)
  - Implement K-means clustering: determine optimal number of clusters using elbow method, initialize cluster centroids using K-means++, iterate until convergence with configurable tolerance, handle outliers and noise
  - Add hierarchical clustering: build dendrogram using linkage criteria (single, complete, average), support agglomerative and divisive approaches, enable cluster cutting at different similarity thresholds, visualize cluster hierarchy
  - Create DBSCAN clustering: identify dense regions and outliers, configure epsilon and minimum points parameters, handle varying cluster densities, detect arbitrary cluster shapes
  - Implement cluster validation: calculate silhouette scores for cluster quality, compute Davies-Bouldin index for cluster separation, measure Calinski-Harabasz index for cluster cohesion, assess cluster stability
  - Add cluster analysis: identify cluster characteristics and common features, determine central programs for each cluster, calculate intra-cluster and inter-cluster similarities, generate cluster descriptions
  - Store clustering results in Qdrant: create cluster vectors for cluster-based search, enable cluster membership queries, implement cluster evolution tracking
  - _Requirements: Custom requirement for program clustering and analysis_

- [ ] 6.3 Create similarity search and clustering interfaces
  - Create `app/programs/similarity/page.tsx` with similarity search interface, target program input with validation, similarity type selection (bytecode/semantic/functional), threshold slider, max results configuration
  - Build `components/SimilaritySearchForm.tsx` with program address input with autocomplete, similarity type radio buttons, threshold range slider (0.1-1.0), advanced options (max results, filter criteria), search button with loading states
  - Implement `components/SimilarityResults.tsx` using @tanstack/react-table displaying similar programs with columns: program address, similarity score, relationship type, match details, last analyzed, with sorting and filtering
  - Add `components/SimilarityVisualization.tsx` using D3.js or Cytoscape for network graph visualization, nodes representing programs, edges showing similarity relationships, interactive zoom and pan, node clustering and highlighting
  - Create `app/programs/clusters/page.tsx` with clustering interface, algorithm selection, parameter configuration, cluster visualization, cluster analysis results
  - Build `components/ClusterVisualization.tsx` with 2D scatter plot using recharts, cluster coloring and labeling, outlier identification, interactive cluster selection, cluster statistics display
  - _Requirements: Custom requirement for similarity search and clustering interfaces_

- [ ] 6.4 Implement detailed similarity analysis components
  - Create `components/SimilarityDetails.tsx` with detailed match analysis, bytecode overlap visualization, function matching results, instruction similarity breakdown, semantic similarity metrics
  - Build `components/BytecodeComparison.tsx` showing side-by-side bytecode comparison, highlighted common sequences, unique sections identification, overlap percentage calculation, sequence alignment visualization
  - Implement `components/FunctionMatching.tsx` displaying function-level comparisons, identical function pairs, similar function analysis, function signature comparison, call graph similarities
  - Add `components/InstructionSimilarity.tsx` with instruction pattern analysis, common instruction sequences, unique instruction identification, control flow comparison, algorithmic similarity assessment
  - Create `components/SemanticAnalysis.tsx` showing transaction pattern similarities, behavioral equivalence analysis, API compatibility assessment, use case comparison, functional similarity metrics
  - Implement export functionality: similarity analysis reports, comparison matrices, cluster analysis results, visualization exports (PNG, SVG), data exports (CSV, JSON)
  - _Requirements: Custom requirement for detailed similarity analysis and comparison_

- [ ] 7. Build global program similarity browser and matrix views
  - Create global similarity browser page for exploring all program similarities
  - Implement similarity matrix view with heatmap visualization
  - Build advanced filtering and export capabilities for similarity data
  - _Requirements: Custom requirement for global similarity browser based on user request_

- [ ] 7.1 Create global program similarity browser page
  - Create `app/programs/similarity-browser/page.tsx` with comprehensive similarity exploration interface, search mode selection (Browse All, Target-based), similarity type tabs (Bytecode, Semantic, Transaction Patterns, Mixed), advanced filtering controls
  - Build `components/GlobalSimilarityBrowser.tsx` with similarity search controls, min similarity threshold slider, category filters, sort options (similarity, activity, category), search and export buttons
  - Implement `components/SimilarityNetworkView.tsx` using D3.js or Cytoscape for interactive network visualization, program nodes sized by activity, similarity edges with thickness based on score, color coding by category, zoom and pan controls
  - Add `components/SimilarityInsightsPanel.tsx` with four-quadrant layout: top clusters (DEX, AMM, NFT clusters with average similarity), common patterns (token swap, liquidity pool, staking patterns), similarity distribution chart, category breakdown
  - Create `components/SimilarProgramsTable.tsx` using @tanstack/react-table displaying program pairs with columns: Program A, Program B, Similarity %, Relationship Type, Common Features, with load more functionality and comparison selection
  - Implement real-time similarity updates: WebSocket connection for new similarity discoveries, notification system for interesting matches, background similarity computation for new programs
  - _Requirements: Custom requirement for global similarity browser interface_

- [ ] 7.2 Build program similarity matrix view
  - Create `app/programs/similarity-matrix/page.tsx` with similarity matrix interface, matrix configuration controls (program selection, similarity type, threshold, display options), heatmap visualization, matrix statistics
  - Build `components/SimilarityMatrix.tsx` with interactive heatmap using D3.js or recharts, color-coded similarity scores (red=high, white=low), clickable cells for detailed analysis, row/column sorting, zoom and pan functionality
  - Implement `components/MatrixConfiguration.tsx` with program selection dropdown (Top 50, Top 100, Custom list), similarity type selection, threshold slider, display options (heatmap, network, table), refresh and export buttons
  - Add `components/MatrixStatistics.tsx` showing total comparisons, similarity distribution (90-100%, 80-90%, etc.), highest similarity pairs, most connected programs, average similarity score
  - Create `components/SelectedPairAnalysis.tsx` displaying detailed analysis when matrix cell is clicked, similarity breakdown, common features, relationship type, detailed comparison link
  - Implement matrix export functionality: export similarity matrix as CSV, save heatmap as PNG/SVG, generate similarity reports, provide API endpoints for programmatic access
  - _Requirements: Custom requirement for similarity matrix visualization_

- [ ] 7.3 Implement advanced similarity filtering and analytics
  - Create `components/SimilarityFilters.tsx` with advanced filtering options: similarity score ranges, program categories, deployment date ranges, activity levels, verification status, custom program lists
  - Build `components/SimilarityAnalytics.tsx` with similarity trend analysis, cluster evolution tracking, similarity pattern detection, ecosystem health metrics based on program relationships
  - Implement `components/SimilarityExport.tsx` with multiple export formats: CSV for data analysis, JSON for API integration, PNG/SVG for visualizations, PDF reports for documentation
  - Add `components/SimilaritySearch.tsx` with advanced search capabilities: search by program name/address, similarity pattern search, cluster-based search, semantic search using natural language
  - Create similarity recommendation system: suggest interesting program comparisons, recommend programs for analysis, identify trending similarity patterns, provide personalized similarity feeds
  - Implement similarity caching and optimization: cache similarity computations, implement incremental similarity updates, optimize matrix calculations, use Web Workers for heavy computations
  - _Requirements: Custom requirement for advanced similarity features_- [ ] 8. 
Build program list and discovery system
  - Create program list page with filtering, sorting, and search capabilities
  - Implement program discovery and categorization system
  - Build program statistics and analytics dashboard
  - _Requirements: 7.1, 7.2, 7.3, 7.4, 7.5, 7.6, 7.7, 7.8_

- [ ] 8.1 Create program list page and discovery interface
  - Create `app/programs/page.tsx` with comprehensive program listing, search and filter controls, category overview, network statistics, with server-side rendering for SEO optimization
  - Build `components/ProgramSearchFilters.tsx` with search input supporting program name and address search, category filter dropdown (DeFi, Gaming, NFT, Infrastructure, Social), activity level filter (inactive, low, moderate, high), verification status checkbox, security score range slider, performance score range slider
  - Implement `components/ProgramTable.tsx` using @tanstack/react-table with virtual scrolling for large datasets, columns: program name/address, category, verification status, deployment date, last activity, transaction count, unique users, success rate, security score, performance score, with sorting and filtering capabilities
  - Add `components/CategoryOverview.tsx` displaying program categories with counts, category-specific statistics, trending categories, category growth metrics, with clickable category filters
  - Create `components/NetworkProgramStats.tsx` showing total programs, active programs (24h), new programs (7d), average security score, top categories, network health indicators, with similarity analysis and clustering buttons
  - Implement infinite scroll or pagination for large program lists, loading states during data fetching, empty states when no programs match filters, export functionality for filtered results
  - _Requirements: 7.1, 7.2, 7.3, 7.4, 7.5, 7.6, 7.7, 7.8_

- [ ] 8.2 Build program discovery and recommendation system
  - Create `lib/discovery/program-discovery.ts` with ProgramDiscovery class implementing discoverPrograms(criteria: DiscoveryCriteria) method, use machine learning algorithms for program recommendation, analyze user behavior and preferences for personalized suggestions
  - Implement trending program detection: identify programs with increasing activity, detect viral programs and rapid adoption, analyze social media mentions and community engagement, track developer activity and updates
  - Add new program monitoring: detect newly deployed programs, analyze program quality and legitimacy, identify promising new projects, track early adoption patterns, provide early access notifications
  - Create similar program recommendations: use Qdrant similarity search for program suggestions, recommend programs based on user viewing history, suggest complementary programs and integrations, provide category-based recommendations
  - Implement program scoring and ranking: calculate program quality scores, rank programs by activity and adoption, assess program maturity and stability, evaluate community support and documentation
  - Store discovery data in Qdrant: create user preference vectors for personalized recommendations, generate program trend vectors, implement recommendation indexing for fast queries
  - _Requirements: 7.1, 7.2, 7.3, 7.4, 7.5, 7.6, 7.7, 7.8_

- [ ] 9. Implement program dependencies and integration analysis
  - Create dependency analysis engine with program relationship mapping
  - Build integration visualization and impact assessment tools
  - Implement ecosystem mapping and influence analysis
  - _Requirements: 9.1, 9.2, 9.3, 9.4, 9.5, 9.6, 9.7, 9.8_

- [ ] 9.1 Build dependency analysis engine
  - Create `lib/analyzers/dependency-analyzer.ts` with DependencyAnalyzer class implementing analyzeDependencies(programAddress: string) method, identify program dependencies through code analysis, detect library usage and imports, analyze cross-program invocations
  - Implement dependency detection: parse program bytecode for external program calls, identify library dependencies and shared code, detect program composition and inheritance patterns, analyze upgrade dependencies and version compatibility
  - Add integration mapping: identify programs that call this program, detect bidirectional dependencies and circular references, analyze integration patterns and usage frequency, map ecosystem relationships and connections
  - Create impact analysis: assess impact of program changes on dependent systems, identify critical dependencies and single points of failure, analyze upgrade cascades and breaking changes, evaluate ecosystem stability and resilience
  - Implement dependency visualization: generate dependency graphs using graph algorithms, create hierarchical dependency trees, visualize integration networks and ecosystems, highlight critical paths and bottlenecks
  - Store dependency data in Qdrant: create dependency pattern vectors for similar dependency analysis, enable dependency-based program recommendations, implement ecosystem clustering and analysis
  - _Requirements: 9.1, 9.2, 9.3, 9.4, 9.5, 9.6, 9.7, 9.8_

- [ ] 9.2 Create dependency visualization and analysis components
  - Create `components/DependencyGraph.tsx` using D3.js or Cytoscape for interactive dependency visualization, nodes representing programs, edges showing dependencies, hierarchical layout with zoom and pan, dependency type color coding
  - Build `components/DependencyTable.tsx` using @tanstack/react-table displaying program dependencies with columns: dependency address, dependency type, relationship strength, last interaction, version compatibility, with filtering and sorting
  - Implement `components/IntegrationMap.tsx` showing programs that integrate with current program, integration frequency and patterns, bidirectional relationship visualization, integration health metrics
  - Add `components/ImpactAnalysis.tsx` displaying potential impact of program changes, affected programs and systems, risk assessment and mitigation strategies, upgrade planning and coordination
  - Create `components/EcosystemOverview.tsx` with ecosystem health metrics, program influence scores, network centrality measures, ecosystem evolution trends, community and adoption metrics
  - Implement dependency export functionality: dependency reports and documentation, integration guides and best practices, ecosystem analysis and insights, visualization exports and sharing
  - _Requirements: 9.1, 9.2, 9.3, 9.4, 9.5, 9.6, 9.7, 9.8_

- [ ] 10. Build advanced analytics and machine learning features
  - Create anomaly detection system for unusual program behavior
  - Implement predictive analytics for program performance and security
  - Build recommendation engine for program discovery and analysis
  - _Requirements: 10.1, 10.2, 10.3, 10.4, 10.5, 10.6, 10.7, 10.8_

- [ ] 10.1 Implement anomaly detection for program behavior
  - Create `lib/ml/anomaly-detector.ts` with AnomalyDetector class implementing detectAnomalies(programData: ProgramData) method, use machine learning algorithms to identify unusual patterns, detect security threats and performance issues
  - Build behavioral analysis: establish baseline behavior patterns for programs, detect deviations from normal operation, identify suspicious transaction patterns, flag unusual resource consumption
  - Add security anomaly detection: detect potential exploits and attacks, identify unusual access patterns, flag suspicious code modifications, monitor for known attack signatures
  - Create performance anomaly detection: identify performance degradation patterns, detect resource usage spikes, flag efficiency regressions, monitor for optimization opportunities
  - Implement real-time anomaly monitoring: stream program activity data, apply anomaly detection algorithms in real-time, generate alerts for critical anomalies, provide anomaly severity scoring
  - Store anomaly patterns in Qdrant: create anomaly signature vectors, enable similar anomaly detection, implement anomaly clustering and analysis, track anomaly evolution over time
  - _Requirements: 10.1, 10.2, 10.3, 10.4, 10.5, 10.6, 10.7, 10.8_

- [ ] 10.2 Build predictive analytics and forecasting system
  - Create `lib/ml/predictor.ts` with ProgramPredictor class implementing predictPerformance(programAddress: string) and predictSecurity(programAddress: string) methods, use time series analysis and machine learning for forecasting
  - Implement performance prediction: forecast compute unit usage trends, predict throughput and scalability limits, estimate resource requirements, project performance under different load conditions
  - Add security risk prediction: predict vulnerability discovery likelihood, forecast security score trends, estimate attack probability, project security improvement timelines
  - Create adoption forecasting: predict program usage growth, forecast community adoption patterns, estimate market penetration, project ecosystem integration trends
  - Build trend analysis: identify long-term patterns in program behavior, detect cyclical patterns and seasonality, forecast technology adoption curves, predict ecosystem evolution
  - Implement prediction accuracy tracking: measure prediction accuracy over time, adjust models based on actual outcomes, provide confidence intervals for predictions, track model performance metrics
  - _Requirements: 10.1, 10.2, 10.3, 10.4, 10.5, 10.6, 10.7, 10.8_

- [ ] 11. Implement comprehensive testing and quality assurance
  - Create unit tests for all analysis engines and components
  - Build integration tests for API endpoints and data flows
  - Implement end-to-end tests for user workflows and features
  - _Requirements: 11.1, 11.2, 11.3, 11.4, 11.5, 11.6, 11.7, 11.8_

- [ ] 11.1 Create comprehensive unit test suite
  - Create `__tests__/analyzers/code-analyzer.test.ts` testing CodeAnalyzer class methods, mock Solana RPC responses, test disassembly generation, validate control flow analysis, verify pattern detection accuracy
  - Build `__tests__/analyzers/security-analyzer.test.ts` testing SecurityAnalyzer vulnerability detection, mock audit report data, test risk scoring algorithms, validate security pattern recognition
  - Implement `__tests__/analyzers/performance-analyzer.test.ts` testing PerformanceAnalyzer metrics calculation, mock transaction history data, test optimization detection, validate benchmarking algorithms
  - Add `__tests__/analyzers/similarity-analyzer.test.ts` testing SimilarityAnalyzer bytecode and semantic comparison, mock Qdrant responses, test clustering algorithms, validate similarity scoring
  - Create `__tests__/components/` directory with tests for all React components, test component rendering, validate prop handling, test user interactions, verify accessibility compliance
  - Implement test utilities in `__tests__/utils/` for mock data generation, test helpers, and common testing patterns, create realistic program data mocks, Qdrant response mocks, Solana RPC mocks
  - _Requirements: 11.1, 11.2, 11.3, 11.4, 11.5, 11.6, 11.7, 11.8_

- [ ] 11.2 Build integration test suite
  - Create `__tests__/integration/api-endpoints.test.ts` testing all API endpoints with real database connections, test program data fetching, validate similarity search, test clustering operations
  - Build `__tests__/integration/qdrant-integration.test.ts` testing Qdrant vector operations, test vector storage and retrieval, validate similarity search accuracy, test collection management
  - Implement `__tests__/integration/cache-integration.test.ts` testing cache operations, validate cache hit/miss behavior, test cache invalidation, verify cache warming functionality
  - Add `__tests__/integration/data-flow.test.ts` testing end-to-end data processing, validate program analysis pipeline, test real-time updates, verify data consistency
  - Create performance integration tests measuring API response times, database query performance, vector search latency, cache performance metrics
  - Implement error handling integration tests for network failures, database errors, invalid inputs, rate limiting scenarios
  - _Requirements: 11.1, 11.2, 11.3, 11.4, 11.5, 11.6, 11.7, 11.8_

- [ ] 11.3 Implement end-to-end testing with Playwright
  - Create `e2e/program-explorer.spec.ts` testing complete user workflows, program detail page navigation, code analysis interactions, security assessment viewing, performance metrics exploration
  - Build `e2e/similarity-analysis.spec.ts` testing similarity search workflows, program comparison features, clustering visualization, matrix view interactions
  - Implement `e2e/program-discovery.spec.ts` testing program list browsing, filtering and search functionality, category navigation, program recommendation features
  - Add `e2e/mobile-responsive.spec.ts` testing mobile user experience, responsive design validation, touch interactions, mobile-specific features
  - Create visual regression tests using Playwright screenshots, test component visual consistency, validate chart rendering, verify layout responsiveness
  - Implement accessibility testing using axe-playwright, test keyboard navigation, validate ARIA labels, verify screen reader compatibility, test color contrast compliance
  - _Requirements: 11.1, 11.2, 11.3, 11.4, 11.5, 11.6, 11.7, 11.8_

- [ ] 12. Implement production deployment and monitoring
  - Set up production infrastructure with proper scaling and monitoring
  - Implement comprehensive logging and error tracking
  - Build performance monitoring and alerting systems
  - _Requirements: 12.1, 12.2, 12.3, 12.4, 12.5, 12.6, 12.7, 12.8_

- [ ] 12.1 Set up production infrastructure and deployment
  - Configure production deployment pipeline using Docker containers, set up Kubernetes cluster for scalability, implement blue-green deployment strategy, configure load balancing and auto-scaling
  - Set up production databases: configure PostgreSQL cluster for metadata storage, deploy Qdrant cluster for vector operations, set up Redis cluster for caching, implement database backup and recovery
  - Configure monitoring infrastructure: deploy Prometheus for metrics collection, set up Grafana for visualization, implement Jaeger for distributed tracing, configure log aggregation with ELK stack
  - Implement security measures: configure SSL/TLS certificates, set up WAF and DDoS protection, implement API rate limiting, configure security headers and CORS policies
  - Set up CI/CD pipeline: automated testing on pull requests, security scanning and vulnerability assessment, performance testing and benchmarking, automated deployment to staging and production
  - Configure environment management: separate configurations for development, staging, and production, secure secret management, environment variable validation, configuration drift detection
  - _Requirements: 12.1, 12.2, 12.3, 12.4, 12.5, 12.6, 12.7, 12.8_

- [ ] 12.2 Implement comprehensive monitoring and alerting
  - Create `lib/monitoring/metrics.ts` with custom metrics collection, track API response times, monitor database query performance, measure vector search latency, collect user interaction metrics
  - Build `lib/monitoring/alerts.ts` with intelligent alerting system, configure alerts for API errors, database connection issues, high response times, unusual traffic patterns, security incidents
  - Implement health check endpoints: `/api/health` for basic health status, `/api/health/detailed` for comprehensive system status, `/api/health/dependencies` for external service status
  - Add performance monitoring: track Core Web Vitals, monitor JavaScript bundle sizes, measure page load times, analyze user experience metrics, identify performance bottlenecks
  - Create error tracking and reporting: integrate with Sentry for error monitoring, implement custom error categorization, track error trends and patterns, provide error resolution workflows
  - Build operational dashboards: real-time system status, performance metrics visualization, error rate tracking, user activity monitoring, resource utilization graphs
  - _Requirements: 12.1, 12.2, 12.3, 12.4, 12.5, 12.6, 12.7, 12.8_
---

## File: ./.kiro/specs/token-explorer-enhancements/design.md

# Token Explorer Enhancements Design

## Overview

The Token Explorer Enhancements design provides a comprehensive solution for token analysis, community engagement, and trading on Solana. The system transforms the basic token explorer into a full-featured platform with advanced analytics, security assessment, community features, portfolio tracking, AI insights, and integrated trading capabilities. The design emphasizes user engagement through gamification, social features, and cutting-edge analysis tools.

## Architecture

### High-Level Architecture

```mermaid
graph TB
    subgraph "Client Layer"
        A[Token Detail Page] --> B[Token List Pages]
        A --> C[Portfolio Tracker]
        A --> D[Trading Interface]
        B --> E[Launch Pad]
        C --> F[AI Insights]
    end
    
    subgraph "API Layer"
        G[Token API] --> H[Analytics Engine]
        G --> I[Security Engine]
        H --> J[AI Prediction Engine]
        I --> K[Rug Pull Detector]
        L[Trading API] --> M[DEX Aggregator]
        N[Community API] --> O[Trollbox Service]
    end
    
    subgraph "Data Layer"
        P[Qdrant Vector DB] --> Q[Token Analytics]
        P --> R[Security Patterns]
        P --> S[User Behavior]
        T[PostgreSQL] --> U[User Data]
        T --> V[Community Data]
        W[Redis Cache] --> X[Real-time Data]
    end
    
    A --> G
    C --> G
    D --> L
    E --> G
    F --> J
    O --> N
    G --> P
    H --> P
    I --> P
    J --> P
```

### Component Architecture

The token explorer follows a modular microservices architecture with clear separation of concerns:

- **Presentation Layer**: React components with real-time updates
- **Business Logic Layer**: Specialized engines for analytics, security, and AI
- **Data Access Layer**: Multi-database approach with Qdrant for vectors, PostgreSQL for relational data
- **Integration Layer**: External APIs for market data, DEX aggregation, and social media

## Components and Interfaces

### Core Token Components

#### TokenDetailsPage Component
```typescript
interface TokenDetailsPageProps {
  mint: string;
  initialData?: TokenData;
}

interface TokenData {
  mint: string;
  metadata: TokenMetadata;
  supply: TokenSupply;
  marketData: TokenMarketData;
  holders: TokenHolder[];
  transfers: TokenTransfer[];
  statistics: TokenStatistics;
  socialLinks: SocialLinks;
  securityAnalysis: SecurityAnalysis;
  creatorAnalysis: CreatorAnalysis;
  bundlingAnalysis: BundlingAnalysis;
  similarTokens: SimilarToken[];
  communityRating: CommunityRating;
  aiInsights: AIInsights;
}

interface TokenMetadata {
  name: string;
  symbol: string;
  decimals: number;
  description?: string;
  image?: string;
  creator: string;
  verified: boolean;
  tags: string[];
  createdAt: number;
  website?: string;
  twitter?: string;
  discord?: string;
  telegram?: string;
}

interface TokenMarketData {
  price: number;
  priceChange24h: number;
  volume24h: number;
  marketCap: number;
  fullyDilutedMarketCap: number;
  liquidity: number;
  holders: number;
  priceHistory: PricePoint[];
  volumeHistory: VolumePoint[];
}
```

#### TokenListPage Component
```typescript
interface TokenListPageProps {
  initialTokens?: TokenListItem[];
  filters?: TokenFilters;
  sortBy?: TokenSortOption;
}

interface TokenListItem {
  mint: string;
  name: string;
  symbol: string;
  image: string;
  price: number;
  priceChange24h: number;
  marketCap: number;
  volume24h: number;
  holders: number;
  verified: boolean;
  riskScore: number;
  communityRating: number;
  launchDate?: number;
}

interface TokenFilters {
  marketCapRange: [number, number];
  volumeRange: [number, number];
  priceRange: [number, number];
  categories: string[];
  verified: boolean;
  riskLevel: 'low' | 'medium' | 'high';
  launchDateRange?: [number, number];
}
```

### Security Analysis Components

#### SecurityAnalysisDisplay Component
```typescript
interface SecurityAnalysisDisplayProps {
  securityAnalysis: SecurityAnalysis;
  creatorAnalysis: CreatorAnalysis;
  bundlingAnalysis: BundlingAnalysis;
  onRiskClick: (riskType: string) => void;
}

interface SecurityAnalysis {
  riskScore: number; // 0-100
  riskLevel: 'low' | 'medium' | 'high' | 'critical';
  riskFactors: RiskFactor[];
  liquidityAnalysis: LiquidityAnalysis;
  contractVerification: ContractVerification;
  auditReports: AuditReport[];
}

interface CreatorAnalysis {
  creatorAddress: string;
  creatorRiskScore: number;
  previousTokens: PreviousToken[];
  rugPullConnections: RugPullConnection[];
  walletSeedAnalysis: WalletSeedAnalysis;
  reputationScore: number;
}

interface BundlingAnalysis {
  bundlingDetected: boolean;
  bundlingScore: number; // 0-100
  coordinatedWallets: CoordinatedWallet[];
  fundingPatterns: FundingPattern[];
  manipulationIndicators: ManipulationIndicator[];
}

interface WalletSeedAnalysis {
  seedingChain: SeedingStep[];
  finalSource: 'exchange' | 'validator' | 'unknown' | 'suspicious';
  riskLevel: 'low' | 'medium' | 'high';
  confidence: number;
}
```

### Community Features Components

#### TokenTrollbox Component
```typescript
interface TokenTrollboxProps {
  tokenMint: string;
  userWallet?: string;
  userHoldings?: number;
  totalSupply: number;
}

interface TrollboxMessage {
  id: string;
  content: string;
  timestamp: number;
  ownershipPercentage: number;
  messageType: 'message' | 'rating';
  sentiment?: 'positive' | 'negative' | 'neutral';
}

interface CommunityRating {
  totalRatings: number;
  positiveRatings: number;
  negativeRatings: number;
  weightedScore: number; // Weighted by ownership
  sentimentTrend: SentimentPoint[];
  topHolderSentiment: number;
}
```

#### CommunityRatingSystem Component
```typescript
interface CommunityRatingSystemProps {
  tokenMint: string;
  userHoldings: number;
  totalSupply: number;
  currentRating: CommunityRating;
  onRatingSubmit: (rating: 'like' | 'dislike') => void;
}

interface RatingWeight {
  userId: string;
  ownershipPercentage: number;
  rating: 'like' | 'dislike';
  timestamp: number;
  weight: number; // Calculated based on ownership
}
```

### Portfolio and Trading Components

#### PortfolioTracker Component
```typescript
interface PortfolioTrackerProps {
  walletAddress: string;
  tokens: PortfolioToken[];
  totalValue: number;
  totalPnL: number;
}

interface PortfolioToken {
  mint: string;
  symbol: string;
  name: string;
  balance: number;
  currentPrice: number;
  averageCostBasis: number;
  unrealizedPnL: number;
  realizedPnL: number;
  allocation: number; // Percentage of portfolio
  priceChange24h: number;
  transactions: PortfolioTransaction[];
}

interface PortfolioTransaction {
  signature: string;
  type: 'buy' | 'sell' | 'transfer_in' | 'transfer_out';
  amount: number;
  price: number;
  timestamp: number;
  fees: number;
}
```

#### TradingInterface Component
```typescript
interface TradingInterfaceProps {
  tokenMint: string;
  tokenData: TokenData;
  userWallet?: string;
  onTradeExecute: (trade: TradeOrder) => void;
}

interface TradeOrder {
  type: 'market' | 'limit' | 'stop_loss' | 'dca';
  side: 'buy' | 'sell';
  amount: number;
  price?: number; // For limit orders
  stopPrice?: number; // For stop loss
  slippage: number;
  dexRoute: DexRoute;
}

interface DexRoute {
  dex: string;
  route: RouteStep[];
  priceImpact: number;
  estimatedOutput: number;
  fees: number;
  executionTime: number;
}
```

### AI and Analytics Components

#### AIInsightsPanel Component
```typescript
interface AIInsightsPanelProps {
  tokenMint: string;
  insights: AIInsights;
  onPredictionRequest: () => void;
}

interface AIInsights {
  pricePrediction: PricePrediction;
  sentimentAnalysis: SentimentAnalysis;
  technicalAnalysis: TechnicalAnalysis;
  riskAssessment: AIRiskAssessment;
  tradingSignals: TradingSignal[];
  marketPatterns: MarketPattern[];
}

interface PricePrediction {
  timeframes: {
    '1h': PredictionPoint;
    '24h': PredictionPoint;
    '7d': PredictionPoint;
    '30d': PredictionPoint;
  };
  confidence: number;
  factors: PredictionFactor[];
  historicalAccuracy: number;
}

interface TradingSignal {
  type: 'buy' | 'sell' | 'hold';
  strength: number; // 0-100
  confidence: number; // 0-100
  reasoning: string;
  targetPrice?: number;
  stopLoss?: number;
  timeframe: string;
}
```

### Gamification Components

#### UserProgressPanel Component
```typescript
interface UserProgressPanelProps {
  userStats: UserStats;
  achievements: Achievement[];
  leaderboard: LeaderboardEntry[];
}

interface UserStats {
  level: number;
  points: number;
  pointsToNextLevel: number;
  rank: number;
  badges: Badge[];
  streaks: Streak[];
  contributions: Contribution[];
}

interface Achievement {
  id: string;
  name: string;
  description: string;
  icon: string;
  points: number;
  unlocked: boolean;
  unlockedAt?: number;
  progress: number; // 0-100
  requirements: AchievementRequirement[];
}

interface LeaderboardEntry {
  rank: number;
  userId: string;
  displayName: string;
  points: number;
  level: number;
  badges: Badge[];
  specialization: string; // 'analyst', 'trader', 'community'
}
```

## Data Models

### Token Data Models
```typescript
interface TokenSupply {
  total: number;
  circulating: number;
  burned: number;
  locked: number;
  inflation: number;
  deflation: number;
}

interface TokenStatistics {
  transferCount24h: number;
  uniqueHolders: number;
  averageHoldingTime: number;
  concentrationRatio: number;
  liquidityScore: number;
  velocityScore: number;
  utilityScore: number;
  ageInDays: number;
  volatility: VolatilityMetrics;
}

interface VolatilityMetrics {
  daily: number;
  weekly: number;
  monthly: number;
  annualized: number;
  beta: number; // vs SOL or market index
}
```

### Security Data Models
```typescript
interface RiskFactor {
  type: 'liquidity' | 'concentration' | 'creator' | 'bundling' | 'contract';
  severity: 'low' | 'medium' | 'high' | 'critical';
  score: number; // 0-100
  description: string;
  evidence: Evidence[];
  mitigation?: string;
}

interface RugPullConnection {
  connectedToken: string;
  connectionType: 'same_creator' | 'funding_source' | 'wallet_cluster';
  confidence: number;
  rugPullDate: number;
  lossAmount: number;
  evidence: string[];
}

interface CoordinatedWallet {
  address: string;
  fundingSource: string;
  purchaseAmount: number;
  purchaseTime: number;
  clusterScore: number; // How closely related to other wallets
  suspiciousPatterns: string[];
}
```

### Community Data Models
```typescript
interface CommunityData {
  trollboxMessages: TrollboxMessage[];
  ratings: CommunityRating;
  socialMetrics: SocialMetrics;
  communityHealth: CommunityHealth;
}

interface SocialMetrics {
  twitterFollowers: number;
  discordMembers: number;
  telegramMembers: number;
  socialGrowth24h: number;
  mentionCount: number;
  sentimentScore: number;
  influencerMentions: InfluencerMention[];
}

interface CommunityHealth {
  activityLevel: 'low' | 'medium' | 'high';
  engagementRate: number;
  toxicityScore: number;
  moderationNeeded: boolean;
  communitySize: 'small' | 'medium' | 'large';
  growthTrend: 'declining' | 'stable' | 'growing';
}
```

## Qdrant Integration Design

### Vector Collections Structure

```typescript
interface QdrantCollections {
  tokens: 'token_vectors';
  security_patterns: 'security_vectors';
  user_behavior: 'user_vectors';
  market_patterns: 'market_vectors';
  community_sentiment: 'sentiment_vectors';
}

interface TokenVector {
  id: string; // token mint
  vector: number[]; // 512-dimensional embedding
  payload: {
    mint: string;
    symbol: string;
    marketCap: number;
    volume24h: number;
    holderCount: number;
    riskScore: number;
    category: string;
    launchDate: number;
    creatorRisk: number;
    bundlingScore: number;
    communityRating: number;
    liquidityScore: number;
    volatility: number;
    utilityScore: number;
  };
}

interface SecurityVector {
  id: string; // unique security pattern id
  vector: number[]; // Security pattern embedding
  payload: {
    patternType: 'rug_pull' | 'bundling' | 'wash_trading' | 'pump_dump';
    severity: number;
    tokenMint: string;
    creatorAddress: string;
    evidence: string[];
    confidence: number;
    detectedAt: number;
  };
}
```

### Vector Search Operations

```typescript
class TokenVectorService {
  async findSimilarTokens(tokenMint: string, limit: number = 10): Promise<SimilarToken[]> {
    const tokenVector = await this.getTokenVector(tokenMint);
    
    const searchResult = await this.qdrantClient.search('token_vectors', {
      vector: tokenVector.vector,
      limit,
      filter: {
        must_not: [{ key: 'mint', match: { value: tokenMint } }]
      }
    });
    
    return searchResult.map(result => ({
      mint: result.payload.mint,
      similarity: result.score,
      reason: this.calculateSimilarityReason(tokenVector.payload, result.payload)
    }));
  }

  async detectSecurityPatterns(tokenMint: string): Promise<SecurityPattern[]> {
    const tokenData = await this.getTokenAnalytics(tokenMint);
    const securityVector = await this.generateSecurityVector(tokenData);
    
    const searchResult = await this.qdrantClient.search('security_vectors', {
      vector: securityVector,
      limit: 50,
      score_threshold: 0.8
    });
    
    return searchResult.map(result => ({
      patternType: result.payload.patternType,
      confidence: result.score,
      evidence: result.payload.evidence,
      severity: result.payload.severity
    }));
  }
}
```

## Error Handling

### Error Types and Recovery

```typescript
enum TokenExplorerErrorType {
  INVALID_MINT = 'INVALID_MINT',
  TOKEN_NOT_FOUND = 'TOKEN_NOT_FOUND',
  MARKET_DATA_ERROR = 'MARKET_DATA_ERROR',
  SECURITY_ANALYSIS_ERROR = 'SECURITY_ANALYSIS_ERROR',
  COMMUNITY_ERROR = 'COMMUNITY_ERROR',
  TRADING_ERROR = 'TRADING_ERROR',
  AI_SERVICE_ERROR = 'AI_SERVICE_ERROR',
  QDRANT_ERROR = 'QDRANT_ERROR'
}

class TokenErrorHandler {
  static handleMintError(mint: string): TokenExplorerError {
    if (!this.isValidMint(mint)) {
      return {
        type: TokenExplorerErrorType.INVALID_MINT,
        message: `Invalid token mint address: ${mint}`,
        retryable: false,
        suggestions: ['Check the mint address format', 'Search by token symbol instead']
      };
    }
  }

  static handleSecurityAnalysisError(error: any): TokenExplorerError {
    return {
      type: TokenExplorerErrorType.SECURITY_ANALYSIS_ERROR,
      message: 'Security analysis temporarily unavailable',
      retryable: true,
      retryAfter: 30000,
      fallback: 'basic_security_info'
    };
  }
}
```

## Testing Strategy

### Unit Testing Approach

```typescript
describe('TokenAnalyzer', () => {
  describe('analyzeTokenSecurity', () => {
    it('should detect rug pull patterns correctly', async () => {
      const mockTokenData = createMockTokenWithRugPullPatterns();
      const result = await TokenAnalyzer.analyzeTokenSecurity(mockTokenData);
      
      expect(result.riskLevel).toBe('high');
      expect(result.riskFactors).toContainEqual(
        expect.objectContaining({ type: 'creator', severity: 'high' })
      );
    });

    it('should identify bundling patterns', async () => {
      const mockTokenData = createMockTokenWithBundling();
      const result = await TokenAnalyzer.analyzeTokenSecurity(mockTokenData);
      
      expect(result.bundlingAnalysis.bundlingDetected).toBe(true);
      expect(result.bundlingAnalysis.bundlingScore).toBeGreaterThan(70);
    });
  });

  describe('findSimilarTokens', () => {
    it('should find tokens with similar characteristics', async () => {
      const mockToken = createMockToken();
      const result = await TokenAnalyzer.findSimilarTokens(mockToken.mint);
      
      expect(result).toHaveLength(10);
      expect(result[0].similarity).toBeGreaterThan(0.8);
    });
  });
});
```

### Integration Testing Strategy

1. **API Integration Tests**: Test all token-related endpoints
2. **Qdrant Integration Tests**: Test vector search and storage
3. **Security Analysis Tests**: Test rug pull and bundling detection
4. **Community Feature Tests**: Test trollbox and rating system
5. **Trading Integration Tests**: Test DEX aggregation and execution
6. **AI Service Tests**: Test prediction and insight generation

## Performance Optimization

### Caching Strategy

```typescript
interface TokenCacheConfig {
  tokenMetadata: {
    ttl: 3600000; // 1 hour
    strategy: 'background-refresh';
  };
  marketData: {
    ttl: 30000; // 30 seconds
    strategy: 'real-time-update';
  };
  securityAnalysis: {
    ttl: 1800000; // 30 minutes
    strategy: 'lazy-refresh';
  };
  communityData: {
    ttl: 60000; // 1 minute
    strategy: 'real-time-update';
  };
  aiInsights: {
    ttl: 900000; // 15 minutes
    strategy: 'background-refresh';
  };
}

class TokenCacheManager {
  async getTokenData(mint: string): Promise<TokenData> {
    const cacheKey = `token:${mint}`;
    const cached = await this.redis.get(cacheKey);
    
    if (cached) {
      // Trigger background refresh if needed
      this.backgroundRefresh(mint);
      return JSON.parse(cached);
    }
    
    const data = await this.fetchTokenData(mint);
    await this.redis.setex(cacheKey, 3600, JSON.stringify(data));
    
    return data;
  }
}
```

### Real-time Updates

```typescript
class TokenRealtimeManager {
  private wsConnections = new Map<string, WebSocket[]>();
  
  subscribeToToken(tokenMint: string, ws: WebSocket) {
    if (!this.wsConnections.has(tokenMint)) {
      this.wsConnections.set(tokenMint, []);
    }
    this.wsConnections.get(tokenMint)!.push(ws);
    
    // Start real-time data stream for this token
    this.startTokenStream(tokenMint);
  }
  
  broadcastTokenUpdate(tokenMint: string, update: TokenUpdate) {
    const connections = this.wsConnections.get(tokenMint) || [];
    
    connections.forEach(ws => {
      if (ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
          type: 'token_update',
          mint: tokenMint,
          data: update
        }));
      }
    });
  }
}
```

## Security Considerations

### Data Privacy and Protection

1. **User Privacy**: Hash wallet addresses in community features
2. **Trading Security**: Secure wallet connections and transaction signing
3. **API Security**: Rate limiting and authentication for sensitive endpoints
4. **Data Encryption**: Encrypt sensitive user data and preferences
5. **Audit Trails**: Log all security-related operations

### AI Model Security

```typescript
class AISecurityManager {
  static validatePredictionInput(input: any): boolean {
    // Validate input to prevent prompt injection
    return this.sanitizeInput(input) && this.checkInputLimits(input);
  }
  
  static filterPredictionOutput(output: any): any {
    // Filter AI output to prevent harmful content
    return this.sanitizeOutput(output);
  }
  
  static trackModelPerformance(predictions: Prediction[]): void {
    // Track accuracy and detect model drift
    this.updateModelMetrics(predictions);
  }
}
```

## Monitoring and Analytics

### Performance Monitoring

1. **Page Load Times**: Track token page performance
2. **API Response Times**: Monitor all token-related endpoints
3. **Qdrant Performance**: Track vector search response times
4. **AI Service Performance**: Monitor prediction generation times
5. **Trading Execution**: Track trade execution success rates

### User Analytics

1. **Feature Usage**: Track which features are most used
2. **User Journey**: Analyze how users navigate token pages
3. **Engagement Metrics**: Measure time spent and interactions
4. **Conversion Tracking**: Track portfolio additions and trades
5. **Community Participation**: Monitor trollbox and rating activity

This comprehensive design provides a robust foundation for implementing the token explorer enhancements with advanced security analysis, community features, AI insights, and integrated trading capabilities.
---

## File: ./.kiro/specs/token-explorer-enhancements/requirements.md

# Token Explorer Enhancements Requirements

## Introduction

This specification defines the requirements for enhancing the token explorer functionality in OpenSVM, covering individual token details, token market data, holder analysis, and trading insights. The token explorer is essential for users to understand token ecosystems, track market movements, and analyze token distribution patterns on Solana.

## Requirements

### Requirement 1: Individual Token Detail Page

**User Story:** As a token investor, I want to view comprehensive information about a specific token, so that I can make informed investment decisions and understand token fundamentals.

#### Acceptance Criteria

1. WHEN a user navigates to `/token/[mint]` with a valid mint address THEN the system SHALL display comprehensive token information including metadata, supply data, market metrics, holder analysis, and transfer history
2. WHEN a user provides an invalid mint address THEN the system SHALL display a 404 error page with suggestions for valid token searches
3. WHEN token data is loading THEN the system SHALL show progressive loading states for different sections (metadata, market data, holders, transfers)
4. WHEN token metadata is unavailable THEN the system SHALL show fallback information using mint address and on-chain data
5. WHEN a user views token details THEN the system SHALL provide links to related tokens and trading pairs
6. WHEN market data is displayed THEN the system SHALL show real-time price updates and historical charts
7. WHEN holder information is shown THEN the system SHALL display top holders and distribution analysis
8. WHEN transfer history is displayed THEN the system SHALL provide filtering and search capabilities

### Requirement 2: Token Market Data Integration

**User Story:** As a trader, I want to see real-time market data and price charts for tokens, so that I can track price movements and make trading decisions.

#### Acceptance Criteria

1. WHEN viewing a token page THEN the system SHALL display current price, 24h change, market cap, volume, and liquidity metrics
2. WHEN market data updates THEN the system SHALL refresh prices in real-time without page reload
3. WHEN price charts are displayed THEN the system SHALL support multiple timeframes (1h, 24h, 7d, 30d, 1y)
4. WHEN volume data is shown THEN the system SHALL display trading volume trends and patterns
5. WHEN market cap is calculated THEN the system SHALL use accurate circulating supply data
6. WHEN liquidity metrics are displayed THEN the system SHALL show DEX liquidity and trading pair information
7. WHEN price alerts are configured THEN the system SHALL notify users of significant price movements
8. WHEN market data is unavailable THEN the system SHALL show appropriate fallback messages and retry options

### Requirement 3: Token Holder Analysis

**User Story:** As a token analyst, I want to analyze token holder distribution and whale activity, so that I can understand token concentration and market dynamics.

#### Acceptance Criteria

1. WHEN viewing token holders THEN the system SHALL display top 100 holders with addresses, balances, and ownership percentages
2. WHEN holder distribution is analyzed THEN the system SHALL show concentration metrics and Gini coefficient
3. WHEN whale activity is tracked THEN the system SHALL identify large holders and their recent transactions
4. WHEN new holders are detected THEN the system SHALL show holder growth metrics and acquisition patterns
5. WHEN holder retention is analyzed THEN the system SHALL calculate average holding time and turnover rates
6. WHEN holder addresses are clicked THEN the system SHALL navigate to account detail pages
7. WHEN holder data is exported THEN the system SHALL provide CSV/JSON export functionality
8. WHEN holder privacy is considered THEN the system SHALL respect user privacy preferences and anonymization requests

### Requirement 4: Token Transfer History and Analysis

**User Story:** As a compliance officer, I want to track token transfers and analyze transaction patterns, so that I can monitor for suspicious activity and ensure regulatory compliance.

#### Acceptance Criteria

1. WHEN viewing transfer history THEN the system SHALL display recent transfers with sender, receiver, amount, and timestamp
2. WHEN transfers are filtered THEN the system SHALL support filtering by amount range, date range, and address
3. WHEN large transfers are detected THEN the system SHALL highlight significant movements and whale activity
4. WHEN transfer patterns are analyzed THEN the system SHALL identify unusual activity and potential wash trading
5. WHEN transfer data is searched THEN the system SHALL support search by transaction signature and addresses
6. WHEN transfers are exported THEN the system SHALL provide detailed export with all transaction metadata
7. WHEN real-time transfers occur THEN the system SHALL update the transfer list with live data
8. WHEN transfer analysis is performed THEN the system SHALL calculate velocity metrics and circulation patterns

### Requirement 5: Token Statistics and Metrics

**User Story:** As a DeFi researcher, I want to see comprehensive token statistics and derived metrics, so that I can analyze token health and ecosystem participation.

#### Acceptance Criteria

1. WHEN token statistics are displayed THEN the system SHALL show supply metrics (total, circulating, burned, locked)
2. WHEN circulation metrics are calculated THEN the system SHALL display velocity, turnover rate, and active addresses
3. WHEN token utility is analyzed THEN the system SHALL show program interactions and use cases
4. WHEN token age is considered THEN the system SHALL display creation date, age, and lifecycle metrics
5. WHEN token performance is measured THEN the system SHALL calculate price performance over multiple timeframes
6. WHEN token correlation is analyzed THEN the system SHALL show correlation with other tokens and market indices
7. WHEN token risk is assessed THEN the system SHALL provide risk scores and volatility metrics
8. WHEN token fundamentals are evaluated THEN the system SHALL show developer activity and community metrics

### Requirement 6: Token List and Market Overview

**User Story:** As a market observer, I want to browse all tokens with market data and filtering options, so that I can discover new tokens and track market trends.

#### Acceptance Criteria

1. WHEN visiting `/tokens` THEN the system SHALL display a comprehensive list of tokens with market data
2. WHEN token list is sorted THEN the system SHALL support sorting by market cap, volume, price change, and holders
3. WHEN tokens are filtered THEN the system SHALL provide filters for market cap range, volume, and token categories
4. WHEN token search is used THEN the system SHALL support search by name, symbol, and mint address
5. WHEN market overview is displayed THEN the system SHALL show total market statistics and trends
6. WHEN token categories are shown THEN the system SHALL group tokens by type (DeFi, gaming, NFT, etc.)
7. WHEN new tokens are highlighted THEN the system SHALL show recently launched tokens with launch metrics
8. WHEN token list is exported THEN the system SHALL provide export functionality with current market data

### Requirement 7: Token Gainers and Losers Tracking

**User Story:** As a momentum trader, I want to see top gaining and losing tokens across different timeframes, so that I can identify trading opportunities and market trends.

#### Acceptance Criteria

1. WHEN visiting `/tokens/gainers` THEN the system SHALL display top performing tokens by price change
2. WHEN timeframes are selected THEN the system SHALL support 1h, 24h, 7d, and 30d performance analysis
3. WHEN gainers are ranked THEN the system SHALL sort by percentage change with volume weighting
4. WHEN losers are displayed THEN the system SHALL show worst performing tokens with context
5. WHEN performance metrics are calculated THEN the system SHALL include volume-adjusted returns
6. WHEN alerts are configured THEN the system SHALL notify users of significant movers
7. WHEN historical gainers are tracked THEN the system SHALL show past performance leaders
8. WHEN gainer analysis is performed THEN the system SHALL identify patterns and catalysts for price movements

### Requirement 8: New Token Discovery and Launch Tracking

**User Story:** As an early investor, I want to discover newly launched tokens and track their early performance, so that I can identify investment opportunities and assess launch success.

#### Acceptance Criteria

1. WHEN visiting `/tokens/new` THEN the system SHALL display recently launched tokens with launch metrics
2. WHEN launch performance is tracked THEN the system SHALL show price change from launch and initial metrics
3. WHEN launch quality is assessed THEN the system SHALL provide verification status and risk indicators
4. WHEN liquidity is analyzed THEN the system SHALL show initial and current liquidity levels
5. WHEN early adoption is measured THEN the system SHALL track holder growth and distribution
6. WHEN launch calendar is displayed THEN the system SHALL show upcoming token launches and schedules
7. WHEN launch alerts are configured THEN the system SHALL notify users of new token launches
8. WHEN launch analysis is performed THEN the system SHALL identify successful launch patterns and red flags

### Requirement 9: Token Social Media and Community Integration

**User Story:** As a community member, I want to see token social media activity and community metrics, so that I can gauge community sentiment and engagement.

#### Acceptance Criteria

1. WHEN token social links are displayed THEN the system SHALL show official website, Twitter, Discord, and Telegram links
2. WHEN social metrics are tracked THEN the system SHALL display follower counts and engagement rates
3. WHEN community activity is measured THEN the system SHALL show discussion volume and sentiment analysis
4. WHEN social sentiment is analyzed THEN the system SHALL provide sentiment scores and trend indicators
5. WHEN community growth is tracked THEN the system SHALL show follower growth and engagement trends
6. WHEN social alerts are configured THEN the system SHALL notify users of significant social activity
7. WHEN community health is assessed THEN the system SHALL provide community health scores and metrics
8. WHEN social data is integrated THEN the system SHALL correlate social activity with price movements

### Requirement 10: Token Holder Trollbox and Community Rating

**User Story:** As a token holder, I want to participate in anonymous community discussions and rate the token with other holders, so that I can share insights and gauge community sentiment without revealing my wallet address.

#### Acceptance Criteria

1. WHEN accessing the trollbox THEN the system SHALL verify user holds the token before allowing message posting and rating
2. WHEN messages are displayed THEN the system SHALL show the user's ownership percentage (~X% of total supply) instead of wallet address
3. WHEN ownership percentage is calculated THEN the system SHALL update in real-time based on current token holdings
4. WHEN messages are posted THEN the system SHALL implement rate limiting based on ownership percentage (higher holders get more frequent posting)
5. WHEN community rating is performed THEN the system SHALL allow token holders to like/dislike the token with voting weight based on ownership percentage
6. WHEN rating results are displayed THEN the system SHALL show aggregated sentiment scores and holder sentiment distribution
7. WHEN rating history is tracked THEN the system SHALL maintain historical sentiment trends and correlate with price movements
8. WHEN message moderation is applied THEN the system SHALL implement community-based moderation and spam filtering
9. WHEN message history is maintained THEN the system SHALL store messages with timestamps and ownership snapshots
10. WHEN trollbox privacy is protected THEN the system SHALL ensure wallet addresses are never revealed in the chat interface
11. WHEN ownership verification is performed THEN the system SHALL re-verify token holdings periodically to maintain access rights
12. WHEN rating manipulation is prevented THEN the system SHALL detect and prevent coordinated rating attacks and bot activity

### Requirement 11: Token Price Alerts and Watchlists

**User Story:** As an active trader, I want to set price alerts and maintain watchlists for tokens, so that I can monitor my investments and react to market opportunities.

#### Acceptance Criteria

1. WHEN price alerts are created THEN the system SHALL support alerts for price thresholds, percentage changes, and volume spikes
2. WHEN watchlists are managed THEN the system SHALL allow users to add/remove tokens and organize by categories
3. WHEN alerts are triggered THEN the system SHALL send notifications via email, browser notifications, or webhooks
4. WHEN watchlist performance is tracked THEN the system SHALL show portfolio-style performance metrics
5. WHEN alert history is maintained THEN the system SHALL provide logs of triggered alerts and user actions
6. WHEN alert conditions are configured THEN the system SHALL support complex conditions and combinations
7. WHEN watchlist sharing is enabled THEN the system SHALL allow users to share watchlists with others
8. WHEN alert management is provided THEN the system SHALL offer bulk operations and alert templates

### Requirement 12: Token Comparison and Analysis Tools

**User Story:** As a token analyst, I want to compare multiple tokens side-by-side and analyze their relative performance, so that I can make informed investment decisions.

#### Acceptance Criteria

1. WHEN tokens are compared THEN the system SHALL display side-by-side metrics for up to 5 tokens
2. WHEN comparison metrics are shown THEN the system SHALL include market data, holder metrics, and performance data
3. WHEN relative performance is analyzed THEN the system SHALL show correlation analysis and beta calculations
4. WHEN comparison charts are displayed THEN the system SHALL overlay price charts and volume data
5. WHEN fundamental comparison is performed THEN the system SHALL compare supply metrics and tokenomics
6. WHEN comparison results are exported THEN the system SHALL provide detailed comparison reports
7. WHEN comparison templates are used THEN the system SHALL offer pre-configured comparison sets
8. WHEN comparison insights are generated THEN the system SHALL highlight key differences and similarities

### Requirement 12: Token API and Data Export

**User Story:** As a developer, I want to access token data programmatically and export data for analysis, so that I can build applications and perform custom analysis.

#### Acceptance Criteria

1. WHEN API endpoints are accessed THEN the system SHALL provide RESTful APIs for all token data
2. WHEN data is exported THEN the system SHALL support CSV, JSON, and Excel formats
3. WHEN API authentication is required THEN the system SHALL provide API key management
4. WHEN rate limiting is applied THEN the system SHALL implement fair usage policies
5. WHEN real-time data is accessed THEN the system SHALL provide WebSocket APIs for live updates
6. WHEN historical data is requested THEN the system SHALL support time-series data export
7. WHEN API documentation is provided THEN the system SHALL offer comprehensive API documentation
8. WHEN API monitoring is implemented THEN the system SHALL track usage and provide analytics

### Requirement 13: Token Security and Risk Assessment

**User Story:** As a security-conscious investor, I want to see security assessments and risk indicators for tokens, so that I can avoid scams and make safer investment decisions.

#### Acceptance Criteria

1. WHEN security analysis is performed THEN the system SHALL check for common scam patterns and red flags
2. WHEN contract verification is checked THEN the system SHALL verify token contract authenticity
3. WHEN liquidity risks are assessed THEN the system SHALL analyze liquidity depth and concentration
4. WHEN holder risks are evaluated THEN the system SHALL identify potential rug pull indicators
5. WHEN audit information is available THEN the system SHALL display security audit results
6. WHEN risk scores are calculated THEN the system SHALL provide comprehensive risk ratings
7. WHEN security alerts are configured THEN the system SHALL notify users of security concerns
8. WHEN risk education is provided THEN the system SHALL offer educational content about token risks

### Requirement 14: Token Creator Analysis and Rug Pull Detection

**User Story:** As a security researcher, I want to analyze token creators and their wallet history to identify potential rug pull risks, so that I can warn users about dangerous tokens.

#### Acceptance Criteria

1. WHEN token creator is analyzed THEN the system SHALL identify the wallet that created/minted the token
2. WHEN creator wallet history is traced THEN the system SHALL analyze the creator's transaction history and previous token creations
3. WHEN rug pull connections are checked THEN the system SHALL identify if the creator wallet is connected to previous rug pulls or scam tokens
4. WHEN wallet seeder analysis is performed THEN the system SHALL trace funding sources back through the chain until reaching exchanges or validators
5. WHEN creator risk assessment is calculated THEN the system SHALL provide risk scores based on creator's history and connections
6. WHEN previous token performance is analyzed THEN the system SHALL show performance of other tokens created by the same entity
7. WHEN creator reputation is displayed THEN the system SHALL show creator's track record and community feedback
8. WHEN creator alerts are configured THEN the system SHALL notify users when tokens are created by flagged addresses

### Requirement 15: Token Bundling and Manipulation Detection

**User Story:** As a market analyst, I want to detect token bundling and coordinated buying patterns, so that I can identify artificially inflated tokens and market manipulation.

#### Acceptance Criteria

1. WHEN bundling analysis is performed THEN the system SHALL identify wallets that purchased tokens from the same funding source
2. WHEN coordinated buying is detected THEN the system SHALL identify purchases made in the same time period by related wallets
3. WHEN wallet clustering is analyzed THEN the system SHALL group wallets based on funding patterns and transaction timing
4. WHEN manipulation patterns are identified THEN the system SHALL detect wash trading and artificial volume inflation
5. WHEN bundle risk scores are calculated THEN the system SHALL provide manipulation risk ratings based on detected patterns
6. WHEN natural vs artificial demand is assessed THEN the system SHALL distinguish between organic growth and coordinated activity
7. WHEN bundling alerts are configured THEN the system SHALL notify users of detected manipulation patterns
8. WHEN bundling evidence is displayed THEN the system SHALL show visual representations of wallet connections and funding flows

### Requirement 16: Similar Tokens and Recommendation System

**User Story:** As a token explorer, I want to discover similar tokens and receive recommendations based on my interests, so that I can find related investment opportunities.

#### Acceptance Criteria

1. WHEN similar tokens are displayed THEN the system SHALL show tokens with similar characteristics (market cap, sector, performance)
2. WHEN token similarity is calculated THEN the system SHALL use multiple factors including price correlation, holder overlap, and use case similarity
3. WHEN recommendations are provided THEN the system SHALL suggest tokens based on user viewing history and preferences
4. WHEN token categories are analyzed THEN the system SHALL group tokens by sector, use case, and ecosystem participation
5. WHEN correlation analysis is performed THEN the system SHALL show price and volume correlations with other tokens
6. WHEN ecosystem connections are mapped THEN the system SHALL identify tokens used in similar protocols or applications
7. WHEN recommendation quality is measured THEN the system SHALL track user engagement with recommended tokens
8. WHEN personalized suggestions are offered THEN the system SHALL adapt recommendations based on user behavior and preferences

### Requirement 17: Data Storage and Vector Search Integration

**User Story:** As a system architect, I want all processed token analytics data to be stored in Qdrant for efficient vector search and similarity analysis, so that the system can provide fast recommendations and complex queries.

#### Acceptance Criteria

1. WHEN token analytics are processed THEN the system SHALL store all processed data (holder analysis, transfer patterns, security scores, creator analysis) in Qdrant collections
2. WHEN token similarity is calculated THEN the system SHALL use Qdrant vector embeddings to find similar tokens based on multiple characteristics
3. WHEN bundling detection is performed THEN the system SHALL store wallet clustering data and funding patterns as vectors in Qdrant
4. WHEN creator risk analysis is completed THEN the system SHALL store creator profiles and risk indicators in Qdrant for fast lookup
5. WHEN token recommendations are generated THEN the system SHALL use Qdrant similarity search to find related tokens
6. WHEN security analysis is performed THEN the system SHALL store risk patterns and scam indicators as searchable vectors
7. WHEN data is queried THEN the system SHALL use Qdrant's filtering and search capabilities for complex analytics queries
8. WHEN data is updated THEN the system SHALL maintain data consistency between Qdrant and other storage systems

### Requirement 18: Performance Optimization and Caching

**User Story:** As a system administrator, I want the token explorer to perform efficiently under high load, so that users experience fast response times and reliable service.

#### Acceptance Criteria

1. WHEN token data is cached THEN the system SHALL implement appropriate caching strategies for different data types
2. WHEN real-time updates are provided THEN the system SHALL optimize for minimal latency and resource usage
3. WHEN large datasets are handled THEN the system SHALL implement pagination and virtual scrolling
4. WHEN API responses are optimized THEN the system SHALL minimize response sizes and implement compression
5. WHEN database queries are executed THEN the system SHALL use efficient indexing and query optimization
6. WHEN CDN is utilized THEN the system SHALL cache static assets and optimize global delivery
7. WHEN performance monitoring is implemented THEN the system SHALL track response times and system health
8. WHEN scaling is required THEN the system SHALL support horizontal scaling and load balancing

### Requirement 19: Token Portfolio Tracking and PnL Analysis

**User Story:** As an investor, I want to track my token portfolio performance and see detailed PnL analysis, so that I can monitor my investments and make informed decisions.

#### Acceptance Criteria

1. WHEN connecting wallet THEN the system SHALL automatically detect and track all token holdings
2. WHEN portfolio is displayed THEN the system SHALL show current value, cost basis, unrealized PnL, and percentage allocation
3. WHEN PnL is calculated THEN the system SHALL track realized gains/losses from all transactions
4. WHEN portfolio performance is analyzed THEN the system SHALL show performance vs market benchmarks and indices
5. WHEN tax reporting is needed THEN the system SHALL generate tax reports with detailed transaction history
6. WHEN portfolio alerts are configured THEN the system SHALL notify users of significant portfolio changes
7. WHEN portfolio sharing is enabled THEN the system SHALL allow users to share portfolio performance (with privacy controls)
8. WHEN portfolio analytics are provided THEN the system SHALL show diversification metrics and risk analysis

### Requirement 20: Token Prediction and AI Insights

**User Story:** As a trader, I want to see AI-powered predictions and insights about token performance, so that I can make more informed trading decisions.

#### Acceptance Criteria

1. WHEN AI analysis is performed THEN the system SHALL provide price prediction models based on historical data and market indicators
2. WHEN sentiment analysis is conducted THEN the system SHALL analyze social media, news, and community sentiment for price impact
3. WHEN technical analysis is provided THEN the system SHALL show AI-generated support/resistance levels and trend analysis
4. WHEN market patterns are identified THEN the system SHALL detect and alert users to similar historical patterns
5. WHEN risk assessment is calculated THEN the system SHALL provide AI-powered risk scores and volatility predictions
6. WHEN trading signals are generated THEN the system SHALL provide buy/sell signals with confidence levels
7. WHEN AI insights are displayed THEN the system SHALL explain the reasoning behind predictions and recommendations
8. WHEN prediction accuracy is tracked THEN the system SHALL maintain performance metrics for AI models and improve over time

### Requirement 21: Gamification and User Engagement

**User Story:** As a platform user, I want to earn rewards and achievements for using the platform, so that I feel engaged and motivated to continue exploring tokens.

#### Acceptance Criteria

1. WHEN users interact with the platform THEN the system SHALL award points for various activities (viewing tokens, sharing insights, accurate predictions)
2. WHEN achievements are unlocked THEN the system SHALL provide badges for milestones (first token analysis, portfolio tracking, community participation)
3. WHEN leaderboards are displayed THEN the system SHALL show top users by points, prediction accuracy, and community contributions
4. WHEN rewards are distributed THEN the system SHALL offer token airdrops, premium features, or exclusive access as rewards
5. WHEN user levels are calculated THEN the system SHALL provide progression system with increasing benefits
6. WHEN challenges are created THEN the system SHALL offer weekly/monthly challenges for token discovery and analysis
7. WHEN social features are gamified THEN the system SHALL reward quality contributions to trollbox and community ratings
8. WHEN referral program is implemented THEN the system SHALL reward users for bringing new users to the platform

### Requirement 22: Token Launch Pad and Early Access Features

**User Story:** As an early investor, I want to discover and get early access to promising token launches before they hit major exchanges, so that I can maximize my investment opportunities.

#### Acceptance Criteria

1. WHEN token launches are tracked THEN the system SHALL monitor and list upcoming token launches with detailed project information
2. WHEN early access is provided THEN the system SHALL offer whitelist spots and early purchase opportunities for verified projects
3. WHEN launch quality is assessed THEN the system SHALL provide due diligence reports and risk assessments for upcoming launches
4. WHEN launch notifications are configured THEN the system SHALL alert users about launches matching their criteria and interests
5. WHEN launch performance is tracked THEN the system SHALL show post-launch performance metrics and early investor returns
6. WHEN launch calendar is displayed THEN the system SHALL provide comprehensive calendar with launch schedules and key dates
7. WHEN launch community is built THEN the system SHALL create dedicated spaces for discussing upcoming launches
8. WHEN launch analytics are provided THEN the system SHALL analyze successful launch patterns and provide insights

### Requirement 23: Advanced Trading Integration and DEX Aggregation

**User Story:** As a trader, I want to execute trades directly from the token explorer with best price discovery, so that I can act quickly on insights without leaving the platform.

#### Acceptance Criteria

1. WHEN trading is initiated THEN the system SHALL integrate with major DEX aggregators (Jupiter, Pumpfun, Bonkfun, Raydium) for best price execution
2. WHEN price comparison is shown THEN the system SHALL display prices across multiple DEXs and recommend optimal routes
3. WHEN trading interface is used THEN the system SHALL provide advanced order types (limit, stop-loss, DCA)
4. WHEN slippage is calculated THEN the system SHALL show real-time slippage estimates and price impact
5. WHEN trading history is tracked THEN the system SHALL maintain detailed trading logs and performance analytics
6. WHEN trading signals are integrated THEN the system SHALL allow one-click trading based on AI recommendations
7. WHEN MEV protection is provided THEN the system SHALL offer MEV-protected trading options
8. WHEN trading fees are optimized THEN the system SHALL find routes with lowest fees and best execution

### Requirement 24: Mobile Optimization and Accessibility

**User Story:** As a mobile user with accessibility needs, I want the token explorer to work seamlessly on mobile devices and with assistive technologies, so that I can access token information anywhere.

#### Acceptance Criteria

1. WHEN using mobile devices THEN the system SHALL provide responsive design optimized for touch interaction
2. WHEN accessibility features are used THEN the system SHALL support screen readers and keyboard navigation
3. WHEN mobile performance is optimized THEN the system SHALL minimize data usage and loading times
4. WHEN touch gestures are implemented THEN the system SHALL support swipe navigation and touch-friendly controls
5. WHEN offline functionality is provided THEN the system SHALL cache essential data for offline viewing
6. WHEN mobile-specific features are used THEN the system SHALL integrate with device capabilities (notifications, sharing)
7. WHEN accessibility standards are met THEN the system SHALL comply with WCAG 2.1 AA guidelines
8. WHEN mobile testing is performed THEN the system SHALL work across different devices and browsers
---

## File: ./.kiro/specs/token-explorer-enhancements/tasks.md

# Token Explorer Enhancements Implementation Plan

- [ ] 1. Set up core token data infrastructure and Qdrant integration
  - Create token data types and interfaces for comprehensive token information
  - Implement Qdrant collections for token vectors, security patterns, and user behavior
  - Set up API endpoints for token fetching, analytics, and real-time updates
  - Configure caching layer with appropriate TTL strategies for different data types
  - _Requirements: 1.1, 17.1, 17.2, 18.1, 18.2_

- [ ] 1.1 Create token data models and TypeScript interfaces
  - Create `lib/types/token.types.ts` with comprehensive TokenData interface including mint, metadata, supply, marketData, holders[], transfers[], statistics, socialLinks, securityAnalysis, creatorAnalysis, bundlingAnalysis, similarTokens[], communityRating, aiInsights
  - Define TokenMetadata interface with name, symbol, decimals, description, image, creator, verified, tags[], createdAt, website, twitter, discord, telegram
  - Create TokenMarketData interface with price, priceChange24h, volume24h, marketCap, fullyDilutedMarketCap, liquidity, holders, priceHistory[], volumeHistory[]
  - Implement TokenSupply interface with total, circulating, burned, locked, inflation, deflation
  - Define TokenStatistics interface with transferCount24h, uniqueHolders, averageHoldingTime, concentrationRatio, liquidityScore, velocityScore, utilityScore, ageInDays, volatility metrics
  - Create SecurityAnalysis interface with riskScore, riskLevel, riskFactors[], liquidityAnalysis, contractVerification, auditReports[]
  - Implement CreatorAnalysis interface with creatorAddress, creatorRiskScore, previousTokens[], rugPullConnections[], walletSeedAnalysis, reputationScore
  - Add BundlingAnalysis interface with bundlingDetected, bundlingScore, coordinatedWallets[], fundingPatterns[], manipulationIndicators[]
  - Create CommunityRating interface with totalRatings, positiveRatings, negativeRatings, weightedScore, sentimentTrend[], topHolderSentiment
  - Define AIInsights interface with pricePrediction, sentimentAnalysis, technicalAnalysis, riskAssessment, tradingSignals[], marketPatterns[]
  - _Requirements: 1.1, 2.1, 3.1, 4.1, 5.1, 10.1, 13.1, 14.1, 15.1, 16.1, 19.1, 20.1_

- [ ] 1.2 Set up Qdrant vector database integration
  - Create `lib/qdrant/token-vectors.ts` with QdrantTokenService class implementing createCollections(), storeTokenVector(), searchSimilarTokens(), storeSecurityPattern(), searchSecurityPatterns() methods
  - Configure Qdrant collections: token_vectors (512-dim embeddings with payload: mint, symbol, marketCap, volume24h, holderCount, riskScore, category, launchDate, creatorRisk, bundlingScore, communityRating, liquidityScore, volatility, utilityScore), security_vectors (security pattern embeddings with patternType, severity, tokenMint, creatorAddress, evidence[], confidence, detectedAt), user_vectors (user behavior patterns), market_vectors (market pattern analysis), sentiment_vectors (community sentiment analysis)
  - Implement vector generation using OpenAI embeddings API for token characteristics, security patterns, and user behavior
  - Create vector search operations with filtering capabilities for similar token discovery, security pattern matching, and recommendation generation
  - Add vector upsert operations for real-time updates when token data changes
  - Implement vector similarity scoring and ranking algorithms for accurate recommendations
  - _Requirements: 17.1, 17.2, 17.3, 17.4, 17.5, 17.6, 17.7, 17.8_- [ ] 1.
3 Implement core token API endpoints
  - Create `app/api/token/[mint]/route.ts` with GET handler that validates mint parameter using base58 validation and length checking, fetches token metadata from Solana RPC using getAccountInfo() and getParsedAccountInfo(), processes token supply data using getTokenSupply(), implements error handling for invalid mints (return 404) and network errors (return 500 with retry headers)
  - Implement `app/api/tokens/route.ts` with GET handler supporting query parameters: limit (default 50, max 100), offset (for pagination), sortBy (marketCap, volume, priceChange, holders), filterBy (category, verified, riskLevel), search (name/symbol search), return TokenListItem[] with mint, name, symbol, image, price, priceChange24h, marketCap, volume24h, holders, verified, riskScore, communityRating, launchDate
  - Add `app/api/tokens/gainers/route.ts` supporting timeframe parameter (1h, 24h, 7d, 30d), return top gaining tokens sorted by percentage change with volume weighting
  - Create `app/api/tokens/new/route.ts` returning recently launched tokens (last 30 days) with launch metrics and performance data
  - Implement input validation using Zod schemas for all query parameters and path parameters
  - Add rate limiting using lib/rate-limiter.ts with different limits per endpoint (token detail: 200/min, token list: 500/min, gainers: 100/min)
  - _Requirements: 1.1, 6.1, 7.1, 8.1_

- [ ] 1.4 Set up token data caching system
  - Create `lib/cache/token-cache.ts` with TokenCacheManager class implementing get/set/invalidate methods for different data types, use Redis for production with Map<string, CacheEntry> fallback for development
  - Configure cache TTL strategies: token metadata = 1 hour (rarely changes), market data = 30 seconds (real-time updates), security analysis = 30 minutes (computationally expensive), community data = 1 minute (active discussions), AI insights = 15 minutes (model inference costs)
  - Implement cache key patterns: "token:{mint}", "token:market:{mint}", "token:security:{mint}", "token:community:{mint}", "token:ai:{mint}", "tokens:list:{params_hash}", "tokens:gainers:{timeframe}"
  - Add cache warming for popular tokens: pre-fetch and cache top 100 tokens by market cap on startup, implement background refresh job every 5 minutes for top tokens
  - Create cache metrics tracking: hit/miss rates, memory usage, eviction counts, expose via /api/cache/metrics endpoint for monitoring
  - Implement cache invalidation triggers: invalidate token cache when new transactions detected, invalidate market data on price updates, invalidate security analysis when new risk patterns detected
  - _Requirements: 18.1, 18.2, 18.3, 18.4_

- [ ] 2. Build token detail page with comprehensive information display
  - Create TokenDetailsPage component with metadata, market data, holder analysis, and security assessment
  - Implement progressive loading states and error handling for different data sections
  - Add real-time price updates and market data streaming
  - _Requirements: 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8_

- [ ] 2.1 Create TokenDetailsPage main component
  - Create `app/token/[mint]/page.tsx` as server component with generateMetadata() function for dynamic SEO, implement getTokenData() server function using fetch to /api/token/[mint], handle loading states with Suspense wrapper
  - Build responsive layout using CSS Grid: header section (token info + price), main content area with tabbed interface (Overview | Holders | Transfers | Security | Community | Trading), sidebar with similar tokens and AI insights
  - Implement tabbed navigation component in `components/TokenTabs.tsx` with URL synchronization, lazy loading of tab content, keyboard navigation support
  - Add error boundary wrapper using `components/TokenErrorBoundary.tsx` to catch and display token not found (404) or network errors, implement retry button that refetches data
  - Create loading skeleton components matching final layout structure, use React Suspense with fallback showing skeleton for each section
  - Implement URL parameter validation: parse mint from params, validate as base58 string with correct length, redirect invalid mints to /tokens with error message
  - _Requirements: 1.1, 1.2, 1.3_- 
[ ] 2.2 Implement token metadata and market data display
  - Create `components/TokenHeader.tsx` component displaying token logo, name, symbol, verified badge, price (with real-time updates), 24h change (with color coding), market cap, volume, and quick action buttons (trade, add to watchlist, share)
  - Build `components/TokenMarketData.tsx` component showing detailed market metrics: current price, 24h high/low, market cap (circulating and fully diluted), 24h volume, liquidity, holder count, price charts with multiple timeframes (1h, 24h, 7d, 30d, 1y)
  - Create `components/TokenSupplyInfo.tsx` displaying supply metrics: total supply, circulating supply, burned tokens, locked tokens, inflation/deflation rates with visual progress bars
  - Implement `components/TokenPriceChart.tsx` using recharts library with candlestick/line chart options, volume overlay, zoom/pan functionality, technical indicators (MA, RSI, MACD), export chart functionality
  - Add real-time price updates using WebSocket connection to price feed, implement price change animations and notifications, show last update timestamp
  - Create copy-to-clipboard functionality for mint address, contract address, and other identifiers using navigator.clipboard API with fallback
  - _Requirements: 1.1, 2.1, 2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8_

- [ ] 2.3 Build token holder analysis and distribution display
  - Create `components/TokenHolders.tsx` using @tanstack/react-table for virtual scrolling, implement columns: rank, address (truncated with copy button), balance (formatted with decimals), percentage of total supply, account type (wallet/program), last activity timestamp
  - Implement holder distribution visualization with `components/HolderDistributionChart.tsx` using recharts: pie chart showing top 10 holders vs others, concentration metrics (Gini coefficient, top 10/50/100 holder percentages), whale activity indicators
  - Add holder analysis metrics: unique holder count, average holding time, holder growth rate, turnover rate, new holders in last 24h/7d, holder retention analysis
  - Create `components/WhaleActivityTracker.tsx` showing large holder movements: recent large transfers, whale accumulation/distribution patterns, whale wallet labels and tracking
  - Implement holder search and filtering: filter by balance range, account type, activity level, sort by balance/percentage/activity, search by address
  - Add holder export functionality: CSV export with holder addresses, balances, percentages, timestamps, include privacy options for data export
  - _Requirements: 3.1, 3.2, 3.3, 3.4, 3.5, 3.6, 3.7, 3.8_

- [ ] 2.4 Build token transfer history and analysis display
  - Create `components/TokenTransfers.tsx` using virtual scrolling for large transfer lists, implement columns: timestamp (relative + absolute), from address (truncated), to address (truncated), amount (formatted), USD value (when available), transaction signature (clickable), transfer type (normal/program interaction)
  - Implement transfer filtering with `components/TransferFilters.tsx`: filter by amount range (min/max), date range picker, address search (sender/receiver), transfer type, sort by amount/time/USD value
  - Add large transfer detection and highlighting: identify transfers above certain thresholds (1%, 5%, 10% of daily volume), highlight whale movements with special styling, show transfer impact on price
  - Create transfer pattern analysis: detect unusual activity patterns, identify potential wash trading, calculate transfer velocity and circulation metrics, show transfer frequency charts
  - Implement real-time transfer updates: WebSocket connection for live transfer feed, show new transfers with animation, maintain scroll position during updates
  - Add transfer export functionality: CSV/JSON export with full transfer details, include transaction signatures and metadata, support date range filtering for exports
  - _Requirements: 4.1, 4.2, 4.3, 4.4, 4.5, 4.6, 4.7, 4.8_

- [ ] 3. Implement comprehensive security analysis and risk assessment
  - Create security analysis engine for rug pull detection and risk scoring
  - Build creator analysis system with wallet history tracking
  - Implement bundling detection and manipulation pattern recognition
  - _Requirements: 13.1, 13.2, 13.3, 13.4, 13.5, 13.6, 13.7, 13.8, 14.1, 14.2, 14.3, 14.4, 14.5, 14.6, 14.7, 14.8, 15.1, 15.2, 15.3, 15.4, 15.5, 15.6, 15.7, 15.8_- 
[ ] 3.1 Build security analysis engine
  - Create `lib/analyzers/security-analyzer.ts` with SecurityAnalyzer class containing analyzeTokenSecurity(tokenData: TokenData) method, implement risk scoring algorithm (0-100) based on multiple factors: liquidity depth, holder concentration, creator history, contract verification, audit status
  - Implement liquidity analysis: calculate liquidity depth across DEXs, identify liquidity concentration risks, detect potential liquidity rug pulls, analyze liquidity provider behavior and token unlock schedules
  - Add contract verification system: verify token contract authenticity against known standards, check for malicious code patterns, validate token metadata consistency, identify proxy contracts and upgrade mechanisms
  - Create audit report integration: fetch and display security audit results from major audit firms, parse audit findings and risk levels, show audit coverage and recommendations
  - Implement risk factor detection: identify common scam patterns (honeypot, high tax, ownership concentration), detect unusual token mechanics, analyze token utility and use cases
  - Store security analysis results in Qdrant: create security pattern vectors for similar risk detection, enable fast lookup of known security issues, implement pattern matching for new tokens
  - _Requirements: 13.1, 13.2, 13.3, 13.4, 13.5, 13.6, 13.7, 13.8_

- [ ] 3.2 Implement creator analysis and rug pull detection
  - Create `lib/analyzers/creator-analyzer.ts` with CreatorAnalyzer class implementing analyzeTokenCreator(creatorAddress: string) method, trace creator wallet history and previous token creations, identify connections to known rug pulls and scam tokens
  - Implement wallet seed analysis: trace funding sources back through transaction chain, identify ultimate funding source (exchange, validator, or suspicious wallet), calculate confidence score for funding legitimacy, detect circular funding patterns
  - Add previous token performance tracking: analyze all tokens created by same wallet, calculate success/failure rate of previous projects, identify patterns in token launches and abandonment, track creator reputation over time
  - Create rug pull connection detection: cross-reference creator with known rug pull database, identify wallet clusters and associated addresses, detect shared funding sources with known scammers, analyze timing patterns of suspicious activity
  - Implement creator reputation scoring: weight factors including previous token performance, community feedback, time since first activity, transaction patterns, social media presence and verification
  - Store creator analysis in Qdrant: create creator risk vectors for pattern matching, enable fast lookup of creator history, implement similarity search for related creators
  - _Requirements: 14.1, 14.2, 14.3, 14.4, 14.5, 14.6, 14.7, 14.8_

- [ ] 3.3 Build bundling detection and manipulation analysis
  - Create `lib/analyzers/bundling-analyzer.ts` with BundlingAnalyzer class implementing detectTokenBundling(tokenMint: string) method, analyze wallet funding patterns and purchase timing, identify coordinated buying activity and artificial demand
  - Implement coordinated wallet detection: identify wallets funded from same source within short time periods, detect similar transaction patterns and amounts, analyze wallet creation timing and funding sequences, cluster related wallets using graph analysis
  - Add manipulation pattern recognition: detect wash trading between related wallets, identify artificial volume inflation, analyze price manipulation attempts, detect coordinated pump and dump schemes
  - Create funding pattern analysis: trace funding sources for token purchasers, identify common funding wallets and exchanges, detect unusual funding patterns and timing, analyze funding amount distributions
  - Implement bundling risk scoring: calculate manipulation probability (0-100), weight factors including wallet clustering, timing patterns, funding sources, transaction similarities, provide evidence and confidence levels
  - Store bundling analysis in Qdrant: create manipulation pattern vectors, enable detection of similar bundling schemes, implement pattern matching for new token launches
  - _Requirements: 15.1, 15.2, 15.3, 15.4, 15.5, 15.6, 15.7, 15.8_

- [ ] 3.4 Create security analysis display components
  - Create `components/SecurityAnalysisPanel.tsx` with risk score display (0-100 with color coding), risk level indicator (low/medium/high/critical), detailed risk factors list with explanations, expandable sections for each risk category
  - Build `components/CreatorAnalysisDisplay.tsx` showing creator wallet address, reputation score, previous token history table, rug pull connections (if any), wallet seed analysis results with funding chain visualization
  - Implement `components/BundlingDetectionDisplay.tsx` with bundling risk score, coordinated wallet clusters visualization, funding pattern charts, manipulation evidence list, timeline of suspicious activity
  - Add `components/SecurityRecommendations.tsx` providing actionable security advice based on analysis results, risk mitigation strategies, red flags to watch for, educational content about token security
  - Create security alert system: show prominent warnings for high-risk tokens, implement progressive disclosure for risk details, provide clear action recommendations, include links to educational resources
  - Implement security data export: generate security reports in PDF format, include all analysis results and evidence, provide shareable security assessments
  - _Requirements: 13.1, 13.2, 13.3, 13.4, 13.5, 13.6, 13.7, 13.8, 14.1, 14.2, 14.3, 14.4, 14.5, 14.6, 14.7, 14.8, 15.1, 15.2, 15.3, 15.4, 15.5, 15.6, 15.7, 15.8_- 
[ ] 4. Build community features with trollbox and rating system
  - Create token holder verification system for community access
  - Implement anonymous trollbox with ownership percentage display
  - Build community rating system weighted by token holdings
  - _Requirements: 10.1, 10.2, 10.3, 10.4, 10.5, 10.6, 10.7, 10.8, 10.9, 10.10, 10.11, 10.12_

- [ ] 4.1 Implement token holder verification system
  - Create `lib/auth/token-holder-auth.ts` with TokenHolderAuth class implementing verifyTokenHoldings(walletAddress: string, tokenMint: string) method, use Solana RPC to check token account balance, calculate ownership percentage of total supply
  - Build holder verification middleware for API endpoints: verify wallet signature, check token holdings in real-time, implement caching for verified holders (5 minute TTL), handle edge cases (zero balance, account not found)
  - Add periodic re-verification system: background job to re-check holder status every 15 minutes, handle balance changes and access revocation, maintain holder status cache with automatic expiration
  - Create holder tier system based on ownership percentage: whale (>1%), large holder (0.1-1%), medium holder (0.01-0.1%), small holder (<0.01%), implement different privileges and rate limits per tier
  - Implement wallet connection integration: support multiple wallet adapters (Phantom, Solflare, Backpack), handle wallet switching and disconnection, maintain session state and re-authentication
  - Add holder verification UI components: wallet connection button, holder status indicator, ownership percentage display, verification progress and error states
  - _Requirements: 10.1, 10.3, 10.8, 10.11_

- [ ] 4.2 Build token trollbox system
  - Create `components/TokenTrollbox.tsx` with real-time chat interface, message input with character limit (280 chars), message display with timestamp and ownership percentage, auto-scroll to latest messages
  - Implement `lib/trollbox/trollbox-service.ts` with TrollboxService class managing message posting, retrieval, and real-time updates, use WebSocket for live message streaming, implement message persistence in database
  - Add rate limiting based on ownership percentage: whales (>1%) can post every 30 seconds, large holders (0.1-1%) every 60 seconds, medium holders (0.01-0.1%) every 120 seconds, small holders (<0.01%) every 300 seconds
  - Create message moderation system: automatic spam detection using content analysis, community-based reporting and moderation, admin moderation tools, message deletion and user timeout capabilities
  - Implement message formatting: support for basic text formatting, emoji support, automatic link detection, mention system for other holders, message threading for replies
  - Add trollbox privacy features: never display wallet addresses, show only ownership percentage (~X.XX%), implement message encryption for sensitive discussions, provide anonymous posting options
  - _Requirements: 10.1, 10.2, 10.4, 10.8, 10.9, 10.10_

- [ ] 4.3 Implement community rating system
  - Create `components/CommunityRatingSystem.tsx` with like/dislike buttons, rating display with weighted scores, sentiment visualization (positive/negative distribution), historical rating trends chart
  - Build `lib/rating/rating-service.ts` with RatingService class implementing submitRating(walletAddress: string, tokenMint: string, rating: 'like' | 'dislike') method, calculate weighted scores based on ownership percentage, prevent duplicate ratings from same wallet
  - Add rating weight calculation: weight votes by ownership percentage (whale vote = 100x small holder), implement quadratic voting to prevent manipulation, cap maximum vote weight to prevent single-holder dominance
  - Create rating analytics: track rating trends over time, correlate ratings with price movements, identify rating manipulation attempts, generate sentiment reports and insights
  - Implement rating display components: overall sentiment score (0-100), positive/negative percentage breakdown, top holder sentiment vs general sentiment, rating history charts with price overlay
  - Add rating manipulation detection: identify coordinated rating attacks, detect bot activity and fake accounts, implement cooldown periods and verification requirements, flag suspicious rating patterns
  - _Requirements: 10.5, 10.6, 10.7, 10.12_

- [ ] 5. Implement AI insights and prediction system
  - Create AI prediction engine for price forecasting and market analysis
  - Build sentiment analysis system for social media and community data
  - Implement trading signal generation and technical analysis
  - _Requirements: 20.1, 20.2, 20.3, 20.4, 20.5, 20.6, 20.7, 20.8_- 
[ ] 5.1 Build AI prediction engine
  - Create `lib/ai/prediction-engine.ts` with PredictionEngine class implementing generatePricePrediction(tokenMint: string, timeframes: string[]) method, use machine learning models for price forecasting, integrate multiple data sources (price history, volume, social sentiment, market indicators)
  - Implement prediction models: LSTM neural networks for time series forecasting, ensemble methods combining multiple models, technical analysis indicators (RSI, MACD, Bollinger Bands), sentiment-based price impact models
  - Add prediction confidence scoring: calculate confidence levels (0-100) for each prediction, factor in data quality and model accuracy, provide uncertainty ranges and risk assessments, track historical prediction accuracy
  - Create market pattern recognition: identify recurring price patterns and cycles, detect support and resistance levels, recognize trend reversals and breakout patterns, analyze correlation with broader market movements
  - Implement prediction caching and optimization: cache predictions for 15 minutes to reduce API costs, implement background model updates, optimize inference speed for real-time predictions, handle model versioning and updates
  - Store prediction results in Qdrant: create prediction pattern vectors for similar market conditions, enable fast lookup of historical predictions, implement pattern matching for market analysis
  - _Requirements: 20.1, 20.4, 20.8_

- [ ] 5.2 Implement sentiment analysis system
  - Create `lib/ai/sentiment-analyzer.ts` with SentimentAnalyzer class implementing analyzeSentiment(tokenMint: string) method, integrate social media APIs (Twitter, Reddit, Discord), analyze community trollbox messages and ratings
  - Build multi-source sentiment aggregation: Twitter mentions and engagement, Reddit discussions and upvotes, Discord community activity, Telegram group sentiment, news article analysis, influencer mentions and opinions
  - Add sentiment scoring algorithms: natural language processing for text analysis, emotion detection and classification, sentiment trend analysis over time, weighted sentiment based on source credibility and reach
  - Create sentiment-price correlation analysis: identify relationships between sentiment changes and price movements, calculate sentiment impact scores, detect sentiment-driven price events, provide sentiment-based trading insights
  - Implement real-time sentiment monitoring: continuous monitoring of social media feeds, real-time sentiment score updates, sentiment alert system for significant changes, sentiment trend visualization and reporting
  - Store sentiment data in Qdrant: create sentiment pattern vectors for similar market conditions, enable sentiment-based token recommendations, implement sentiment clustering and analysis
  - _Requirements: 20.2, 20.7_

- [ ] 5.3 Build trading signal generation system
  - Create `lib/ai/signal-generator.ts` with SignalGenerator class implementing generateTradingSignals(tokenMint: string) method, combine technical analysis, sentiment data, and market patterns, generate buy/sell/hold recommendations with confidence levels
  - Implement technical analysis signals: moving average crossovers, RSI overbought/oversold conditions, MACD divergences, Bollinger Band squeezes, volume analysis and breakout detection
  - Add fundamental analysis signals: holder concentration changes, liquidity depth analysis, whale movement detection, token utility and adoption metrics, competitive analysis and market positioning
  - Create signal confidence scoring: weight signals by historical accuracy, combine multiple signal types for stronger recommendations, provide risk-adjusted signal strength, include stop-loss and take-profit levels
  - Implement signal backtesting and validation: test signals against historical data, calculate win rates and risk-adjusted returns, optimize signal parameters for better performance, track signal performance over time
  - Add signal delivery system: real-time signal notifications, customizable signal filters and preferences, signal history and performance tracking, integration with trading interface for one-click execution
  - _Requirements: 20.3, 20.5, 20.6, 20.7_

- [ ] 5.4 Create AI insights display components
  - Create `components/AIInsightsPanel.tsx` with prediction display (price targets for different timeframes), confidence indicators and uncertainty ranges, prediction reasoning and key factors, historical accuracy metrics
  - Build `components/SentimentAnalysisDisplay.tsx` showing overall sentiment score, sentiment breakdown by source, sentiment trend charts, correlation with price movements, sentiment alerts and notifications
  - Implement `components/TradingSignalsDisplay.tsx` with current signals (buy/sell/hold), signal strength and confidence, recommended entry/exit points, stop-loss and take-profit levels, signal history and performance
  - Add `components/MarketPatternAnalysis.tsx` displaying identified patterns, pattern completion probability, similar historical patterns, pattern-based predictions and insights
  - Create AI insights export functionality: generate AI analysis reports, include predictions and reasoning, provide downloadable insights summary, share insights with community (with privacy controls)
  - Implement AI model transparency: explain AI decision-making process, show data sources and weights, provide model performance metrics, include disclaimers and risk warnings
  - _Requirements: 20.1, 20.2, 20.3, 20.4, 20.5, 20.6, 20.7, 20.8_

- [ ] 6. Build portfolio tracking and PnL analysis system
  - Create portfolio tracking system with automatic wallet detection
  - Implement comprehensive PnL calculation with cost basis tracking
  - Build portfolio analytics and performance comparison tools
  - _Requirements: 19.1, 19.2, 19.3, 19.4, 19.5, 19.6, 19.7, 19.8_-
 [ ] 6.1 Implement portfolio tracking system
  - Create `lib/portfolio/portfolio-tracker.ts` with PortfolioTracker class implementing trackWalletPortfolio(walletAddress: string) method, automatically detect all token holdings using Solana RPC getTokenAccountsByOwner(), calculate current values using real-time price data
  - Build transaction history analysis: fetch all token transactions for wallet, categorize transactions (buy, sell, transfer in/out, swap), calculate cost basis using FIFO/LIFO methods, track realized and unrealized gains/losses
  - Add portfolio performance metrics: total portfolio value, 24h/7d/30d performance, best/worst performing tokens, allocation percentages, diversification metrics, risk-adjusted returns (Sharpe ratio)
  - Create portfolio comparison tools: compare performance vs market benchmarks (SOL, market indices), peer portfolio comparison, sector allocation analysis, performance attribution analysis
  - Implement portfolio alerts: significant portfolio value changes, individual token performance alerts, rebalancing recommendations, risk threshold notifications
  - Store portfolio data in database: user portfolio snapshots, historical performance data, transaction records with cost basis, portfolio preferences and settings
  - _Requirements: 19.1, 19.2, 19.3, 19.4, 19.6_

- [ ] 6.2 Build PnL calculation engine
  - Create `lib/portfolio/pnl-calculator.ts` with PnLCalculator class implementing calculatePnL(transactions: Transaction[], currentPrices: PriceData[]) method, support multiple cost basis methods (FIFO, LIFO, average cost), handle complex scenarios (swaps, liquidity provision, staking rewards)
  - Implement realized PnL tracking: calculate gains/losses from completed transactions, handle partial sales and cost basis adjustments, track wash sale rules and tax implications, generate detailed transaction reports
  - Add unrealized PnL calculation: current market value vs cost basis, mark-to-market valuation, unrealized gain/loss percentages, portfolio-level unrealized PnL aggregation
  - Create tax reporting functionality: generate tax reports with realized gains/losses, support different tax jurisdictions and rules, export tax data in standard formats (CSV, TurboTax), include transaction details and cost basis information
  - Implement PnL analytics: PnL trends over time, token-specific PnL analysis, trading performance metrics, win/loss ratios, average holding periods, return on investment calculations
  - Add PnL visualization components: PnL charts and graphs, profit/loss distribution, performance heatmaps, comparative PnL analysis across time periods
  - _Requirements: 19.2, 19.3, 19.5_

- [ ] 6.3 Create portfolio display components
  - Create `components/PortfolioOverview.tsx` with total portfolio value display, 24h change with color coding, allocation pie chart, top holdings table, performance metrics dashboard
  - Build `components/PortfolioTokenList.tsx` using @tanstack/react-table with columns: token name/symbol, balance, current price, cost basis, unrealized PnL ($ and %), allocation %, 24h change, actions (trade, remove from watchlist)
  - Implement `components/PortfolioPerformanceChart.tsx` using recharts with portfolio value over time, comparison with benchmarks, performance attribution, drawdown analysis, return distribution
  - Add `components/PortfolioAnalytics.tsx` showing diversification metrics, risk analysis, correlation matrix, sector allocation, performance statistics (total return, annualized return, volatility, Sharpe ratio)
  - Create portfolio sharing functionality: generate shareable portfolio performance reports, privacy controls for shared data, social media integration for portfolio updates
  - Implement portfolio export features: CSV/Excel export with detailed holdings and performance, PDF portfolio reports, tax reporting exports, historical data downloads
  - _Requirements: 19.1, 19.2, 19.3, 19.4, 19.7, 19.8_

- [ ] 7. Implement gamification and user engagement system
  - Create user points and achievement system
  - Build leaderboards and competitive features
  - Implement reward system and user progression
  - _Requirements: 21.1, 21.2, 21.3, 21.4, 21.5, 21.6, 21.7, 21.8_

- [ ] 7.1 Build user points and achievement system
  - Create `lib/gamification/points-system.ts` with PointsSystem class implementing awardPoints(userId: string, activity: string, points: number) method, track user activities (token views, portfolio updates, community participation, accurate predictions), implement point multipliers for premium users
  - Define point-earning activities: view token details (1 point), add token to watchlist (5 points), share token analysis (10 points), accurate price prediction (50 points), community contribution (25 points), referral signup (100 points)
  - Build achievement system: create achievement definitions with requirements and rewards, track progress towards achievements, unlock badges and special privileges, implement rare achievements for exceptional contributions
  - Add user level progression: calculate user levels based on total points, unlock new features and privileges at higher levels, provide level-based benefits (higher rate limits, exclusive features, priority support)
  - Create achievement categories: analyst achievements (accurate predictions, detailed analysis), community achievements (helpful contributions, positive ratings), explorer achievements (discovering new tokens, early adoption), trader achievements (successful trades, portfolio performance)
  - Store gamification data in database: user points and levels, achievement progress and unlocks, activity history and streaks, leaderboard rankings and statistics
  - _Requirements: 21.1, 21.2, 21.5_- [
 ] 7.2 Implement leaderboards and competitive features
  - Create `components/Leaderboards.tsx` with multiple leaderboard categories: top analysts (prediction accuracy), top contributors (community points), top traders (portfolio performance), top discoverers (early token finds), overall points leaders
  - Build `lib/gamification/leaderboard-service.ts` with LeaderboardService class managing leaderboard calculations, rankings, and updates, implement real-time leaderboard updates, handle ties and ranking algorithms
  - Add competitive challenges: weekly prediction contests, monthly portfolio challenges, community contribution competitions, token discovery races, collaborative challenges for teams
  - Create challenge system: define challenge rules and rewards, track participant progress, announce winners and distribute rewards, create seasonal and special event challenges
  - Implement social features for competition: challenge friends and followers, create private leaderboards for groups, share achievements and rankings, celebrate milestones and victories
  - Add leaderboard rewards: exclusive badges and titles, premium feature access, token airdrops and prizes, recognition in community, special privileges and early access
  - _Requirements: 21.3, 21.6_

- [ ] 7.3 Build reward system and user progression
  - Create `lib/gamification/reward-system.ts` with RewardSystem class implementing distributeRewards(userId: string, rewardType: string, amount: number) method, manage token airdrops, premium feature access, exclusive content unlocks
  - Implement reward types: token airdrops for top performers, premium subscription credits, exclusive feature access, early access to new features, special badges and titles, merchandise and physical rewards
  - Add referral program: reward users for bringing new users, track referral success and engagement, provide tiered referral bonuses, create referral leaderboards and competitions
  - Create user progression paths: analyst track (focus on predictions and analysis), trader track (portfolio performance and trading), community track (social contributions and moderation), explorer track (token discovery and research)
  - Implement streak systems: daily login streaks, prediction streaks, community participation streaks, provide streak bonuses and multipliers, celebrate milestone streaks
  - Add seasonal events and special rewards: holiday-themed challenges, anniversary celebrations, market milestone rewards, community achievement celebrations
  - _Requirements: 21.4, 21.5, 21.7, 21.8_

- [ ] 7.4 Create gamification display components
  - Create `components/UserProgressDashboard.tsx` with current level and points, progress to next level, recent achievements, active challenges, leaderboard position, streak counters
  - Build `components/AchievementGallery.tsx` showing unlocked achievements with descriptions, progress on locked achievements, achievement categories and filters, sharing functionality for achievements
  - Implement `components/LeaderboardDisplay.tsx` with tabbed interface for different leaderboard types, user ranking and position, top performers showcase, filtering and search functionality
  - Add `components/ChallengeCenter.tsx` displaying active challenges, challenge progress tracking, challenge history and results, challenge creation for community moderators
  - Create gamification notifications: achievement unlock notifications, level up celebrations, challenge completion alerts, leaderboard position changes, reward distribution notifications
  - Implement gamification analytics: user engagement metrics, feature usage tracking, reward effectiveness analysis, challenge participation rates, progression funnel analysis
  - _Requirements: 21.1, 21.2, 21.3, 21.4, 21.5, 21.6, 21.7, 21.8_

- [ ] 8. Build token launch pad and early access system
  - Create token launch tracking and discovery system
  - Implement early access and whitelist management
  - Build launch quality assessment and due diligence tools
  - _Requirements: 22.1, 22.2, 22.3, 22.4, 22.5, 22.6, 22.7, 22.8_

- [ ] 8.1 Implement token launch tracking system
  - Create `lib/launchpad/launch-tracker.ts` with LaunchTracker class implementing trackUpcomingLaunches() method, monitor new token creations on Solana, identify legitimate projects vs spam tokens, collect launch metadata and project information
  - Build launch data collection: project descriptions and whitepapers, team information and social links, tokenomics and distribution plans, roadmap and development milestones, community size and engagement metrics
  - Add launch calendar functionality: upcoming launch schedules, launch countdown timers, timezone support for global users, calendar integration and reminders, launch notification system
  - Create launch performance tracking: post-launch price performance, initial vs current market cap, holder growth and distribution, liquidity development, trading volume trends
  - Implement launch quality scoring: project legitimacy assessment, team credibility analysis, tokenomics evaluation, community engagement metrics, technical implementation quality
  - Store launch data in Qdrant: create launch pattern vectors for similar project discovery, enable launch success prediction, implement pattern matching for quality assessment
  - _Requirements: 22.1, 22.5, 22.6, 22.8_- [ 
] 8.2 Build early access and whitelist system
  - Create `lib/launchpad/whitelist-manager.ts` with WhitelistManager class implementing manageWhitelist(projectId: string, userAddress: string) method, handle whitelist applications and approvals, manage allocation limits and purchase windows
  - Implement early access criteria: user level and points requirements, portfolio size and activity thresholds, community contribution scores, referral program participation, premium subscription status
  - Add whitelist application process: application forms with user verification, project-specific requirements and questions, application review and approval workflow, waitlist management for oversubscribed launches
  - Create allocation management: fair distribution algorithms, anti-sybil measures, allocation limits per user, purchase window management, refund handling for failed launches
  - Implement launch participation tracking: user participation history, success rates and returns, allocation utilization rates, feedback and rating system for completed launches
  - Add early access benefits: discounted token prices, larger allocation limits, priority access to popular launches, exclusive project information, direct communication with project teams
  - _Requirements: 22.2, 22.4, 22.7_

- [ ] 8.3 Implement launch quality assessment system
  - Create `lib/launchpad/due-diligence.ts` with DueDiligenceAnalyzer class implementing assessLaunchQuality(projectData: ProjectData) method, analyze project fundamentals, team credibility, technical implementation, market opportunity
  - Build team verification system: verify team member identities and backgrounds, check previous project history and success rates, analyze team social media presence and credibility, identify red flags and warning signs
  - Add technical assessment: code quality and security analysis, smart contract audits and verification, tokenomics analysis and sustainability, technical roadmap feasibility assessment
  - Create market analysis: competitive landscape analysis, market size and opportunity assessment, token utility and value proposition evaluation, adoption potential and use case validation
  - Implement risk assessment: identify potential risks and red flags, calculate overall risk score, provide risk mitigation recommendations, generate comprehensive due diligence reports
  - Add community assessment: community size and engagement analysis, social media presence and growth, influencer endorsements and partnerships, community sentiment and feedback analysis
  - _Requirements: 22.3, 22.8_

- [ ] 8.4 Create launch pad display components
  - Create `components/LaunchPadDashboard.tsx` with upcoming launches grid, featured projects showcase, launch calendar view, user allocation status, participation history
  - Build `components/LaunchProjectCard.tsx` showing project logo and name, launch date and countdown, allocation details, quality score and risk assessment, whitelist status and application button
  - Implement `components/LaunchDetails.tsx` with comprehensive project information, team details and verification status, tokenomics and distribution, roadmap and milestones, due diligence report
  - Add `components/LaunchCalendar.tsx` with calendar view of upcoming launches, filtering by date and category, launch reminders and notifications, timezone support and customization
  - Create launch participation interface: whitelist application forms, allocation management, purchase interface, transaction status tracking, refund and support system
  - Implement launch analytics: launch success metrics, user participation statistics, return on investment tracking, launch performance comparisons, market impact analysis
  - _Requirements: 22.1, 22.2, 22.3, 22.4, 22.5, 22.6, 22.7, 22.8_

- [ ] 9. Implement advanced trading integration
  - Create DEX aggregation and price discovery system
  - Build advanced trading interface with multiple order types
  - Implement MEV protection and optimal execution
  - _Requirements: 23.1, 23.2, 23.3, 23.4, 23.5, 23.6, 23.7, 23.8_

- [ ] 9.1 Build DEX aggregation system
  - Create `lib/trading/dex-aggregator.ts` with DexAggregator class implementing findBestRoute(inputToken: string, outputToken: string, amount: number) method, integrate with Jupiter, 1inch, and other aggregators, compare prices and execution routes across multiple DEXs
  - Implement route optimization: find routes with best price execution, minimize slippage and price impact, optimize for lowest fees and fastest execution, handle complex multi-hop routes
  - Add liquidity analysis: analyze liquidity depth across DEXs, identify potential slippage and price impact, monitor liquidity changes in real-time, provide liquidity warnings and recommendations
  - Create price comparison interface: show prices across different DEXs, highlight best execution venues, display price differences and arbitrage opportunities, provide historical price comparison data
  - Implement route caching and optimization: cache popular routes for faster execution, pre-calculate routes for trending tokens, optimize route calculation performance, handle route expiration and updates
  - Add execution monitoring: track trade execution status, monitor for failed transactions, provide execution analytics and performance metrics, handle partial fills and order management
  - _Requirements: 23.1, 23.2, 23.4, 23.8_- [ 
] 9.2 Implement advanced trading interface
  - Create `components/TradingInterface.tsx` with order entry form, market/limit/stop order types, slippage controls, trade size calculator, execution preview with fees and impact
  - Build `lib/trading/order-manager.ts` with OrderManager class implementing submitOrder(orderData: OrderData) method, handle different order types (market, limit, stop-loss, DCA), manage order lifecycle and status updates
  - Add advanced order types: dollar-cost averaging (DCA) orders, trailing stop orders, conditional orders based on technical indicators, portfolio rebalancing orders, time-weighted average price (TWAP) orders
  - Create trading analytics: trade history and performance tracking, profit/loss analysis per trade, trading statistics and metrics, win/loss ratios and average returns, trading pattern analysis
  - Implement risk management: position sizing recommendations, stop-loss and take-profit suggestions, portfolio risk analysis, maximum drawdown protection, risk-adjusted return calculations
  - Add one-click trading from AI signals: integrate with AI signal system, execute trades based on AI recommendations, automatic order placement with predefined parameters, signal-based portfolio management
  - _Requirements: 23.3, 23.5, 23.6_

- [ ] 9.3 Build MEV protection and execution optimization
  - Create `lib/trading/mev-protection.ts` with MEVProtection class implementing protectTrade(tradeData: TradeData) method, integrate with MEV protection services (Flashbots, Eden Network), implement private mempool submission
  - Add execution optimization: optimize transaction timing and routing, minimize MEV extraction and sandwich attacks, use private mempools for sensitive trades, implement batch trading for better execution
  - Create execution analytics: track MEV extraction and protection effectiveness, analyze execution quality and slippage, monitor front-running and sandwich attacks, provide execution improvement recommendations
  - Implement fee optimization: find routes with lowest total fees, optimize gas usage and transaction costs, provide fee estimation and optimization, handle fee market volatility and spikes
  - Add execution monitoring: real-time trade execution tracking, transaction status updates and confirmations, execution quality metrics and reporting, failed transaction handling and retry logic
  - Create execution reporting: detailed execution reports with costs and performance, execution quality benchmarking, MEV protection effectiveness analysis, trading cost analysis and optimization suggestions
  - _Requirements: 23.7, 23.8_

- [ ] 9.4 Create trading display components
  - Create `components/TradingDashboard.tsx` with trading interface, order book display, recent trades, portfolio impact preview, execution status and history
  - Build `components/OrderEntry.tsx` with token selection, order type selection, amount input with validation, slippage controls, execution preview with fees and impact, submit and cancel buttons
  - Implement `components/TradeHistory.tsx` using @tanstack/react-table with columns: timestamp, token pair, order type, amount, price, fees, status, PnL, actions (view details, repeat trade)
  - Add `components/TradingAnalytics.tsx` showing trading performance metrics, profit/loss charts, win/loss ratios, trading frequency analysis, risk metrics and recommendations
  - Create trading notifications: order execution alerts, price target notifications, stop-loss triggers, trading opportunity alerts, execution quality warnings
  - Implement trading export features: trade history export in CSV/Excel, tax reporting integration, trading performance reports, execution quality analysis reports
  - _Requirements: 23.1, 23.2, 23.3, 23.4, 23.5, 23.6, 23.7, 23.8_

- [ ] 10. Build token comparison and recommendation system
  - Create similar token discovery using Qdrant vector search
  - Implement token comparison tools and analysis
  - Build personalized recommendation engine
  - _Requirements: 16.1, 16.2, 16.3, 16.4, 16.5, 16.6, 16.7, 16.8_

- [ ] 10.1 Implement similar token discovery system
  - Create `lib/recommendations/similarity-engine.ts` with SimilarityEngine class implementing findSimilarTokens(tokenMint: string, criteria: SimilarityType[]) method, use Qdrant vector search for token similarity, support multiple similarity criteria (market cap, sector, performance, holder patterns)
  - Build token embedding generation: create multi-dimensional embeddings from token characteristics (price history, volume patterns, holder distribution, social metrics, technical indicators), update embeddings regularly with new data
  - Add similarity scoring algorithms: calculate similarity scores based on multiple factors, weight different similarity criteria, provide similarity explanations and reasoning, handle edge cases and outliers
  - Create similarity categories: price correlation similarity, market cap and volume similarity, holder pattern similarity, sector and use case similarity, social sentiment similarity, technical indicator similarity
  - Implement similarity caching: cache similarity calculations for popular tokens, update similarity scores when token data changes, optimize similarity search performance, handle similarity score expiration
  - Store similarity data in Qdrant: maintain updated token vectors, enable fast similarity search, implement similarity clustering and analysis, support complex similarity queries
  - _Requirements: 16.1, 16.2, 16.5_- [ ] 
10.2 Build token comparison tools
  - Create `components/TokenComparison.tsx` with side-by-side comparison interface supporting up to 5 tokens, comparison metrics selection, visual comparison charts, export comparison results
  - Build `lib/analysis/comparison-engine.ts` with ComparisonEngine class implementing compareTokens(tokenMints: string[]) method, calculate relative metrics and performance, identify key differences and similarities, generate comparison insights
  - Add comparison categories: market metrics (price, market cap, volume, liquidity), fundamental metrics (supply, holder distribution, age), performance metrics (price changes, volatility, returns), social metrics (community size, sentiment, activity)
  - Create comparison visualizations: side-by-side metric tables, comparison charts and graphs, relative performance analysis, correlation analysis, competitive positioning maps
  - Implement comparison templates: pre-configured comparison sets for common analysis (DeFi tokens, gaming tokens, meme coins), user-created comparison templates, popular comparison combinations
  - Add comparison sharing: shareable comparison reports, social media integration, comparison bookmarking, collaborative comparison analysis, comparison discussion threads
  - _Requirements: 16.3, 16.4, 16.6, 16.8_

- [ ] 10.3 Implement personalized recommendation engine
  - Create `lib/recommendations/recommendation-engine.ts` with RecommendationEngine class implementing generateRecommendations(userId: string) method, analyze user behavior and preferences, provide personalized token recommendations, adapt recommendations based on user feedback
  - Build user behavior analysis: track token views and interactions, analyze portfolio composition and changes, monitor trading patterns and preferences, identify user interests and investment style
  - Add recommendation algorithms: collaborative filtering based on similar users, content-based filtering using token characteristics, hybrid approaches combining multiple methods, machine learning models for preference prediction
  - Create recommendation categories: tokens similar to user's portfolio, trending tokens in user's interest areas, undervalued tokens based on user criteria, new launches matching user preferences, tokens with strong fundamentals
  - Implement recommendation feedback: user rating system for recommendations, recommendation effectiveness tracking, continuous learning from user actions, recommendation quality improvement over time
  - Add recommendation personalization: customize recommendations based on user level and experience, adjust for risk tolerance and investment goals, consider user's geographic location and regulations, provide explanation for each recommendation
  - _Requirements: 16.7, 16.8_

- [ ] 10.4 Create recommendation display components
  - Create `components/SimilarTokens.tsx` with similar token cards, similarity scores and explanations, quick comparison buttons, similarity criteria filters
  - Build `components/TokenRecommendations.tsx` showing personalized recommendations, recommendation reasons, user feedback options, recommendation categories and filters
  - Implement `components/ComparisonDashboard.tsx` with comparison interface, metric selection, visualization options, export and sharing functionality
  - Add `components/RecommendationFeed.tsx` with personalized token feed, recommendation updates, trending recommendations, social recommendations from followed users
  - Create recommendation notifications: new recommendation alerts, recommendation performance updates, similar token discoveries, trending token notifications
  - Implement recommendation analytics: recommendation click-through rates, user engagement with recommendations, recommendation effectiveness metrics, user satisfaction tracking
  - _Requirements: 16.1, 16.2, 16.3, 16.4, 16.5, 16.6, 16.7, 16.8_

- [ ] 11. Implement comprehensive testing and quality assurance
  - Write unit tests for all analytics engines and components
  - Create integration tests for API endpoints and real-time features
  - Implement end-to-end tests for complete user workflows
  - Add performance testing for large datasets and concurrent users
  - _Requirements: All requirements need comprehensive testing coverage_

- [ ] 11.1 Write comprehensive unit tests
  - Create `__tests__/analyzers/security-analyzer.test.ts` testing SecurityAnalyzer.analyzeTokenSecurity() with mock token data, test risk scoring algorithms with various risk scenarios, verify rug pull detection accuracy, test bundling detection with coordinated wallet patterns
  - Build `__tests__/analyzers/creator-analyzer.test.ts` testing CreatorAnalyzer.analyzeTokenCreator() with different creator scenarios, test wallet seed analysis with various funding patterns, verify rug pull connection detection, test creator reputation scoring
  - Create `__tests__/community/trollbox-service.test.ts` testing TrollboxService message posting and retrieval, test holder verification and rate limiting, verify message moderation and spam detection, test real-time message streaming
  - Add `__tests__/ai/prediction-engine.test.ts` testing PredictionEngine.generatePricePrediction() with historical data, test prediction accuracy and confidence scoring, verify model performance and optimization, test prediction caching and updates
  - Implement `__tests__/portfolio/portfolio-tracker.test.ts` testing PortfolioTracker.trackWalletPortfolio() with various wallet scenarios, test PnL calculations with different transaction types, verify portfolio performance metrics, test tax reporting functionality
  - Create `__tests__/trading/dex-aggregator.test.ts` testing DexAggregator.findBestRoute() with different token pairs, test route optimization and price comparison, verify execution monitoring and analytics, test MEV protection effectiveness
  - _Requirements: All requirements need unit test coverage_- [ ]
 11.2 Create integration and end-to-end tests
  - Create `__tests__/integration/token-api-integration.test.ts` testing all token-related API endpoints with real Solana data, test API response times and data accuracy, verify caching behavior and cache invalidation, test rate limiting and error handling
  - Build `__tests__/integration/qdrant-integration.test.ts` testing Qdrant vector operations with token data, test similarity search accuracy and performance, verify vector storage and retrieval, test vector updates and consistency
  - Create `__tests__/integration/realtime-integration.test.ts` testing WebSocket connections for real-time updates, verify price updates and market data streaming, test trollbox real-time messaging, test notification delivery and user experience
  - Add `e2e/token-explorer.spec.ts` using Playwright testing complete user workflows: token discovery and analysis, portfolio tracking and management, community participation and rating, trading execution and monitoring
  - Implement `e2e/security-analysis.spec.ts` testing security analysis workflows: rug pull detection, creator analysis, bundling detection, risk assessment and reporting
  - Create `e2e/ai-insights.spec.ts` testing AI features: price predictions, sentiment analysis, trading signals, recommendation system
  - _Requirements: All requirements need integration and E2E test coverage_

- [ ] 11.3 Implement performance and load testing
  - Create `__tests__/performance/token-analysis-performance.test.ts` testing analytics processing performance with large datasets, measure security analysis speed with complex patterns, test AI prediction generation times, verify Qdrant search performance
  - Build load testing scenarios using Artillery or similar tools: simulate concurrent users accessing token pages, test API endpoint performance under load, verify real-time feature scalability, test database and cache performance
  - Add memory usage and resource monitoring: track memory consumption during analytics processing, monitor CPU usage for AI operations, test garbage collection and memory leaks, verify resource cleanup
  - Create performance benchmarks: establish baseline performance metrics, track performance regression over time, optimize slow operations and bottlenecks, implement performance monitoring and alerting
  - _Requirements: 18.1, 18.2, 18.3, 18.4, 18.5, 18.6, 18.7, 18.8_

- [ ] 12. Implement mobile optimization and accessibility
  - Create responsive design for all token explorer components
  - Add accessibility features including ARIA labels and keyboard navigation
  - Optimize touch interactions and mobile performance
  - _Requirements: 24.1, 24.2, 24.3, 24.4, 24.5, 24.6, 24.7, 24.8_

- [ ] 12.1 Implement responsive design and mobile optimization
  - Create mobile-first responsive layouts using CSS Grid and Flexbox: implement breakpoints at 320px (mobile), 768px (tablet), 1024px (desktop), 1440px (wide), optimize token detail pages for mobile viewing with collapsible sections
  - Optimize complex components for mobile: redesign token comparison interface for mobile screens, create mobile-friendly trading interface with simplified controls, implement swipe navigation for token browsing
  - Add touch-friendly interactions: increase touch target sizes to minimum 44px, implement swipe gestures for token navigation, add haptic feedback for important actions, optimize scrolling performance for long lists
  - Create mobile-specific components: `components/mobile/MobileTokenCard.tsx` for condensed token display, `components/mobile/MobileTrollbox.tsx` with optimized chat interface, implement mobile portfolio dashboard
  - Implement progressive enhancement: ensure core functionality works without JavaScript, add mobile-specific enhancements progressively, optimize images and assets for mobile networks, implement service worker for offline functionality
  - Add mobile performance optimizations: implement virtual scrolling for token lists, use intersection observer for lazy loading, minimize bundle size for mobile, implement efficient caching strategies
  - _Requirements: 24.1, 24.3, 24.4, 24.5_

- [ ] 12.2 Add comprehensive accessibility features
  - Implement proper ARIA labels and semantic HTML structure: use semantic HTML5 elements throughout token explorer, add ARIA labels for all interactive elements, implement proper heading hierarchy, use role attributes for complex components
  - Add keyboard navigation support: implement focus management with proper tab order, add keyboard shortcuts for common actions, create skip links for main content areas, implement focus trapping in modals and dropdowns
  - Create high contrast mode support: implement CSS custom properties for colors, add high contrast theme toggle, ensure minimum contrast ratios, test with Windows High Contrast mode
  - Add screen reader compatibility: provide descriptive alt text for charts and visualizations, implement live regions for dynamic content updates, add screen reader only text for context, use proper form labels and fieldsets
  - Implement accessibility testing: integrate @axe-core/react for automated testing, add manual testing checklist, implement keyboard-only navigation testing, test with screen readers (NVDA, JAWS, VoiceOver)
  - Create accessibility documentation: document keyboard shortcuts and navigation, provide accessibility statement, implement user feedback mechanism for accessibility issues
  - _Requirements: 24.2, 24.7_

- [ ] 13. Deploy and monitor production system
  - Set up production deployment with proper scaling and monitoring
  - Configure performance monitoring and alerting
  - Implement gradual rollout and feature flags
  - Create documentation and user guides
  - _Requirements: All requirements need production deployment and monitoring_

- [ ] 13.1 Configure production deployment and scaling
  - Set up production environment with Kubernetes or similar orchestration, configure auto-scaling for API services based on load, implement load balancing for high availability, set up database clustering and replication
  - Configure monitoring and logging: implement structured logging with correlation IDs, set up error tracking with Sentry, configure performance monitoring with DataDog/New Relic, implement health check endpoints
  - Add security measures: implement API rate limiting and DDoS protection, configure SSL/TLS certificates and security headers, set up WAF and security scanning, implement secrets management and rotation
  - Create deployment pipeline: configure CI/CD with automated testing, implement blue-green deployment strategy, set up feature flags for gradual rollout, configure rollback procedures and disaster recovery
  - _Requirements: All requirements need production deployment_

- [ ] 13.2 Set up comprehensive monitoring and alerting
  - Configure application monitoring: track API response times and error rates, monitor database performance and query times, track Qdrant vector search performance, monitor AI service response times and accuracy
  - Set up business metrics monitoring: track user engagement and feature usage, monitor token analysis accuracy and performance, track community participation and sentiment, measure trading execution success rates
  - Implement alerting system: configure alerts for system performance degradation, set up business metric alerts for anomalies, implement escalation procedures for critical issues, create status page for user communication
  - Create monitoring dashboards: build executive dashboard with key metrics, create operational dashboard for system health, implement user analytics dashboard, set up real-time monitoring displays
  - _Requirements: All requirements need comprehensive monitoring_
---

## File: ./.kiro/specs/transaction-explorer-enhancements/design.md

# Transaction Explorer Enhancements - Design Document

## Overview

The enhanced Transaction Explorer provides comprehensive transaction analysis through detailed instruction parsing, account change visualization, AI-powered explanations, and related transaction discovery. The system transforms raw blockchain data into understandable insights for users of all technical levels.

## Architecture

### System Components

```mermaid
graph TB
    UI[Transaction UI] --> Parser[Instruction Parser]
    UI --> Changes[Account Changes Analyzer]
    UI --> AI[AI Explanation Engine]
    UI --> Related[Related Tx Finder]
    UI --> Graph[Transaction Graph]
    
    Parser --> Programs[Program Registry]
    Changes --> Diff[State Diff Engine]
    AI --> LLM[Language Model]
    Related --> Cache[Transaction Cache]
    Graph --> Viz[Graph Visualizer]
```

### Enhanced Transaction Flow

1. **Transaction Loading**: Fetch transaction data with full account states
2. **Instruction Parsing**: Parse and categorize all instructions
3. **Account Analysis**: Calculate before/after state changes
4. **AI Analysis**: Generate natural language explanation
5. **Related Discovery**: Find connected transactions
6. **Visualization**: Render interactive transaction graph
7. **Metrics Calculation**: Compute performance and cost metrics

## Components and Interfaces

### Frontend Components

#### `EnhancedTransactionView`
```typescript
interface EnhancedTransactionViewProps {
  signature: string;
  transaction?: ParsedTransaction;
  onRelatedTransactionClick?: (signature: string) => void;
}

interface ParsedTransaction {
  signature: string;
  slot: number;
  blockTime: number;
  instructions: ParsedInstruction[];
  accountChanges: AccountChange[];
  aiExplanation?: AIExplanation;
  relatedTransactions: RelatedTransaction[];
  metrics: TransactionMetrics;
}
```

#### `InstructionBreakdown`
```typescript
interface InstructionBreakdownProps {
  instructions: ParsedInstruction[];
  onInstructionClick?: (instruction: ParsedInstruction) => void;
}

interface ParsedInstruction {
  programId: string;
  programName?: string;
  instructionType: string;
  description: string;
  accounts: InstructionAccount[];
  data: InstructionData;
  innerInstructions?: ParsedInstruction[];
  computeUnits: number;
}

interface InstructionAccount {
  pubkey: string;
  isSigner: boolean;
  isWritable: boolean;
  role: 'payer' | 'recipient' | 'authority' | 'program' | 'system';
}
```

#### `AccountChangesPanel`
```typescript
interface AccountChangesPanelProps {
  changes: AccountChange[];
  onAccountClick?: (address: string) => void;
}

interface AccountChange {
  address: string;
  before: AccountState;
  after: AccountState;
  lamportsDiff: number;
  tokenChanges: TokenChange[];
  dataChanges?: DataChange;
}

interface AccountState {
  lamports: number;
  owner: string;
  executable: boolean;
  rentEpoch: number;
  data?: string;
}

interface TokenChange {
  mint: string;
  symbol?: string;
  beforeAmount: number;
  afterAmount: number;
  difference: number;
}
```

#### `AIExplanationPanel`
```typescript
interface AIExplanationPanelProps {
  explanation: AIExplanation;
  isLoading: boolean;
  onRegenerateExplanation?: () => void;
}

interface AIExplanation {
  summary: string;
  mainAction: string;
  secondaryEffects: string[];
  riskAssessment: RiskAssessment;
  technicalDetails: TechnicalDetail[];
  confidence: number;
}

interface RiskAssessment {
  level: 'low' | 'medium' | 'high';
  factors: string[];
  recommendations: string[];
}
```

#### `RelatedTransactionsPanel`
```typescript
interface RelatedTransactionsPanelProps {
  relatedTransactions: RelatedTransaction[];
  onTransactionClick: (signature: string) => void;
  isLoading: boolean;
}

interface RelatedTransaction {
  signature: string;
  relationship: RelationshipType;
  strength: number;
  description: string;
  timestamp: number;
  accounts: string[];
}

type RelationshipType = 
  | 'same_accounts'
  | 'same_program'
  | 'temporal_proximity'
  | 'token_flow'
  | 'authority_chain';
```

#### `TransactionGraph`
```typescript
interface TransactionGraphProps {
  transaction: ParsedTransaction;
  showRelated?: boolean;
  onNodeClick?: (address: string) => void;
  onEdgeClick?: (transfer: Transfer) => void;
}

interface GraphNode {
  id: string;
  type: 'account' | 'program' | 'token';
  label: string;
  balance?: number;
  isWritable: boolean;
  isSigner: boolean;
}

interface GraphEdge {
  source: string;
  target: string;
  type: 'transfer' | 'instruction' | 'authority';
  amount?: number;
  label: string;
}
```

### Backend Services

#### `InstructionParserService`
```typescript
class InstructionParserService {
  async parseInstructions(
    transaction: Transaction
  ): Promise<ParsedInstruction[]>;
  
  async getInstructionDescription(
    programId: string,
    instructionData: Buffer
  ): Promise<string>;
  
  async identifyInstructionType(
    programId: string,
    data: Buffer
  ): Promise<string>;
}
```

#### `AccountChangesAnalyzer`
```typescript
class AccountChangesAnalyzer {
  async analyzeAccountChanges(
    transaction: Transaction,
    preBalances: number[],
    postBalances: number[]
  ): Promise<AccountChange[]>;
  
  async getTokenChanges(
    address: string,
    beforeSlot: number,
    afterSlot: number
  ): Promise<TokenChange[]>;
  
  async analyzeDataChanges(
    address: string,
    beforeData: Buffer,
    afterData: Buffer
  ): Promise<DataChange>;
}
```

#### `AITransactionAnalyzer`
```typescript
class AITransactionAnalyzer {
  async generateExplanation(
    transaction: ParsedTransaction
  ): Promise<AIExplanation>;
  
  async assessRisk(
    transaction: ParsedTransaction
  ): Promise<RiskAssessment>;
  
  async identifyMainAction(
    instructions: ParsedInstruction[]
  ): Promise<string>;
}
```

#### `RelatedTransactionFinder`
```typescript
class RelatedTransactionFinder {
  async findRelatedTransactions(
    signature: string,
    options: RelatedTxOptions
  ): Promise<RelatedTransaction[]>;
  
  async findByAccountInteractions(
    accounts: string[],
    timeWindow: number
  ): Promise<RelatedTransaction[]>;
  
  async findByProgramUsage(
    programId: string,
    timeWindow: number
  ): Promise<RelatedTransaction[]>;
}
```

## Data Models

### Enhanced Transaction Data

```typescript
interface TransactionMetrics {
  totalFee: number;
  computeUnitsUsed: number;
  computeUnitsRequested: number;
  efficiency: number;
  size: number;
  accountsModified: number;
  instructionCount: number;
  innerInstructionCount: number;
  priorityFee?: number;
  baseFee: number;
  feePerComputeUnit: number;
}

interface DataChange {
  type: 'account_data' | 'token_account' | 'program_data';
  beforeHash: string;
  afterHash: string;
  sizeChange: number;
  significantChanges: string[];
  fieldChanges?: FieldChange[];
}

interface FieldChange {
  field: string;
  beforeValue: any;
  afterValue: any;
  significance: 'high' | 'medium' | 'low';
}

interface TechnicalDetail {
  category: 'instruction' | 'account' | 'program' | 'token';
  title: string;
  description: string;
  importance: 'high' | 'medium' | 'low';
  data?: any;
}

interface InstructionData {
  raw: Buffer;
  parsed?: any;
  discriminator?: string;
  args?: Record<string, any>;
}
```

### Program Registry

```typescript
interface ProgramInfo {
  programId: string;
  name: string;
  description: string;
  category: string;
  instructions: InstructionDefinition[];
  website?: string;
  documentation?: string;
}

interface InstructionDefinition {
  discriminator: string;
  name: string;
  description: string;
  accounts: AccountDefinition[];
  args: ArgumentDefinition[];
}
```

## Error Handling

### Transaction Loading Errors
- Transaction not found or invalid signature
- RPC timeout or connection issues
- Incomplete transaction data
- Historical transaction limitations

### Parsing Errors
- Unknown program instructions
- Malformed instruction data
- Missing account information
- Incomplete state data

### AI Analysis Errors
- LLM service unavailability
- Context too large for analysis
- Analysis timeout
- Confidence threshold not met

## Testing Strategy

### Unit Tests
- Instruction parsing accuracy
- Account change calculations
- AI explanation generation
- Related transaction discovery
- Graph construction algorithms

### Integration Tests
- End-to-end transaction analysis
- AI service integration
- RPC data fetching and parsing
- Graph visualization rendering
- Related transaction accuracy

### Performance Tests
- Large transaction parsing
- Complex instruction analysis
- AI explanation generation time
- Graph rendering performance
- Related transaction search speed

### User Experience Tests
- Transaction explanation clarity
- Graph interaction usability
- Mobile responsiveness
- Accessibility compliance
- Error state handling
---

## File: ./.kiro/specs/transaction-explorer-enhancements/requirements.md

# Transaction Explorer Enhancements - Requirements Document

## Introduction

The Transaction Explorer currently provides basic transaction display but lacks detailed instruction parsing, account change visualization, AI-powered explanations, and related transaction discovery. These enhancements will transform it into a comprehensive transaction analysis tool that helps users understand complex Solana transactions.

## Requirements

### Requirement 1: Detailed Instruction Parsing and Display

**User Story:** As a developer, I want to see parsed transaction instructions with human-readable descriptions, so that I can understand what each instruction does.

#### Acceptance Criteria

1. WHEN a transaction loads THEN the system SHALL parse all instructions and display them in a structured format
2. WHEN displaying instructions THEN the system SHALL show program names, instruction types, and parameters
3. WHEN an instruction involves known programs THEN the system SHALL provide human-readable descriptions
4. WHEN displaying complex instructions THEN the system SHALL group related instructions together
5. WHEN instructions have nested calls THEN the system SHALL show the call hierarchy clearly

### Requirement 2: Account Changes Visualization

**User Story:** As a user, I want to see how account balances and data changed during a transaction, so that I can understand the transaction's impact.

#### Acceptance Criteria

1. WHEN a transaction loads THEN the system SHALL display before/after states for all affected accounts
2. WHEN showing account changes THEN the system SHALL highlight balance changes with clear visual indicators
3. WHEN accounts have token balances THEN the system SHALL show token balance changes separately
4. WHEN account data changes THEN the system SHALL display data diffs in a readable format
5. WHEN changes are significant THEN the system SHALL highlight them with appropriate visual emphasis

### Requirement 3: AI-Powered Transaction Explanation

**User Story:** As a non-technical user, I want AI to explain what a transaction does in plain English, so that I can understand complex blockchain operations.

#### Acceptance Criteria

1. WHEN a transaction loads THEN the system SHALL generate an AI explanation of the transaction's purpose
2. WHEN the AI analyzes a transaction THEN it SHALL identify the main action and secondary effects
3. WHEN explaining complex transactions THEN the AI SHALL break down the explanation into digestible parts
4. WHEN transactions involve DeFi protocols THEN the AI SHALL explain the financial implications
5. WHEN transactions are potentially suspicious THEN the AI SHALL highlight risk factors

### Requirement 4: Related Transaction Discovery

**User Story:** As an analyst, I want to find transactions related to the current one, so that I can trace transaction flows and understand broader patterns.

#### Acceptance Criteria

1. WHEN viewing a transaction THEN the system SHALL identify and display related transactions
2. WHEN finding related transactions THEN the system SHALL show relationships by account interactions
3. WHEN finding related transactions THEN the system SHALL show relationships by program usage
4. WHEN finding related transactions THEN the system SHALL show relationships by time proximity
5. WHEN displaying related transactions THEN the system SHALL rank them by relevance strength

### Requirement 5: Transaction Graph Visualization

**User Story:** As a user, I want to see a visual representation of transaction flows, so that I can understand complex multi-step operations.

#### Acceptance Criteria

1. WHEN viewing a transaction THEN the system SHALL provide an option to view it as a graph
2. WHEN displaying the transaction graph THEN accounts SHALL be shown as nodes
3. WHEN displaying the transaction graph THEN transfers SHALL be shown as directed edges
4. WHEN the graph is complex THEN the system SHALL provide zoom and pan controls
5. WHEN nodes are clicked THEN the system SHALL show detailed account information

### Requirement 6: Advanced Transaction Metrics

**User Story:** As a researcher, I want detailed metrics about transaction performance and costs, so that I can analyze transaction efficiency.

#### Acceptance Criteria

1. WHEN displaying a transaction THEN the system SHALL show detailed fee breakdown
2. WHEN displaying a transaction THEN the system SHALL show compute unit usage
3. WHEN displaying a transaction THEN the system SHALL show transaction size and efficiency metrics
4. WHEN comparing similar transactions THEN the system SHALL provide comparative analysis
5. WHEN transactions fail THEN the system SHALL provide detailed error analysis and suggestions
---

## File: ./.kiro/specs/transaction-explorer-enhancements/tasks.md

# Transaction Explorer Enhancements - Implementation Plan

## Task Overview

This implementation plan enhances the existing Transaction Explorer with detailed instruction parsing, account change visualization, AI explanations, and related transaction discovery.

## Implementation Tasks

- [ ] 1. Enhance transaction data fetching and parsing
  - [x] 1.1 Upgrade transaction data collection
    - Modify existing transaction fetching to include pre/post account states
    - Add comprehensive instruction data collection
    - Implement transaction metadata enrichment
    - _Requirements: 1.1, 2.1_

  - [x] 1.2 Create instruction parsing service
    - Build instruction parser for common Solana programs
    - Create program registry with instruction definitions
    - Implement instruction categorization and description generation
    - _Requirements: 1.1, 1.2, 1.3_

- [ ] 2. Build detailed instruction display components
  - [x] 2.1 Create instruction breakdown component
    - Design hierarchical instruction display with nested calls
    - Implement program name resolution and instruction type identification
    - Add expandable/collapsible instruction details
    - _Requirements: 1.1, 1.4, 1.5_

  - [x] 2.2 Add instruction interaction features
    - Implement instruction hover tooltips with additional context
    - Add click-to-expand functionality for complex instructions
    - Create instruction filtering and search capabilities
    - _Requirements: 1.2, 1.3_

- [ ] 3. Implement account changes analysis and visualization
  - [x] 3.1 Build account changes analyzer
    - Create service to calculate before/after account states
    - Implement balance change detection and calculation
    - Add token balance change analysis
    - _Requirements: 2.1, 2.2, 2.3_

  - [x] 3.2 Create account changes display component
    - Design visual diff display for account changes
    - Implement balance change highlighting with color coding
    - Add token balance changes with metadata resolution
    - _Requirements: 2.2, 2.3, 2.5_

  - [x] 3.3 Add account data change visualization
    - Implement data diff visualization for account data changes
    - Create readable format for complex data structures
    - Add significance highlighting for major changes
    - _Requirements: 2.4, 2.5_

- [ ] 4. Integrate AI-powered transaction explanation
  - [x] 4.1 Build AI transaction analyzer service
    - Create service to generate natural language transaction explanations
    - Implement main action identification and secondary effects analysis
    - Add risk assessment and security analysis
    - _Requirements: 3.1, 3.2, 3.5_

  - [x] 4.2 Create AI explanation display component
    - Design explanation panel with summary and detailed breakdown
    - Implement progressive disclosure for technical details
    - Add regeneration and feedback functionality
    - _Requirements: 3.3, 3.4_

  - [x] 4.3 Add specialized DeFi transaction analysis
    - Implement DeFi protocol recognition and analysis
    - Add financial impact calculation and explanation
    - Create yield farming and liquidity analysis
    - _Requirements: 3.4_

- [ ] 5. Develop related transaction discovery
  - [x] 5.1 Build related transaction finder service
    - Implement account-based relationship discovery
    - Add program usage pattern analysis
    - Create temporal proximity detection
    - _Requirements: 4.1, 4.2, 4.3_

  - [x] 5.2 Create relationship strength scoring
    - Implement scoring algorithm for transaction relationships
    - Add relationship type classification
    - Create relevance ranking system
    - _Requirements: 4.4, 4.5_

  - [x] 5.3 Build related transactions display
    - Create related transactions panel with categorization
    - Implement relationship visualization and explanation
    - Add click-to-navigate functionality
    - _Requirements: 4.5_

- [ ] 6. Implement transaction graph visualization
  - [x] 6.1 Create transaction graph builder
    - Build graph data structure from transaction data
    - Implement node and edge creation for accounts and transfers
    - Add graph layout calculation and optimization
    - _Requirements: 5.1, 5.2, 5.3_

  - [x] 6.2 Build interactive graph component
    - Integrate D3.js or Cytoscape for graph rendering
    - Implement zoom, pan, and node interaction controls
    - Add node and edge click handlers with detailed information
    - _Requirements: 5.4, 5.5_

  - [x] 6.3 Add graph filtering and customization
    - Implement graph filtering by account types and amounts
    - Add layout options and visual customization
    - Create graph export functionality
    - _Requirements: 5.4_

- [ ] 7. Build advanced transaction metrics
  - [x] 7.1 Create transaction metrics calculator
    - Implement detailed fee breakdown analysis
    - Add compute unit usage tracking and analysis
    - Create transaction efficiency scoring
    - _Requirements: 6.1, 6.2, 6.3_

  - [x] 7.2 Build metrics display component
    - Design comprehensive metrics dashboard
    - Implement comparative analysis with similar transactions
    - Add performance benchmarking and recommendations
    - _Requirements: 6.4_

  - [x] 7.3 Add transaction failure analysis
    - Implement detailed error analysis for failed transactions
    - Create failure reason explanation and suggestions
    - Add retry and optimization recommendations
    - _Requirements: 6.5_

- [ ] 8. Enhance existing transaction content component
  - [x] 8.1 Integrate new components into TransactionContent
    - Modify existing TransactionContent to use enhanced components
    - Add tabbed interface for different analysis views
    - Implement responsive layout for all new features
    - _Requirements: All_

  - [x] 8.2 Add loading states and error handling
    - Implement progressive loading for different analysis phases
    - Add error boundaries and fallback states
    - Create retry mechanisms for failed analyses
    - _Requirements: All_

- [x] 9. Create program registry and instruction definitions
  - [x] 9.1 Build comprehensive program registry
    - Create database of known Solana programs
    - Add instruction definitions for major programs (SPL Token, System, etc.)
    - Implement program metadata and documentation links
    - _Requirements: 1.2, 1.3_

  - [x] 9.2 Add dynamic program discovery
    - Implement automatic program detection and categorization
    - Add community-contributed program definitions
    - Create program usage statistics and popularity tracking
    - _Requirements: 1.2_

- [x] 10. Implement caching and performance optimization
  - [x] 10.1 Add transaction analysis caching
    - Implement caching for parsed instructions and account changes
    - Add AI explanation caching to reduce API costs
    - Create related transaction caching with TTL
    - _Requirements: All_

  - [x] 10.2 Optimize for large transactions
    - Implement pagination for transactions with many instructions
    - Add lazy loading for related transactions
    - Create performance monitoring and optimization
    - _Requirements: 1.4, 4.5_

- [x] 11. Build API endpoints for enhanced features
  - [x] 11.1 Create transaction analysis endpoints
    - Add `/api/transaction/[signature]/analysis` endpoint
    - Implement `/api/transaction/[signature]/related` endpoint
    - Create `/api/transaction/[signature]/explain` endpoint
    - _Requirements: All_

  - [x] 11.2 Add supporting API services
    - Create program registry API endpoints
    - Add instruction definition lookup endpoints
    - Implement transaction metrics calculation endpoints
    - _Requirements: 1.2, 6.1_

- [x] 12. Add comprehensive testing
  - [x] 12.1 Write unit tests for analysis services
    - Test instruction parsing accuracy across different programs
    - Test account change calculation correctness
    - Test AI explanation generation and quality
    - _Requirements: All_

  - [x] 12.2 Create integration tests
    - Test end-to-end transaction analysis workflow
    - Test graph visualization rendering and interactions
    - Test related transaction discovery accuracy
    - _Requirements: All_

- [x] 13. Implement accessibility and mobile support
  - [x] 13.1 Add accessibility features
    - Implement keyboard navigation for all interactive elements
    - Add screen reader support for complex visualizations
    - Create high contrast mode for graph visualizations
    - _Requirements: All_

  - [x] 13.2 Optimize for mobile devices
    - Create responsive layouts for all new components
    - Implement touch-friendly graph interactions
    - Add mobile-optimized instruction display
    - _Requirements: All_

- [x] 14. Create user documentation and help
  - [x] 14.1 Add contextual help and tooltips
    - Create help text for all new features
    - Add tooltips explaining technical concepts
    - Implement guided tour for new users
    - _Requirements: All_

  - [x] 14.2 Build comprehensive documentation
    - Write user guide for enhanced transaction analysis
    - Create developer documentation for API endpoints
    - Add troubleshooting guide for common issues
    - _Requirements: All_

## Implementation Notes

### Development Approach
- Enhance existing components incrementally rather than replacing
- Implement caching early to support development and testing
- Use progressive enhancement to maintain backward compatibility
- Prioritize core parsing and analysis before advanced visualizations

### Technology Integration
- **Instruction Parsing**: Custom parsers for major programs, extensible architecture
- **AI Analysis**: Integration with existing AI infrastructure
- **Graph Visualization**: Reuse existing graph components where possible
- **Caching**: Leverage existing caching infrastructure

### Performance Considerations
- Implement lazy loading for expensive analysis operations
- Cache AI explanations to reduce API costs and improve response times
- Use Web Workers for intensive parsing operations
- Optimize graph rendering for transactions with many accounts

### Testing Strategy
- Use real transaction data for testing parsing accuracy
- Mock AI services for consistent testing
- Performance testing with complex transactions
- Cross-browser testing for graph visualizations
---

## File: ./.kiro/specs/user-profile-enhancements/design.md

# User Profile Enhancements Design

## Overview

The User Profile Enhancements design provides a comprehensive social platform for Solana users with profile management, social interactions, activity feeds, community features, and reputation systems. The system transforms wallet addresses into social identities, enabling users to connect, share insights, and build communities around their blockchain activities.

## Architecture

### High-Level Architecture

```mermaid
graph TB
    subgraph "Client Layer"
        A[User Profile Page] --> B[Activity Feed]
        A --> C[Social Features]
        A --> D[Community Groups]
        B --> E[Content Creation]
        C --> F[Messaging System]
    end
    
    subgraph "API Layer"
        G[User API] --> H[Profile Service]
        G --> I[Social Service]
        H --> J[Authentication Service]
        I --> K[Activity Service]
        L[Community API] --> M[Group Service]
        N[Messaging API] --> O[Chat Service]
    end
    
    subgraph "Data Layer"
        P[PostgreSQL] --> Q[User Profiles]
        P --> R[Social Graph]
        P --> S[Activity Feed]
        T[Redis Cache] --> U[Session Cache]
        T --> V[Feed Cache]
        W[File Storage] --> X[Profile Images]
        W --> Y[Content Media]
    end
    
    A --> G
    B --> K
    C --> I
    D --> L
    E --> K
    F --> N
    G --> P
    I --> P
    L --> P
    N --> P
```

### Component Architecture

The user profile system follows a social media architecture pattern:

- **Presentation Layer**: React components with real-time updates and social interactions
- **Service Layer**: User management, social graph, activity feeds, and community features
- **Data Access Layer**: PostgreSQL for structured social data and Redis for caching
- **Integration Layer**: External social platforms, wallet providers, and blockchain services

## Layout Design Scheme

### User Profile Page Layout (`/user/[walletAddress]`)

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                                User Profile                                         │
│                                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐ │
│  │                            Profile Header                                       │ │
│  │  ┌─────────────────┐  ┌──────────────────────────────────────────────────────┐ │ │
│  │  │                 │  │  @username • Verified ✓                             │ │ │
│  │  │   Profile       │  │  Display Name                                        │ │ │
│  │  │   Avatar        │  │  Bio: DeFi enthusiast and NFT collector...          │ │ │
│  │  │                 │  │  📍 Location • 🔗 website.com • 🐦 @twitter         │ │ │
│  │  │   [Edit]        │  │  Joined: Jan 2024 • Wallet: 0x1234...abcd           │ │ │
│  │  └─────────────────┘  └──────────────────────────────────────────────────────┘ │ │
│  └─────────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐ │
│  │                            Profile Stats                                        │ │
│  │  Following: 234 | Followers: 1,456 | Posts: 89 | Reputation: 8.7/10           │ │
│  │  Portfolio: $45,230 | Transactions: 2,345 | Programs: 23 | NFTs: 67           │ │
│  └─────────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐ │
│  │                              Action Buttons                                     │ │
│  │  [Follow] [Message] [Share Profile] [Add to List] [Report] [Block]             │ │
│  └─────────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐ │
│  │                              Tab Navigation                                     │ │
│  │  [ Posts ] [ Portfolio ] [ Activity ] [ NFTs ] [ Groups ] [ Achievements ]     │ │
│  └─────────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                     │
│  ┌─────────────────────────────────────────┐  ┌─────────────────────────────────────┐  │
│  │                                     │  │                                     │  │
│  │           Main Content              │  │            Sidebar                  │  │
│  │                                     │  │                                     │  │
│  │  (Content changes based on         │  │  • Achievements & Badges            │  │
│  │   selected tab)                    │  │    - Early Adopter                  │  │
│  │                                     │  │    - DeFi Expert                    │  │
│  │                                     │  │    - NFT Collector                  │  │
│  │                                     │  │                                     │  │
│  │                                     │  │  • Recent Activity                  │  │
│  │                                     │  │    - Swapped 100 USDC              │  │
│  │                                     │  │    - Joined DeFi Group             │  │
│  │                                     │  │    - Posted Analysis               │  │
│  │                                     │  │                                     │  │
│  │                                     │  │  • Mutual Connections              │  │
│  │                                     │  │    - @alice (DeFi Trader)          │  │
│  │                                     │  │    - @bob (NFT Artist)             │  │
│  │                                     │  │                                     │  │
│  └─────────────────────────────────────┘  └─────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────────────┘
```### Po
sts Tab Layout

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                                User Posts                                           │
│                                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐ │
│  │                          Create Post Section                                    │ │
│  │  ┌─────────────────────────────────────────────────────────────────────────────┐ │ │
│  │  │ What's happening in your blockchain journey?                                │ │ │
│  │  │ [Text Area for Post Content]                                                │ │ │
│  │  │                                                                             │ │ │
│  │  │ [📷 Image] [📊 Share Transaction] [💰 Share Portfolio] [🎯 Tag Users]       │ │ │
│  │  │                                              [Cancel] [Post] │ │ │
│  │  └─────────────────────────────────────────────────────────────────────────────┘ │ │
│  └─────────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐ │
│  │                              Posts Feed                                         │ │
│  │                                                                                 │ │
│  │  ┌─────────────────────────────────────────────────────────────────────────────┐ │ │
│  │  │ @username • 2h ago                                                          │ │ │
│  │  │                                                                             │ │ │
│  │  │ Just made a huge profit on my $BONK trade! 🚀                               │ │ │
│  │  │ Bought at $0.000012 and sold at $0.000018 (+50%)                           │ │ │
│  │  │                                                                             │ │ │
│  │  │ [Transaction Card: Swap 1000 SOL → 83.3M BONK]                             │ │ │
│  │  │                                                                             │ │ │
│  │  │ 💬 12 Comments  🔄 5 Reshares  ❤️ 23 Likes  📊 View Analysis               │ │ │
│  │  └─────────────────────────────────────────────────────────────────────────────┘ │ │
│  │                                                                                 │ │
│  │  ┌─────────────────────────────────────────────────────────────────────────────┐ │ │
│  │  │ @username • 5h ago                                                          │ │ │
│  │  │                                                                             │ │ │
│  │  │ New analysis on Solana DeFi trends 📈                                       │ │ │
│  │  │ TVL has grown 300% this quarter across major protocols...                  │ │ │
│  │  │                                                                             │ │ │
│  │  │ [Article Preview with thumbnail and excerpt]                               │ │ │
│  │  │                                                                             │ │ │
│  │  │ 💬 8 Comments  🔄 12 Reshares  ❤️ 45 Likes  📖 Read More                   │ │ │
│  │  └─────────────────────────────────────────────────────────────────────────────┘ │ │
│  │                                                                                 │ │
│  │  ┌─────────────────────────────────────────────────────────────────────────────┐ │ │
│  │  │ @username • 1d ago                                                          │ │ │
│  │  │                                                                             │ │ │
│  │  │ Minted my first NFT on Magic Eden! 🎨                                       │ │ │
│  │  │ Really excited about this new collection...                                 │ │ │
│  │  │                                                                             │ │ │
│  │  │ [NFT Image with metadata]                                                   │ │ │
│  │  │                                                                             │ │ │
│  │  │ 💬 15 Comments  🔄 3 Reshares  ❤️ 67 Likes  🖼️ View NFT                    │ │ │
│  │  └─────────────────────────────────────────────────────────────────────────────┘ │ │
│  │                                                                                 │ │
│  │ [Load More Posts]                                                               │ │
│  └─────────────────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

### Activity Feed Layout (`/feed`)

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                               Activity Feed                                         │
│                                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐ │
│  │                            Feed Controls                                        │ │
│  │  [🏠 Home] [🔥 Trending] [👥 Following] [🎯 For You] | [⚙️ Settings]            │ │
│  └─────────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                     │
│  ┌─────────────────────────────────────────┐  ┌─────────────────────────────────────┐  │
│  │                                     │  │                                     │  │
│  │           Main Feed                 │  │         Trending Sidebar            │  │
│  │                                     │  │                                     │  │
│  │  ┌─────────────────────────────────┐ │  │  • Trending Topics                  │  │
│  │  │ @alice • 1h ago                 │ │  │    #DeFiSummer                      │  │
│  │  │                                 │ │  │    #SolanaNFTs                      │  │
│  │  │ Amazing returns on my Jupiter   │ │  │    #MemeCoinMadness                 │  │
│  │  │ strategy this week! 📈           │ │  │                                     │  │
│  │  │                                 │ │  │  • Suggested Users                  │  │
│  │  │ [Portfolio Performance Chart]   │ │  │    @defi_expert (Follow)            │  │
│  │  │                                 │ │  │    @nft_collector (Follow)          │  │
│  │  │ 💬 5  🔄 2  ❤️ 12               │ │  │    @solana_dev (Follow)             │  │
│  │  └─────────────────────────────────┘ │  │                                     │  │
│  │                                     │  │  • Active Groups                     │  │
│  │  ┌─────────────────────────────────┐ │  │    DeFi Strategies (234 members)    │  │
│  │  │ @bob • 2h ago                   │ │  │    NFT Alpha (567 members)          │  │
│  │  │                                 │ │  │    Solana Developers (890 members)  │  │
│  │  │ Just discovered this hidden gem │ │  │                                     │  │
│  │  │ NFT collection 💎               │ │  │  • Recent Achievements              │  │
│  │  │                                 │ │  │    @charlie earned "DeFi Master"    │  │
│  │  │ [NFT Collection Preview]        │ │  │    @diana reached 1000 followers    │  │
│  │  │                                 │ │  │    @eve joined "Whale Club"         │  │
│  │  │ 💬 8  🔄 4  ❤️ 23               │ │  │                                     │  │
│  │  └─────────────────────────────────┘ │  │                                     │  │
│  │                                     │  │                                     │  │
│  │  ┌─────────────────────────────────┐ │  │                                     │  │
│  │  │ @charlie • 3h ago               │ │  │                                     │  │
│  │  │                                 │ │  │                                     │  │
│  │  │ Market analysis: SOL looking    │ │  │                                     │  │
│  │  │ bullish for next week 🚀        │ │  │                                     │  │
│  │  │                                 │ │  │                                     │  │
│  │  │ [Technical Analysis Chart]      │ │  │                                     │  │
│  │  │                                 │ │  │                                     │  │
│  │  │ 💬 15  🔄 7  ❤️ 34              │ │  │                                     │  │
│  │  └─────────────────────────────────┘ │  │                                     │  │
│  │                                     │  │                                     │  │
│  │ [Load More Posts]                   │  │                                     │  │
│  └─────────────────────────────────────┘  └─────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

### Groups/Communities Layout (`/groups`)

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                                Communities                                          │
│                                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐ │
│  │                           Community Controls                                    │ │
│  │  [🔍 Search Groups] [➕ Create Group] | Filter: [All ▼] Sort: [Popular ▼]       │ │
│  └─────────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐ │
│  │                            Featured Groups                                      │ │
│  │                                                                                 │ │
│  │  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────┐ │ │
│  │  │                 │  │                 │  │                 │  │             │ │ │
│  │  │   DeFi Alpha    │  │  NFT Collectors │  │ Solana Devs     │  │ Meme Coins  │ │ │
│  │  │                 │  │                 │  │                 │  │             │ │ │
│  │  │ 1,234 members   │  │ 2,567 members   │  │ 890 members     │  │ 3,456 mem.  │ │ │
│  │  │ 45 posts/day    │  │ 23 posts/day    │  │ 67 posts/day    │  │ 89 posts/d  │ │ │
│  │  │                 │  │                 │  │                 │  │             │ │ │
│  │  │ [Join Group]    │  │ [Join Group]    │  │ [Join Group]    │  │ [Join Group]│ │ │
│  │  └─────────────────┘  └─────────────────┘  └─────────────────┘  └─────────────┘ │ │
│  └─────────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐ │
│  │                             Your Groups                                         │ │
│  │                                                                                 │ │
│  │ Group Name        | Members | Activity | Role      | Last Visit | Actions      │ │
│  │ ───────────────── | ─────── | ──────── | ───────── | ────────── | ──────────── │ │
│  │ DeFi Strategies   | 1,234   | High     | Admin     | 2h ago     | [Manage]     │ │
│  │ NFT Alpha         | 567     | Medium   | Member    | 1d ago     | [View]       │ │
│  │ Solana News       | 2,890   | High     | Moderator | 4h ago     | [Moderate]   │ │
│  │ Trading Tips      | 445     | Low      | Member    | 3d ago     | [View]       │ │
│  │                                                                                 │ │
│  └─────────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────────────┐ │
│  │                           Discover Groups                                       │ │
│  │                                                                                 │ │
│  │  Categories: [DeFi] [NFT] [Gaming] [Development] [Trading] [General]           │ │
│  │                                                                                 │ │
│  │  ┌─────────────────────────────────────────────────────────────────────────────┐ │ │
│  │  │ 🏛️ Jupiter Trading Strategies                                               │ │ │
│  │  │ Advanced trading strategies and market analysis for Jupiter DEX             │ │ │
│  │  │ 2,345 members • 156 posts this week • Very Active                          │ │ │
│  │  │ Tags: #DeFi #Trading #Jupiter #Strategies                                   │ │ │
│  │  │                                                        [Join Group]        │ │ │
│  │  └─────────────────────────────────────────────────────────────────────────────┘ │ │
│  │                                                                                 │ │
│  │  ┌─────────────────────────────────────────────────────────────────────────────┐ │ │
│  │  │ 🎨 Solana NFT Artists                                                       │ │ │
│  │  │ Community for NFT artists and creators on Solana                           │ │ │
│  │  │ 1,567 members • 89 posts this week • Active                                │ │ │
│  │  │ Tags: #NFT #Art #Creators #Community                                        │ │ │
│  │  │                                                        [Join Group]        │ │ │
│  │  └─────────────────────────────────────────────────────────────────────────────┘ │ │
│  │                                                                                 │ │
│  │ [Load More Groups]                                                              │ │
│  └─────────────────────────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

### Messaging Interface Layout (`/messages`)

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                                Messages                                             │
│                                                                                     │
│  ┌─────────────────────────────────────┐  ┌─────────────────────────────────────┐  │
│  │                                     │  │                                     │  │
│  │        Conversations List           │  │          Chat Window                │  │
│  │                                     │  │                                     │  │
│  │  [🔍 Search conversations]          │  │  @alice • Online                    │  │
│  │                                     │  │  ┌─────────────────────────────────┐ │  │
│  │  ┌─────────────────────────────────┐ │  │  │                                 │ │  │
│  │  │ @alice • 2m ago                 │ │  │  │        Chat Messages            │ │  │
│  │  │ Hey, saw your Jupiter analysis  │ │  │  │                                 │ │  │
│  │  │ 💬 2 unread                     │ │  │  │  alice: Hey, saw your Jupiter   │ │  │
│  │  └─────────────────────────────────┘ │  │  │         analysis! Great work    │ │  │
│  │                                     │  │  │                            2m   │ │  │
│  │  ┌─────────────────────────────────┐ │  │  │                                 │ │  │
│  │  │ @bob • 1h ago                   │ │  │  │  you: Thanks! I spent a lot of  │ │  │
│  │  │ Thanks for the NFT tip!         │ │  │  │       time researching it       │ │  │
│  │  │                                 │ │  │  │                            1m   │ │  │
│  │  └─────────────────────────────────┘ │  │  │                                 │ │  │
│  │                                     │  │  │  alice: Would love to discuss    │ │  │
│  │  ┌─────────────────────────────────┐ │  │  │         more strategies         │ │  │
│  │  │ @charlie • 3h ago               │ │  │  │                           30s   │ │  │
│  │  │ Group: DeFi Alpha               │ │  │  │                                 │ │  │
│  │  │ New market update posted        │ │  │  └─────────────────────────────────┘ │  │
│  │  └─────────────────────────────────┘ │  │                                     │  │
│  │                                     │  │  ┌─────────────────────────────────┐ │  │
│  │  ┌─────────────────────────────────┐ │  │  │ Type a message...               │ │  │
│  │  │ @diana • 1d ago                 │ │  │  │                                 │ │  │
│  │  │ Portfolio review session?       │ │  │  │ [📎] [😊] [💰] [📊]      [Send] │ │  │
│  │  │                                 │ │  │  └─────────────────────────────────┘ │  │
│  │  └─────────────────────────────────┘ │  │                                     │  │
│  │                                     │  │                                     │  │
│  │ [New Message]                       │  │                                     │  │
│  └─────────────────────────────────────┘  └─────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────────────┘
```
---

## File: ./.kiro/specs/user-profile-enhancements/requirements.md

# User Profile Enhancements Requirements

## Introduction

The User Profile Enhancements provide social features and user-centric functionality for Solana wallet addresses, including user profiles, social interactions, activity feeds, following systems, and community features. This system transforms basic wallet viewing into a social platform for blockchain users to connect, share insights, and build communities around their on-chain activities.

## Requirements

### Requirement 1: User Profile Creation and Management

**User Story:** As a blockchain user, I want to create and customize a profile for my wallet address with personal information and preferences, so that I can establish my identity and connect with other users in the ecosystem.

#### Acceptance Criteria

1. WHEN a user connects their wallet THEN the system SHALL create a basic profile with wallet address as identifier
2. WHEN profile customization is accessed THEN the system SHALL allow setting display name, bio, avatar image, and social links
3. WHEN profile verification is requested THEN the system SHALL provide wallet signature verification for profile ownership
4. WHEN profile privacy is configured THEN the system SHALL allow users to set visibility levels for different profile elements
5. WHEN profile badges are earned THEN the system SHALL display achievement badges, verification status, and community roles
6. WHEN profile is updated THEN the system SHALL validate changes and update profile information in real-time
7. WHEN profile deletion is requested THEN the system SHALL provide secure profile deletion with data retention policies
8. WHEN profile recovery is needed THEN the system SHALL allow profile recovery through wallet signature verification

### Requirement 2: Social Following and Connection System

**User Story:** As a community member, I want to follow other users and build a network of connections, so that I can stay updated on their activities and discover interesting blockchain interactions.

#### Acceptance Criteria

1. WHEN following another user THEN the system SHALL create a following relationship and update follower counts
2. WHEN unfollowing a user THEN the system SHALL remove the following relationship and update counts accordingly
3. WHEN viewing followers THEN the system SHALL display list of users following the current profile with pagination
4. WHEN viewing following THEN the system SHALL display list of users the current profile follows with management options
5. WHEN mutual connections exist THEN the system SHALL highlight mutual followers and suggest connections
6. WHEN follow notifications are enabled THEN the system SHALL notify users of new followers and follow-backs
7. WHEN privacy settings are applied THEN the system SHALL respect user preferences for follower visibility
8. WHEN blocking users THEN the system SHALL provide blocking functionality to prevent unwanted interactions

### Requirement 3: Activity Feed and Social Sharing

**User Story:** As an active user, I want to share my blockchain activities and see updates from users I follow, so that I can engage with the community and discover interesting transactions and insights.

#### Acceptance Criteria

1. WHEN sharing activities THEN the system SHALL allow users to share transactions, achievements, and insights with commentary
2. WHEN activity feed is viewed THEN the system SHALL display chronological feed of activities from followed users
3. WHEN interacting with posts THEN the system SHALL support likes, comments, and reshares for shared content
4. WHEN content is moderated THEN the system SHALL provide reporting and moderation tools for inappropriate content
5. WHEN privacy controls are used THEN the system SHALL allow users to control who can see their shared activities
6. WHEN feed is personalized THEN the system SHALL use algorithms to show relevant and engaging content
7. WHEN notifications are configured THEN the system SHALL notify users of interactions on their shared content
8. WHEN content is searched THEN the system SHALL provide search functionality across shared activities and comments

### Requirement 4: Community Features and Groups

**User Story:** As a community organizer, I want to create and manage groups around specific interests or projects, so that users can collaborate and share knowledge within focused communities.

#### Acceptance Criteria

1. WHEN creating groups THEN the system SHALL allow users to create communities around specific topics or projects
2. WHEN joining groups THEN the system SHALL provide group discovery and joining mechanisms with approval processes
3. WHEN managing groups THEN the system SHALL provide moderation tools, member management, and group settings
4. WHEN group activities occur THEN the system SHALL track group discussions, shared content, and member interactions
5. WHEN group events are created THEN the system SHALL support event creation, RSVP tracking, and event notifications
6. WHEN group analytics are viewed THEN the system SHALL provide insights on group growth, engagement, and activity
7. WHEN group privacy is configured THEN the system SHALL support public, private, and invite-only group types
8. WHEN group content is moderated THEN the system SHALL provide community guidelines enforcement and content moderation

### Requirement 5: Reputation and Achievement System

**User Story:** As a platform user, I want to build reputation and earn achievements based on my blockchain activities and community participation, so that I can demonstrate my expertise and contributions.

#### Acceptance Criteria

1. WHEN activities are tracked THEN the system SHALL calculate reputation scores based on transaction history, community participation, and contributions
2. WHEN achievements are earned THEN the system SHALL award badges for milestones, special activities, and community contributions
3. WHEN reputation is displayed THEN the system SHALL show reputation scores, levels, and progress indicators on profiles
4. WHEN leaderboards are viewed THEN the system SHALL provide rankings based on different reputation metrics and achievements
5. WHEN reputation factors are calculated THEN the system SHALL consider transaction volume, DeFi participation, NFT activities, and social engagement
6. WHEN achievement verification occurs THEN the system SHALL verify achievements through on-chain data and community validation
7. WHEN reputation decay is applied THEN the system SHALL implement time-based reputation decay to maintain active participation
8. WHEN reputation abuse is detected THEN the system SHALL prevent gaming and manipulation of reputation systems

### Requirement 6: User Discovery and Recommendations

**User Story:** As a new user, I want to discover interesting users and receive recommendations for people to follow, so that I can quickly build a relevant network and find valuable content.

#### Acceptance Criteria

1. WHEN user discovery is accessed THEN the system SHALL provide user search with filters for interests, activity level, and reputation
2. WHEN recommendations are generated THEN the system SHALL suggest users based on similar activities, mutual connections, and interests
3. WHEN trending users are displayed THEN the system SHALL highlight users with high activity, engagement, or recent achievements
4. WHEN user categories are browsed THEN the system SHALL organize users by categories like DeFi experts, NFT collectors, developers, traders
5. WHEN discovery algorithms run THEN the system SHALL use machine learning to improve recommendation accuracy over time
6. WHEN onboarding occurs THEN the system SHALL provide guided user discovery during initial platform setup
7. WHEN discovery preferences are set THEN the system SHALL allow users to customize discovery criteria and recommendation types
8. WHEN privacy is maintained THEN the system SHALL respect user privacy preferences in discovery and recommendations

### Requirement 7: Messaging and Communication System

**User Story:** As a community member, I want to communicate directly with other users through messaging and comments, so that I can build relationships and collaborate on blockchain activities.

#### Acceptance Criteria

1. WHEN direct messaging is used THEN the system SHALL provide private messaging between users with encryption
2. WHEN message threads are managed THEN the system SHALL organize conversations, support message history, and provide search functionality
3. WHEN group messaging occurs THEN the system SHALL support group chats and community discussions
4. WHEN message notifications are sent THEN the system SHALL provide real-time notifications for new messages and mentions
5. WHEN message moderation is applied THEN the system SHALL provide spam filtering, blocking, and reporting mechanisms
6. WHEN message privacy is configured THEN the system SHALL allow users to control who can message them and message visibility
7. WHEN message encryption is used THEN the system SHALL implement end-to-end encryption for sensitive communications
8. WHEN message retention is managed THEN the system SHALL provide message retention policies and deletion options

### Requirement 8: Portfolio Sharing and Analysis

**User Story:** As a trader or investor, I want to share my portfolio performance and analysis with the community, so that I can showcase my strategies and learn from others.

#### Acceptance Criteria

1. WHEN portfolios are shared THEN the system SHALL allow users to share portfolio snapshots, performance metrics, and analysis
2. WHEN portfolio privacy is controlled THEN the system SHALL provide granular privacy controls for different portfolio elements
3. WHEN portfolio comparisons are made THEN the system SHALL enable portfolio comparison tools and benchmarking
4. WHEN portfolio insights are generated THEN the system SHALL provide AI-powered insights and recommendations for shared portfolios
5. WHEN portfolio discussions occur THEN the system SHALL support comments and discussions on shared portfolio content
6. WHEN portfolio tracking is enabled THEN the system SHALL allow users to track and follow other users' portfolio performance
7. WHEN portfolio analytics are provided THEN the system SHALL offer detailed analytics and performance attribution for shared portfolios
8. WHEN portfolio education is delivered THEN the system SHALL provide educational content and strategy explanations

### Requirement 9: Event and Activity Coordination

**User Story:** As an event organizer, I want to create and manage blockchain-related events and activities, so that I can bring the community together for learning and networking.

#### Acceptance Criteria

1. WHEN events are created THEN the system SHALL allow users to create events with details, location, time, and requirements
2. WHEN event discovery occurs THEN the system SHALL provide event browsing, filtering, and search functionality
3. WHEN event participation is managed THEN the system SHALL handle RSVP tracking, attendee management, and capacity limits
4. WHEN event notifications are sent THEN the system SHALL provide event reminders, updates, and communication tools
5. WHEN event verification is performed THEN the system SHALL verify event attendance through various mechanisms
6. WHEN event feedback is collected THEN the system SHALL gather feedback, ratings, and reviews for events
7. WHEN event analytics are provided THEN the system SHALL offer insights on event success, attendance, and engagement
8. WHEN event integration occurs THEN the system SHALL integrate with external calendar and event management systems

### Requirement 10: Content Creation and Curation

**User Story:** As a content creator, I want to create and curate blockchain-related content for the community, so that I can share knowledge and build my reputation as a thought leader.

#### Acceptance Criteria

1. WHEN content is created THEN the system SHALL support various content types including articles, tutorials, analysis, and multimedia
2. WHEN content is published THEN the system SHALL provide publishing tools, formatting options, and media embedding
3. WHEN content is curated THEN the system SHALL allow users to curate and organize content collections around specific topics
4. WHEN content is discovered THEN the system SHALL provide content discovery through search, categories, and recommendations
5. WHEN content is engaged with THEN the system SHALL track views, likes, shares, and comments for content analytics
6. WHEN content is monetized THEN the system SHALL provide options for content monetization and creator rewards
7. WHEN content quality is maintained THEN the system SHALL implement content moderation and quality control mechanisms
8. WHEN content is attributed THEN the system SHALL ensure proper attribution and prevent plagiarism

### Requirement 11: Privacy and Security Controls

**User Story:** As a privacy-conscious user, I want comprehensive privacy and security controls for my profile and activities, so that I can participate in the community while protecting my sensitive information.

#### Acceptance Criteria

1. WHEN privacy settings are configured THEN the system SHALL provide granular privacy controls for all profile elements and activities
2. WHEN data encryption is applied THEN the system SHALL encrypt sensitive user data and communications
3. WHEN access controls are implemented THEN the system SHALL provide role-based access controls and permission management
4. WHEN audit trails are maintained THEN the system SHALL log all access and modifications to user data for security monitoring
5. WHEN data portability is requested THEN the system SHALL allow users to export their data in standard formats
6. WHEN account security is managed THEN the system SHALL provide two-factor authentication and security monitoring
7. WHEN privacy compliance is maintained THEN the system SHALL comply with relevant privacy regulations and standards
8. WHEN data deletion is requested THEN the system SHALL provide secure data deletion with verification of removal

### Requirement 12: Integration with External Platforms

**User Story:** As a multi-platform user, I want to integrate my profile with external social platforms and blockchain services, so that I can maintain a unified online presence and leverage existing networks.

#### Acceptance Criteria

1. WHEN social integration is configured THEN the system SHALL integrate with Twitter, Discord, Telegram, and other social platforms
2. WHEN cross-platform sharing occurs THEN the system SHALL enable sharing of activities and achievements to external platforms
3. WHEN identity verification is performed THEN the system SHALL verify social media accounts and external identities
4. WHEN data synchronization happens THEN the system SHALL sync relevant data from connected platforms while respecting privacy
5. WHEN external notifications are managed THEN the system SHALL provide notification management across integrated platforms
6. WHEN platform APIs are used THEN the system SHALL integrate with blockchain service APIs for enhanced functionality
7. WHEN single sign-on is implemented THEN the system SHALL support SSO with major platforms and wallet providers
8. WHEN integration security is maintained THEN the system SHALL secure all external integrations and API communications

### Requirement 13: Mobile Application and Responsive Design

**User Story:** As a mobile user, I want full social functionality on mobile devices with native app features, so that I can stay connected and engaged with the community while on-the-go.

#### Acceptance Criteria

1. WHEN mobile interface is used THEN the system SHALL provide responsive design optimized for mobile screens and touch interactions
2. WHEN mobile app features are utilized THEN the system SHALL support push notifications, offline functionality, and device integration
3. WHEN mobile performance is optimized THEN the system SHALL load quickly and efficiently on mobile networks with data optimization
4. WHEN mobile-specific features are implemented THEN the system SHALL utilize device capabilities like camera, GPS, and biometric authentication
5. WHEN cross-device synchronization occurs THEN the system SHALL sync user data and preferences across all devices
6. WHEN mobile accessibility is provided THEN the system SHALL comply with mobile accessibility standards and guidelines
7. WHEN mobile security is maintained THEN the system SHALL implement mobile-specific security measures and secure storage
8. WHEN mobile user experience is optimized THEN the system SHALL provide intuitive navigation and mobile-first design patterns

### Requirement 14: Analytics and Insights for Users

**User Story:** As a data-driven user, I want detailed analytics and insights about my social activities and community engagement, so that I can optimize my participation and measure my impact.

#### Acceptance Criteria

1. WHEN user analytics are generated THEN the system SHALL provide comprehensive analytics on profile views, engagement, and growth
2. WHEN social metrics are calculated THEN the system SHALL track follower growth, content performance, and interaction rates
3. WHEN community impact is measured THEN the system SHALL assess user influence, contribution quality, and community value
4. WHEN trend analysis is performed THEN the system SHALL identify trends in user behavior, content performance, and community engagement
5. WHEN comparative analytics are provided THEN the system SHALL benchmark user performance against peers and community averages
6. WHEN predictive insights are generated THEN the system SHALL provide recommendations for improving engagement and community impact
7. WHEN analytics visualization is displayed THEN the system SHALL present analytics through interactive charts, graphs, and dashboards
8. WHEN analytics export is enabled THEN the system SHALL allow users to export their analytics data for external analysis
---

## File: ./.kiro/specs/user-profile-enhancements/tasks.md

# User Profile Enhancements Implementation Plan

- [ ] 1. Set up core user profile infrastructure and authentication system
  - Create user profile data models and interfaces for social features
  - Implement wallet-based authentication and profile creation system
  - Set up API endpoints for user management, profiles, and social interactions
  - Configure database schema for users, social graph, and activity feeds
  - _Requirements: 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8_

- [ ] 1.1 Create user profile data models and TypeScript interfaces
  - Create `lib/types/user.types.ts` with comprehensive UserProfile interface including walletAddress, displayName, bio, avatar, socialLinks[], verified, joinDate, privacy settings
  - Define SocialGraph interface with following[], followers[], mutualConnections[], relationshipStrength, connectionDate
  - Create ActivityFeed interface with posts[], interactions[], sharedContent[], visibility, timestamp, engagement metrics
  - Implement UserSettings interface with privacy controls, notification preferences, theme settings, language preferences
  - Define CommunityGroup interface with groupId, name, description, members[], moderators[], privacy, rules[], activity metrics
  - Create ReputationSystem interface with score, level, badges[], achievements[], contributionMetrics, trustScore
  - Add MessagingSystem interface with conversations[], messages[], participants[], encryption, messageStatus
  - Implement ContentCreation interface with posts[], articles[], media[], tags[], engagement, monetization
  - _Requirements: 1.1, 1.2, 1.3, 1.4_

- [ ] 1.2 Implement wallet-based authentication and profile creation
  - Create `lib/auth/wallet-auth.ts` with WalletAuthService class implementing connectWallet(), verifySignature(), createProfile(), updateProfile() methods
  - Implement wallet signature verification for profile ownership and authentication, support multiple wallet providers (Phantom, Solflare, Backpack)
  - Add profile creation flow: automatic profile generation on first wallet connection, guided profile setup with display name and bio, avatar upload and social links
  - Create profile verification system: verify wallet ownership through signature, verify social media accounts through OAuth, implement verification badges and trust scores
  - Implement session management: JWT token generation and validation, session persistence across devices, secure logout and session cleanup
  - Add profile recovery mechanisms: recover profile through wallet signature, handle wallet changes and profile migration, backup and restore profile data
  - _Requirements: 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8_

- [ ] 1.3 Set up core user API endpoints and database schema
  - Create `app/api/user/[walletAddress]/route.ts` with GET/PUT handlers for user profile management, profile data retrieval, privacy controls, profile updates
  - Implement `app/api/user/[walletAddress]/social/route.ts` with endpoints for following/unfollowing users, retrieving followers/following lists, managing social connections
  - Add `app/api/user/[walletAddress]/feed/route.ts` with GET/POST handlers for activity feed management, post creation, feed retrieval with pagination
  - Create `app/api/auth/wallet/route.ts` with POST handler for wallet authentication, signature verification, session creation, profile linking
  - Implement database schema in PostgreSQL: users table, social_connections table, activity_feed table, user_settings table, groups table, messages table
  - Add database indexes for performance: wallet_address, user_id, follower/following relationships, activity feed queries, message threads
  - _Requirements: 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8_

- [ ] 2. Build user profile page with social features and customization
  - Create UserProfilePage component with profile header, stats, and tabbed interface
  - Implement profile customization with avatar upload, bio editing, and social links
  - Add social interaction features like following, messaging, and profile sharing
  - _Requirements: 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8_

- [ ] 2.1 Create UserProfilePage main component and layout
  - Create `app/user/[walletAddress]/page.tsx` as server component with generateMetadata() for dynamic SEO, implement getUserProfile() server function, handle loading states with Suspense
  - Build responsive profile layout: profile header with avatar and info, profile stats bar, action buttons, tabbed navigation, main content area with sidebar
  - Implement `components/ProfileHeader.tsx` with avatar display, display name, bio, social links, verification badges, join date, wallet address with copy functionality
  - Add `components/ProfileStats.tsx` showing followers, following, posts, reputation score, portfolio value, transaction count, with real-time updates
  - Create `components/ProfileActions.tsx` with follow/unfollow button, message button, share profile, add to list, report/block options
  - Implement URL parameter validation and error handling for invalid wallet addresses, profile not found scenarios, privacy restrictions
  - _Requirements: 1.1, 1.2, 1.3_

- [ ] 2.2 Implement profile customization and editing features
  - Create `components/ProfileEditor.tsx` modal component with form fields for display name, bio, location, website, social media links
  - Implement `components/AvatarUpload.tsx` with drag-and-drop image upload, image cropping and resizing, file validation, IPFS storage integration
  - Add `components/PrivacySettings.tsx` with granular privacy controls for profile visibility, activity sharing, follower lists, messaging permissions
  - Create `components/SocialLinksManager.tsx` for adding/removing social media accounts, OAuth verification for Twitter/Discord/Telegram, link validation
  - Implement profile preview functionality: preview changes before saving, revert changes option, validation and error handling for all fields
  - Add profile themes and customization: color schemes, layout preferences, display options, accessibility settings
  - _Requirements: 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8_

- [ ] 2.3 Build social interaction features and relationship management
  - Create `components/FollowButton.tsx` with follow/unfollow functionality, loading states, follow-back detection, mutual connection indicators
  - Implement `components/FollowersList.tsx` and `components/FollowingList.tsx` with paginated user lists, search functionality, mutual connections highlighting
  - Add `components/MessageButton.tsx` with direct messaging initiation, conversation creation, message thread navigation
  - Create `components/ProfileSharing.tsx` with share profile functionality, social media sharing, profile link generation, QR code generation
  - Implement relationship strength calculation: interaction frequency, mutual connections, shared interests, engagement levels
  - Add blocking and reporting features: block users, report inappropriate profiles, privacy protection, content moderation
  - _Requirements: 2.1, 2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8_

- [ ] 3. Implement activity feed and social sharing system
  - Create activity feed with post creation, sharing, and engagement features
  - Build content creation tools for sharing transactions, portfolios, and insights
  - Implement feed algorithms for personalized content discovery
  - _Requirements: 3.1, 3.2, 3.3, 3.4, 3.5, 3.6, 3.7, 3.8_

- [ ] 3.1 Build activity feed and post creation system
  - Create `components/ActivityFeed.tsx` with infinite scroll, real-time updates, post filtering, engagement tracking
  - Implement `components/PostCreator.tsx` with rich text editor, media upload, transaction sharing, portfolio sharing, user tagging
  - Add `components/PostCard.tsx` displaying post content, author info, engagement metrics (likes, comments, shares), interaction buttons
  - Create `components/PostEngagement.tsx` with like/unlike functionality, comment system, reshare options, bookmark features
  - Implement post types: text posts, image posts, transaction shares, portfolio updates, article links, poll posts
  - Add content moderation: spam detection, inappropriate content filtering, community reporting, automated moderation
  - _Requirements: 3.1, 3.2, 3.3, 3.4, 3.5, 3.6, 3.7, 3.8_

- [ ] 3.2 Create content sharing and transaction integration
  - Create `components/TransactionShare.tsx` for sharing transaction details with commentary, transaction analysis, performance metrics
  - Implement `components/PortfolioShare.tsx` with portfolio snapshot sharing, performance highlights, privacy controls for sensitive data
  - Add `components/MediaUpload.tsx` with image/video upload, file validation, compression, IPFS storage, thumbnail generation
  - Create `components/ContentEmbed.tsx` for embedding external content: articles, videos, tweets, blockchain data, market charts
  - Implement content templates: transaction analysis template, portfolio update template, market insight template, educational content template
  - Add content scheduling: schedule posts for optimal engagement times, draft management, content calendar integration
  - _Requirements: 3.1, 3.2, 3.3, 3.4, 3.5, 3.6, 3.7, 3.8_

- [ ] 3.3 Build feed algorithms and content discovery
  - Create `lib/algorithms/feed-algorithm.ts` with FeedAlgorithm class implementing generateFeed(), rankContent(), personalizeContent() methods
  - Implement content ranking: engagement-based ranking, recency weighting, user interest matching, social graph influence
  - Add personalization features: user interest tracking, content preference learning, engagement pattern analysis, recommendation engine
  - Create feed types: chronological feed, algorithmic feed, trending content, following-only feed, topic-based feeds
  - Implement content filtering: hide seen content, filter by content type, keyword filtering, user-defined filters
  - Add trending detection: identify viral content, trending topics, popular users, engagement spikes, community discussions
  - _Requirements: 3.1, 3.2, 3.3, 3.4, 3.5, 3.6, 3.7, 3.8_

- [ ] 4. Build community groups and collaboration features
  - Create community group system with creation, management, and participation
  - Implement group discussions, events, and collaborative features
  - Build group discovery and recommendation system
  - _Requirements: 4.1, 4.2, 4.3, 4.4, 4.5, 4.6, 4.7, 4.8_

- [ ] 4.1 Build community group creation and management system
  - Create `components/GroupCreator.tsx` with group creation form, group settings, privacy options, member management tools
  - Implement `components/GroupManagement.tsx` with admin controls, moderator assignment, member approval, group settings, rule management
  - Add `components/GroupDiscovery.tsx` with group search, category browsing, featured groups, recommendation engine
  - Create `components/GroupCard.tsx` displaying group info, member count, activity level, join button, group preview
  - Implement group types: public groups, private groups, invite-only groups, paid groups, verified groups
  - Add group moderation tools: content moderation, member management, rule enforcement, reporting system, automated moderation
  - _Requirements: 4.1, 4.2, 4.3, 4.4, 4.5, 4.6, 4.7, 4.8_

- [ ] 4.2 Create group discussion and collaboration features
  - Create `components/GroupFeed.tsx` with group-specific activity feed, discussion threads, pinned posts, announcement system
  - Implement `components/GroupChat.tsx` with real-time group messaging, thread discussions, file sharing, voice/video calls
  - Add `components/GroupEvents.tsx` with event creation, RSVP tracking, event calendar, reminder system, virtual event integration
  - Create `components/GroupProjects.tsx` for collaborative projects, task management, resource sharing, progress tracking
  - Implement group roles and permissions: admin, moderator, member, contributor roles with specific permissions and capabilities
  - Add group analytics: member engagement, content performance, growth metrics, activity insights, member retention
  - _Requirements: 4.1, 4.2, 4.3, 4.4, 4.5, 4.6, 4.7, 4.8_

- [ ] 5. Implement reputation and achievement system
  - Create reputation calculation engine with multiple scoring factors
  - Build achievement system with badges, levels, and recognition
  - Implement leaderboards and community recognition features
  - _Requirements: 5.1, 5.2, 5.3, 5.4, 5.5, 5.6, 5.7, 5.8_

- [ ] 5.1 Build reputation calculation and scoring system
  - Create `lib/reputation/reputation-engine.ts` with ReputationEngine class implementing calculateScore(), updateReputation(), trackContributions() methods
  - Implement reputation factors: transaction volume and frequency, DeFi participation, NFT activities, community engagement, content quality, social interactions
  - Add reputation decay: time-based decay to encourage continued activity, activity-based maintenance, reputation recovery mechanisms
  - Create reputation categories: trading reputation, DeFi expertise, NFT knowledge, community contribution, technical expertise, social influence
  - Implement reputation verification: on-chain verification of activities, community validation, peer review system, anti-gaming measures
  - Add reputation display: reputation scores, level indicators, category breakdowns, progress tracking, reputation history
  - _Requirements: 5.1, 5.2, 5.3, 5.4, 5.5, 5.6, 5.7, 5.8_

- [ ] 5.2 Create achievement and badge system
  - Create `components/AchievementSystem.tsx` with badge display, achievement tracking, progress indicators, unlock notifications
  - Implement achievement categories: trading achievements, DeFi milestones, NFT collector badges, community contributor awards, social influence recognition
  - Add achievement verification: on-chain data verification, community validation, manual review for special achievements
  - Create achievement rarity: common, rare, epic, legendary achievements with different unlock requirements and recognition levels
  - Implement achievement sharing: share achievements on social media, display on profile, achievement showcase, celebration posts
  - Add achievement rewards: reputation bonuses, special privileges, exclusive access, community recognition, monetary rewards
  - _Requirements: 5.1, 5.2, 5.3, 5.4, 5.5, 5.6, 5.7, 5.8_

- [ ] 6. Build messaging and communication system
  - Create direct messaging system with encryption and privacy
  - Implement group messaging and community discussions
  - Build notification system for all communication channels
  - _Requirements: 7.1, 7.2, 7.3, 7.4, 7.5, 7.6, 7.7, 7.8_

- [ ] 6.1 Build direct messaging system with encryption
  - Create `components/MessagingInterface.tsx` with conversation list, chat window, message composition, file sharing
  - Implement `lib/messaging/encryption.ts` with end-to-end encryption for sensitive messages, key management, secure message storage
  - Add `components/ConversationList.tsx` with conversation search, unread indicators, conversation management, archive functionality
  - Create `components/ChatWindow.tsx` with message display, typing indicators, read receipts, message reactions, reply functionality
  - Implement message types: text messages, image/video sharing, file attachments, transaction sharing, voice messages, location sharing
  - Add message moderation: spam filtering, inappropriate content detection, user blocking, message reporting, automated moderation
  - _Requirements: 7.1, 7.2, 7.3, 7.4, 7.5, 7.6, 7.7, 7.8_

- [ ] 6.2 Create notification system and communication management
  - Create `lib/notifications/notification-service.ts` with NotificationService class implementing sendNotification(), managePreferences(), trackDelivery() methods
  - Implement notification types: follow notifications, message alerts, post interactions, group activities, achievement unlocks, system announcements
  - Add notification channels: in-app notifications, email notifications, push notifications, webhook notifications, SMS notifications
  - Create `components/NotificationCenter.tsx` with notification list, read/unread status, notification actions, notification history
  - Implement notification preferences: granular notification controls, quiet hours, notification frequency, channel preferences
  - Add real-time notifications: WebSocket-based real-time updates, notification badges, sound alerts, desktop notifications
  - _Requirements: 7.1, 7.2, 7.3, 7.4, 7.5, 7.6, 7.7, 7.8_

- [ ] 7. Implement user discovery and recommendation system
  - Create user discovery engine with search and filtering
  - Build recommendation algorithms for user connections
  - Implement trending users and community highlights
  - _Requirements: 6.1, 6.2, 6.3, 6.4, 6.5, 6.6, 6.7, 6.8_

- [ ] 7.1 Build user discovery and search system
  - Create `components/UserDiscovery.tsx` with user search, advanced filters, category browsing, trending users section
  - Implement `lib/discovery/user-search.ts` with UserSearchEngine class implementing searchUsers(), filterUsers(), rankResults() methods
  - Add search filters: activity level, reputation score, interests, location, verification status, mutual connections
  - Create user categories: DeFi experts, NFT collectors, developers, traders, content creators, community leaders
  - Implement search algorithms: relevance ranking, social graph influence, activity matching, interest alignment
  - Add discovery features: suggested users, people you may know, trending profiles, new user highlights, expert recommendations
  - _Requirements: 6.1, 6.2, 6.3, 6.4, 6.5, 6.6, 6.7, 6.8_

- [ ] 7.2 Create recommendation engine and user matching
  - Create `lib/recommendations/user-recommender.ts` with UserRecommender class implementing generateRecommendations(), calculateSimilarity(), updatePreferences() methods
  - Implement recommendation algorithms: collaborative filtering, content-based filtering, social graph analysis, activity pattern matching
  - Add similarity calculation: transaction pattern similarity, interest overlap, social network proximity, engagement compatibility
  - Create recommendation types: users to follow, potential collaborators, similar traders, community matches, expert connections
  - Implement machine learning: user preference learning, recommendation accuracy tracking, algorithm optimization, feedback incorporation
  - Add recommendation personalization: user interest tracking, interaction history analysis, preference weighting, recommendation diversity
  - _Requirements: 6.1, 6.2, 6.3, 6.4, 6.5, 6.6, 6.7, 6.8_

- [ ] 8. Build analytics and insights system for users
  - Create comprehensive user analytics dashboard
  - Implement social metrics and engagement tracking
  - Build performance insights and growth recommendations
  - _Requirements: 14.1, 14.2, 14.3, 14.4, 14.5, 14.6, 14.7, 14.8_

- [ ] 8.1 Build user analytics dashboard and metrics tracking
  - Create `components/UserAnalyticsDashboard.tsx` with comprehensive analytics overview, key performance indicators, growth metrics, engagement insights
  - Implement `lib/analytics/user-analytics.ts` with UserAnalytics class implementing trackMetrics(), generateInsights(), calculateGrowth() methods
  - Add social metrics: follower growth, engagement rates, content performance, reach and impressions, interaction quality
  - Create performance tracking: profile views, post engagement, message response rates, group participation, community impact
  - Implement trend analysis: growth trends, engagement patterns, content performance over time, seasonal variations
  - Add comparative analytics: benchmark against similar users, peer group analysis, percentile rankings, competitive insights
  - _Requirements: 14.1, 14.2, 14.3, 14.4, 14.5, 14.6, 14.7, 14.8_

- [ ] 8.2 Create insights and recommendation system
  - Create `components/UserInsights.tsx` with actionable insights, growth recommendations, optimization suggestions, trend alerts
  - Implement insight generation: content optimization recommendations, engagement improvement tips, network growth strategies, community participation advice
  - Add predictive analytics: growth forecasting, engagement prediction, trend identification, opportunity detection
  - Create personalized recommendations: optimal posting times, content suggestions, user connections, group recommendations
  - Implement A/B testing: test different strategies, measure improvement, optimize recommendations, track success rates
  - Add goal tracking: set social media goals, track progress, measure achievement, adjust strategies based on performance
  - _Requirements: 14.1, 14.2, 14.3, 14.4, 14.5, 14.6, 14.7, 14.8_
---

## File: ./.kiro/specs/wallet-path-finding/design.md

# Wallet Path Finding - Design Document

## Overview

The Wallet Path Finding system analyzes connections between Solana wallet addresses by examining transaction histories, token transfers, and program interactions. The system uses graph algorithms to discover direct and indirect relationships, visualizes connections in an interactive interface, and provides detailed analytics about wallet relationships.

## Architecture

### System Components

```mermaid
graph TB
    UI[Path Finding UI] --> API[Path Finding API]
    API --> Cache[Path Cache]
    API --> Analyzer[Connection Analyzer]
    Analyzer --> Solana[Solana RPC]
    Analyzer --> Graph[Graph Builder]
    Graph --> Viz[Graph Visualizer]
    Cache --> DB[(Cache Database)]
```

### Data Flow

1. **Input Validation**: Validate wallet addresses and sanitize inputs
2. **Cache Check**: Check if path analysis exists in cache
3. **Data Collection**: Fetch transaction histories from Solana RPC
4. **Connection Analysis**: Analyze transactions to identify connections
5. **Graph Construction**: Build graph representation of connections
6. **Path Finding**: Use BFS/DFS algorithms to find paths
7. **Visualization**: Render interactive graph with D3.js/Cytoscape
8. **Caching**: Store results for future queries

## Components and Interfaces

### Frontend Components

#### `WalletPathFinder`
```typescript
interface WalletPathFinderProps {
  initialSource?: string;
  initialTarget?: string;
  onAnalysisComplete?: (results: PathAnalysisResults) => void;
}

interface PathAnalysisResults {
  paths: WalletPath[];
  graph: ConnectionGraph;
  metrics: ConnectionMetrics;
  executionTime: number;
}
```

#### `ConnectionGraph`
```typescript
interface ConnectionGraphProps {
  nodes: GraphNode[];
  edges: GraphEdge[];
  onNodeClick?: (node: GraphNode) => void;
  onEdgeClick?: (edge: GraphEdge) => void;
  filters?: GraphFilters;
}

interface GraphNode {
  id: string;
  address: string;
  label?: string;
  balance: number;
  transactionCount: number;
  tokenCount: number;
  type: 'source' | 'target' | 'intermediate';
}

interface GraphEdge {
  source: string;
  target: string;
  weight: number;
  transactionCount: number;
  totalVolume: number;
  firstTransaction: Date;
  lastTransaction: Date;
  tokens: string[];
}
```

#### `PathAnalysisPanel`
```typescript
interface PathAnalysisPanelProps {
  paths: WalletPath[];
  selectedPath?: number;
  onPathSelect: (pathIndex: number) => void;
  onExport: (format: ExportFormat) => void;
}

interface WalletPath {
  nodes: string[];
  totalHops: number;
  connectionStrength: number;
  totalVolume: number;
  pathType: 'direct' | 'token_transfer' | 'program_interaction';
  transactions: PathTransaction[];
}
```

### Backend Services

#### `PathFindingService`
```typescript
class PathFindingService {
  async findPaths(
    source: string,
    target: string,
    options: PathFindingOptions
  ): Promise<PathAnalysisResults>;
  
  async getConnectionStrength(
    address1: string,
    address2: string
  ): Promise<ConnectionStrength>;
  
  async getCachedAnalysis(
    source: string,
    target: string
  ): Promise<PathAnalysisResults | null>;
}

interface PathFindingOptions {
  maxDepth: number;
  minTransactionAmount: number;
  timeRange?: DateRange;
  includeTokenTransfers: boolean;
  includeProgramInteractions: boolean;
}
```

#### `ConnectionAnalyzer`
```typescript
class ConnectionAnalyzer {
  async analyzeDirectConnections(
    address1: string,
    address2: string
  ): Promise<DirectConnection[]>;
  
  async analyzeTokenConnections(
    address1: string,
    address2: string
  ): Promise<TokenConnection[]>;
  
  async analyzeProgramConnections(
    address1: string,
    address2: string
  ): Promise<ProgramConnection[]>;
  
  async calculateConnectionStrength(
    connections: Connection[]
  ): Promise<number>;
}
```

#### `GraphBuilder`
```typescript
class GraphBuilder {
  buildGraph(connections: Connection[]): ConnectionGraph;
  optimizeGraph(graph: ConnectionGraph): ConnectionGraph;
  clusterNodes(graph: ConnectionGraph, threshold: number): ConnectionGraph;
  calculateLayout(graph: ConnectionGraph): LayoutedGraph;
}
```

## Data Models

### Connection Types

```typescript
interface DirectConnection {
  type: 'direct_transfer';
  fromAddress: string;
  toAddress: string;
  transactions: TransactionSummary[];
  totalVolume: number;
  frequency: number;
}

interface TokenConnection {
  type: 'token_transfer';
  fromAddress: string;
  toAddress: string;
  tokenMint: string;
  tokenSymbol: string;
  transfers: TokenTransfer[];
  totalAmount: number;
}

interface ProgramConnection {
  type: 'program_interaction';
  address1: string;
  address2: string;
  programId: string;
  programName?: string;
  interactions: ProgramInteraction[];
  sharedInstructions: string[];
}
```

### Graph Data Structure

```typescript
interface ConnectionGraph {
  nodes: Map<string, GraphNode>;
  edges: Map<string, GraphEdge>;
  metadata: GraphMetadata;
}

interface GraphMetadata {
  totalNodes: number;
  totalEdges: number;
  maxDepth: number;
  analysisTimestamp: Date;
  sourceAddress: string;
  targetAddress: string;
}
```

## Error Handling

### Input Validation Errors
- Invalid wallet address format
- Same source and target address
- Address not found on blockchain
- Insufficient transaction history

### Analysis Errors
- RPC connection failures
- Timeout during analysis
- Memory limitations for large graphs
- Cache corruption or unavailability

### Visualization Errors
- Graph rendering failures
- Performance issues with large datasets
- Browser compatibility issues
- Export functionality failures

## Testing Strategy

### Unit Tests
- Address validation functions
- Connection analysis algorithms
- Graph building and optimization
- Path finding algorithms
- Caching mechanisms

### Integration Tests
- End-to-end path finding workflow
- RPC integration and error handling
- Cache integration and performance
- Export functionality
- Real-time graph updates

### Performance Tests
- Large graph rendering (1000+ nodes)
- Complex path finding (6+ degrees)
- Concurrent analysis requests
- Memory usage optimization
- Cache hit/miss ratios

### User Experience Tests
- Interactive graph manipulation
- Filter application and performance
- Export functionality across formats
- Mobile responsiveness
- Accessibility compliance

## Security Considerations

### Input Sanitization
- Validate all wallet addresses
- Sanitize user inputs to prevent injection
- Rate limit analysis requests
- Implement request size limits

### Data Privacy
- No storage of sensitive transaction data
- Anonymize exported data options
- Secure caching mechanisms
- Audit trail for analysis requests

### Performance Security
- Prevent DoS through complex queries
- Implement circuit breakers
- Monitor resource usage
- Graceful degradation under load
---

## File: ./.kiro/specs/wallet-path-finding/requirements.md

# Wallet Path Finding - Requirements Document

## Introduction

The Wallet Path Finding feature enables users to discover and analyze connections between Solana wallet addresses through transaction flows, token transfers, and shared program interactions. This feature helps users understand wallet relationships, trace fund flows, and identify potential connections in the Solana ecosystem.

## Requirements

### Requirement 1: Wallet Connection Discovery

**User Story:** As a blockchain analyst, I want to find connections between two wallet addresses, so that I can trace fund flows and understand wallet relationships.

#### Acceptance Criteria

1. WHEN a user enters a source wallet address THEN the system SHALL validate the address format and display wallet information
2. WHEN a user enters a target wallet address THEN the system SHALL validate the address format and display wallet information  
3. WHEN both addresses are valid THEN the system SHALL initiate path finding analysis
4. IF no direct connection exists THEN the system SHALL search for indirect connections up to 6 degrees of separation
5. WHEN connections are found THEN the system SHALL display all discovered paths ranked by connection strength

### Requirement 2: Interactive Graph Visualization

**User Story:** As a user, I want to see wallet connections in an interactive graph, so that I can visually explore the relationship network.

#### Acceptance Criteria

1. WHEN path analysis completes THEN the system SHALL render an interactive force-directed graph
2. WHEN a user hovers over a node THEN the system SHALL display wallet information and connection details
3. WHEN a user clicks on a node THEN the system SHALL highlight all connections for that wallet
4. WHEN a user clicks on an edge THEN the system SHALL display transaction details for that connection
5. WHEN the graph is complex THEN the system SHALL provide zoom, pan, and filtering controls

### Requirement 3: Connection Analysis Metrics

**User Story:** As a compliance officer, I want to see detailed metrics about wallet connections, so that I can assess the strength and nature of relationships.

#### Acceptance Criteria

1. WHEN displaying connections THEN the system SHALL show transaction volume between wallets
2. WHEN displaying connections THEN the system SHALL show transaction frequency over time
3. WHEN displaying connections THEN the system SHALL show shared token holdings
4. WHEN displaying connections THEN the system SHALL show shared program interactions
5. WHEN displaying connections THEN the system SHALL calculate and display a connection strength score

### Requirement 4: Path Export and Sharing

**User Story:** As a researcher, I want to export path finding results, so that I can share findings and include them in reports.

#### Acceptance Criteria

1. WHEN path analysis is complete THEN the system SHALL provide export options for results
2. WHEN exporting THEN the system SHALL support JSON format for raw data
3. WHEN exporting THEN the system SHALL support PNG format for graph visualization
4. WHEN exporting THEN the system SHALL support CSV format for connection metrics
5. WHEN sharing THEN the system SHALL generate a shareable URL with analysis parameters

### Requirement 5: Advanced Filtering and Search

**User Story:** As an investigator, I want to filter connections by various criteria, so that I can focus on specific types of relationships.

#### Acceptance Criteria

1. WHEN viewing results THEN the system SHALL allow filtering by transaction amount thresholds
2. WHEN viewing results THEN the system SHALL allow filtering by time periods
3. WHEN viewing results THEN the system SHALL allow filtering by token types
4. WHEN viewing results THEN the system SHALL allow filtering by program interactions
5. WHEN filters are applied THEN the system SHALL update the graph visualization in real-time

### Requirement 6: Performance and Scalability

**User Story:** As a user, I want path finding to complete quickly, so that I can efficiently analyze multiple wallet relationships.

#### Acceptance Criteria

1. WHEN analyzing direct connections THEN the system SHALL complete analysis within 5 seconds
2. WHEN analyzing indirect connections THEN the system SHALL complete analysis within 30 seconds
3. WHEN the graph has more than 100 nodes THEN the system SHALL implement clustering for performance
4. WHEN analysis takes longer than expected THEN the system SHALL show progress indicators
5. WHEN memory usage is high THEN the system SHALL implement pagination for large result sets
---

## File: ./.kiro/specs/wallet-path-finding/tasks.md

# Wallet Path Finding - Implementation Plan

## Task Overview

This implementation plan breaks down the Wallet Path Finding feature into discrete, manageable coding tasks that build incrementally toward a complete solution.

## Implementation Tasks

- [ ] 1. Set up project structure and core interfaces
  - Create directory structure for path finding components and services
  - Define TypeScript interfaces for graph nodes, edges, and connections
  - Set up basic routing for `/wallet-path-finding` page
  - _Requirements: 1.1, 1.2, 1.3_

- [ ] 2. Implement wallet address validation and input handling
  - [ ] 2.1 Create wallet address validation utilities
    - Write validation functions for Solana address format
    - Implement address existence checking via RPC
    - Create error handling for invalid addresses
    - _Requirements: 1.1, 1.2_

  - [ ] 2.2 Build wallet input components
    - Create source and target wallet input fields
    - Implement address auto-completion and suggestions
    - Add wallet information display (balance, transaction count)
    - _Requirements: 1.1, 1.2_

- [ ] 3. Develop connection analysis engine
  - [ ] 3.1 Implement direct transaction analysis
    - Write functions to fetch transaction history for addresses
    - Parse transactions to identify direct transfers
    - Calculate transaction volumes and frequencies
    - _Requirements: 1.3, 3.1, 3.2_

  - [ ] 3.2 Build token transfer analysis
    - Implement SPL token transfer detection
    - Analyze shared token holdings between addresses
    - Calculate token-based connection strength
    - _Requirements: 3.1, 3.3_

  - [ ] 3.3 Create program interaction analysis
    - Detect shared program interactions between addresses
    - Analyze instruction patterns and frequencies
    - Identify program-based relationships
    - _Requirements: 3.4_

- [ ] 4. Implement path finding algorithms
  - [ ] 4.1 Build breadth-first search for direct paths
    - Implement BFS algorithm for shortest path finding
    - Handle multiple path discovery and ranking
    - Optimize for performance with large datasets
    - _Requirements: 1.4, 1.5_

  - [ ] 4.2 Create depth-limited search for indirect paths
    - Implement DFS with configurable depth limits
    - Handle path pruning and optimization
    - Implement connection strength scoring
    - _Requirements: 1.4, 3.5_

- [ ] 5. Build graph data structure and management
  - [ ] 5.1 Implement graph builder service
    - Create graph construction from connection data
    - Implement node and edge management
    - Add graph optimization and clustering
    - _Requirements: 2.1, 2.2_

  - [ ] 5.2 Create graph layout algorithms
    - Implement force-directed layout calculation
    - Add clustering for large graphs
    - Optimize layout for visualization performance
    - _Requirements: 2.1, 6.3_

- [ ] 6. Develop interactive graph visualization
  - [ ] 6.1 Create base graph visualization component
    - Integrate D3.js or Cytoscape for graph rendering
    - Implement basic node and edge rendering
    - Add zoom and pan functionality
    - _Requirements: 2.1, 2.2, 2.3_

  - [ ] 6.2 Add interactive features
    - Implement node hover and click interactions
    - Add edge click for transaction details
    - Create node highlighting and selection
    - _Requirements: 2.2, 2.3, 2.4_

  - [ ] 6.3 Implement graph filtering and controls
    - Add filter controls for connection types
    - Implement real-time graph updates
    - Create graph reset and navigation controls
    - _Requirements: 2.5, 5.1, 5.2, 5.5_

- [ ] 7. Build analysis results panel
  - [ ] 7.1 Create path listing component
    - Display discovered paths with metrics
    - Implement path selection and highlighting
    - Show path details and transaction summaries
    - _Requirements: 1.5, 3.1, 3.2_

  - [ ] 7.2 Add connection metrics display
    - Show transaction volumes and frequencies
    - Display connection strength scores
    - Create time-based analysis charts
    - _Requirements: 3.1, 3.2, 3.3, 3.5_

- [ ] 8. Implement caching and performance optimization
  - [ ] 8.1 Create path analysis caching
    - Implement Redis/memory cache for analysis results
    - Add cache invalidation strategies
    - Create cache key generation for queries
    - _Requirements: 6.1, 6.2_

  - [ ] 8.2 Optimize for large datasets
    - Implement pagination for large result sets
    - Add progressive loading for complex graphs
    - Create performance monitoring and limits
    - _Requirements: 6.3, 6.4, 6.5_

- [ ] 9. Build export and sharing functionality
  - [ ] 9.1 Implement data export features
    - Create JSON export for raw analysis data
    - Add CSV export for connection metrics
    - Implement PNG export for graph visualization
    - _Requirements: 4.2, 4.3, 4.4_

  - [ ] 9.2 Add sharing capabilities
    - Generate shareable URLs with analysis parameters
    - Create social media sharing integration
    - Add bookmark and save functionality
    - _Requirements: 4.5_

- [ ] 10. Develop filtering and search features
  - [ ] 10.1 Create advanced filtering interface
    - Build filter controls for amount thresholds
    - Add time period filtering
    - Implement token type and program filtering
    - _Requirements: 5.1, 5.2, 5.3, 5.4_

  - [ ] 10.2 Implement real-time filter application
    - Update graph visualization with filters
    - Maintain filter state across interactions
    - Add filter presets and saved searches
    - _Requirements: 5.5_

- [ ] 11. Add API endpoints and backend services
  - [ ] 11.1 Create path finding API endpoints
    - Implement `/api/wallet-path-finding` POST endpoint
    - Add connection analysis endpoints
    - Create caching and rate limiting
    - _Requirements: 1.3, 6.1, 6.2_

  - [ ] 11.2 Build supporting API services
    - Add wallet validation endpoints
    - Create export generation endpoints
    - Implement sharing URL generation
    - _Requirements: 1.1, 1.2, 4.5_

- [ ] 12. Implement error handling and loading states
  - [ ] 12.1 Create comprehensive error handling
    - Handle RPC connection failures gracefully
    - Add timeout handling for long analyses
    - Implement user-friendly error messages
    - _Requirements: 6.4_

  - [ ] 12.2 Add loading and progress indicators
    - Show progress during analysis phases
    - Add loading states for graph rendering
    - Create cancellation functionality for long operations
    - _Requirements: 6.4_

- [ ] 13. Build responsive UI and mobile support
  - [ ] 13.1 Create responsive layout
    - Implement mobile-friendly graph controls
    - Add touch interactions for graph manipulation
    - Create collapsible panels for small screens
    - _Requirements: 2.5_

  - [ ] 13.2 Optimize mobile performance
    - Reduce graph complexity on mobile devices
    - Implement simplified mobile visualization
    - Add mobile-specific interaction patterns
    - _Requirements: 6.3_

- [ ] 14. Add comprehensive testing
  - [ ] 14.1 Write unit tests for core functionality
    - Test address validation and connection analysis
    - Test path finding algorithms and graph building
    - Test caching and performance optimizations
    - _Requirements: All_

  - [ ] 14.2 Create integration and E2E tests
    - Test complete path finding workflow
    - Test graph visualization and interactions
    - Test export and sharing functionality
    - _Requirements: All_

- [ ] 15. Implement accessibility and documentation
  - [ ] 15.1 Add accessibility features
    - Implement keyboard navigation for graph
    - Add screen reader support for analysis results
    - Create high contrast mode for visualizations
    - _Requirements: 2.2, 2.3_

  - [ ] 15.2 Create user documentation
    - Write user guide for path finding features
    - Add tooltips and help text throughout UI
    - Create API documentation for developers
    - _Requirements: All_

## Implementation Notes

### Development Approach
- Start with core path finding algorithms before UI
- Implement caching early to support development testing
- Use mock data for initial UI development
- Prioritize performance optimization throughout

### Technology Choices
- **Graph Visualization**: Cytoscape.js for performance with large graphs
- **Caching**: Redis for production, in-memory for development
- **Path Finding**: Custom BFS/DFS implementation optimized for blockchain data
- **Export**: Canvas-based PNG generation, native JSON/CSV export

### Performance Considerations
- Implement progressive loading for large graphs (>100 nodes)
- Use Web Workers for intensive path finding calculations
- Cache intermediate results during multi-hop analysis
- Implement graph clustering for visualization performance

### Testing Strategy
- Mock Solana RPC calls for consistent testing
- Use snapshot testing for graph layouts
- Performance testing with large datasets
- Cross-browser testing for visualization compatibility
---

## File: ./.kiro/steering/account-explorer-routes.md

# Account Explorer Routes Steering

## Routes Covered
- `/account/[address]` - Individual account details
- `/user/[walletAddress]` - User profile and social features

## Account Detail Page (`/account/[address]`)

### Purpose
Comprehensive account information including balances, token holdings, transaction history, NFTs, and relationship analysis.

### Key Components Required
- **AccountInfo**: Basic account information display
- **AccountOverview**: Balance and holdings summary
- **TokenAccounts**: SPL token holdings with metadata
- **TransactionHistory**: Paginated transaction list
- **TransactionGraph**: Visual transaction relationships
- **NFTHoldings**: NFT collection display
- **ProgramInteractions**: Program usage analysis
- **AccountAnalytics**: Activity statistics and insights

### Data Requirements
```typescript
interface AccountData {
  address: string;
  info: AccountInfo;
  balance: AccountBalance;
  tokens: TokenHolding[];
  transactions: Transaction[];
  nfts: NFTHolding[];
  programs: ProgramInteraction[];
  analytics: AccountAnalytics;
  relationships: AccountRelationship[];
}

interface AccountInfo {
  lamports: number;
  owner: string;
  executable: boolean;
  rentEpoch: number;
  dataSize: number;
  type: 'wallet' | 'program' | 'token_account' | 'system';
  created: number;
  lastActivity: number;
}

interface AccountBalance {
  sol: number;
  usdValue: number;
  tokens: TokenBalance[];
  totalValue: number;
  change24h: number;
}

interface TokenHolding {
  mint: string;
  symbol: string;
  name: string;
  balance: number;
  decimals: number;
  usdValue: number;
  percentage: number;
  logo?: string;
  verified: boolean;
}

interface AccountAnalytics {
  transactionCount: number;
  uniquePrograms: number;
  averageTransactionSize: number;
  activityLevel: 'inactive' | 'low' | 'moderate' | 'high';
  riskScore: number;
  labels: string[];
  tags: string[];
}

interface AccountRelationship {
  address: string;
  type: 'frequent_sender' | 'frequent_receiver' | 'token_partner' | 'program_user';
  strength: number;
  transactionCount: number;
  totalVolume: number;
  lastInteraction: number;
}
```

### Implementation Guidelines
- Use server-side rendering for account metadata
- Implement real-time balance updates
- Show progressive loading for different sections
- Cache account data with appropriate TTL
- Implement infinite scroll for transaction history
- Add export functionality for account data

### Tabbed Interface
- **Overview**: Balance, tokens, and key metrics
- **Transactions**: Full transaction history with filtering
- **Tokens**: Detailed token holdings and transfers
- **NFTs**: NFT collection with metadata
- **Programs**: Program interaction analysis
- **Analytics**: Advanced statistics and insights

### Transaction History Features
- Infinite scroll pagination
- Advanced filtering (date, type, amount, program)
- Search within transactions
- Export to CSV/JSON
- Real-time updates for new transactions
- Transaction categorization and labeling

## User Profile Page (`/user/[walletAddress]`)

### Purpose
Social features and user-centric view of wallet activity with profiles, following, and community features.

### Key Components Required
- **UserProfile**: Profile information and customization
- **ActivityFeed**: Social activity and updates
- **FollowingList**: Accounts being followed
- **FollowersList**: Accounts following this user
- **SharedContent**: Shared transactions and insights
- **UserStats**: Social and activity statistics

### Social Features
```typescript
interface UserProfile {
  walletAddress: string;
  displayName?: string;
  bio?: string;
  avatar?: string;
  verified: boolean;
  joinDate: number;
  privacy: PrivacySettings;
  stats: UserStats;
  badges: Badge[];
}

interface UserStats {
  followers: number;
  following: number;
  postsShared: number;
  transactionsAnalyzed: number;
  reputation: number;
  level: number;
}

interface ActivityFeedItem {
  id: string;
  type: 'transaction' | 'follow' | 'share' | 'comment' | 'analysis';
  timestamp: number;
  data: any;
  visibility: 'public' | 'followers' | 'private';
}

interface PrivacySettings {
  profileVisibility: 'public' | 'followers' | 'private';
  transactionHistory: 'public' | 'followers' | 'private';
  followingList: 'public' | 'followers' | 'private';
  activityFeed: 'public' | 'followers' | 'private';
}
```

### Social Interaction Features
- Follow/unfollow other wallet addresses
- Share interesting transactions with commentary
- Comment on shared content
- Like and react to posts
- Reputation system based on contributions


## API Integration

### Required Endpoints
- `GET /api/account-stats/[address]` - Get account statistics
- `GET /api/account-token-stats/[address]` - Get token holdings
- `GET /api/account-transactions/[address]` - Get transaction history
- `GET /api/account-transfers/[address]` - Get transfer history
- `GET /api/user-profile/[walletAddress]` - Get user profile
- `GET /api/user-social/[walletAddress]` - Get social data
- `POST /api/user-social/follow` - Follow/unfollow actions
- `GET /api/user-history/[walletAddress]` - Get user activity history

### Real-time Updates
- WebSocket connection for balance updates
- Server-sent events for new transactions
- Push notifications for social interactions
- Real-time activity feed updates

### Caching Strategy
- Account info: Cache for 30 seconds
- Token balances: Cache for 1 minute
- Transaction history: Cache for 300 seconds
- User profiles: Cache for 5 minutes
- Social data: Cache for 1 minute

## Testing Requirements

### Unit Tests
- Account data parsing and validation
- Balance calculations accuracy
- Token metadata resolution
- Social feature functionality
- Privacy settings enforcement

### Integration Tests
- Account page loads with valid address
- Invalid addresses show appropriate errors
- Real-time updates work correctly
- Social features function properly
- Privacy controls are enforced

### E2E Tests
- Account search and navigation
- Transaction history pagination
- Token holdings display
- Social interactions work
- Privacy settings are respected

## Performance Considerations
- Lazy load heavy components (transaction graph, NFT images)
- Implement virtual scrolling for large lists
- Use React.memo for list items
- Optimize image loading for NFTs and avatars
- Bundle split social features

## Security Considerations
- Validate wallet addresses before processing
- Sanitize user-generated content
- Rate limit social interactions
- Prevent spam and abuse
- Secure handling of private data

## Account Analysis Features

### Risk Assessment
```typescript
interface RiskAnalyzer {
  analyzeAccount: (address: string) => Promise<RiskAssessment>;
  detectSuspiciousActivity: (transactions: Transaction[]) => SuspiciousActivity[];
  calculateRiskScore: (account: AccountData) => number;
  identifyPatterns: (activity: Activity[]) => Pattern[];
}

interface RiskAssessment {
  score: number; // 0-100
  level: 'low' | 'medium' | 'high' | 'critical';
  factors: RiskFactor[];
  recommendations: string[];
  lastUpdated: number;
}

interface RiskFactor {
  type: string;
  severity: number;
  description: string;
  evidence: any[];
}
```

### Activity Patterns
```typescript
interface ActivityAnalyzer {
  analyzeTransactionPatterns: (transactions: Transaction[]) => TransactionPattern[];
  detectTradingBehavior: (transactions: Transaction[]) => TradingBehavior;
  identifyAccountType: (account: AccountData) => AccountType;
  calculateActivityScore: (account: AccountData) => number;
}

interface TransactionPattern {
  type: 'regular_trading' | 'arbitrage' | 'liquidity_provision' | 'wash_trading';
  confidence: number;
  frequency: number;
  volume: number;
  timeframe: string;
}
```

## Accessibility Requirements
- Screen reader support for account data
- Keyboard navigation for all features
- High contrast mode for visualizations
- Alternative text for charts and graphs
- Focus management in modal dialogs

## Mobile Optimization
- Responsive design for all components
- Touch-friendly navigation
- Optimized loading for mobile networks
- Simplified views for small screens
- Swipe gestures for navigation

## SEO Optimization
- Dynamic meta titles with account type
- Rich meta descriptions with account summary
- Structured data for account information
- Canonical URLs for account pages
- Social media optimization

## Monitoring and Analytics
- Track account page views and engagement
- Monitor real-time update performance
- Measure user interactions with features
- Track error rates and API failures
- Monitor social feature adoption
---

## File: ./.kiro/steering/ai-functionality.md

---
inclusion: fileMatch
fileMatchPattern: ['**/ai/**/*', '**/chat/**/*', '**/analyze*', '**/anomaly*']
---

# OpenSVM AI Functionality Steering

## AI System Architecture

The AI system provides natural language blockchain analysis, anomaly detection, and educational assistance through modular components. All AI functionality follows these core principles:

- **Context Awareness**: AI understands current page context and injects relevant data
- **Streaming Responses**: Use streaming for better UX with loading states
- **Error Resilience**: Graceful degradation with fallback responses
- **Caching Strategy**: Cache responses for common queries to reduce API costs

## Component Architecture

### AI Agent Pattern
Use factory pattern for creating specialized AI agents:
```typescript
// Always inject current page context
const agent = AgentFactory.createAnalysisAgent({
  context: getCurrentPageContext(),
  capabilities: ['transaction_analysis', 'anomaly_detection']
});
```

### Core AI Tool Interfaces
```typescript
// Base interface for all AI analysis tools
interface AIAnalyzer<T, R> {
  analyze(input: T): Promise<R>;
  getContext(): PageContext;
  setContext(context: PageContext): void;
}

// Standard analysis response format
interface AnalysisResponse {
  summary: string;
  riskLevel: 'low' | 'medium' | 'high' | 'critical';
  insights: string[];
  recommendations: string[];
  confidence: number; // 0-1
}
```

### AI Chat Interface (`/components/ai/`)

#### `AIChatSidebar`
- **Purpose**: Persistent resizable sidebar for AI conversations across all pages
- **State Management**: Global state persists across page navigation
- **Context Injection**: Automatically injects current page data into conversations

##### Acceptance Criteria
- **Resize Behavior**:
  - Draggable resize handle on left edge
  - Minimum width: 300px, Maximum width: 50% of viewport
  - Width persists in localStorage across sessions
  - Smooth resize animation without content jumping
  
- **Visibility States**:
  - Closed: Completely hidden with floating AI button visible
  - Open: Sidebar visible with chat interface
  - Minimized: Collapsed to show only header with expand option
  
- **Context Awareness**:
  - Automatically detects page changes and offers to inject new context
  - Shows current context indicator (e.g., "Analyzing Account: 7xKX...")
  - Context injection prompt: "I can see you're viewing [entity]. Would you like me to analyze it?"
  
- **User Profile Integration**:
  - All conversations are saved to the user's profile for persistent access
  - User navigation history is tracked and stored in user profile
  - When viewing an account, checks for transaction connections with ALL previously visited wallets from user history
  - Displays notification: "🔗 This account has [X] transactions with [WalletName] that you viewed [timeframe] ago"
  - Provides quick action to analyze connection patterns and relationship strength
  - Cross-references user's entire exploration history to surface hidden connections
  
- **Conversation Management**:
  - Multiple conversation tabs within sidebar
  - Auto-save conversations every 30 seconds
  - Clear conversation button with confirmation
  - Export conversation as markdown/JSON
  
- **Performance Requirements**:
  - Sidebar toggle animation < 200ms
  - Context injection < 500ms
  - Message rendering < 100ms per message
  - Smooth scrolling with 60fps during resize

- **Interaction Patterns**:
  - Click outside sidebar to close (when not pinned)
  - Escape key closes sidebar
  - Floating AI button pulses when new context is available
  - Auto-focus message input when sidebar opens
  
- **Mobile Behavior**:
  - On mobile: Sidebar becomes full-screen overlay
  - Swipe down gesture to close on mobile
  - Touch-friendly resize handle (minimum 44px touch target)
  
- **Accessibility**:
  - ARIA labels for all interactive elements
  - Keyboard navigation support (Tab, Shift+Tab)
  - Screen reader announcements for context changes
  - Focus trap when sidebar is open

#### `AIChatDialog`
- **Purpose**: Full-screen modal for AI interactions
- **Features**:
  - Immersive chat experience
  - Screen sharing for complex analysis
  - Multi-modal input (text, voice, images)
  - Conversation branching and forking

#### `AIMessageBubble`
- **Purpose**: Individual message display component
- **Features**:
  - Markdown rendering with syntax highlighting
  - Code block execution for Solana queries
  - Interactive charts and visualizations
  - Copy/share functionality

### Conversation Management

#### `ConversationManager`
```typescript
interface ConversationManager {
  createConversation(context?: PageContext): Promise<Conversation>;
  addMessage(conversationId: string, message: Message): Promise<void>;
  getConversationHistory(conversationId: string): Promise<Message[]>;
  updateContext(conversationId: string, context: PageContext): Promise<void>;
  exportConversation(conversationId: string): Promise<ExportData>;
}

interface Message {
  id: string;
  role: 'user' | 'assistant' | 'system';
  content: string;
  timestamp: number;
  context?: PageContext;
  metadata?: MessageMetadata;
}

interface PageContext {
  page: string;
  entityType?: 'account' | 'transaction' | 'token' | 'block';
  entityId?: string;
  additionalData?: Record<string, any>;
}
```

## AI Capabilities

### Agentic Navigation System
The AI can autonomously navigate through the website to achieve user-requested tasks, acting as an intelligent blockchain explorer that can execute complex multi-step investigations.

#### Core Architecture
```typescript
interface AgenticNavigator {
  // Primary navigation interface
  navigateToPage(url: string): Promise<NavigationResult>;
  searchAndNavigate(query: string): Promise<NavigationResult>;
  followTransactionPath(signature: string): Promise<PathAnalysis>;
  exploreAccountConnections(address: string, depth: number): Promise<ConnectionMap>;
  executeMultiStepAnalysis(task: AnalysisTask): Promise<AnalysisResult>;
  
  // State management
  getCurrentContext(): PageContext;
  getNavigationHistory(): NavigationStep[];
  saveCheckpoint(label: string): Promise<void>;
  restoreCheckpoint(label: string): Promise<void>;
}

interface NavigationResult {
  success: boolean;
  url: string;
  context: PageContext;
  data: any;
  timestamp: number;
  reasoning: string;
  nextSuggestions: NavigationAction[];
}

interface NavigationAction {
  type: 'navigate' | 'search' | 'analyze' | 'compare' | 'follow_link' | 'extract_data';
  target: string;
  context: string;
  reasoning: string;
  priority: number;
  estimatedTime: number;
}

interface AnalysisTask {
  id: string;
  objective: string;
  steps: NavigationAction[];
  expectedOutcome: string;
  maxDepth: number;
  timeLimit: number;
  progressCallback?: (step: NavigationStep) => void;
}

interface NavigationStep {
  action: NavigationAction;
  result: NavigationResult;
  duration: number;
  insights: string[];
  errors?: Error[];
}
```

#### Implementation Strategy

##### 1. Navigation Engine
```typescript
class AgenticNavigationEngine {
  private router: NextRouter;
  private contextManager: ContextManager;
  private dataExtractor: DataExtractor;
  private progressTracker: ProgressTracker;
  
  async executeTask(task: AnalysisTask): Promise<AnalysisResult> {
    const session = this.createNavigationSession(task);
    
    try {
      for (const step of task.steps) {
        // Update user with progress
        this.notifyProgress(step, session);
        
        // Execute navigation step
        const result = await this.executeNavigationStep(step);
        
        // Extract and analyze data
        const insights = await this.extractInsights(result);
        
        // Update session state
        session.addStep(step, result, insights);
        
        // Check if objective is met early
        if (this.isObjectiveMet(task.objective, session)) {
          break;
        }
      }
      
      return this.generateAnalysisResult(session);
    } catch (error) {
      return this.handleNavigationError(error, session);
    }
  }
  
  private async executeNavigationStep(action: NavigationAction): Promise<NavigationResult> {
    switch (action.type) {
      case 'navigate':
        return await this.navigateToPage(action.target);
      case 'search':
        return await this.performSearch(action.target);
      case 'analyze':
        return await this.analyzeCurrentPage(action.context);
      case 'extract_data':
        return await this.extractPageData(action.target);
      default:
        throw new Error(`Unknown navigation action: ${action.type}`);
    }
  }
}
```

##### 2. Data Extraction System
```typescript
interface DataExtractor {
  extractAccountData(address: string): Promise<AccountData>;
  extractTransactionData(signature: string): Promise<TransactionData>;
  extractTokenData(mint: string): Promise<TokenData>;
  extractRelationships(entity: string): Promise<RelationshipData>;
  extractMarketData(context: PageContext): Promise<MarketData>;
}

interface ExtractionRule {
  pageType: string;
  selectors: Record<string, string>;
  transformers: Record<string, (data: any) => any>;
  validators: Record<string, (data: any) => boolean>;
}

// Example extraction rules
const EXTRACTION_RULES: Record<string, ExtractionRule> = {
  account: {
    pageType: 'account',
    selectors: {
      balance: '[data-testid="account-balance"]',
      tokens: '[data-testid="token-holdings"]',
      transactions: '[data-testid="transaction-list"]'
    },
    transformers: {
      balance: (text) => parseFloat(text.replace(/[^\d.]/g, '')),
      tokens: (elements) => elements.map(el => extractTokenInfo(el))
    },
    validators: {
      balance: (value) => typeof value === 'number' && value >= 0
    }
  }
};
```

#### Advanced Features

##### 1. Intelligent Path Planning
```typescript
interface PathPlanner {
  planOptimalPath(objective: string, startContext: PageContext): Promise<NavigationAction[]>;
  adaptPlanBasedOnFindings(currentPlan: NavigationAction[], newInsights: Insight[]): Promise<NavigationAction[]>;
  estimateTaskComplexity(objective: string): Promise<ComplexityEstimate>;
}

interface ComplexityEstimate {
  estimatedSteps: number;
  estimatedTime: number;
  confidence: number;
  riskFactors: string[];
  alternativeApproaches: string[];
}

// Example path planning for complex investigation
const investigateWalletDeFiActivity = async (walletAddress: string): Promise<NavigationAction[]> => {
  return [
    {
      type: 'navigate',
      target: `/account/${walletAddress}`,
      reasoning: 'Start with account overview to understand wallet composition',
      priority: 1,
      estimatedTime: 2000
    },
    {
      type: 'extract_data',
      target: 'token_holdings',
      reasoning: 'Identify DeFi tokens to understand protocol involvement',
      priority: 2,
      estimatedTime: 1000
    },
    {
      type: 'analyze',
      target: 'defi_protocols',
      reasoning: 'Analyze which DeFi protocols this wallet interacts with',
      priority: 3,
      estimatedTime: 3000
    },
    {
      type: 'follow_link',
      target: 'transaction_history',
      reasoning: 'Examine transaction patterns for DeFi activity',
      priority: 4,
      estimatedTime: 5000
    }
  ];
};
```

##### 2. Real-time Progress Communication
```typescript
interface ProgressNotification {
  type: 'step_started' | 'step_completed' | 'insight_discovered' | 'error_encountered' | 'task_completed';
  message: string;
  currentStep: number;
  totalSteps: number;
  timeElapsed: number;
  estimatedTimeRemaining: number;
  insights?: Insight[];
  data?: any;
}

// Example progress updates
const progressUpdates = [
  "🔍 Starting investigation of wallet 7xKX... (Step 1/5)",
  "📊 Analyzing token holdings - found 12 DeFi tokens (Step 2/5)",
  "🔗 Discovered connections to 3 major DeFi protocols (Step 3/5)",
  "📈 Examining transaction patterns - 847 DeFi transactions found (Step 4/5)",
  "✅ Investigation complete - generating comprehensive report (Step 5/5)"
];
```

##### 3. Cross-Page Data Correlation
```typescript
interface DataCorrelator {
  correlateAccountData(accounts: string[]): Promise<CorrelationResult>;
  findTransactionPatterns(transactions: string[]): Promise<PatternResult>;
  identifyAnomalousConnections(entities: Entity[]): Promise<AnomalyResult>;
  buildRelationshipGraph(startEntity: string, depth: number): Promise<RelationshipGraph>;
}

interface CorrelationResult {
  commonTokens: TokenCorrelation[];
  sharedTransactions: TransactionCorrelation[];
  temporalPatterns: TemporalPattern[];
  riskIndicators: RiskIndicator[];
  insights: string[];
}

// Example correlation analysis
const analyzeWalletCluster = async (walletAddresses: string[]): Promise<ClusterAnalysis> => {
  const correlations = await dataCorrelator.correlateAccountData(walletAddresses);
  
  return {
    clusterType: determineClusterType(correlations),
    riskLevel: calculateClusterRisk(correlations),
    keyFindings: extractKeyFindings(correlations),
    recommendations: generateRecommendations(correlations),
    visualizationData: prepareVisualizationData(correlations)
  };
};
```

#### User Experience Features

##### 1. Interactive Investigation Mode
- **Live Progress Tracking**: Real-time updates as AI navigates through pages
- **Breadcrumb Trail**: Visual representation of navigation path taken
- **Insight Highlights**: Key discoveries highlighted as they're found
- **User Intervention**: Ability to pause, redirect, or modify investigation mid-stream
- **Bookmark Findings**: Save interesting discoveries for later review

##### 2. Investigation Templates
```typescript
interface InvestigationTemplate {
  name: string;
  description: string;
  objective: string;
  steps: NavigationAction[];
  expectedDuration: number;
  skillLevel: 'beginner' | 'intermediate' | 'advanced';
  categories: string[];
}

const INVESTIGATION_TEMPLATES: InvestigationTemplate[] = [
  {
    name: "DeFi Portfolio Analysis",
    description: "Comprehensive analysis of a wallet's DeFi activities and positions",
    objective: "Understand DeFi strategy and risk exposure",
    steps: [...], // Predefined navigation steps
    expectedDuration: 30000, // 30 seconds
    skillLevel: 'intermediate',
    categories: ['defi', 'portfolio', 'risk-analysis']
  },
  {
    name: "Suspicious Activity Investigation",
    description: "Deep dive into potentially suspicious wallet behavior",
    objective: "Identify and analyze suspicious patterns",
    steps: [...],
    expectedDuration: 60000, // 1 minute
    skillLevel: 'advanced',
    categories: ['security', 'anomaly-detection', 'forensics']
  }
];
```

##### 3. Collaborative Investigation
- **Share Investigation Sessions**: Allow users to share ongoing investigations
- **Investigation Replay**: Replay the AI's navigation path for learning
- **Community Templates**: User-contributed investigation templates
- **Expert Validation**: Community validation of AI findings

#### Advanced Navigation Capabilities

##### 1. Multi-dimensional Analysis
```typescript
interface MultiDimensionalAnalyzer {
  analyzeAcrossTime(entity: string, timeRange: TimeRange): Promise<TemporalAnalysis>;
  analyzeAcrossNetworks(entity: string, networks: string[]): Promise<CrossNetworkAnalysis>;
  analyzeAcrossProtocols(entity: string, protocols: string[]): Promise<ProtocolAnalysis>;
  compareEntities(entities: string[], dimensions: string[]): Promise<ComparisonAnalysis>;
}

// Example: Analyze wallet behavior across different time periods
const analyzeWalletEvolution = async (walletAddress: string): Promise<EvolutionAnalysis> => {
  const timeRanges = ['1d', '7d', '30d', '90d', '1y'];
  const analyses = await Promise.all(
    timeRanges.map(range => 
      multiDimensionalAnalyzer.analyzeAcrossTime(walletAddress, range)
    )
  );
  
  return {
    evolutionPattern: identifyEvolutionPattern(analyses),
    behaviorChanges: detectBehaviorChanges(analyses),
    riskProgression: analyzeRiskProgression(analyses),
    recommendations: generateEvolutionRecommendations(analyses)
  };
};
```

##### 2. Predictive Navigation
```typescript
interface PredictiveNavigator {
  predictNextBestAction(currentContext: PageContext, objective: string): Promise<NavigationAction>;
  suggestAlternativePaths(currentPath: NavigationAction[], objective: string): Promise<NavigationAction[][]>;
  estimateSuccessProbability(path: NavigationAction[], objective: string): Promise<number>;
  optimizeNavigationStrategy(feedback: UserFeedback[]): Promise<void>;
}

// Example: AI learns from user behavior to improve navigation
const adaptiveNavigation = async (userQuery: string, userHistory: UserHistory): Promise<NavigationStrategy> => {
  const baseStrategy = await planBasicNavigation(userQuery);
  const userPreferences = extractUserPreferences(userHistory);
  const optimizedStrategy = await optimizeForUser(baseStrategy, userPreferences);
  
  return {
    primaryPath: optimizedStrategy.primaryPath,
    alternativePaths: optimizedStrategy.alternatives,
    confidenceScore: optimizedStrategy.confidence,
    personalizationFactors: optimizedStrategy.personalization
  };
};
```

This comprehensive agentic navigation system transforms the AI from a passive assistant into an active blockchain explorer that can autonomously investigate complex scenarios, discover hidden patterns, and provide deep insights through intelligent navigation and analysis.

### Natural Language Processing

#### Query Understanding
- **Intent Recognition**: Classify user queries (analysis, explanation, search, comparison, navigation)
- **Entity Extraction**: Extract addresses, signatures, token names from natural language
- **Context Awareness**: Understand references to current page data
- **Multi-turn Conversations**: Maintain context across conversation turns
- **Task Planning**: Break down complex requests into executable navigation steps

#### Response Generation
- **Explanation Generation**: Convert technical blockchain data to natural language
- **Educational Content**: Provide learning materials and concept explanations
- **Actionable Insights**: Suggest next steps and recommendations
- **Personalization**: Adapt responses to user expertise level
- **Progress Updates**: Provide real-time updates during autonomous navigation

### Blockchain Analysis

#### Transaction Analysis
```typescript
// Example AI analysis workflow
const analyzeTransaction = async (signature: string) => {
  // 1. Fetch transaction data
  const transaction = await solanaDataTool.getTransaction(signature);
  
  // 2. Parse instructions and accounts
  const parsedInstructions = await parseInstructions(transaction);
  const accountChanges = await analyzeAccountChanges(transaction);
  
  // 3. Detect patterns and anomalies
  const anomalies = await patternDetector.detectAnomalies(transaction);
  const riskLevel = await assessRisk(transaction, anomalies);
  
  // 4. Generate natural language explanation
  const explanation = await generateExplanation({
    transaction,
    instructions: parsedInstructions,
    accountChanges,
    anomalies,
    riskLevel
  });
  
  return {
    summary: explanation.summary,
    details: explanation.details,
    riskLevel,
    anomalies,
    recommendations: explanation.recommendations
  };
};
```

#### Anomaly Detection
```typescript
interface AnomalyDetectionSystem {
  // Real-time anomaly detection
  detectRealTimeAnomalies(transaction: Transaction): Promise<Anomaly[]>;
  
  // Pattern-based detection
  detectSuspiciousPatterns(timeWindow: TimeWindow): Promise<Pattern[]>;
  
  // ML-based detection
  detectMLAnomalies(features: TransactionFeatures): Promise<MLAnomaly[]>;
  
  // Cross-reference detection
  detectCrossChainAnomalies(transaction: Transaction): Promise<CrossChainAnomaly[]>;
}

interface Anomaly {
  type: 'wash_trading' | 'pump_dump' | 'sybil' | 'mev' | 'suspicious_volume';
  severity: 'low' | 'medium' | 'high' | 'critical';
  confidence: number; // 0-1
  description: string;
  evidence: Evidence[];
  relatedEntities: string[];
  recommendations: string[];
}
```

### Educational Features

#### Concept Explanation
- **Blockchain Basics**: Explain fundamental blockchain concepts
- **Solana Specifics**: Solana-specific features and mechanisms
- **DeFi Concepts**: Decentralized finance protocols and strategies
- **Security Awareness**: Common scams and security best practices

#### Interactive Learning
- **Guided Tours**: Step-by-step exploration of blockchain data
- **Quiz Mode**: Test understanding of blockchain concepts
- **Scenario Analysis**: "What if" scenarios for learning
- **Best Practices**: Recommendations for safe blockchain interaction

## AI Integration Patterns

### Context Injection
```typescript
// Inject current page context into AI conversations
const injectPageContext = (context: PageContext) => {
  const systemMessage = {
    role: 'system' as const,
    content: `
      Current page context:
      - Page: ${context.page}
      - Entity Type: ${context.entityType}
      - Entity ID: ${context.entityId}
      - Additional Data: ${JSON.stringify(context.additionalData)}
      
      Use this context to provide relevant and specific assistance.
      Reference the current data when appropriate.
    `
  };
  
  return systemMessage;
};
```

### Streaming Responses
```typescript
// Stream AI responses for better UX
const streamAIResponse = async function* (
  messages: Message[],
  onToken?: (token: string) => void
) {
  const response = await fetch('/api/ai-response', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ messages, stream: true })
  });
  
  const reader = response.body?.getReader();
  const decoder = new TextDecoder();
  
  while (reader) {
    const { done, value } = await reader.read();
    if (done) break;
    
    const chunk = decoder.decode(value);
    const lines = chunk.split('\n');
    
    for (const line of lines) {
      if (line.startsWith('data: ')) {
        const data = line.slice(6);
        if (data === '[DONE]') return;
        
        try {
          const parsed = JSON.parse(data);
          const token = parsed.choices[0]?.delta?.content;
          if (token) {
            onToken?.(token);
            yield token;
          }
        } catch (e) {
          console.error('Error parsing streaming response:', e);
        }
      }
    }
  }
};
```

### Error Handling
```typescript
// AI-specific error handling
class AIError extends Error {
  constructor(
    message: string,
    public code: AIErrorCode,
    public retryable: boolean = false
  ) {
    super(message);
    this.name = 'AIError';
  }
}

enum AIErrorCode {
  RATE_LIMIT = 'RATE_LIMIT',
  CONTEXT_TOO_LARGE = 'CONTEXT_TOO_LARGE',
  INVALID_QUERY = 'INVALID_QUERY',
  MODEL_UNAVAILABLE = 'MODEL_UNAVAILABLE',
  ANALYSIS_FAILED = 'ANALYSIS_FAILED'
}

const handleAIError = (error: AIError) => {
  switch (error.code) {
    case AIErrorCode.RATE_LIMIT:
      return 'AI service is temporarily busy. Please try again in a moment.';
    case AIErrorCode.CONTEXT_TOO_LARGE:
      return 'Query is too complex. Please try breaking it into smaller parts.';
    case AIErrorCode.INVALID_QUERY:
      return 'I didn\'t understand your query. Could you rephrase it?';
    default:
      return 'An error occurred while processing your request.';
  }
};
```

## AI API Endpoints

### `/api/ai-response`
- **Purpose**: Main AI query processing endpoint
- **Method**: POST
- **Body**: `{ messages: Message[], context?: PageContext, stream?: boolean }`
- **Response**: AI-generated response with analysis and recommendations

### `/api/analyze-transaction`
- **Purpose**: Dedicated transaction analysis endpoint
- **Method**: POST
- **Body**: `{ signature: string, analysisType?: string }`
- **Response**: Detailed transaction analysis with AI insights

### `/api/chat`
- **Purpose**: Conversational AI interface
- **Method**: POST
- **Body**: `{ conversationId?: string, message: string, context?: PageContext }`
- **Response**: Streaming or complete AI response

### `/api/anomaly`
- **Purpose**: Anomaly detection and reporting
- **Method**: GET/POST
- **Response**: Anomaly reports with AI-generated explanations

## Performance Optimization

### Caching Strategies
```typescript
// Cache AI responses for common queries
const aiResponseCache = new Map<string, CachedResponse>();

const getCachedResponse = (query: string, context: PageContext) => {
  const cacheKey = `${query}-${JSON.stringify(context)}`;
  const cached = aiResponseCache.get(cacheKey);
  
  if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
    return cached.response;
  }
  
  return null;
};

const setCachedResponse = (query: string, context: PageContext, response: string) => {
  const cacheKey = `${query}-${JSON.stringify(context)}`;
  aiResponseCache.set(cacheKey, {
    response,
    timestamp: Date.now()
  });
};
```

### Request Optimization
```typescript
// Batch multiple AI requests
const batchAIRequests = async (requests: AIRequest[]) => {
  const batches = chunk(requests, BATCH_SIZE);
  const results = [];
  
  for (const batch of batches) {
    const batchResults = await Promise.all(
      batch.map(request => processAIRequest(request))
    );
    results.push(...batchResults);
  }
  
  return results;
};
```

## Security & Privacy

### Data Protection
- **PII Filtering**: Remove personally identifiable information from queries
- **Query Sanitization**: Sanitize user inputs before processing
- **Response Filtering**: Filter sensitive information from AI responses
- **Audit Logging**: Log AI interactions for security monitoring

### Rate Limiting
- **User-based Limits**: Different limits for anonymous vs authenticated users
- **Query Complexity**: Higher limits for simple queries, lower for complex analysis
- **Adaptive Limiting**: Adjust limits based on system load and user behavior

### Content Moderation
- **Input Validation**: Validate queries for malicious content
- **Output Filtering**: Filter inappropriate or harmful AI responses
- **Abuse Detection**: Detect and prevent AI system abuse
- **Compliance**: Ensure AI responses comply with platform policies
---

## File: ./.kiro/steering/analytics-monitoring-routes.md

# Analytics & Monitoring Routes Steering

## Routes Covered
- `/analytics` - Main analytics dashboard
- `/analytics/defi` - DeFi protocol analytics
- `/analytics/tokens` - Token market analytics
- `/monitoring` - Network monitoring and alerts
- `/networks` - Network comparison and status

## Analytics Dashboard (`/analytics`)

### Purpose
Comprehensive analytics dashboard providing insights into Solana network performance, DeFi metrics, token markets, and ecosystem health.

### Key Components Required
- **AnalyticsOverview**: High-level network statistics
- **NetworkMetricsTable**: Real-time network performance
- **DeFiAnalytics**: DeFi protocol metrics and TVL
- **TokenAnalytics**: Token market data and trends
- **ValidatorAnalytics**: Validator performance and staking
- **EcosystemMetrics**: Overall ecosystem health indicators
- **CustomDashboard**: User-customizable widget layout

### Tabbed Interface Structure
```typescript
interface AnalyticsTab {
  id: string;
  name: string;
  component: React.ComponentType;
  data: any;
  refreshInterval: number;
}

const ANALYTICS_TABS = [
  { id: 'overview', name: 'Overview', refreshInterval: 30000 },
  { id: 'network', name: 'Network', refreshInterval: 10000 },
  { id: 'defi', name: 'DeFi', refreshInterval: 60000 },
  { id: 'tokens', name: 'Tokens', refreshInterval: 30000 },
  { id: 'validators', name: 'Validators', refreshInterval: 120000 },
  { id: 'dex', name: 'DEX', refreshInterval: 30000 },
  { id: 'nft', name: 'NFT', refreshInterval: 300000 },
  { id: 'gaming', name: 'Gaming', refreshInterval: 300000 },
  { id: 'crosschain', name: 'Cross-Chain', refreshInterval: 120000 },
  { id: 'ecosystem', name: 'Ecosystem', refreshInterval: 300000 },
  { id: 'security', name: 'Security', refreshInterval: 60000 },
  { id: 'custom', name: 'Custom', refreshInterval: 60000 }
];
```

### Data Requirements
```typescript
interface AnalyticsData {
  network: NetworkMetrics;
  defi: DeFiMetrics;
  tokens: TokenMetrics;
  validators: ValidatorMetrics;
  ecosystem: EcosystemMetrics;
  security: SecurityMetrics;
}

interface NetworkMetrics {
  tps: number;
  blockTime: number;
  epochProgress: number;
  validatorCount: number;
  stakeRatio: number;
  networkHealth: number;
  trends: MetricTrend[];
}

interface DeFiMetrics {
  totalValueLocked: number;
  protocolCount: number;
  topProtocols: Protocol[];
  volumeMetrics: VolumeMetrics;
  yieldMetrics: YieldMetrics;
  liquidityMetrics: LiquidityMetrics;
}

interface TokenMetrics {
  totalMarketCap: number;
  tradingVolume24h: number;
  activeTokens: number;
  topGainers: TokenGainer[];
  topLosers: TokenLoser[];
  newTokens: NewToken[];
}
```

### Implementation Guidelines
- Use server-side rendering for initial data
- Implement real-time updates via WebSocket/SSE
- Cache analytics data with appropriate TTL
- Show loading states for each tab
- Implement data export functionality
- Add customizable dashboard widgets

## DeFi Analytics (`/analytics/defi`)

### Purpose
Specialized DeFi analytics with protocol-specific metrics, TVL tracking, yield analysis, and liquidity monitoring.

### Key Components Required
- **TVLChart**: Total Value Locked over time
- **ProtocolRankings**: Top protocols by various metrics
- **YieldFarming**: Yield opportunities and APY tracking
- **LiquidityAnalysis**: Pool liquidity and trading volume
- **DeFiComparison**: Protocol comparison tools
- **RiskMetrics**: DeFi protocol risk assessment

### DeFi Categories
```typescript
interface DeFiCategory {
  name: string;
  protocols: Protocol[];
  totalTVL: number;
  growth24h: number;
  dominance: number;
}

const DEFI_CATEGORIES = [
  'DEX', 'Lending', 'Yield Farming', 'Derivatives', 
  'Insurance', 'Asset Management', 'Payments', 'Synthetics'
];

interface Protocol {
  name: string;
  category: string;
  tvl: number;
  volume24h: number;
  users24h: number;
  apy: number;
  riskScore: number;
  verified: boolean;
}
```

### Features to Implement
- TVL tracking across all protocols
- Yield farming opportunity scanner
- Liquidity pool analysis
- Protocol risk assessment
- Cross-protocol comparison
- Historical performance tracking

## Token Analytics (`/analytics/tokens`)

### Purpose
Token market analytics with price tracking, market cap analysis, trading volume metrics, and token ecosystem insights.

### Key Components Required
- **MarketOverview**: Overall token market statistics
- **TokenRankings**: Top tokens by market cap and volume
- **PriceCharts**: Token price movements and trends
- **TradingAnalysis**: Trading volume and liquidity analysis
- **TokenLaunchpad**: New token launches and performance
- **MarketSentiment**: Sentiment analysis and social metrics

### Market Metrics
```typescript
interface TokenMarketMetrics {
  totalMarketCap: number;
  totalVolume24h: number;
  activeTokens: number;
  newTokens24h: number;
  marketDominance: MarketDominance[];
  priceMovements: PriceMovement[];
}

interface MarketDominance {
  symbol: string;
  marketCap: number;
  dominance: number;
  change24h: number;
}
```

## Network Monitoring (`/monitoring`)

### Purpose
Real-time network monitoring with anomaly detection, alert management, and performance tracking.

### Key Components Required
- **LiveEventMonitor**: Real-time event streaming
- **AnomalyAlertsTable**: Anomaly detection and alerts
- **NetworkHealthDashboard**: Network status indicators
- **PerformanceMetrics**: Network performance tracking
- **AlertManagement**: Custom alert configuration
- **HistoricalAnalysis**: Historical event analysis

### Monitoring Features
```typescript
interface MonitoringSystem {
  realTimeEvents: EventStream;
  anomalyDetection: AnomalyDetector;
  alertManager: AlertManager;
  performanceTracker: PerformanceTracker;
  historicalAnalyzer: HistoricalAnalyzer;
}

interface EventStream {
  subscribe: (callback: (event: NetworkEvent) => void) => void;
  filter: (criteria: EventFilter) => EventStream;
  pause: () => void;
  resume: () => void;
}

interface AnomalyDetector {
  detectRealTime: (event: NetworkEvent) => Anomaly[];
  detectPatterns: (timeWindow: TimeWindow) => Pattern[];
  configureRules: (rules: DetectionRule[]) => void;
  getAnomalyHistory: () => Anomaly[];
}

interface AlertManager {
  createAlert: (config: AlertConfig) => void;
  updateAlert: (id: string, config: AlertConfig) => void;
  deleteAlert: (id: string) => void;
  getAlerts: () => Alert[];
  testAlert: (id: string) => void;
}
```

### Alert Types
- Network performance degradation
- Unusual transaction patterns
- Security threats and attacks
- Validator performance issues
- Token price anomalies
- DeFi protocol risks

## Network Comparison (`/networks`)

### Purpose
Compare different Solana networks (mainnet, devnet, testnet) with RPC endpoint monitoring and performance benchmarking.

### Key Components Required
- **NetworkComparison**: Side-by-side network comparison
- **RPCEndpointStatus**: RPC endpoint health monitoring
- **PerformanceBenchmarks**: Network performance metrics
- **NetworkSwitcher**: Easy network switching interface
- **EndpointTesting**: RPC endpoint testing tools

### Network Data
```typescript
interface NetworkInfo {
  name: string;
  type: 'mainnet' | 'devnet' | 'testnet';
  rpcEndpoints: RPCEndpoint[];
  status: 'healthy' | 'degraded' | 'down';
  metrics: NetworkMetrics;
  features: NetworkFeature[];
}

interface RPCEndpoint {
  url: string;
  provider: string;
  status: 'online' | 'offline' | 'slow';
  latency: number;
  reliability: number;
  rateLimit: number;
  features: string[];
}
```

## API Integration

### Required Endpoints
- `GET /api/analytics/overview` - Get analytics overview
- `GET /api/analytics/defi` - Get DeFi analytics
- `GET /api/analytics/tokens` - Get token analytics
- `GET /api/monitoring/events` - Get monitoring events
- `GET /api/monitoring/alerts` - Get alert configuration
- `POST /api/monitoring/alerts` - Create/update alerts
- `GET /api/networks` - Get network information
- `GET /api/networks/rpc-status` - Get RPC endpoint status

### Real-time Data
- Server-sent events for live analytics updates
- WebSocket for monitoring events
- Push notifications for critical alerts
- Real-time network status updates

### Caching Strategy
- Analytics data: Cache for 1-5 minutes depending on type
- Monitoring events: No caching (real-time)
- Network status: Cache for 30 seconds
- Historical data: Cache for 1 hour

## Testing Requirements

### Unit Tests
- Analytics calculation accuracy
- Anomaly detection algorithms
- Alert triggering logic
- Network status monitoring
- Data aggregation functions

### Integration Tests
- Real-time data updates
- Alert system functionality
- Network switching works
- Analytics tab navigation
- Export functionality

### E2E Tests
- Dashboard loads and displays data
- Real-time updates work correctly
- Alert creation and management
- Network comparison functionality
- Mobile responsiveness

## Performance Considerations
- Lazy load heavy analytics components
- Use Web Workers for complex calculations
- Implement data virtualization for large datasets
- Optimize chart rendering performance
- Bundle split analytics libraries

## Security Considerations
- Rate limit analytics API requests
- Validate alert configurations
- Secure monitoring data access
- Prevent alert spam and abuse
- Audit trail for alert changes

## Accessibility Requirements
- Screen reader support for charts and metrics
- Keyboard navigation for all features
- High contrast mode for visualizations
- Alternative text for graphs and charts
- Focus management in modal dialogs

## Mobile Optimization
- Responsive dashboard layout
- Touch-friendly chart interactions
- Optimized loading for mobile networks
- Simplified views for small screens
- Swipe gestures for navigation

## Monitoring and Analytics
- Track dashboard usage and engagement
- Monitor real-time update performance
- Measure alert accuracy and effectiveness
- Track user interactions with features
- Monitor system performance and errors
---

## File: ./.kiro/steering/api-routes.md

# OpenSVM API Routes Documentation

## API Architecture

All API routes follow RESTful conventions and are organized under `/api/` with consistent response formats, error handling, and authentication patterns.

## Core API Endpoints

### Account APIs (`/api/account-*`)

#### `/api/account-stats/[address]`
- **Purpose**: Get comprehensive account statistics
- **Method**: GET
- **Response**: Account balance, transaction count, token holdings summary
- **Caching**: 30 seconds for active accounts, 5 minutes for inactive

#### `/api/account-token-stats/[address]`
- **Purpose**: Get detailed token holdings and statistics
- **Method**: GET
- **Response**: List of tokens with balances, USD values, percentage allocations
- **Features**: Token metadata resolution, price data integration

#### `/api/account-transactions/[address]`
- **Purpose**: Paginated transaction history for an account
- **Method**: GET
- **Query Params**: `page`, `limit`, `before`, `until`
- **Response**: Transactions with parsed instructions and metadata

#### `/api/account-transfers/[address]`
- **Purpose**: Token transfer history for an account
- **Method**: GET
- **Response**: Filtered transfers with token metadata and USD values

### Transaction APIs (`/api/transaction/`)

#### `/api/transaction/[signature]`
- **Purpose**: Get detailed transaction information
- **Method**: GET
- **Response**: Complete transaction data with parsed instructions
- **Features**: Instruction parsing, account change analysis, fee calculation

#### `/api/analyze-transaction`
- **Purpose**: AI-powered transaction analysis
- **Method**: POST
- **Body**: `{ signature: string }`
- **Response**: Natural language explanation of transaction purpose and effects

### Block APIs (`/api/block*`)

#### `/api/block`
- **Purpose**: Get block information by slot
- **Method**: GET
- **Query Params**: `slot`
- **Response**: Block metadata, transactions, validator info

#### `/api/blocks/[slot]`
- **Purpose**: Get specific block details
- **Method**: GET
- **Response**: Detailed block information with transaction list

### Token APIs (`/api/token*`)

#### `/api/token/[mint]`
- **Purpose**: Get token metadata and statistics
- **Method**: GET
- **Response**: Token info, supply, holder count, price data

#### `/api/token-stats/[account]`
- **Purpose**: Get token statistics for a specific account
- **Method**: GET
- **Response**: Token balances and transaction history

### Search APIs (`/api/search*`)

#### `/api/search`
- **Purpose**: Universal search across all blockchain entities
- **Method**: GET
- **Query Params**: `q` (query), `type` (filter), `limit`
- **Response**: Categorized search results

#### `/api/search/suggestions`
- **Purpose**: Auto-complete suggestions for search queries
- **Method**: GET
- **Query Params**: `q` (partial query)
- **Response**: Suggested completions with entity types

#### `/api/search/accounts`
- **Purpose**: Search specifically for accounts
- **Method**: GET
- **Response**: Account matches with metadata

### AI APIs (`/api/ai-*`, `/api/chat`)

#### `/api/ai-response`
- **Purpose**: Process AI queries about blockchain data
- **Method**: POST
- **Body**: `{ message: string, context?: object }`
- **Response**: AI-generated response with data analysis

#### `/api/chat`
- **Purpose**: Conversational AI interface
- **Method**: POST
- **Body**: `{ messages: ChatMessage[] }`
- **Response**: Streaming AI responses

### Analytics APIs (`/api/analytics/`)

#### `/api/analytics/overview`
- **Purpose**: High-level network statistics
- **Method**: GET
- **Response**: Network metrics, validator count, TPS, epoch info

#### `/api/analytics/defi`
- **Purpose**: DeFi protocol analytics
- **Method**: GET
- **Response**: TVL data, protocol metrics, yield information

#### `/api/analytics/tokens`
- **Purpose**: Token market analytics
- **Method**: GET
- **Response**: Token prices, volume, market cap data

### Real-time APIs (`/api/sse-*`, `/api/stream`)

#### `/api/sse-events/feed`
- **Purpose**: Server-sent events for real-time updates
- **Method**: GET (EventSource)
- **Response**: Streaming blockchain events

#### `/api/sse-alerts`
- **Purpose**: Real-time security alerts
- **Method**: GET (EventSource)
- **Response**: Anomaly detection alerts

#### `/api/stream`
- **Purpose**: WebSocket-like streaming for live data
- **Method**: GET
- **Response**: Continuous data stream

### Utility APIs

#### `/api/solana-proxy`
- **Purpose**: Proxy requests to Solana RPC with load balancing
- **Method**: POST
- **Body**: Standard Solana RPC request
- **Response**: Proxied RPC response with error handling

#### `/api/solana-rpc`
- **Purpose**: Direct Solana RPC interface
- **Method**: POST
- **Features**: Request validation, response caching, rate limiting

#### `/api/check-account-type`
- **Purpose**: Determine account type (wallet, program, token account)
- **Method**: GET
- **Query Params**: `address`
- **Response**: Account type classification

### Program APIs (`/api/program/`)

#### `/api/program/[address]`
- **Purpose**: Get program information and statistics
- **Method**: GET
- **Response**: Program metadata, instruction usage, account ownership

### Validator APIs (`/api/validator/`)

#### `/api/validator/[address]`
- **Purpose**: Get validator information and performance
- **Method**: GET
- **Response**: Validator stats, commission, stake, performance history

### NFT APIs (`/api/nft*`)

#### `/api/nft-collections`
- **Purpose**: Get NFT collection data
- **Method**: GET
- **Response**: Collection metadata, floor prices, volume

#### `/api/nft-collections/trending`
- **Purpose**: Get trending NFT collections
- **Method**: GET
- **Response**: Collections sorted by activity and volume

### User & Social APIs (`/api/user-*`)

#### `/api/user-profile/[walletAddress]`
- **Purpose**: Get user profile information
- **Method**: GET
- **Response**: User preferences, activity summary, social connections

#### `/api/user-history/[walletAddress]`
- **Purpose**: Get user's interaction history
- **Method**: GET
- **Response**: Page views, searches, bookmarks

#### `/api/user-social/follow`
- **Purpose**: Follow/unfollow wallet addresses
- **Method**: POST
- **Body**: `{ target: string, action: 'follow' | 'unfollow' }`

### Anomaly Detection APIs (`/api/anomaly/`)

#### `/api/anomaly`
- **Purpose**: Report and query anomalies
- **Method**: GET/POST
- **Response**: Anomaly reports, risk scores, related transactions

#### `/api/anomaly/similar`
- **Purpose**: Find similar anomalous patterns
- **Method**: GET
- **Response**: Related anomalies and pattern analysis

### Monetization APIs (`/api/referrals/`, `/api/share/`)

#### `/api/referrals/balance`
- **Purpose**: Get referral earnings balance
- **Method**: GET
- **Response**: Earnings, pending rewards, referral stats

#### `/api/share/generate`
- **Purpose**: Generate shareable links with tracking
- **Method**: POST
- **Body**: `{ url: string, metadata: object }`
- **Response**: Shareable link with tracking code

## API Response Patterns

### Success Response
```typescript
{
  success: true,
  data: T,
  timestamp: number,
  cached?: boolean
}
```

### Error Response
```typescript
{
  success: false,
  error: {
    code: string,
    message: string,
    details?: object
  },
  timestamp: number
}
```

### Paginated Response
```typescript
{
  success: true,
  data: T[],
  pagination: {
    page: number,
    limit: number,
    total: number,
    hasNext: boolean,
    hasPrev: boolean
  },
  timestamp: number
}
```

## Authentication & Rate Limiting

### API Keys
- Optional API keys for higher rate limits
- JWT tokens for authenticated features
- Wallet signature verification for user actions

### Rate Limiting
- Anonymous: 100 requests/minute
- Authenticated: 1000 requests/minute
- Premium: 10000 requests/minute

### CORS Policy
- Allowed origins: configured domains
- Credentials: included for authenticated requests
- Methods: GET, POST, OPTIONS

## Caching Strategy

### Cache Levels
1. **Browser Cache**: Static responses (5 minutes)
2. **CDN Cache**: Public data (1 minute)
3. **Application Cache**: Computed results (30 seconds)
4. **Database Cache**: Query results (10 seconds)

### Cache Keys
- Include relevant parameters in cache keys
- Invalidate on blockchain state changes
- Use cache tags for bulk invalidation

## Error Handling

### Common Error Codes
- `INVALID_ADDRESS`: Malformed Solana address
- `ACCOUNT_NOT_FOUND`: Account doesn't exist
- `TRANSACTION_NOT_FOUND`: Transaction not found
- `RATE_LIMIT_EXCEEDED`: Too many requests
- `INTERNAL_ERROR`: Server-side error
- `NETWORK_ERROR`: Solana RPC error

### Error Recovery
- Automatic retries for transient errors
- Fallback to alternative RPC endpoints
- Graceful degradation for non-critical features
---

## File: ./.kiro/steering/block-explorer-routes.md

# Block Explorer Routes Steering

## Routes Covered
- `/block/[slot]` - Individual block details
- `/block/[slot]/opengraph-image` - Block social sharing images
- `/blocks` - Block list and exploration

## Block Detail Page (`/block/[slot]`)

### Purpose
Display comprehensive information about a specific Solana block including metadata, transactions, validator info, and performance metrics.

### Key Components Required
- **BlockDetails**: Main component showing block metadata
- **TransactionsInBlock**: List of all transactions in the block
- **ValidatorInfo**: Information about the block producer
- **BlockRewards**: Rewards calculation and distribution
- **BlockNavigation**: Previous/next block navigation

### Data Requirements
```typescript
interface BlockData {
  slot: number;
  blockhash: string;
  parentSlot: number;
  blockTime: number | null;
  blockHeight: number;
  transactions: Transaction[];
  rewards: Reward[];
  validator: ValidatorInfo;
  metrics: BlockMetrics;
}

interface BlockMetrics {
  transactionCount: number;
  successfulTransactions: number;
  failedTransactions: number;
  totalFees: number;
  computeUnitsConsumed: number;
  averageTransactionSize: number;
}
```

### Implementation Guidelines
- Use server-side rendering for SEO and performance
- Implement proper error handling for invalid slots
- Cache block data aggressively (blocks are immutable)
- Show loading states for transaction list
- Implement pagination for blocks with many transactions
- Add breadcrumb navigation (Home > Blocks > Block #12345)

### Performance Considerations
- Lazy load transaction details
- Implement virtual scrolling for large transaction lists
- Use React.memo for transaction list items
- Prefetch adjacent blocks for navigation

### Error Handling
- Invalid slot numbers should show 404
- Network errors should show retry mechanism
- Partial data loading should show what's available

## Block List Page (`/blocks`)

### Purpose
Browse recent blocks with real-time updates, statistics, and search functionality.

### Key Components Required
- **BlockExploreTable**: Main table showing recent blocks
- **NetworkStats**: Real-time network statistics
- **BlockFilters**: Filtering and search options
- **LoadMoreButton**: Pagination for older blocks

### Features to Implement
- Real-time block updates (WebSocket/SSE)
- Auto-refresh every 30 seconds
- Load more functionality for historical blocks
- Block statistics dashboard
- Search by slot number or blockhash
- Export functionality for block data

### Data Structure
```typescript
interface BlockListItem {
  slot: number;
  blockhash: string;
  blockTime: number;
  transactionCount: number;
  validator: string;
  fees: number;
  status: 'confirmed' | 'finalized';
}
```

### Real-time Updates
- Connect to `/api/sse-events/feed` for live block updates
- Update block list without full page refresh
- Show notification for new blocks
- Maintain scroll position during updates

## OpenGraph Images (`/block/[slot]/opengraph-image`)

### Purpose
Generate dynamic social sharing images for block pages.

### Implementation
- Use Next.js ImageResponse API
- Include key block information (slot, time, transaction count)
- Use consistent branding and styling
- Optimize for Twitter/Discord/LinkedIn sharing
- Cache generated images

### Image Content
- Block slot number prominently displayed
- Block timestamp
- Transaction count
- Validator information
- OpenSVM branding

## API Integration

### Required Endpoints
- `GET /api/block?slot={slot}` - Get specific block data
- `GET /api/blocks` - Get recent blocks list
- `GET /api/blocks/stats` - Get block statistics
- `SSE /api/sse-events/feed` - Real-time block updates

### Caching Strategy
- Block data: Cache indefinitely (immutable)
- Block list: Cache for 30 seconds
- Statistics: Cache for 10 seconds
- Use stale-while-revalidate pattern

## Testing Requirements

### Unit Tests
- Block data parsing and validation
- Component rendering with mock data
- Error state handling
- Loading state management

### Integration Tests
- Block page loads correctly with valid slot
- Invalid slots show appropriate errors
- Navigation between blocks works
- Real-time updates function properly

### E2E Tests
- Search for specific block works
- Block list pagination functions
- Social sharing generates correct images
- Mobile responsiveness

## Accessibility Requirements
- Proper heading hierarchy (h1 > h2 > h3)
- ARIA labels for interactive elements
- Keyboard navigation support
- Screen reader compatibility
- High contrast mode support

## Mobile Considerations
- Responsive table design for block list
- Touch-friendly navigation buttons
- Optimized loading for mobile networks
- Simplified view for small screens

## SEO Optimization
- Dynamic meta titles: "Block #12345 | OpenSVM"
- Meta descriptions with block summary
- Structured data for search engines
- Canonical URLs for block pages
- Sitemap inclusion for recent blocks
---

## File: ./.kiro/steering/components.md

# OpenSVM Components Documentation

## Component Architecture

Components are organized by feature area and follow consistent patterns for props, state management, error handling, and accessibility.

## Core UI Components (`/components/ui/`)

### Base Components
- **Button**: Primary, secondary, destructive, ghost variants with loading states
- **Input**: Text inputs with validation states and icons
- **Card**: Container component with header, content, and footer sections
- **Table**: Data tables with sorting, pagination, and selection
- **Dialog**: Modal dialogs with backdrop and focus management
- **Dropdown**: Dropdown menus with keyboard navigation
- **Progress**: Progress bars and loading indicators
- **Avatar**: User avatars with fallback initials
- **Badge**: Status badges and labels
- **Tooltip**: Contextual help tooltips

### Form Components
- **Form**: Form wrapper with validation and error handling
- **FormField**: Individual form fields with labels and validation
- **Select**: Dropdown select with search and multi-select
- **Checkbox**: Checkboxes with indeterminate state
- **RadioGroup**: Radio button groups
- **Switch**: Toggle switches
- **Slider**: Range sliders with multiple handles

## Blockchain-Specific Components

### Account Components (`/components/account/`)

#### `AccountInfo`
- **Purpose**: Display basic account information
- **Props**: `address`, `isSystemProgram`, `parsedOwner`
- **Features**: Address validation, copy functionality, QR code generation
- **Usage**: Account detail pages, search results

#### `AccountOverview`
- **Purpose**: Account balance and token holdings summary
- **Props**: `address`, `solBalance`, `tokenAccounts`, `isSystemProgram`
- **Features**: Balance formatting, token metadata resolution, USD values
- **State**: Loading states, error handling, refresh capability

#### `AccountTabs`
- **Purpose**: Tabbed interface for account data (tokens, transactions, NFTs)
- **Props**: `address`, `solBalance`, `tokenBalances`, `activeTab`
- **Features**: Lazy loading, URL synchronization, infinite scroll
- **Tabs**: Tokens, Transactions, NFTs, Programs, History

### Transaction Components (`/components/transaction/`)

#### `TransactionDetails`
- **Purpose**: Complete transaction information display
- **Props**: `signature`, `transaction`, `meta`
- **Features**: Instruction parsing, account changes, fee breakdown
- **Sections**: Overview, Instructions, Account Changes, Logs

#### `TransactionGraph`
- **Purpose**: Visual representation of transaction flow
- **Props**: `address`, `signature?`, `depth?`
- **Features**: Interactive graph, zoom/pan, node filtering
- **Libraries**: D3.js for rendering, Cytoscape for layout

#### `TransactionTable`
- **Purpose**: Paginated table of transactions
- **Props**: `transactions`, `loading`, `onLoadMore`
- **Features**: Sorting, filtering, infinite scroll, export
- **Columns**: Signature, Type, Age, Fee, Status

### Block Components (`/components/block/`)

#### `BlockDetails`
- **Purpose**: Block information and transaction list
- **Props**: `slot`, `block?`
- **Features**: Block metadata, transaction filtering, validator info
- **Sections**: Header, Transactions, Rewards, Statistics

#### `RecentBlocks`
- **Purpose**: Live feed of recent blocks
- **Props**: `blocks`, `onBlockSelect`, `isLoading`
- **Features**: Real-time updates, click handling, loading states
- **Updates**: WebSocket connection for live data

### Token Components (`/components/token/`)

#### `TokenDetails`
- **Purpose**: Token metadata and statistics
- **Props**: `mint`, `token?`
- **Features**: Token info, supply data, holder analysis
- **Sections**: Overview, Statistics, Holders, Transfers

#### `TokenBalance`
- **Purpose**: Display token balance with formatting
- **Props**: `balance`, `decimals`, `symbol`, `showUSD?`
- **Features**: Number formatting, USD conversion, loading states

#### `TokenTable`
- **Purpose**: Table of token holdings or transfers
- **Props**: `tokens`, `type`, `loading`
- **Features**: Sorting by balance/value, token metadata, pagination

### Program Components (`/components/program/`)

#### `ProgramDetails`
- **Purpose**: Program information and analysis
- **Props**: `address`, `program?`
- **Features**: Program metadata, instruction analysis, account ownership
- **Sections**: Overview, Instructions, Accounts, Statistics

#### `ProgramVisualizer`
- **Purpose**: Visual representation of program bytecode
- **Props**: `address`, `data`
- **Features**: Hex view, disassembly, interactive exploration
- **Views**: Hex dump, Assembly, Control flow graph

## AI Components (`/components/ai/`)

### Core AI Components

#### `AIChatSidebar`
- **Purpose**: Resizable sidebar with AI chat interface
- **Props**: `isOpen`, `onClose`, `onWidthChange`, `initialWidth`
- **Features**: Drag resize, conversation history, context awareness
- **State**: Chat messages, loading states, error handling

#### `AIAssistant`
- **Purpose**: Main AI interaction component
- **Props**: `context?`, `initialMessage?`
- **Features**: Natural language processing, blockchain data analysis
- **Capabilities**: Transaction explanation, anomaly detection, education

#### `AIChatDialog`
- **Purpose**: Modal dialog for AI interactions
- **Props**: `isOpen`, `onClose`, `context?`
- **Features**: Full-screen chat, context injection, export conversations

### AI Action Components

#### `AIAnalyzeButton`
- **Purpose**: Button to trigger AI analysis of current data
- **Props**: `data`, `type`, `onAnalysis`
- **Features**: Loading states, error handling, result display

#### `AIExplainTransaction`
- **Purpose**: AI explanation of transaction purpose and effects
- **Props**: `signature`, `transaction?`
- **Features**: Natural language explanation, technical details toggle

## Visualization Components (`/components/visualization/`)

### Chart Components

#### `NetworkResponseChart`
- **Purpose**: Real-time network performance visualization
- **Props**: `data`, `timeRange?`
- **Features**: Live updates, zoom/pan, multiple metrics
- **Library**: Chart.js with real-time plugin

#### `TokenPriceChart`
- **Purpose**: Token price history and trends
- **Props**: `mint`, `timeRange`, `data?`
- **Features**: Candlestick/line charts, volume overlay, indicators

#### `AccountActivityChart`
- **Purpose**: Account transaction activity over time
- **Props**: `address`, `timeRange`
- **Features**: Transaction volume, balance changes, activity heatmap

### Graph Components

#### `TransactionGraph`
- **Purpose**: Interactive transaction flow visualization
- **Props**: `address`, `depth?`, `filters?`
- **Features**: Force-directed layout, node clustering, path highlighting
- **Libraries**: D3.js, Cytoscape

#### `WalletConnectionGraph`
- **Purpose**: Wallet relationship visualization
- **Props**: `sourceWallet`, `targetWallet?`, `maxDepth`
- **Features**: Path finding, connection strength, interactive exploration

## Search Components (`/components/search/`)

#### `SearchSuggestions`
- **Purpose**: Auto-complete suggestions for search queries
- **Props**: `showSuggestions`, `suggestions`, `onSelect`
- **Features**: Keyboard navigation, entity type icons, recent searches

#### `SearchResults`
- **Purpose**: Categorized search results display
- **Props**: `results`, `query`, `loading`
- **Features**: Result categorization, pagination, result highlighting

#### `SearchFilters`
- **Purpose**: Advanced search filtering interface
- **Props**: `filters`, `onFilterChange`
- **Features**: Date ranges, amount filters, entity type filters

## Analytics Components (`/components/analytics/`)

#### `NetworkStats`
- **Purpose**: High-level network statistics dashboard
- **Props**: `stats`, `timeRange?`
- **Features**: Key metrics, trend indicators, comparison views

#### `DeFiAnalytics`
- **Purpose**: DeFi protocol analytics and TVL tracking
- **Props**: `protocols?`, `timeRange`
- **Features**: TVL charts, protocol comparison, yield analysis

#### `ValidatorAnalytics`
- **Purpose**: Validator performance and staking analytics
- **Props**: `validators?`, `metrics`
- **Features**: Performance rankings, stake distribution, commission analysis

## Data Display Components

### Table Components

#### `DataTable`
- **Purpose**: Generic data table with advanced features
- **Props**: `data`, `columns`, `pagination?`, `sorting?`
- **Features**: Sorting, filtering, pagination, row selection, export
- **Library**: @tanstack/react-table

#### `VirtualTable`
- **Purpose**: High-performance virtual table for large datasets
- **Props**: `data`, `columns`, `height`
- **Features**: Virtual scrolling, dynamic row heights, column resizing
- **Library**: @visactor/vtable

### List Components

#### `TransactionList`
- **Purpose**: Optimized list of transactions
- **Props**: `transactions`, `showDetails?`, `onSelect?`
- **Features**: Virtual scrolling, lazy loading, item selection

#### `AccountList`
- **Purpose**: List of accounts with metadata
- **Props**: `accounts`, `showBalances?`, `sortBy?`
- **Features**: Balance display, sorting options, bulk actions

## Layout Components

#### `PageLayout`
- **Purpose**: Standard page layout with navigation and sidebar
- **Props**: `children`, `sidebar?`, `breadcrumbs?`
- **Features**: Responsive design, sidebar toggle, breadcrumb navigation

#### `DashboardLayout`
- **Purpose**: Dashboard layout with widget areas
- **Props**: `widgets`, `layout`, `onLayoutChange?`
- **Features**: Drag-and-drop widgets, responsive grid, layout persistence

## Error Handling Components

#### `ErrorBoundary`
- **Purpose**: Catch and display component errors gracefully
- **Props**: `fallback?`, `onError?`
- **Features**: Error reporting, retry functionality, fallback UI

#### `LoadingSpinner`
- **Purpose**: Loading indicators with different styles
- **Props**: `size?`, `variant?`, `text?`
- **Features**: Multiple variants, accessible labels, timeout handling

## Component Patterns

### Props Patterns
```typescript
// Base component props
interface BaseComponentProps {
  className?: string;
  children?: React.ReactNode;
  'data-testid'?: string;
}

// Data component props
interface DataComponentProps<T> extends BaseComponentProps {
  data?: T;
  loading?: boolean;
  error?: Error | null;
  onRefresh?: () => void;
}

// Interactive component props
interface InteractiveComponentProps extends BaseComponentProps {
  disabled?: boolean;
  onClick?: (event: React.MouseEvent) => void;
  onKeyDown?: (event: React.KeyboardEvent) => void;
}
```

### State Management Patterns
```typescript
// Loading states
const [loading, setLoading] = useState(false);
const [error, setError] = useState<Error | null>(null);
const [data, setData] = useState<T | null>(null);

// Async data fetching
const fetchData = useCallback(async () => {
  setLoading(true);
  setError(null);
  try {
    const result = await api.getData();
    setData(result);
  } catch (err) {
    setError(err as Error);
  } finally {
    setLoading(false);
  }
}, []);
```

### Error Handling Patterns
```typescript
// Component error boundaries
const ErrorFallback = ({ error, resetError }: ErrorFallbackProps) => (
  <div className="error-container">
    <h2>Something went wrong</h2>
    <p>{error.message}</p>
    <button onClick={resetError}>Try again</button>
  </div>
);

// Async error handling
const handleAsyncError = (error: Error) => {
  console.error('Component error:', error);
  // Report to error tracking service
  // Show user-friendly error message
};
```

### Accessibility Patterns
```typescript
// ARIA labels and roles
<button
  aria-label="Copy address to clipboard"
  aria-describedby="copy-help-text"
  role="button"
  tabIndex={0}
>
  Copy
</button>

// Keyboard navigation
const handleKeyDown = (event: React.KeyboardEvent) => {
  if (event.key === 'Enter' || event.key === ' ') {
    event.preventDefault();
    onClick?.(event as any);
  }
};
```

### Performance Patterns
```typescript
// Memoization for expensive calculations
const expensiveValue = useMemo(() => {
  return calculateExpensiveValue(data);
}, [data]);

// Callback memoization
const handleClick = useCallback((id: string) => {
  onItemClick?.(id);
}, [onItemClick]);

// Component memoization
const MemoizedComponent = React.memo(Component, (prevProps, nextProps) => {
  return prevProps.data === nextProps.data;
});
```
---

## File: ./.kiro/steering/development.md

# OpenSVM Development Patterns & Guidelines

## Code Organization Principles

### Feature-First Architecture
- Organize code by feature/domain rather than technical layer
- Keep related functionality together (components, hooks, utils, types)
- Use barrel exports for clean imports
- Co-locate tests with source code

### Naming Conventions

#### Files and Directories
```
// Components - PascalCase
TransactionTable.tsx
AccountOverview.tsx

// Utilities - camelCase
solanaUtils.ts
formatHelpers.ts

// Directories - kebab-case
transaction-graph/
wallet-path-finding/

// API Routes - kebab-case
account-stats/
token-metadata/

// Types - PascalCase with .types.ts suffix
Transaction.types.ts
Account.types.ts
```

#### Variables and Functions
```typescript
// Variables - camelCase
const accountBalance = 1000;
const isLoading = false;

// Functions - camelCase with descriptive verbs
const fetchAccountData = async () => {};
const parseTransaction = (tx) => {};
const validateSolanaAddress = (address) => {};

// Constants - SCREAMING_SNAKE_CASE
const MAX_RETRY_ATTEMPTS = 3;
const DEFAULT_RPC_TIMEOUT = 5000;

// React Components - PascalCase
const TransactionTable = () => {};
const AccountInfo = () => {};
```

## TypeScript Patterns

### Type Definitions
```typescript
// Base types for blockchain entities
interface SolanaAddress {
  readonly value: string;
  readonly isValid: boolean;
}

interface Transaction {
  signature: string;
  slot: number;
  blockTime: number | null;
  meta: TransactionMeta | null;
